index,branch,method_before,method_after,target,buggy_line
38251,bugs-dot-jar_CAMEL-3314_4badd9c5,"public OnExceptionDefinition onException(Class... exceptions) {
        OnExceptionDefinition answer = new OnExceptionDefinition(Arrays.asList(exceptions));
        addOutput(answer);
        return answer;
    }","public OnExceptionDefinition onException(Class... exceptions) {
        OnExceptionDefinition answer = new OnExceptionDefinition(Arrays.asList(exceptions));
        addOutput(answer);
        return answer;
    }",0,[0]
13754,bugs-dot-jar_MATH-318_83f18d52,"private void dqd(final int start, final int end) {

        eMin = work[4 * start + pingPong + 4];
        double d = work[4 * start + pingPong];
        dMin = d;

        if (pingPong == 0) {
            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                if (work[j4 - 2] == 0.0) {
                    work[j4] = 0.0;
                    d = work[j4 + 1];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                    final double tmp = work[j4 + 1] / work[j4 - 2];
                    work[j4] = work[j4 - 1] * tmp;
                    d *= tmp;
                } else {
                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
                    d *= work[j4 + 1] / work[j4 - 2];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4]);
            }
        } else {
            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                if (work[j4 - 3] == 0.0) {
                    work[j4 - 1] = 0.0;
                    d = work[j4 + 2];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                    final double tmp = work[j4 + 2] / work[j4 - 3];
                    work[j4 - 1] = work[j4] * tmp;
                    d *= tmp;
                } else {
                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
                    d *= work[j4 + 2] / work[j4 - 3];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4 - 1]);
            }
        }

        // Unroll last two steps
        dN2   = d;
        dMin2 = dMin;
        int j4 = 4 * (end - 2) - pingPong - 1;
        int j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN2 + work[j4p2];
        if (work[j4 - 2] == 0.0) {
            work[j4] = 0.0;
            dN1  = work[j4p2 + 2];
            dMin = dN1;
            eMin = 0.0;
        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
            final double tmp = work[j4p2 + 2] / work[j4 - 2];
            work[j4] = work[j4p2] * tmp;
            dN1 = dN2 * tmp;
        } else {
            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
        }
        dMin = Math.min(dMin, dN1);

        dMin1 = dMin;
        j4 = j4 + 4;
        j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN1 + work[j4p2];
        if (work[j4 - 2] == 0.0) {
            work[j4] = 0.0;
            dN   = work[j4p2 + 2];
            dMin = dN;
            eMin = 0.0;
        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
            final double tmp = work[j4p2 + 2] / work[j4 - 2];
            work[j4] = work[j4p2] * tmp;
            dN = dN1 * tmp;
        } else {
            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
        }
        dMin = Math.min(dMin, dN);

        work[j4 + 2] = dN;
        work[4 * end - pingPong - 1] = eMin;

    }","private void dqd(final int start, final int end) {

        eMin = work[4 * start + pingPong + 4];
        double d = work[4 * start + pingPong];
        dMin = d;

        if (pingPong == 0) {
            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                if (work[j4 - 2] == 0.0) {
                    work[j4] = 0.0;
                    d = work[j4 + 1];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
                    final double tmp = work[j4 + 1] / work[j4 - 2];
                    work[j4] = work[j4 - 1] * tmp;
                    d *= tmp;
                } else {
                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
                    d *= work[j4 + 1] / work[j4 - 2];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4]);
            }
        } else {
            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                if (work[j4 - 3] == 0.0) {
                    work[j4 - 1] = 0.0;
                    d = work[j4 + 2];
                    dMin = d;
                    eMin = 0.0;
                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
                    final double tmp = work[j4 + 2] / work[j4 - 3];
                    work[j4 - 1] = work[j4] * tmp;
                    d *= tmp;
                } else {
                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
                    d *= work[j4 + 2] / work[j4 - 3];
                }
                dMin = Math.min(dMin, d);
                eMin = Math.min(eMin, work[j4 - 1]);
            }
        }

        // Unroll last two steps
        dN2   = d;
        dMin2 = dMin;
        int j4 = 4 * (end - 2) - pingPong - 1;
        int j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN2 + work[j4p2];
        if (work[j4 - 2] == 0.0) {
            work[j4] = 0.0;
            dN1  = work[j4p2 + 2];
            dMin = dN1;
            eMin = 0.0;
        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
            final double tmp = work[j4p2 + 2] / work[j4 - 2];
            work[j4] = work[j4p2] * tmp;
            dN1 = dN2 * tmp;
        } else {
            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
        }
        dMin = Math.min(dMin, dN1);

        dMin1 = dMin;
        j4 = j4 + 4;
        j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN1 + work[j4p2];
        if (work[j4 - 2] == 0.0) {
            work[j4] = 0.0;
            dN   = work[j4p2 + 2];
            dMin = dN;
            eMin = 0.0;
        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
            final double tmp = work[j4p2 + 2] / work[j4 - 2];
            work[j4] = work[j4p2] * tmp;
            dN = dN1 * tmp;
        } else {
            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
        }
        dMin = Math.min(dMin, dN);

        work[j4 + 2] = dN;
        work[4 * end - pingPong - 1] = eMin;

    }",0,[0]
23748,bugs-dot-jar_OAK-447_00df38d2,"@Override
    public boolean isModified() {
        NodeState baseState = getBaseState();
        if (writeState == null) {
            return false;
        }
        else {
            Map<String, MutableNodeState> nodes = writeState.nodes;
            for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {
                if (n.getValue() == null) {
                    return true;
                }
                if (baseState == null || !baseState.hasChildNode(n.getKey())) {
                    return true;
                }
            }
            for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {
                PropertyState pState = p.getValue();
                if (pState == null) {
                    return true;
                }
                if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {
                    return true;
                }
            }
            return false;
        }
    }","@Override
    public boolean isModified() {
        NodeState baseState = getBaseState();
        if (writeState == null) {
            return false;
        }
        else {
            Map<String, MutableNodeState> nodes = writeState.nodes;
            for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {
                if (n.getValue() == null) {
                    return true;
                }
                if (baseState == null || !baseState.hasChildNode(n.getKey())) {
                    return true;
                }
            }
            for (Entry<String, PropertyState> p : writeState.properties.entrySet()) {
                PropertyState pState = p.getValue();
                if (pState == null) {
                    return true;
                }
                if (baseState == null || !pState.equals(baseState.getProperty(p.getKey()))) {
                    return true;
                }
            }
            return false;
        }
    }",0,[0]
2623,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void flush(String writer) throws UnknownWriter, org.apache.accumulo.proxy.thrift.MutationsRejectedException, TException {
    try {
      BatchWriterPlusException bwpe = getWriter(writer);
      if (bwpe.exception != null)
        throw bwpe.exception;
      bwpe.writer.flush();
    } catch (MutationsRejectedException e) {
      throw new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());
    } catch (UnknownWriter uw) {
      throw uw;
    } catch (Exception e) {
      throw new TException(e);
    }
  }","@Override
  public void flush(String writer) throws UnknownWriter, org.apache.accumulo.proxy.thrift.MutationsRejectedException, TException {
    try {
      BatchWriterPlusException bwpe = getWriter(writer);
      if (bwpe.exception != null)
        throw bwpe.exception;
      bwpe.writer.flush();
    } catch (MutationsRejectedException e) {
      throw new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());
    } catch (UnknownWriter uw) {
      throw uw;
    } catch (Exception e) {
      throw new TException(e);
    }
  }",0,[0]
2203,bugs-dot-jar_MNG-4918_691a03a7,"public void addScriptSourceRoot( String path )
    {
        if ( path != null )
        {
            path = path.trim();
            if ( path.length() != 0 )
            {
                if ( !getScriptSourceRoots().contains( path ) )
                {
                    getScriptSourceRoots().add( path );
                }
            }
        }
    }","public void addScriptSourceRoot( String path )
    {
        if ( path != null )
        {
            path = path.trim();
            if ( path.length() != 0 )
            {
                if ( !getScriptSourceRoots().contains( path ) )
                {
                    getScriptSourceRoots().add( path );
                }
            }
        }
    }",0,[0]
7780,bugs-dot-jar_ACCUMULO-843_65390f8c,"@Override
  public void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
  }","@Override
  public void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    if (!exists(tableName))
      throw new TableNotFoundException(tableName, tableName, """");
 }",1,"[2, 3]"
22623,bugs-dot-jar_OAK-47_b62f1c26,"private NodeImpl getRoot() {
        return nodeMap.getRootId().getNode(nodeMap);
    }","private NodeImpl getRoot() {
        return nodeMap.getRootId().getNode(nodeMap);
    }",0,[0]
2521,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static Expression concatExpression(final Collection<Expression> expressions, final String expression) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                StringBuilder buffer = new StringBuilder();
                for (Expression expression : expressions) {
                    String text = expression.evaluate(exchange, String.class);
                    if (text != null) {
                        buffer.append(text);
                    }
                }
                return buffer.toString();
            }

            @Override
            public String toString() {
                if (expression != null) {
                    return expression;
                } else {
                    return ""concat"" + expressions;
                }
            }
        };
    }","public static Expression concatExpression(final Collection<Expression> expressions, final String expression) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                StringBuilder buffer = new StringBuilder();
                for (Expression expression : expressions) {
                    String text = expression.evaluate(exchange, String.class);
                    if (text != null) {
                        buffer.append(text);
                    }
                }
                return buffer.toString();
            }

            @Override
            public String toString() {
                if (expression != null) {
                    return expression;
                } else {
                    return ""concat"" + expressions;
                }
            }
        };
    }",0,[0]
3730,bugs-dot-jar_OAK-3324_5f863af6,"@Nonnull
    private PrivilegeBits internalGetPrivileges(@Nullable Tree tree) {
        int type = (tree == null) ? TreeTypeProvider.TYPE_DEFAULT : typeProvider.getType(tree);
        switch (type) {
            case TreeTypeProvider.TYPE_HIDDEN:
                return PrivilegeBits.EMPTY;
            case TreeTypeProvider.TYPE_VERSION:
                Tree versionableTree = getVersionableTree(tree);
                if (versionableTree == null || !versionableTree.exists()) {
                    // unable to determine the location of the versionable item -> deny access.
                    return PrivilegeBits.EMPTY;
                }  else {
                    return getPrivilegeBits(versionableTree);
                }
            case TreeTypeProvider.TYPE_INTERNAL:
                return PrivilegeBits.EMPTY;
            default:
                return getPrivilegeBits(tree);
        }
    }","@Nonnull
    private PrivilegeBits internalGetPrivileges(@Nullable Tree tree) {
        int type = (tree == null) ? TreeTypeProvider.TYPE_DEFAULT : typeProvider.getType(tree);
        switch (type) {
            case TreeTypeProvider.TYPE_HIDDEN:
                return PrivilegeBits.EMPTY;
            case TreeTypeProvider.TYPE_VERSION:
                Tree versionableTree = getVersionableTree(tree);
                if (versionableTree == null || !versionableTree.exists()) {
                    // unable to determine the location of the versionable item -> deny access.
                    return PrivilegeBits.EMPTY;
                }  else {
                    return getPrivilegeBits(versionableTree);
                }
            case TreeTypeProvider.TYPE_INTERNAL:
                return PrivilegeBits.EMPTY;
            default:
                return getPrivilegeBits(tree);
        }
    }",0,[0]
1379,Bears-160,"protected List<String> parseColumnNameList(Marker start) {
        List<String> names = new ArrayList<>();
        tokens.consume('(');
        names.add(parseColumnName());
        while (tokens.canConsume(',')) {
            names.add(parseColumnName());
        }
        tokens.consume(')');
        return names;
    }","protected List<String> parseColumnNameList(Marker start) {
        List<String> names = new ArrayList<>();
        tokens.consume('(');
        names.add(parseColumnName());
        while (tokens.canConsume(',')) {
            names.add(parseColumnName());
        }
        tokens.consume(')');
        return names;
    }",0,[0]
12827,bugs-dot-jar_OAK-3053_7552a10b,"public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {
        Directory local = createLocalDirForIndexReader(indexPath, definition);
        return new CopyOnReadDirectory(remote, local);
    }","public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {
        Directory local = createLocalDirForIndexReader(indexPath, definition);
        return new CopyOnReadDirectory(remote, local);
    }",0,[0]
30604,bugs-dot-jar_CAMEL-3531_41e4b5b9,"public static Iterator<Object> createIterator(Object value) {
        return createIterator(value, "","");
    }","public static Iterator<Object> createIterator(Object value) {
        return createIterator(value, "","");
    }",0,[0]
7180,bugs-dot-jar_CAMEL-3545_050c542e,"public Class getParameterType() {
        return parameterType;
    }","public Class getParameterType() {
        return parameterType;
    }",0,[0]
16276,bugs-dot-jar_FLINK-3189_a5b05566,"public static void printHelpForCancel() {
		HelpFormatter formatter = new HelpFormatter();
		formatter.setLeftPadding(5);
		formatter.setWidth(80);

		System.out.println(""\nAction \""cancel\"" cancels a running program."");
		System.out.println(""\n  Syntax: cancel [OPTIONS] <Job ID>"");
		formatter.setSyntaxPrefix(""  \""cancel\"" action options:"");
		formatter.printHelp("" "", getCancelOptions(new Options()));
		System.out.println();
	}","public static void printHelpForCancel() {
		HelpFormatter formatter = new HelpFormatter();
		formatter.setLeftPadding(5);
		formatter.setWidth(80);

		System.out.println(""\nAction \""cancel\"" cancels a running program."");
		System.out.println(""\n  Syntax: cancel [OPTIONS] <Job ID>"");
		formatter.setSyntaxPrefix(""  \""cancel\"" action options:"");
		formatter.printHelp("" "", getCancelOptions(new Options()));
		System.out.println();
	}",0,[0]
1019,bugs-dot-jar_CAMEL-9238_169b981e,"@SuppressWarnings(""unchecked"")
    public GenericFile<T> copyFrom(GenericFile<T> source) {
        GenericFile<T> result;
        try {
            result = source.getClass().newInstance();
        } catch (Exception e) {
            throw ObjectHelper.wrapRuntimeCamelException(e);
        }
        result.setCopyFromAbsoluteFilePath(source.getAbsoluteFilePath());
        result.setEndpointPath(source.getEndpointPath());
        result.setAbsolute(source.isAbsolute());
        result.setDirectory(source.isDirectory());
        result.setAbsoluteFilePath(source.getAbsoluteFilePath());
        result.setRelativeFilePath(source.getRelativeFilePath());
        result.setFileName(source.getFileName());
        result.setFileNameOnly(source.getFileNameOnly());
        result.setFileLength(source.getFileLength());
        result.setLastModified(source.getLastModified());
        result.setFile(source.getFile());
        result.setBody(source.getBody());
        result.setBinding(source.getBinding());
        result.setCharset(source.getCharset());

        copyFromPopulateAdditional(source, result);
        return result;
    }","@SuppressWarnings(""unchecked"")
    public GenericFile<T> copyFrom(GenericFile<T> source) {
        GenericFile<T> result;
        try {
            result = source.getClass().newInstance();
        } catch (Exception e) {
            throw ObjectHelper.wrapRuntimeCamelException(e);
        }
        result.setCopyFromAbsoluteFilePath(source.getAbsoluteFilePath());
        result.setEndpointPath(source.getEndpointPath());
        result.setAbsolute(source.isAbsolute());
        result.setDirectory(source.isDirectory());
        result.setAbsoluteFilePath(source.getAbsoluteFilePath());
        result.setRelativeFilePath(source.getRelativeFilePath());
        result.setFileName(source.getFileName());
        result.setFileNameOnly(source.getFileNameOnly());
        result.setFileLength(source.getFileLength());
        result.setLastModified(source.getLastModified());
        result.setFile(source.getFile());
        result.setBody(source.getBody());
        result.setBinding(source.getBinding());
        result.setCharset(source.getCharset());

        copyFromPopulateAdditional(source, result);
        return result;
    }",0,[0]
17314,bugs-dot-jar_OAK-1269_b8fe2ded,"@Override
    public double getCost(Filter filter, NodeState root) {
        // TODO don't call getCost for such queries
        if (filter.getFullTextConstraint() != null) {
            // not an appropriate index for full-text search
            return Double.POSITIVE_INFINITY;
        }
        if (!hasNodeTypeRestriction(filter)) {
            // this is not an appropriate index if the filter
            // doesn't have a node type restriction
            return Double.POSITIVE_INFINITY;
        }
        NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);
        if (lookup.isIndexed(filter.getPath())) {
            return lookup.getCost(filter);
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }","@Override
    public double getCost(Filter filter, NodeState root) {
        // TODO don't call getCost for such queries
        if (filter.getFullTextConstraint() != null) {
            // not an appropriate index for full-text search
            return Double.POSITIVE_INFINITY;
        }
        if (!hasNodeTypeRestriction(filter)) {
            // this is not an appropriate index if the filter
            // doesn't have a node type restriction
            return Double.POSITIVE_INFINITY;
        }
        NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);
        if (lookup.isIndexed(filter.getPath(), filter)) {
            return lookup.getCost(filter);
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }",1,[13]
7969,bugs-dot-jar_MATH-924_2836a6f9,"public double getRMS() {
        return FastMath.sqrt(getChiSquare() / rows);
    }","public double getRMS() {
        return FastMath.sqrt(getChiSquare() / rows);
    }",0,[0]
11650,bugs-dot-jar_CAMEL-5796_de6dd425,"public SamplingDefinition sample(long samplePeriod, TimeUnit unit) {
        SamplingDefinition answer = new SamplingDefinition(samplePeriod, unit);
        addOutput(answer);
        return answer;
    }","public SamplingDefinition sample(long samplePeriod, TimeUnit unit) {
        SamplingDefinition answer = new SamplingDefinition(samplePeriod, unit);
        addOutput(answer);
        return answer;
    }",0,[0]
40786,bugs-dot-jar_OAK-3424_f4349a96,"private static long getProcessId() {
        try {
            String name = ManagementFactory.getRuntimeMXBean().getName();
            return Long.parseLong(name.substring(0, name.indexOf('@')));
        } catch (Exception e) {
            LOG.warn(""Could not get process id"", e);
            return 0;
        }
    }","private static long getProcessId() {
        try {
            String name = ManagementFactory.getRuntimeMXBean().getName();
            return Long.parseLong(name.substring(0, name.indexOf('@')));
        } catch (Exception e) {
            LOG.warn(""Could not get process id"", e);
            return 0;
        }
    }",0,[0]
20236,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Deprecated
  @Override
  public MultiTableBatchWriter createMultiTableBatchWriter(long maxMemory, long maxLatency, int maxWriteThreads) {
    return new MultiTableBatchWriterImpl(instance, credentials, new BatchWriterConfig().setMaxMemory(maxMemory)
        .setMaxLatency(maxLatency, TimeUnit.MILLISECONDS).setMaxWriteThreads(maxWriteThreads));
  }","@Deprecated
  @Override
  public MultiTableBatchWriter createMultiTableBatchWriter(long maxMemory, long maxLatency, int maxWriteThreads) {
    return new MultiTableBatchWriterImpl(instance, credentials, new BatchWriterConfig().setMaxMemory(maxMemory)
        .setMaxLatency(maxLatency, TimeUnit.MILLISECONDS).setMaxWriteThreads(maxWriteThreads));
  }",0,[0]
8157,bugs-dot-jar_FLINK-2121_03340919,public FileInputFormat() {},public FileInputFormat() {},0,[0]
10214,bugs-dot-jar_OAK-3897_94c6c575,"public void dispose() {
        LOG.info(""Starting disposal of DocumentNodeStore with clusterNodeId: {} ({})"", clusterId,
                getClusterNodeInfoDisplayString());

        if (isDisposed.getAndSet(true)) {
            // only dispose once
            return;
        }
        // notify background threads waiting on isDisposed
        synchronized (isDisposed) {
            isDisposed.notifyAll();
        }
        try {
            backgroundReadThread.join();
        } catch (InterruptedException e) {
            // ignore
        }
        try {
            backgroundUpdateThread.join();
        } catch (InterruptedException e) {
            // ignore
        }

        // do a final round of background operations after
        // the background thread stopped
        try{
            internalRunBackgroundUpdateOperations();
        } catch(AssertionError ae) {
            // OAK-3250 : when a lease check fails, subsequent modifying requests
            // to the DocumentStore will throw an AssertionError. Since as a result
            // of a failing lease check a bundle.stop is done and thus a dispose of the
            // DocumentNodeStore happens, it is very likely that in that case 
            // you run into an AssertionError. We should still continue with disposing
            // though - thus catching and logging..
            LOG.error(""dispose: an AssertionError happened during dispose's last background ops: ""+ae, ae);
        }

        try {
            leaseUpdateThread.join();
        } catch (InterruptedException e) {
            // ignore
        }

        // now mark this cluster node as inactive by
        // disposing the clusterNodeInfo
        clusterNodeInfo.dispose();
        store.dispose();

        if (blobStore instanceof Closeable) {
            try {
                ((Closeable) blobStore).close();
            } catch (IOException ex) {
                LOG.debug(""Error closing blob store "" + blobStore, ex);
            }
        }
        if (persistentCache != null) {
            persistentCache.close();
        }
        LOG.info(""Disposed DocumentNodeStore with clusterNodeId: {}"", clusterId);
    }","public void dispose() {
        LOG.info(""Starting disposal of DocumentNodeStore with clusterNodeId: {} ({})"", clusterId,
                getClusterNodeInfoDisplayString());

        if (isDisposed.getAndSet(true)) {
            // only dispose once
            return;
        }
        // notify background threads waiting on isDisposed
        synchronized (isDisposed) {
            isDisposed.notifyAll();
        }
        try {
            backgroundReadThread.join();
        } catch (InterruptedException e) {
            // ignore
        }
        try {
            backgroundUpdateThread.join();
        } catch (InterruptedException e) {
            // ignore
        }

        // do a final round of background operations after
        // the background thread stopped
        try{
            internalRunBackgroundUpdateOperations();
        } catch(AssertionError ae) {
            // OAK-3250 : when a lease check fails, subsequent modifying requests
            // to the DocumentStore will throw an AssertionError. Since as a result
            // of a failing lease check a bundle.stop is done and thus a dispose of the
            // DocumentNodeStore happens, it is very likely that in that case 
            // you run into an AssertionError. We should still continue with disposing
            // though - thus catching and logging..
            LOG.error(""dispose: an AssertionError happened during dispose's last background ops: ""+ae, ae);
        }

        try {
            leaseUpdateThread.join();
        } catch (InterruptedException e) {
            // ignore
        }

        // now mark this cluster node as inactive by
        // disposing the clusterNodeInfo
        clusterNodeInfo.dispose();
        store.dispose();

        if (blobStore instanceof Closeable) {
            try {
                ((Closeable) blobStore).close();
            } catch (IOException ex) {
                LOG.debug(""Error closing blob store "" + blobStore, ex);
            }
        }
        if (persistentCache != null) {
            persistentCache.close();
        }
        LOG.info(""Disposed DocumentNodeStore with clusterNodeId: {}"", clusterId);
    }",0,[0]
12649,bugs-dot-jar_WICKET-4309_b4274415,"public final Integer toInteger() throws StringValueConversionException
	{
		try
		{
			return new Integer(text);
		}
		catch (NumberFormatException e)
		{
			throw new StringValueConversionException(""Unable to convert '"" + text +
				""' to an Integer value"", e);
		}
	}","public final Integer toInteger() throws StringValueConversionException
	{
		try
		{
			return new Integer(text);
		}
		catch (NumberFormatException e)
		{
			throw new StringValueConversionException(""Unable to convert '"" + text +
				""' to an Integer value"", e);
		}
	}",0,[0]
12730,bugs-dot-jar_WICKET-4121_8967eb2b,"protected final IWizardStep findNextVisibleStep()
	{
		int startIndex = (activeStep == null) ? 0 : steps.indexOf(activeStep) + 1;

		for (int i = startIndex; i < conditions.size(); i++)
		{
			ICondition condition = conditions.get(i);
			if (condition.evaluate())
			{
				return steps.get(i);
			}
		}

		throw new IllegalStateException(""Wizard contains no more visible steps"");
	}","protected final IWizardStep findNextVisibleStep()
	{
		int startIndex = (activeStep == null) ? 0 : steps.indexOf(activeStep) + 1;

		for (int i = startIndex; i < conditions.size(); i++)
		{
			ICondition condition = conditions.get(i);
			if (condition.evaluate())
			{
				return steps.get(i);
			}
		}

		throw new IllegalStateException(""Wizard contains no more visible steps"");
	}",0,[0]
33063,bugs-dot-jar_OAK-2999_3bf07779,"private boolean addTypedOrderedFields(List<Field> fields,
                                          PropertyState property,
                                          String pname,
                                          PropertyDefinition pd) {
        // Ignore and warn if property multi-valued as not supported
        if (property.getType().isArray()) {
            log.warn(
                    ""[{}] Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported"",
                    getIndexName(), pname,
                    Type.fromTag(property.getType().tag(), true), getPath());
            return false;
        }

        int tag = property.getType().tag();
        int idxDefinedTag = pd.getType();
        // Try converting type to the defined type in the index definition
        if (tag != idxDefinedTag) {
            log.debug(
                    ""[{}] Ordered property defined with type {} differs from property {} with type {} in ""
                            + ""path {}"",
                    getIndexName(),
                    Type.fromTag(idxDefinedTag, false), property.toString(),
                    Type.fromTag(tag, false), getPath());
            tag = idxDefinedTag;
        }

        String name = FieldNames.createDocValFieldName(pname);
        boolean fieldAdded = false;
        Field f = null;
        try {
            if (tag == Type.LONG.tag()) {
                //TODO Distinguish fields which need to be used for search and for sort
                //If a field is only used for Sort then it can be stored with less precision
                f = new NumericDocValuesField(name, property.getValue(Type.LONG));
            } else if (tag == Type.DATE.tag()) {
                String date = property.getValue(Type.DATE);
                f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));
            } else if (tag == Type.DOUBLE.tag()) {
                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE));
            } else if (tag == Type.BOOLEAN.tag()) {
                f = new SortedDocValuesField(name,
                    new BytesRef(property.getValue(Type.BOOLEAN).toString()));
            } else if (tag == Type.STRING.tag()) {
                f = new SortedDocValuesField(name,
                    new BytesRef(property.getValue(Type.STRING)));
            }

            if (f != null) {
                fields.add(f);
                fieldAdded = true;
            }
        } catch (Exception e) {
            log.warn(
                    ""[{}] Ignoring ordered property. Could not convert property {} of type {} to type {} for path {}"",
                    getIndexName(), pname,
                    Type.fromTag(property.getType().tag(), false),
                    Type.fromTag(tag, false), getPath(), e);
        }
        return fieldAdded;
    }","private boolean addTypedOrderedFields(List<Field> fields,
                                          PropertyState property,
                                          String pname,
                                          PropertyDefinition pd) {
        // Ignore and warn if property multi-valued as not supported
        if (property.getType().isArray()) {
            log.warn(
                    ""[{}] Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported"",
                    getIndexName(), pname,
                    Type.fromTag(property.getType().tag(), true), getPath());
            return false;
        }

        int tag = property.getType().tag();
        int idxDefinedTag = pd.getType();
        // Try converting type to the defined type in the index definition
        if (tag != idxDefinedTag) {
            log.debug(
                    ""[{}] Ordered property defined with type {} differs from property {} with type {} in ""
                            + ""path {}"",
                    getIndexName(),
                    Type.fromTag(idxDefinedTag, false), property.toString(),
                    Type.fromTag(tag, false), getPath());
            tag = idxDefinedTag;
        }

        String name = FieldNames.createDocValFieldName(pname);
        boolean fieldAdded = false;
        Field f = null;
        try {
            if (tag == Type.LONG.tag()) {
                //TODO Distinguish fields which need to be used for search and for sort
                //If a field is only used for Sort then it can be stored with less precision
                f = new NumericDocValuesField(name, property.getValue(Type.LONG));
            } else if (tag == Type.DATE.tag()) {
                String date = property.getValue(Type.DATE);
                f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));
            } else if (tag == Type.DOUBLE.tag()) {
                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE));
            } else if (tag == Type.BOOLEAN.tag()) {
                f = new SortedDocValuesField(name,
                    new BytesRef(property.getValue(Type.BOOLEAN).toString()));
            } else if (tag == Type.STRING.tag()) {
                f = new SortedDocValuesField(name,
                    new BytesRef(property.getValue(Type.STRING)));
            }

            if (f != null) {
                fields.add(f);
                fieldAdded = true;
            }
        } catch (Exception e) {
            log.warn(
                    ""[{}] Ignoring ordered property. Could not convert property {} of type {} to type {} for path {}"",
                    getIndexName(), pname,
                    Type.fromTag(property.getType().tag(), false),
                    Type.fromTag(tag, false), getPath(), e);
        }
        return fieldAdded;
    }",0,[0]
2216,bugs-dot-jar_MNG-4918_691a03a7,"@Deprecated
    public List<Dependency> getRuntimeDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return list;
    }","@Deprecated
    public List<Dependency> getRuntimeDependencies()
    {
        Set<Artifact> artifacts = getArtifacts();

        if ( ( artifacts == null ) || artifacts.isEmpty() )
        {
            return Collections.emptyList();
        }

        List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );

        for ( Artifact a : getArtifacts()  )
        {
            // TODO: let the scope handler deal with this
            if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
            {
                Dependency dependency = new Dependency();

                dependency.setArtifactId( a.getArtifactId() );
                dependency.setGroupId( a.getGroupId() );
                dependency.setVersion( a.getVersion() );
                dependency.setScope( a.getScope() );
                dependency.setType( a.getType() );
                dependency.setClassifier( a.getClassifier() );

                list.add( dependency );
            }
        }
        return list;
    }",0,[0]
7427,bugs-dot-jar_MATH-699_b2e24119,"public double[] sample(int sampleSize) {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }
        double[] out = new double[sampleSize];
        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }
        return out;
    }","public double[] sample(int sampleSize) {
        if (sampleSize <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                    sampleSize);
        }
        double[] out = new double[sampleSize];
        for (int i = 0; i < sampleSize; i++) {
            out[i] = sample();
        }
        return out;
    }",0,[0]
307,Bears-14,"protected void addInjectables(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanDeserializerBuilder builder)
        throws JsonMappingException
    {
        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();
        if (raw != null) {
            boolean fixAccess = ctxt.canOverrideAccessModifiers();
            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {
                AnnotatedMember m = entry.getValue();
                if (fixAccess) {
                    m.fixAccess(forceAccess); // to ensure we can call it
                }
                builder.addInjectable(PropertyName.construct(m.getName()),
                        m.getType(),
                        beanDesc.getClassAnnotations(), m, entry.getKey());
            }
        }
    }","protected void addInjectables(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanDeserializerBuilder builder)
        throws JsonMappingException
    {
        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();
        if (raw != null) {
            boolean fixAccess = ctxt.canOverrideAccessModifiers();
            boolean forceAccess = fixAccess && ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);
            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {
                AnnotatedMember m = entry.getValue();
                if (fixAccess) {
                    m.fixAccess(forceAccess); // to ensure we can call it
                }
                builder.addInjectable(PropertyName.construct(m.getName()),
                        m.getType(),
                        beanDesc.getClassAnnotations(), m, entry.getKey());
            }
        }
    }",0,[0]
7584,bugs-dot-jar_OAK-1178_f2bb1a17,"@Override
    protected boolean isModified() {
        return nodeBuilder.isModified();
    }","@Override
    protected boolean isModified() {
        return nodeBuilder.isModified();
    }",0,[0]
14921,bugs-dot-jar_OAK-3318_e12e2052,"private static long determineReindexCount(NodeState defn, NodeBuilder defnb) {
        //Give precedence to count from builder as that reflects the latest state
        //and might be higher than one from nodeState which is the base state
        if (defnb != null && defnb.hasProperty(REINDEX_COUNT)) {
            return defnb.getProperty(REINDEX_COUNT).getValue(Type.LONG);
        }
        if (defn.hasProperty(REINDEX_COUNT)) {
            return defn.getProperty(REINDEX_COUNT).getValue(Type.LONG);
        }
        return 0;
    }","private static long determineReindexCount(NodeState defn, NodeBuilder defnb) {
        //Give precedence to count from builder as that reflects the latest state
        //and might be higher than one from nodeState which is the base state
        if (defnb != null && defnb.hasProperty(REINDEX_COUNT)) {
            return defnb.getProperty(REINDEX_COUNT).getValue(Type.LONG);
        }
        if (defn.hasProperty(REINDEX_COUNT)) {
            return defn.getProperty(REINDEX_COUNT).getValue(Type.LONG);
        }
        return 0;
    }",0,[0]
40586,bugs-dot-jar_WICKET-442_246d53c5,"public void setUpdateSession(boolean updateCluster)
	{
		this.updateSession = updateCluster;
	}","public void setUpdateSession(boolean updateCluster)
	{
		this.updateSession = updateCluster;
	}",0,[0]
5869,bugs-dot-jar_MATH-859_66dece12,"public double getNumericalVariance() {
        double ul = upper - lower;
        return ul * ul / 12;
    }","public double getNumericalVariance() {
        double ul = upper - lower;
        return ul * ul / 12;
    }",0,[0]
3095,bugs-dot-jar_CAMEL-5261_55c2e2d8,"@Override
    protected void doShutdown() throws Exception {
        // notify component we are shutting down this endpoint
        if (getComponent() != null) {
            getComponent().onShutdownEndpoint(this);
        }
        // shutdown thread pool if it was in use
        if (multicastExecutor != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor);
            multicastExecutor = null;
        }
        super.doShutdown();
    }","@Override
    protected void doShutdown() throws Exception {
        // notify component we are shutting down this endpoint
        if (getComponent() != null) {
            getComponent().onShutdownEndpoint(this);
        }
        // shutdown thread pool if it was in use
        if (multicastExecutor != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor);
            multicastExecutor = null;
        }

        // clear queue, as we are shutdown, so if re-created then the queue must be updated
        queue = null;

        super.doShutdown();
    }",1,[]
22708,bugs-dot-jar_MATH-778_5b9302d5,"protected Dfp(final DfpField field, double x) {

        // initialize as if 0
        mant = new int[field.getRadixDigits()];
        sign = 1;
        exp = 0;
        nans = FINITE;
        this.field = field;

        long bits = Double.doubleToLongBits(x);
        long mantissa = bits & 0x000fffffffffffffL;
        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;

        if (exponent == -1023) {
            // Zero or sub-normal
            if (x == 0) {
                // make sure 0 has the right sign
                if ((bits & 0x8000000000000000L) != 0) {
                    sign = -1;
                }
                return;
            }

            exponent++;

            // Normalize the subnormal number
            while ( (mantissa & 0x0010000000000000L) == 0) {
                exponent--;
                mantissa <<= 1;
            }
            mantissa &= 0x000fffffffffffffL;
        }

        if (exponent == 1024) {
            // infinity or NAN
            if (x != x) {
                sign = (byte) 1;
                nans = QNAN;
            } else if (x < 0) {
                sign = (byte) -1;
                nans = INFINITE;
            } else {
                sign = (byte) 1;
                nans = INFINITE;
            }
            return;
        }

        Dfp xdfp = new Dfp(field, mantissa);
        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one
        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));

        if ((bits & 0x8000000000000000L) != 0) {
            xdfp = xdfp.negate();
        }

        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);
        sign = xdfp.sign;
        exp  = xdfp.exp;
        nans = xdfp.nans;

    }","protected Dfp(final DfpField field, double x) {

        // initialize as if 0
        mant = new int[field.getRadixDigits()];
        sign = 1;
        exp = 0;
        nans = FINITE;
        this.field = field;

        long bits = Double.doubleToLongBits(x);
        long mantissa = bits & 0x000fffffffffffffL;
        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;

        if (exponent == -1023) {
            // Zero or sub-normal
            if (x == 0) {
                // make sure 0 has the right sign
                if ((bits & 0x8000000000000000L) != 0) {
                    sign = -1;
                }
                return;
            }

            exponent++;

            // Normalize the subnormal number
            while ( (mantissa & 0x0010000000000000L) == 0) {
                exponent--;
                mantissa <<= 1;
            }
            mantissa &= 0x000fffffffffffffL;
        }

        if (exponent == 1024) {
            // infinity or NAN
            if (x != x) {
                sign = (byte) 1;
                nans = QNAN;
            } else if (x < 0) {
                sign = (byte) -1;
                nans = INFINITE;
            } else {
                sign = (byte) 1;
                nans = INFINITE;
            }
            return;
        }

        Dfp xdfp = new Dfp(field, mantissa);
        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one
        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));

        if ((bits & 0x8000000000000000L) != 0) {
            xdfp = xdfp.negate();
        }

        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);
        sign = xdfp.sign;
        exp  = xdfp.exp;
        nans = xdfp.nans;

    }",0,[0]
8613,bugs-dot-jar_WICKET-5112_ed780cc7,"public boolean isOff(long flag)
	{
		return (options & flag) == 0;
	}","public boolean isOff(long flag)
	{
		return (options & flag) == 0;
	}",0,[0]
37141,bugs-dot-jar_CAMEL-7239_ae419224,"@Deprecated
    public boolean isUseDom() {
        return useDom;
    }","@Deprecated
    public boolean isUseDom() {
        return useDom;
    }",0,[0]
1779,Bears-202,"public ClassGraph filterClasspathElements(final ClasspathElementFilter classpathElementFilter) {
        scanSpec.filterClasspathElements(classpathElementFilter);
        return this;
    }","public ClassGraph filterClasspathElements(final ClasspathElementFilter classpathElementFilter) {
        scanSpec.filterClasspathElements(classpathElementFilter);
        return this;
    }",0,[0]
1709,Bears-197,"private String buildString() {
        final StringBuilder sb = new StringBuilder();
        if (this.scheme != null) {
            sb.append(this.scheme).append(':');
        }
        if (this.encodedSchemeSpecificPart != null) {
            sb.append(this.encodedSchemeSpecificPart);
        } else {
            if (this.encodedAuthority != null) {
                sb.append(""//"").append(this.encodedAuthority);
            } else if (this.host != null) {
                sb.append(""//"");
                if (this.encodedUserInfo != null) {
                    sb.append(this.encodedUserInfo).append(""@"");
                } else if (this.userInfo != null) {
                    sb.append(encodeUserInfo(this.userInfo)).append(""@"");
                }
                if (isIPv6Address(this.host)) {
                    sb.append(""["").append(this.host).append(""]"");
                } else {
                    sb.append(this.host);
                }
                if (this.port >= 0) {
                    sb.append("":"").append(this.port);
                }
            }
            if (this.encodedPath != null) {
                sb.append(normalizePath(this.encodedPath));
            } else if (this.path != null) {
                sb.append(encodePath(normalizePath(this.path)));
            }
            if (this.encodedQuery != null) {
                sb.append(""?"").append(this.encodedQuery);
            } else if (this.queryParams != null && !this.queryParams.isEmpty()) {
                sb.append(""?"").append(encodeUrlForm(this.queryParams));
            } else if (this.query != null) {
                sb.append(""?"").append(encodeUric(this.query));
            }
        }
        if (this.encodedFragment != null) {
            sb.append(""#"").append(this.encodedFragment);
        } else if (this.fragment != null) {
            sb.append(""#"").append(encodeUric(this.fragment));
        }
        return sb.toString();
    }","private String buildString() {
        final StringBuilder sb = new StringBuilder();
        if (this.scheme != null) {
            sb.append(this.scheme).append(':');
        }
        if (this.encodedSchemeSpecificPart != null) {
            sb.append(this.encodedSchemeSpecificPart);
        } else {
            if (this.encodedAuthority != null) {
                sb.append(""//"").append(this.encodedAuthority);
            } else if (this.host != null) {
                sb.append(""//"");
                if (this.encodedUserInfo != null) {
                    sb.append(this.encodedUserInfo).append(""@"");
                } else if (this.userInfo != null) {
                    sb.append(encodeUserInfo(this.userInfo)).append(""@"");
                }
                if (isIPv6Address(this.host)) {
                    sb.append(""["").append(this.host).append(""]"");
                } else {
                    sb.append(this.host);
                }
                if (this.port >= 0) {
                    sb.append("":"").append(this.port);
                }
            }
            if (this.encodedPath != null) {
                sb.append(normalizePath(this.encodedPath));
            } else if (this.path != null) {
                sb.append(encodePath(normalizePath(this.path)));
            }
            if (this.encodedQuery != null) {
                sb.append(""?"").append(this.encodedQuery);
            } else if (this.queryParams != null && !this.queryParams.isEmpty()) {
                sb.append(""?"").append(encodeUrlForm(this.queryParams));
            } else if (this.query != null) {
                sb.append(""?"").append(encodeUric(this.query));
            }
        }
        if (this.encodedFragment != null) {
            sb.append(""#"").append(this.encodedFragment);
        } else if (this.fragment != null) {
            sb.append(""#"").append(encodeUric(this.fragment));
        }
        return sb.toString();
    }",0,[0]
7389,bugs-dot-jar_OAK-1369_ce0b0955,"int getPrecedence() {
        return PRECEDENCE_OPERAND;
    }","int getPrecedence() {
        return PRECEDENCE_OPERAND;
    }",0,[0]
40583,bugs-dot-jar_WICKET-442_246d53c5,"public final void setResponsePage(final Class pageClass)
	{
		setResponsePage(pageClass, null);
	}","public final void setResponsePage(final Class pageClass)
	{
		setResponsePage(pageClass, null);
	}",0,[0]
8472,bugs-dot-jar_ACCUMULO-366_db4a291f,"public TabletStatsKeeper getStatsKeeper() {
    return statsKeeper;
  }","public TabletStatsKeeper getStatsKeeper() {
    return statsKeeper;
  }",0,[0]
29205,bugs-dot-jar_WICKET-3884_b772ff87,"public AttributeAppender(String attribute, IModel<?> replaceModel)
	{
		super(attribute, replaceModel);
	}","public AttributeAppender(String attribute, IModel<?> replaceModel)
	{
		super(attribute, replaceModel);
	}",0,[0]
36273,bugs-dot-jar_CAMEL-9444_baece126,"public String getDelimiter() {
        return delimiter;
    }","public String getDelimiter() {
        return delimiter;
    }",0,[0]
35332,bugs-dot-jar_WICKET-5447_2abc18f1,"@Override
	public void beforeRender(Component component)
	{
		Response response = component.getResponse();

		for (int i = 0; i < branches.length; i++)
		{
			if (i > 0)
			{
				response.write(""<div class=\""tree-subtree\"">"");
			}

			if (branches[i])
			{
				response.write(""<div class=\""tree-branch tree-branch-mid\"">"");
			}
			else
			{
				response.write(""<div class=\""tree-branch tree-branch-last\"">"");
			}
		}
	}","@Override
	public void beforeRender(Component component)
	{
		Response response = component.getResponse();

		for (int i = 0; i < branches.length; i++)
		{
			if (i > 0)
			{
				response.write(""<div class=\""tree-subtree\"">"");
			}

			if (branches[i])
			{
				response.write(""<div class=\""tree-branch tree-branch-mid\"">"");
			}
			else
			{
				response.write(""<div class=\""tree-branch tree-branch-last\"">"");
			}
		}
	}",0,[0]
34556,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"public void compactAll(long compactionId) {
    boolean updateMetadata = false;

    synchronized (this) {
      if (lastCompactID >= compactionId)
        return;

      if (closing || closed || majorCompactionQueued.contains(MajorCompactionReason.USER) || majorCompactionInProgress)
        return;

      if (datafileManager.getDatafileSizes().size() == 0) {
        // no files, so jsut update the metadata table
        majorCompactionInProgress = true;
        updateMetadata = true;
        lastCompactID = compactionId;
      } else
        initiateMajorCompaction(MajorCompactionReason.USER);
    }

    if (updateMetadata) {
      try {
        // if multiple threads were allowed to update this outside of a sync block, then it would be
        // a race condition
        MetadataTableUtil.updateTabletCompactID(extent, compactionId, SystemCredentials.get(), tabletServer.getLock());
      } finally {
        synchronized (this) {
          majorCompactionInProgress = false;
          this.notifyAll();
        }
      }
    }
  }","public void compactAll(long compactionId) {
    boolean updateMetadata = false;

    synchronized (this) {
      if (lastCompactID >= compactionId)
        return;

      if (closing || closed || majorCompactionQueued.contains(MajorCompactionReason.USER) || majorCompactionInProgress)
        return;

      if (datafileManager.getDatafileSizes().size() == 0) {
        // no files, so jsut update the metadata table
        majorCompactionInProgress = true;
        updateMetadata = true;
        lastCompactID = compactionId;
      } else
        initiateMajorCompaction(MajorCompactionReason.USER);
    }

    if (updateMetadata) {
      try {
        // if multiple threads were allowed to update this outside of a sync block, then it would be
        // a race condition
        MetadataTableUtil.updateTabletCompactID(extent, compactionId, SystemCredentials.get(), tabletServer.getLock());
      } finally {
        synchronized (this) {
          majorCompactionInProgress = false;
          this.notifyAll();
        }
      }
    }
  }",0,[0]
991,bugs-dot-jar_LOG4J2-1067_4786a739,"public String getName() {
        return this.name;
    }","public String getName() {
        return this.name;
    }",0,[0]
690,Bears-22,"@Override
    public JavaType withTypeHandler(Object h) {
        return this;
    }","@Override
    public JavaType withTypeHandler(Object h) {
        return this;
    }",0,[0]
22949,bugs-dot-jar_CAMEL-3428_320545cd,"public void addRoutes(RoutesBuilder builder) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug(""Adding routes from builder: "" + builder);
        }
        // lets now add the routes from the builder
        builder.addRoutesToCamelContext(this);
    }","public void addRoutes(RoutesBuilder builder) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug(""Adding routes from builder: "" + builder);
        }
        // lets now add the routes from the builder
        builder.addRoutesToCamelContext(this);
    }",0,[0]
39883,bugs-dot-jar_WICKET-2621_c849f986,"public final void visitFormComponentsPostOrder(final FormComponent.IVisitor visitor)
	{
		FormComponent.visitFormComponentsPostOrder(this, visitor);
	}","public final void visitFormComponentsPostOrder(final FormComponent.IVisitor visitor)
	{
		FormComponent.visitFormComponentsPostOrder(this, visitor);
	}",0,[0]
6880,bugs-dot-jar_OAK-2062_5c4589bd,"@Override
    public void setOuterJoin(boolean outerJoinLeftHandSide, boolean outerJoinRightHandSide) {
        this.outerJoinLeftHandSide = outerJoinLeftHandSide;
        this.outerJoinRightHandSide = outerJoinRightHandSide;
    }","@Override
    public void setOuterJoin(boolean outerJoinLeftHandSide, boolean outerJoinRightHandSide) {
        this.outerJoinLeftHandSide = outerJoinLeftHandSide;
        this.outerJoinRightHandSide = outerJoinRightHandSide;
    }",0,[0]
39100,bugs-dot-jar_OAK-1662_3efb5cbf,"private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc,
                                         UpdateOp old, Revision maxRev) {
        setSplitDocMaxRev(old, maxRev);

        SplitDocType type = SplitDocType.DEFAULT;
        if(!mainDoc.hasChildren()){
            type = SplitDocType.DEFAULT_NO_CHILD;
        } else if (oldDoc.getLocalRevisions().isEmpty()){
            type = SplitDocType.PROP_COMMIT_ONLY;
        }

        //Copy over the hasBinary flag
        if(mainDoc.hasBinary()){
            setHasBinary(old);
        }

        setSplitDocType(old,type);
    }","private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc,
                                         UpdateOp old, Revision maxRev) {
        setSplitDocMaxRev(old, maxRev);

        SplitDocType type = SplitDocType.DEFAULT;
        if(!mainDoc.hasChildren()){
            type = SplitDocType.DEFAULT_NO_CHILD;
        } else if (oldDoc.getLocalRevisions().isEmpty()){
            type = SplitDocType.PROP_COMMIT_ONLY;
        }

        //Copy over the hasBinary flag
        if(mainDoc.hasBinary()){
            setHasBinary(old);
        }

        setSplitDocType(old,type);
    }",0,[0]
1353,bugs-dot-jar_MATH-1252_09fe956a,"@Override
    public int getNumElements() {
        return numElements;
    }","@Override
    public int getNumElements() {
        return numElements;
    }",0,[0]
9025,bugs-dot-jar_OAK-3879_4faf31e3,"public LucenePropertyIndex(IndexTracker tracker, ScorerProviderFactory factory, IndexAugmentorFactory augmentorFactory) {
        this.tracker = tracker;
        this.scorerProviderFactory = factory;
        this.augmentorFactory = augmentorFactory;
    }","public LucenePropertyIndex(IndexTracker tracker, ScorerProviderFactory factory, IndexAugmentorFactory augmentorFactory) {
        this.tracker = tracker;
        this.scorerProviderFactory = factory;
        this.augmentorFactory = augmentorFactory;
    }",0,[0]
18859,bugs-dot-jar_OAK-1749_591e4d4a,"private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {
        NodeBuilder builder = store.getRoot().builder();
        preAsyncRunNodeStatus(builder, name);
        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
    }","private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {
        NodeBuilder builder = store.getRoot().builder();
        preAsyncRunNodeStatus(builder, name);
        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
    }",0,[0]
27276,bugs-dot-jar_OAK-782_45b110e1,"@Nonnull
    private MutableNodeState write(long newRevision, boolean reconnect) {
        // make sure that all revision numbers up to the root gets updated
        if (!isRoot()) {
            parent.write(newRevision, reconnect);
            checkState(reconnect || exists(), ""This node has been removed"");
        }

        if (writeState == null || revision != root.revision) {
            assert(!isRoot()); // root never gets here since revision == root.revision

            // The builder could have been reset, need to re-get base state
            baseState = parent.getBaseState(name);

            writeState = parent.getWriteState(name);
            if (writeState == null) {
                if (exists()) {
                    writeState = new MutableNodeState(baseState);
                }
                else {
                    writeState = new MutableNodeState(null);
                }
                assert parent.writeState != null; // guaranteed by called parent.write()
                parent.writeState.nodes.put(name, writeState);
            }
        }

        revision = newRevision;
        assert classInvariants();
        assert writeState != null;
        return writeState;
    }","@Nonnull
    private MutableNodeState write(long newRevision, boolean reconnect) {
        // make sure that all revision numbers up to the root gets updated
        if (!isRoot()) {
            parent.write(newRevision, reconnect);
            checkState(reconnect || exists(), ""This node has been removed"");
        }

        if (writeState == null || revision != root.revision) {
            assert(!isRoot()); // root never gets here since revision == root.revision

            // The builder could have been reset, need to re-get base state
            baseState = parent.getBaseState(name);

            writeState = parent.getWriteState(name);
            if (writeState == null) {
                if (exists()) {
                    NodeState writeBase =
                            parent.writeState.base.getChildNode(name);
                    writeState = new MutableNodeState(writeBase);
                }
                else {
                    writeState = new MutableNodeState(null);
                }
                assert parent.writeState != null; // guaranteed by called parent.write()
                parent.writeState.nodes.put(name, writeState);
            }
        }

        revision = newRevision;
        assert classInvariants();
        assert writeState != null;
        return writeState;
    }",1,[17]
15665,bugs-dot-jar_MATH-329_6dd3724b,"public long getCumFreq(char v) {
        return getCumFreq(Character.valueOf(v));
    }","public long getCumFreq(char v) {
        return getCumFreq(Character.valueOf(v));
    }",0,[0]
25188,bugs-dot-jar_OAK-3549_9772f5b2,"@CheckForNull
    @Override
    public NodeState retrieve(@Nonnull String checkpoint) {
        Revision r;
        try {
            r = Revision.fromString(checkpoint);
        } catch (IllegalArgumentException e) {
            LOG.warn(""Malformed checkpoint reference: {}"", checkpoint);
            return null;
        }
        SortedMap<Revision, Info> checkpoints = this.checkpoints.getCheckpoints();
        if (checkpoints != null && checkpoints.containsKey(r)) {
            return getRoot(r);
        } else {
            return null;
        }
    }","@CheckForNull
    @Override
    public NodeState retrieve(@Nonnull String checkpoint) {
        Revision r;
        try {
            r = Revision.fromString(checkpoint);
        } catch (IllegalArgumentException e) {
            LOG.warn(""Malformed checkpoint reference: {}"", checkpoint);
            return null;
        }
        SortedMap<Revision, Info> checkpoints = this.checkpoints.getCheckpoints();
        if (checkpoints != null && checkpoints.containsKey(r)) {
            return getRoot(r);
        } else {
            return null;
        }
    }",0,[0]
1486,Bears-169,"protected SegmentCompletionProtocol.Response doSplitCommit(File segmentTarFile, SegmentCompletionProtocol.Response prevResponse) {
    SegmentCompletionProtocol.Response segmentCommitStartResponse = _protocolHandler.segmentCommitStart(_currentOffset, _segmentNameStr);
    if (!segmentCommitStartResponse.getStatus().equals(SegmentCompletionProtocol.ControllerResponseStatus.COMMIT_CONTINUE)) {
      segmentLogger.warn(""CommitStart failed  with response {}"", segmentCommitStartResponse.toJsonString());
      return SegmentCompletionProtocol.RESP_FAILED;
    }

    SegmentCompletionProtocol.Response segmentCommitUploadResponse = _protocolHandler.segmentCommitUpload(
        _currentOffset, _segmentNameStr, segmentTarFile, prevResponse.getControllerVipUrl());
    if (!segmentCommitUploadResponse.getStatus().equals(SegmentCompletionProtocol.ControllerResponseStatus.UPLOAD_SUCCESS)) {
      segmentLogger.warn(""Segment upload failed  with response {}"", segmentCommitUploadResponse.toJsonString());
      return SegmentCompletionProtocol.RESP_FAILED;
    }

    SegmentCompletionProtocol.Response commitEndResponse =  _protocolHandler.segmentCommitEnd(_currentOffset,
        _segmentNameStr, segmentCommitUploadResponse.getSegmentLocation(), _memoryManager.getTotalAllocatedBytes());
    if (!commitEndResponse.getStatus().equals(SegmentCompletionProtocol.ControllerResponseStatus.COMMIT_SUCCESS))  {
      segmentLogger.warn(""CommitEnd failed  with response {}"", commitEndResponse.toJsonString());
      return SegmentCompletionProtocol.RESP_FAILED;
    }
    return commitEndResponse;
  }","protected SegmentCompletionProtocol.Response doSplitCommit(File segmentTarFile, SegmentCompletionProtocol.Response prevResponse) {
    SegmentCompletionProtocol.Response segmentCommitStartResponse = _protocolHandler.segmentCommitStart(_currentOffset, _segmentNameStr);
    if (!segmentCommitStartResponse.getStatus().equals(SegmentCompletionProtocol.ControllerResponseStatus.COMMIT_CONTINUE)) {
      segmentLogger.warn(""CommitStart failed  with response {}"", segmentCommitStartResponse.toJsonString());
      return SegmentCompletionProtocol.RESP_FAILED;
    }

    SegmentCompletionProtocol.Response segmentCommitUploadResponse = _protocolHandler.segmentCommitUpload(
        _currentOffset, _segmentNameStr, segmentTarFile, prevResponse.getControllerVipUrl());
    if (!segmentCommitUploadResponse.getStatus().equals(SegmentCompletionProtocol.ControllerResponseStatus.UPLOAD_SUCCESS)) {
      segmentLogger.warn(""Segment upload failed  with response {}"", segmentCommitUploadResponse.toJsonString());
      return SegmentCompletionProtocol.RESP_FAILED;
    }

    SegmentCompletionProtocol.Response commitEndResponse =  _protocolHandler.segmentCommitEnd(_currentOffset,
        _segmentNameStr, segmentCommitUploadResponse.getSegmentLocation(), _memoryManager.getTotalAllocatedBytes());
    if (!commitEndResponse.getStatus().equals(SegmentCompletionProtocol.ControllerResponseStatus.COMMIT_SUCCESS))  {
      segmentLogger.warn(""CommitEnd failed  with response {}"", commitEndResponse.toJsonString());
      return SegmentCompletionProtocol.RESP_FAILED;
    }
    return commitEndResponse;
  }",0,[0]
30496,bugs-dot-jar_CAMEL-8626_d063f471,"@Override
    public boolean equals(Object o) {
        return this == o || (o != null && getClass() == o.getClass() && route.equals(((ManagedRoute) o).route));
    }","@Override
    public boolean equals(Object o) {
        return this == o || (o != null && getClass() == o.getClass() && route.equals(((ManagedRoute) o).route));
    }",0,[0]
5477,bugs-dot-jar_OAK-1186_52372042,"@CheckForNull
    public Revision getLiveRevision(RevisionContext context, Revision maxRev,
                                    Set<Revision> validRevisions) {
        // check local deleted map first
        Value value = getLatestValue(context, getLocalDeleted(),
                null, maxRev, validRevisions);
        if (value == null) {
            // need to check complete map
            value = getLatestValue(context, getDeleted(),
                    null, maxRev, validRevisions);
        }
        return value != null && value.value.equals(""false"") ? value.revision : null;
    }","@CheckForNull
    public Revision getLiveRevision(RevisionContext context, Revision maxRev,
                                    Set<Revision> validRevisions) {
        // check local deleted map first
        Value value = getLatestValue(context, getLocalDeleted(),
                null, maxRev, validRevisions);
        if (value == null) {
            // need to check complete map
            value = getLatestValue(context, getDeleted(),
                    null, maxRev, validRevisions);
        }
        return value != null && value.value.equals(""false"") ? value.revision : null;
    }",0,[0]
1886,bugs-dot-jar_FLINK-1145_22c370d9,"public static <IN1, IN2, OUT> TypeInformation<OUT> getJoinReturnTypes(JoinFunction<IN1, IN2, OUT> joinInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
		return getBinaryOperatorReturnType((Function) joinInterface, JoinFunction.class, false, false, in1Type, in2Type);
	}","public static <IN1, IN2, OUT> TypeInformation<OUT> getJoinReturnTypes(JoinFunction<IN1, IN2, OUT> joinInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
		return getBinaryOperatorReturnType((Function) joinInterface, JoinFunction.class, false, false, in1Type, in2Type);
	}",0,[0]
1403,bugs-dot-jar_OAK-185_7fe28a0e,"private synchronized Tree getTree() throws InvalidItemStateException {
        resolve();
        if (tree == null) {
            throw new InvalidItemStateException(""Node is stale"");
        }

        return tree;
    }","private synchronized Tree getTree() throws InvalidItemStateException {
        resolve();
        if (tree == null) {
            throw new InvalidItemStateException(""Node is stale"");
        }

        return tree;
    }",0,[0]
30501,bugs-dot-jar_CAMEL-8626_d063f471,"@Override
    public void init(ManagementStrategy strategy) {
        super.init(strategy);
        exchangesInFlightStartTimestamps.clear();
    }","@Override
    public void init(ManagementStrategy strategy) {
        exchangesInFlightStartTimestamps.clear();
        super.init(strategy);
    }",1,[2]
21170,bugs-dot-jar_WICKET-5442_a382917f,"public int getYear(final Calendar calendar)
	{
		return get(calendar, Calendar.YEAR);
	}","public int getYear(final Calendar calendar)
	{
		return get(calendar, Calendar.YEAR);
	}",0,[0]
3269,bugs-dot-jar_CAMEL-5699_6d63a502,"public void setShowCaughtException(boolean showCaughtException) {
        this.showCaughtException = showCaughtException;
    }","public void setShowCaughtException(boolean showCaughtException) {
        this.showCaughtException = showCaughtException;
    }",0,[0]
87,bugs-dot-jar_OAK-1822_3e83a4c1,"public boolean isNew() {
        return isNew;
    }","public boolean isNew() {
        return isNew;
    }",0,[0]
5429,bugs-dot-jar_OAK-1186_52372042,"@Nonnull
    Iterable<NodeDocument> readChildren(final String path, int limit) {
        String from = Utils.getKeyLowerLimit(path);
        String to = Utils.getKeyUpperLimit(path);
        if (limit > NUM_CHILDREN_CACHE_LIMIT) {
            // do not use cache
            return store.query(Collection.NODES, from, to, limit);
        }
        // check cache
        NodeDocument.Children c = docChildrenCache.getIfPresent(path);
        if (c == null) {
            c = new NodeDocument.Children();
            List<NodeDocument> docs = store.query(Collection.NODES, from, to, limit);
            for (NodeDocument doc : docs) {
                String p = Utils.getPathFromId(doc.getId());
                c.childNames.add(PathUtils.getName(p));
            }
            c.isComplete = docs.size() < limit;
            docChildrenCache.put(path, c);
        } else if (c.childNames.size() < limit && !c.isComplete) {
            // fetch more and update cache
            String lastName = c.childNames.get(c.childNames.size() - 1);
            String lastPath = PathUtils.concat(path, lastName);
            from = Utils.getIdFromPath(lastPath);
            int remainingLimit = limit - c.childNames.size();
            List<NodeDocument> docs = store.query(Collection.NODES,
                    from, to, remainingLimit);
            NodeDocument.Children clone = c.clone();
            for (NodeDocument doc : docs) {
                String p = Utils.getPathFromId(doc.getId());
                clone.childNames.add(PathUtils.getName(p));
            }
            clone.isComplete = docs.size() < remainingLimit;
            docChildrenCache.put(path, clone);
            c = clone;
        }
        Iterable<NodeDocument> it = Iterables.transform(c.childNames, new Function<String, NodeDocument>() {
            @Override
            public NodeDocument apply(String name) {
                String p = PathUtils.concat(path, name);
                return store.find(Collection.NODES, Utils.getIdFromPath(p));
            }
        });
        if (c.childNames.size() > limit * 2) {
            it = Iterables.limit(it, limit * 2);
        }
        return it;
    }","@Nonnull
    Iterable<NodeDocument> readChildren(final String path, int limit) {
        String from = Utils.getKeyLowerLimit(path);
        String to = Utils.getKeyUpperLimit(path);
        if (limit > NUM_CHILDREN_CACHE_LIMIT) {
            // do not use cache
            return store.query(Collection.NODES, from, to, limit);
        }
        // check cache
        NodeDocument.Children c = docChildrenCache.getIfPresent(path);
        if (c == null) {
            c = new NodeDocument.Children();
            List<NodeDocument> docs = store.query(Collection.NODES, from, to, limit);
            for (NodeDocument doc : docs) {
                String p = Utils.getPathFromId(doc.getId());
                c.childNames.add(PathUtils.getName(p));
            }
            c.isComplete = docs.size() < limit;
            docChildrenCache.put(path, c);
        } else if (c.childNames.size() < limit && !c.isComplete) {
            // fetch more and update cache
            String lastName = c.childNames.get(c.childNames.size() - 1);
            String lastPath = PathUtils.concat(path, lastName);
            from = Utils.getIdFromPath(lastPath);
            int remainingLimit = limit - c.childNames.size();
            List<NodeDocument> docs = store.query(Collection.NODES,
                    from, to, remainingLimit);
            NodeDocument.Children clone = c.clone();
            for (NodeDocument doc : docs) {
                String p = Utils.getPathFromId(doc.getId());
                clone.childNames.add(PathUtils.getName(p));
            }
            clone.isComplete = docs.size() < remainingLimit;
            docChildrenCache.put(path, clone);
            c = clone;
        }
        Iterable<NodeDocument> it = Iterables.transform(c.childNames, new Function<String, NodeDocument>() {
            @Override
            public NodeDocument apply(String name) {
                String p = PathUtils.concat(path, name);
                return store.find(Collection.NODES, Utils.getIdFromPath(p));
            }
        });
        if (c.childNames.size() > limit * 2) {
            it = Iterables.limit(it, limit * 2);
        }
        return it;
    }",0,[0]
38914,bugs-dot-jar_OAK-4358_74cbba24,"public static boolean isLeafPreviousDocId(String id){
        return isPreviousDocId(id) && id.endsWith(""/0"");
    }","public static boolean isLeafPreviousDocId(String id){
        return isPreviousDocId(id) && id.endsWith(""/0"");
    }",0,[0]
36696,bugs-dot-jar_ACCUMULO-3424_27d4ee21,"public boolean config(String... args) {
    ShellOptionsJC options = new ShellOptionsJC();
    JCommander jc = new JCommander();

    jc.setProgramName(""accumulo shell"");
    jc.addObject(options);
    try {
      jc.parse(args);
    } catch (ParameterException e) {
      configError = true;
    }

    if (options.isHelpEnabled()) {
      configError = true;
    }

    if (!configError && options.getUnrecognizedOptions() != null) {
      configError = true;
      logError(""Unrecognized Options: "" + options.getUnrecognizedOptions().toString());
    }

    if (configError) {
      jc.usage();
      return true;
    }

    setDebugging(options.isDebugEnabled());
    authTimeout = TimeUnit.MINUTES.toNanos(options.getAuthTimeout());
    disableAuthTimeout = options.isAuthTimeoutDisabled();

    // get the options that were parsed
    String user = options.getUsername();
    String password = options.getPassword();

    tabCompletion = !options.isTabCompletionDisabled();

    // Use a fake (Mock), ZK, or HdfsZK Accumulo instance
    setInstance(options);

    // AuthenticationToken options
    token = options.getAuthenticationToken();
    Map<String,String> loginOptions = options.getTokenProperties();

    // process default parameters if unspecified
    try {
      boolean hasToken = (token != null);
      boolean hasTokenOptions = !loginOptions.isEmpty();

      if (hasToken && password != null) {
        throw new ParameterException(""Can not supply '--pass' option with '--tokenClass' option"");
      }

      Runtime.getRuntime().addShutdownHook(new Thread() {
        @Override
        public void run() {
          reader.getTerminal().setEchoEnabled(true);
        }
      });

      // Need either both a token and options, or neither, but not just one.
      if (hasToken != hasTokenOptions) {
        throw new ParameterException(""Must supply either both or neither of '--tokenClass' and '--tokenProperty'"");
      } else if (hasToken) { // implied hasTokenOptions
        // Fully qualified name so we don't shadow java.util.Properties
        org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;
        // and line wrap it because the package name is so long
        props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();

        props.putAllStrings(loginOptions);
        token.init(props);
      } else {
        // Read password if the user explicitly asked for it, or didn't specify anything at all
        if (""stdin"".equals(password) || password == null) {
          password = reader.readLine(""Password: "", '*');
        }

        if (password == null) {
          // User cancel, e.g. Ctrl-D pressed
          throw new ParameterException(""No password or token option supplied"");
        } else {
          this.token = new PasswordToken(password);
        }
      }

      if (!options.isFake()) {
        ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());
        DistributedTrace.enable(instance, zr, ""shell"", InetAddress.getLocalHost().getHostName());
      }

      this.setTableName("""");
      this.principal = user;
      connector = instance.getConnector(this.principal, token);

    } catch (Exception e) {
      printException(e);
      configError = true;
    }

    // decide whether to execute commands from a file and quit
    if (options.getExecFile() != null) {
      execFile = options.getExecFile();
      verbose = false;
    } else if (options.getExecFileVerbose() != null) {
      execFile = options.getExecFileVerbose();
      verbose = true;
    }
    execCommand = options.getExecCommand();
    if (execCommand != null) {
      verbose = false;
    }

    rootToken = new Token();

    Command[] dataCommands = {new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(),
        new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand()};
    Command[] debuggingCommands = {new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(),
        new PingCommand()};
    Command[] execCommands = {new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand()};
    Command[] exitCommands = {new ByeCommand(), new ExitCommand(), new QuitCommand()};
    Command[] helpCommands = {new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand()};
    Command[] iteratorCommands = {new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(),
        new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand()};
    Command[] otherCommands = {new HiddenCommand()};
    Command[] permissionsCommands = {new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(),
        new UserPermissionsCommand(), new NamespacePermissionsCommand()};
    Command[] stateCommands = {new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(),
        new TableCommand(), new UserCommand(), new WhoAmICommand()};
    Command[] tableCommands = {new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(),
        new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(),
        new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand()};
    Command[] tableControlCommands = {new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(),
        new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand()};
    Command[] userCommands = {new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(),
        new PasswdCommand(), new SetAuthsCommand(), new UsersCommand()};
    commandGrouping.put(""-- Writing, Reading, and Removing Data --"", dataCommands);
    commandGrouping.put(""-- Debugging Commands -------------------"", debuggingCommands);
    commandGrouping.put(""-- Shell Execution Commands -------------"", execCommands);
    commandGrouping.put(""-- Exiting Commands ---------------------"", exitCommands);
    commandGrouping.put(""-- Help Commands ------------------------"", helpCommands);
    commandGrouping.put(""-- Iterator Configuration ---------------"", iteratorCommands);
    commandGrouping.put(""-- Permissions Administration Commands --"", permissionsCommands);
    commandGrouping.put(""-- Shell State Commands -----------------"", stateCommands);
    commandGrouping.put(""-- Table Administration Commands --------"", tableCommands);
    commandGrouping.put(""-- Table Control Commands ---------------"", tableControlCommands);
    commandGrouping.put(""-- User Administration Commands ---------"", userCommands);

    for (Command[] cmds : commandGrouping.values()) {
      for (Command cmd : cmds)
        commandFactory.put(cmd.getName(), cmd);
    }
    for (Command cmd : otherCommands) {
      commandFactory.put(cmd.getName(), cmd);
    }
    return configError;
  }","public boolean config(String... args) {
    ShellOptionsJC options = new ShellOptionsJC();
    JCommander jc = new JCommander();

    jc.setProgramName(""accumulo shell"");
    jc.addObject(options);
    try {
      jc.parse(args);
    } catch (ParameterException e) {
      configError = true;
    }

    if (options.isHelpEnabled()) {
      configError = true;
    }

    if (!configError && options.getUnrecognizedOptions() != null) {
      configError = true;
      logError(""Unrecognized Options: "" + options.getUnrecognizedOptions().toString());
    }

    if (configError) {
      jc.usage();
      return true;
    }

    setDebugging(options.isDebugEnabled());
    authTimeout = TimeUnit.MINUTES.toNanos(options.getAuthTimeout());
    disableAuthTimeout = options.isAuthTimeoutDisabled();

    // get the options that were parsed
    String user = options.getUsername();
    String password = options.getPassword();

    tabCompletion = !options.isTabCompletionDisabled();

    // Use a fake (Mock), ZK, or HdfsZK Accumulo instance
    setInstance(options);

    // AuthenticationToken options
    token = options.getAuthenticationToken();
    Map<String,String> loginOptions = options.getTokenProperties();

    // process default parameters if unspecified
    try {
      final boolean hasToken = (token != null);

      if (hasToken && password != null) {
        throw new ParameterException(""Can not supply '--pass' option with '--tokenClass' option"");
      }

      Runtime.getRuntime().addShutdownHook(new Thread() {
        @Override
        public void run() {
          reader.getTerminal().setEchoEnabled(true);
        }
      });

      if (hasToken) { // implied hasTokenOptions
        // Fully qualified name so we don't shadow java.util.Properties
        org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;
        // and line wrap it because the package name is so long
        props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();

        if (!loginOptions.isEmpty()) {
          props.putAllStrings(loginOptions);
        }
        token.init(props);
      } else {
        // Read password if the user explicitly asked for it, or didn't specify anything at all
        if (""stdin"".equals(password) || password == null) {
          password = reader.readLine(""Password: "", '*');
        }

        if (password == null) {
          // User cancel, e.g. Ctrl-D pressed
          throw new ParameterException(""No password or token option supplied"");
        } else {
          this.token = new PasswordToken(password);
        }
      }

      if (!options.isFake()) {
        ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());
        DistributedTrace.enable(instance, zr, ""shell"", InetAddress.getLocalHost().getHostName());
      }

      this.setTableName("""");
      this.principal = user;
      connector = instance.getConnector(this.principal, token);

    } catch (Exception e) {
      printException(e);
      configError = true;
    }

    // decide whether to execute commands from a file and quit
    if (options.getExecFile() != null) {
      execFile = options.getExecFile();
      verbose = false;
    } else if (options.getExecFileVerbose() != null) {
      execFile = options.getExecFileVerbose();
      verbose = true;
    }
    execCommand = options.getExecCommand();
    if (execCommand != null) {
      verbose = false;
    }

    rootToken = new Token();

    Command[] dataCommands = {new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(),
        new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand()};
    Command[] debuggingCommands = {new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(),
        new PingCommand()};
    Command[] execCommands = {new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand()};
    Command[] exitCommands = {new ByeCommand(), new ExitCommand(), new QuitCommand()};
    Command[] helpCommands = {new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand()};
    Command[] iteratorCommands = {new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(),
        new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand()};
    Command[] otherCommands = {new HiddenCommand()};
    Command[] permissionsCommands = {new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(),
        new UserPermissionsCommand(), new NamespacePermissionsCommand()};
    Command[] stateCommands = {new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(),
        new TableCommand(), new UserCommand(), new WhoAmICommand()};
    Command[] tableCommands = {new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(),
        new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(),
        new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand()};
    Command[] tableControlCommands = {new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(),
        new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand()};
    Command[] userCommands = {new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(),
        new PasswdCommand(), new SetAuthsCommand(), new UsersCommand()};
    commandGrouping.put(""-- Writing, Reading, and Removing Data --"", dataCommands);
    commandGrouping.put(""-- Debugging Commands -------------------"", debuggingCommands);
    commandGrouping.put(""-- Shell Execution Commands -------------"", execCommands);
    commandGrouping.put(""-- Exiting Commands ---------------------"", exitCommands);
    commandGrouping.put(""-- Help Commands ------------------------"", helpCommands);
    commandGrouping.put(""-- Iterator Configuration ---------------"", iteratorCommands);
    commandGrouping.put(""-- Permissions Administration Commands --"", permissionsCommands);
    commandGrouping.put(""-- Shell State Commands -----------------"", stateCommands);
    commandGrouping.put(""-- Table Administration Commands --------"", tableCommands);
    commandGrouping.put(""-- Table Control Commands ---------------"", tableControlCommands);
    commandGrouping.put(""-- User Administration Commands ---------"", userCommands);

    for (Command[] cmds : commandGrouping.values()) {
      for (Command cmd : cmds)
        commandFactory.put(cmd.getName(), cmd);
    }
    for (Command cmd : otherCommands) {
      commandFactory.put(cmd.getName(), cmd);
    }
    return configError;
  }",1,"[45, 46, 59, 60, 61, 62, 68]"
19602,bugs-dot-jar_WICKET-2882_ebe56869,"public IMarkupFragment getMarkup(final Component child)
	{
		// Get the markup for the container
		IMarkupFragment markup = getMarkup();
		if (markup == null)
		{
			return null;
		}

		if (child == null)
		{
			return markup;
		}

		// Find the child's markup
		markup = markup.find(child.getId());
		if (markup != null)
		{
			return markup;
		}

		// This is to make migration for Items from 1.4 to 1.5 more easy
		if (Character.isDigit(child.getId().charAt(0)))
		{
			String id = child.getId();
			boolean miss = false;
			for (int i = 1; i < id.length(); i++)
			{
				if (Character.isDigit(id.charAt(i)) == false)
				{
					miss = true;
					break;
				}
			}

			if (miss == false)
			{
				// The LoopItems markup is equal to the Loops markup
				markup = getMarkup();

				if (log.isWarnEnabled())
				{
					log.warn(""1.4 to 1.5 migration issue: your item component should be derived from AbstractItem. Item="" +
						child.toString());
				}
			}
		}

		return markup;
	}","public IMarkupFragment getMarkup(final Component child)
	{
		// Get the markup for the container
		IMarkupFragment markup = getMarkup();
		if (markup == null)
		{
			return null;
		}

		if (child == null)
		{
			return markup;
		}

		// Find the child's markup
		markup = markup.find(child.getId());
		if (markup != null)
		{
			return markup;
		}

		// This is to make migration for Items from 1.4 to 1.5 more easy
		if (Character.isDigit(child.getId().charAt(0)))
		{
			String id = child.getId();
			boolean miss = false;
			for (int i = 1; i < id.length(); i++)
			{
				if (Character.isDigit(id.charAt(i)) == false)
				{
					miss = true;
					break;
				}
			}

			if (miss == false)
			{
				// The LoopItems markup is equal to the Loops markup
				markup = getMarkup();

				if (log.isWarnEnabled())
				{
					log.warn(""1.4 to 1.5 migration issue: your item component should be derived from AbstractItem. Item="" +
						child.toString());
				}
			}
		}

		return markup;
	}",0,[0]
9885,bugs-dot-jar_OAK-3634_90ad50da,"@Override
    public void setReadWriteMode(String readWriteMode) {
        // ignored
    }","@Override
    public void setReadWriteMode(String readWriteMode) {
        // ignored
    }",0,[0]
13778,bugs-dot-jar_CAMEL-6936_4954d573,"protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {
        if (!isMatched(file, isDirectory, files)) {
            log.trace(""File did not match. Will skip this file: {}"", file);
            return false;
        }

        // if its a file then check if its already in progress
        if (!isDirectory && isInProgress(file)) {
            if (log.isTraceEnabled()) {
                log.trace(""Skipping as file is already in progress: {}"", file.getFileName());
            }
            return false;
        }

        // if its a file then check we have the file in the idempotent registry already
        if (!isDirectory && endpoint.isIdempotent()) {
            // use absolute file path as default key, but evaluate if an expression key was configured
            String key = file.getAbsoluteFilePath();
            if (endpoint.getIdempotentKey() != null) {
                Exchange dummy = endpoint.createExchange(file);
                key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
            }
            if (key != null && endpoint.getIdempotentRepository().contains(key)) {
                log.trace(""This consumer is idempotent and the file has been consumed before. Will skip this file: {}"", file);
                return false;
            }
        }

        // file matched
        return true;
    }","protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T> files) {
        if (!isMatched(file, isDirectory, files)) {
            log.trace(""File did not match. Will skip this file: {}"", file);
            return false;
        }

        // if its a file then check if its already in progress
        if (!isDirectory && isInProgress(file)) {
            if (log.isTraceEnabled()) {
                log.trace(""Skipping as file is already in progress: {}"", file.getFileName());
            }
            return false;
        }

        boolean answer = true;
        String key = null;
        try {
            // if its a file then check we have the file in the idempotent registry already
            if (!isDirectory && endpoint.isIdempotent()) {
                // use absolute file path as default key, but evaluate if an expression key was configured
                key = file.getAbsoluteFilePath();
                if (endpoint.getIdempotentKey() != null) {
                    Exchange dummy = endpoint.createExchange(file);
                    key = endpoint.getIdempotentKey().evaluate(dummy, String.class);
                }
                if (key != null && endpoint.getIdempotentRepository().contains(key)) {
                    log.trace(""This consumer is idempotent and the file has been consumed before. Will skip this file: {}"", file);
                    answer = false;
                }
            }
        } finally {
            // ensure to run this in finally block in case of runtime exceptions being thrown
            if (!answer) {
                // remove file from the in progress list as its no longer in progress
                endpoint.getInProgressRepository().remove(key);
            }
        }

        // file matched
        return answer;
    }",1,"[14, 15, 16, 17, 18, 19, 20, 22, 23, 24, 29]"
7760,bugs-dot-jar_ACCUMULO-843_65390f8c,"@Override
  public Collection<Text> getSplits(String tableName, int maxSplits) throws TableNotFoundException {
    return getSplits(tableName);
  }","@Override
  public Collection<Text> getSplits(String tableName, int maxSplits) throws TableNotFoundException {
    return getSplits(tableName);
  }",0,[0]
20684,bugs-dot-jar_ACCUMULO-3746_47c64d9a,"public ClientConfiguration(String configFile) throws ConfigurationException {
    this(new PropertiesConfiguration(), configFile);
  }","public ClientConfiguration(String configFile) throws ConfigurationException {
    this(new PropertiesConfiguration(), configFile);
  }",0,[0]
24016,bugs-dot-jar_OAK-579_7d72e6ed,"public DescendantNodeJoinConditionImpl(String descendantSelectorName,
            String ancestorSelectorName) {
        this.descendantSelectorName = descendantSelectorName;
        this.ancestorSelectorName = ancestorSelectorName;
    }","public DescendantNodeJoinConditionImpl(String descendantSelectorName,
            String ancestorSelectorName) {
        this.descendantSelectorName = descendantSelectorName;
        this.ancestorSelectorName = ancestorSelectorName;
    }",0,[0]
20875,bugs-dot-jar_CAMEL-5215_033eb6fe,"public static int copy(InputStream input, OutputStream output) throws IOException {
        return copy(input, output, DEFAULT_BUFFER_SIZE);
    }","public static int copy(InputStream input, OutputStream output) throws IOException {
        return copy(input, output, DEFAULT_BUFFER_SIZE);
    }",0,[0]
20927,bugs-dot-jar_WICKET-5784_b6259e5f,"@Override
	public void sessionDestroyed(String sessionId)
	{
		RequestCycle requestCycle = RequestCycle.get();
		SessionData sessionData = liveSessions.remove(sessionId);
		if (requestCycle != null)
			requestCycle.setMetaData(SESSION_DATA, sessionData);
	}","@Override
	public void sessionDestroyed(String sessionId)
	{
		RequestCycle requestCycle = RequestCycle.get();
		SessionData sessionData = liveSessions.remove(sessionId);
		if (requestCycle != null)
			requestCycle.setMetaData(SESSION_DATA, sessionData);
	}",0,[0]
3624,bugs-dot-jar_WICKET-4256_09166ea8,"public final List<? extends Behavior> getBehaviors()
	{
		return getBehaviors(Behavior.class);
	}","public final List<? extends Behavior> getBehaviors()
	{
		return getBehaviors(Behavior.class);
	}",0,[0]
21874,bugs-dot-jar_MNG-2174_778f044e,"private static List<DomainModel> getParentsOfDomainModel( MavenDomainModel domainModel, MetadataReader mdReader )
        throws IOException, MetadataReaderException, PomProcessorException
    {
        List<DomainModel> domainModels = new ArrayList<DomainModel>();
        if ( domainModel.hasParent() )
        {
            byte[] b = mdReader.readMetadata( domainModel.getParentMetadata() );

            if ( b == null || b.length < 1 )
                throw new PomProcessorException( ""cannot read metadata for "" + domainModel.getParentMetadata() );

            MavenDomainModel parentDomainModel =
                new MavenDomainModel( b );
            domainModels.add( parentDomainModel );
            domainModels.addAll( getParentsOfDomainModel( parentDomainModel, mdReader ) );
        }
        return domainModels;
    }","private static List<DomainModel> getParentsOfDomainModel( MavenDomainModel domainModel, MetadataReader mdReader )
        throws IOException, MetadataReaderException, PomProcessorException
    {
        List<DomainModel> domainModels = new ArrayList<DomainModel>();
        if ( domainModel.hasParent() )
        {
            byte[] b = mdReader.readMetadata( domainModel.getParentMetadata() );

            if ( b == null || b.length < 1 )
                throw new PomProcessorException( ""cannot read metadata for "" + domainModel.getParentMetadata() );

            MavenDomainModel parentDomainModel =
                new MavenDomainModel( b );
            domainModels.add( parentDomainModel );
            domainModels.addAll( getParentsOfDomainModel( parentDomainModel, mdReader ) );
        }
        return domainModels;
    }",0,[0]
8998,bugs-dot-jar_OAK-3412_2f85bd78,"static String[] getNamespaceURIs(Tree root) {
        Set<String> uris = safeGet(getNamespaceTree(root).getChild(REP_NSDATA), REP_URIS);
        return uris.toArray(new String[uris.size()]);
    }","static String[] getNamespaceURIs(Tree root) {
        Set<String> uris = safeGet(getNamespaceTree(root).getChild(REP_NSDATA), REP_URIS);
        return uris.toArray(new String[uris.size()]);
    }",0,[0]
637,Bears-18,"protected boolean _isIgnorable(Annotated a)
    {
        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);
        if (ann != null) {
            return ann.value();
        }
        if (_java7Helper != null) {
            Boolean b = _java7Helper.findTransient(a);
            if (b != null) {
                return b.booleanValue();
            }
        }
        return false;
    }","protected boolean _isIgnorable(Annotated a)
    {
        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);
        if (ann != null) {
            return ann.value();
        }
        if (_java7Helper != null) {
            Boolean b = _java7Helper.findTransient(a);
            if (b != null) {
                return b.booleanValue();
            }
        }
        return false;
    }",0,[0]
11576,bugs-dot-jar_CAMEL-5796_de6dd425,"@SuppressWarnings(""unchecked"")
    public Type attribute(QName name, Object value) {
        if (otherAttributes == null) {
            otherAttributes = new HashMap<QName, Object>();
        }
        otherAttributes.put(name, value);
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    public Type attribute(QName name, Object value) {
        if (otherAttributes == null) {
            otherAttributes = new HashMap<QName, Object>();
        }
        otherAttributes.put(name, value);
        return (Type) this;
    }",0,[0]
13187,bugs-dot-jar_FLINK-2074_6bc6dbec,"private Map<Object, T> reduceMaps(Map<Object, T> first, Map<Object, T> second) throws Exception {

		Map<Object, T> reduced = new HashMap<Object, T>();

		// Get the common keys in the maps
		Set<Object> interSection = new HashSet<Object>();
		Set<Object> diffFirst = new HashSet<Object>();
		Set<Object> diffSecond = new HashSet<Object>();

		for (Object key : first.keySet()) {
			if (second.containsKey(key)) {
				interSection.add(key);
			} else {
				diffFirst.add(key);
			}
		}

		for (Object key : second.keySet()) {
			if (!interSection.contains(key)) {
				diffSecond.add(key);
			}
		}

		// Reduce the common keys
		for (Object key : interSection) {
			reduced.put(
					key,
					reducer.reduce(serializer.copy(first.get(key)),
							serializer.copy(second.get(key))));
		}

		for (Object key : diffFirst) {
			reduced.put(key, first.get(key));
		}

		for (Object key : diffSecond) {
			reduced.put(key, second.get(key));
		}

		return reduced;
	}","private Map<Object, T> reduceMaps(Map<Object, T> first, Map<Object, T> second) throws Exception {

		Map<Object, T> reduced = new HashMap<Object, T>();

		// Get the common keys in the maps
		Set<Object> interSection = new HashSet<Object>();
		Set<Object> diffFirst = new HashSet<Object>();
		Set<Object> diffSecond = new HashSet<Object>();

		for (Object key : first.keySet()) {
			if (second.containsKey(key)) {
				interSection.add(key);
			} else {
				diffFirst.add(key);
			}
		}

		for (Object key : second.keySet()) {
			if (!interSection.contains(key)) {
				diffSecond.add(key);
			}
		}

		// Reduce the common keys
		for (Object key : interSection) {
			reduced.put(
					key,
					reducer.reduce(serializer.copy(first.get(key)),
							serializer.copy(second.get(key))));
		}

		for (Object key : diffFirst) {
			reduced.put(key, first.get(key));
		}

		for (Object key : diffSecond) {
			reduced.put(key, second.get(key));
		}

		return reduced;
	}",0,[0]
26561,bugs-dot-jar_OAK-539_ffa818f3,"public static Id fromLong(long value) {
        byte[] raw = new byte[8];
        
        for (int i = raw.length - 1; i >= 0 && value != 0; i--) {
            raw[i] = (byte) (value & 0xff);
            value >>>= 8;
        }
        return new Id(raw);
    }","public static Id fromLong(long value) {
        byte[] raw = new byte[8];
        
        for (int i = raw.length - 1; i >= 0 && value != 0; i--) {
            raw[i] = (byte) (value & 0xff);
            value >>>= 8;
        }
        return new Id(raw);
    }",0,[0]
17792,bugs-dot-jar_OAK-740_35a7f014,"@Override
    public String toString() {
        return ""SolrIndexUpdate [path="" + path + "", insert="" + insert
                + "", remove="" + remove + ""]"";
    }","@Override
    public String toString() {
        return ""SolrIndexUpdate [path="" + path + "", insert="" + insert
                + "", remove="" + remove + ""]"";
    }",0,[0]
20469,bugs-dot-jar_WICKET-128_7e1000dd,"protected final ISessionStore getSessionStore()
	{
		if (sessionStore == null)
		{
			sessionStore = getApplication().getSessionStore();
		}
		return sessionStore;
	}","protected final ISessionStore getSessionStore()
	{
		if (sessionStore == null)
		{
			sessionStore = getApplication().getSessionStore();
		}
		return sessionStore;
	}",0,[0]
7876,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public double getEntry(int index) {
        checkIndex(index);
        return entries.get(index);
    }","@Override
    public double getEntry(int index) {
        checkIndex(index);
        return entries.get(index);
    }",0,[0]
34903,bugs-dot-jar_CAMEL-5570_a57830ed,"public OnExceptionDefinition logContinued(boolean logContinued) {
        getOrCreateRedeliveryPolicy().logContinued(logContinued);
        return this;
    }","public OnExceptionDefinition logContinued(boolean logContinued) {
        getOrCreateRedeliveryPolicy().logContinued(logContinued);
        return this;
    }",0,[0]
11131,bugs-dot-jar_MATH-1269_a94ff90a,"public static long decrementExact(final long n) throws MathArithmeticException {

        if (n == Long.MIN_VALUE) {
            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);
        }

        return n - 1;

    }","public static long decrementExact(final long n) throws MathArithmeticException {

        if (n == Long.MIN_VALUE) {
            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);
        }

        return n - 1;

    }",0,[0]
11058,bugs-dot-jar_MATH-1269_a94ff90a,"private static double doubleHighPart(double d) {
        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){
            return d; // These are un-normalised - don't try to convert
        }
        long xl = Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back
        xl &= MASK_30BITS; // Drop low order bits
        return Double.longBitsToDouble(xl);
    }","private static double doubleHighPart(double d) {
        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){
            return d; // These are un-normalised - don't try to convert
        }
        long xl = Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back
        xl &= MASK_30BITS; // Drop low order bits
        return Double.longBitsToDouble(xl);
    }",0,[0]
37064,bugs-dot-jar_WICKET-172_99e22ce4,"MarkupContainer()
	{
		super();
	}","MarkupContainer()
	{
		super();
	}",0,[0]
882,Bears-118,"@Override
    protected Position handlePosition(Position position) {
        if (filter(position)) {
            return null;
        }
        return position;
    }","@Override
    protected Position handlePosition(Position position) {
        if (filter(position)) {
            return null;
        }
        return position;
    }",0,[0]
567,bugs-dot-jar_MATH-1300_1d635088,"@Override
    public float nextFloat() {
        return (float) nextDouble();
    }","@Override
    public float nextFloat() {
        return (float) nextDouble();
    }",0,[0]
10776,bugs-dot-jar_LOG4J2-114_afcf92eb,"public StructuredDataMessage(final String id, final String msg, final String type,
                                 Map<String, String> data) {
        super(data);
        this.id = new StructuredDataId(id, null, null);
        this.message = msg;
        this.type = type;
    }","public StructuredDataMessage(final String id, final String msg, final String type,
                                 Map<String, String> data) {
        super(data);
        this.id = new StructuredDataId(id, null, null);
        this.message = msg;
        this.type = type;
    }",0,[0]
25255,bugs-dot-jar_ACCUMULO-193_8ad5a888,"public Key(Text row, Text cf, Text cq, ColumnVisibility cv, long ts) {
    byte[] expr = cv.getExpression();
    init(row.getBytes(), 0, row.getLength(), cf.getBytes(), 0, cf.getLength(), cq.getBytes(), 0, cq.getLength(), expr, 0, expr.length, ts, false, true);
  }","public Key(Text row, Text cf, Text cq, ColumnVisibility cv, long ts) {
    byte[] expr = cv.getExpression();
    init(row.getBytes(), 0, row.getLength(), cf.getBytes(), 0, cf.getLength(), cq.getBytes(), 0, cq.getLength(), expr, 0, expr.length, ts, false, true);
  }",0,[0]
38799,bugs-dot-jar_FLINK-2567_948b6e05,"@Override
	public void close() throws IOException {
		if (this.invalidLineCount > 0) {
			if (LOG.isWarnEnabled()) {
				LOG.warn(""In file \""""+ this.filePath + ""\"" (split start: "" + this.splitStart + "") "" + this.invalidLineCount +"" invalid line(s) were skipped."");
			}
		}

		if (this.commentCount > 0) {
			if (LOG.isInfoEnabled()) {
				LOG.info(""In file \""""+ this.filePath + ""\"" (split start: "" + this.splitStart + "") "" + this.commentCount +"" comment line(s) were skipped."");
			}
		}
		super.close();
	}","@Override
	public void close() throws IOException {
		if (this.invalidLineCount > 0) {
			if (LOG.isWarnEnabled()) {
				LOG.warn(""In file \""""+ this.filePath + ""\"" (split start: "" + this.splitStart + "") "" + this.invalidLineCount +"" invalid line(s) were skipped."");
			}
		}

		if (this.commentCount > 0) {
			if (LOG.isInfoEnabled()) {
				LOG.info(""In file \""""+ this.filePath + ""\"" (split start: "" + this.splitStart + "") "" + this.commentCount +"" comment line(s) were skipped."");
			}
		}
		super.close();
	}",0,[0]
771,Bears-83,"public static <T extends CtType<?>> T substitute(Template<?> template, T templateType) {
		T result = (T) templateType.clone();
		result.setPositions(null);
		// result.setParent(templateType.getParent());
		new SubstitutionVisitor(templateType.getFactory(), result, template).substitute(result);
		return result;
	}","public static <T extends CtType<?>> T substitute(Template<?> template, T templateType) {
		T result = (T) templateType.clone();
		result.setPositions(null);
		// result.setParent(templateType.getParent());
		new SubstitutionVisitor(templateType.getFactory(), result, template).substitute(result);
		return result;
	}",0,[0]
11212,bugs-dot-jar_WICKET-1931_986848f7,"public void setURL(String url)
	{
		if (url.startsWith(""http://""))
		{
			int index = url.indexOf(""/"", 7);
			url = url.substring(index);
		}
		this.url = url;
		if (url.startsWith(getContextPath()))
		{
			url = url.substring(getContextPath().length());
		}
		if (url.startsWith(getServletPath()))
		{
			url = url.substring(getServletPath().length());
		}

		int index = url.indexOf(""?"");
		if (index == -1)
		{
			path = url;
		}
		else
		{
			path = url.substring(0, index);

			String queryString = url.substring(index + 1);
			RequestUtils.decodeParameters(queryString, parameters);
		}
	}","public void setURL(String url)
	{
		if (url.startsWith(""http://""))
		{
			int index = url.indexOf(""/"", 7);
			url = url.substring(index);
		}
		this.url = url;
		if (url.startsWith(getContextPath()))
		{
			url = url.substring(getContextPath().length());
		}
		if (url.startsWith(getServletPath()))
		{
			url = url.substring(getServletPath().length());
		}

		int index = url.indexOf(""?"");
		if (index == -1)
		{
			path = url;
		}
		else
		{
			path = url.substring(0, index);

			String queryString = url.substring(index + 1);
			RequestUtils.decodeParameters(queryString, parameters);
		}
	}",0,[0]
13041,bugs-dot-jar_OAK-1054_0adf3a6e,"@Override
    public void propertyChanged(PropertyState before, PropertyState after) throws CommitFailedException {
        if (authorizableType == null) {
            return;
        }

        String name = before.getName();
        if (REP_PRINCIPAL_NAME.equals(name) || REP_AUTHORIZABLE_ID.equals(name)) {
            String msg = ""Authorizable property "" + name + "" may not be altered after user/group creation."";
            throw constraintViolation(22, msg);
        } else if (JcrConstants.JCR_UUID.equals(name)) {
            checkNotNull(parentAfter);
            if (!isValidUUID(parentAfter, after.getValue(Type.STRING))) {
                String msg = ""Invalid jcr:uuid for authorizable "" + parentAfter.getName();
                throw constraintViolation(23, msg);
            }
        }

        if (isUser(parentBefore) && REP_PASSWORD.equals(name) && PasswordUtil.isPlainTextPassword(after.getValue(Type.STRING))) {
            String msg = ""Password may not be plain text."";
            throw constraintViolation(24, msg);
        }

        if (REP_MEMBERS.equals(name)) {
            checkForCyclicMembership(after);
        }
    }","@Override
    public void propertyChanged(PropertyState before, PropertyState after) throws CommitFailedException {
        if (authorizableType == null) {
            return;
        }

        String name = before.getName();
        if (REP_PRINCIPAL_NAME.equals(name) || REP_AUTHORIZABLE_ID.equals(name)) {
            String msg = ""Authorizable property "" + name + "" may not be altered after user/group creation."";
            throw constraintViolation(22, msg);
        } else if (JcrConstants.JCR_UUID.equals(name)) {
            checkNotNull(parentAfter);
            if (!isValidUUID(parentAfter, after.getValue(Type.STRING))) {
                String msg = ""Invalid jcr:uuid for authorizable "" + parentAfter.getName();
                throw constraintViolation(23, msg);
            }
        }

        if (isUser(parentBefore) && REP_PASSWORD.equals(name) && PasswordUtil.isPlainTextPassword(after.getValue(Type.STRING))) {
            String msg = ""Password may not be plain text."";
            throw constraintViolation(24, msg);
        }

        if (REP_MEMBERS.equals(name)) {
            checkForCyclicMembership(after);
        }
    }",0,[0]
3719,bugs-dot-jar_OAK-3324_5f863af6,"private CompiledPermissionImpl(@Nonnull Set<Principal> principals,
                                   @Nonnull Root root, @Nonnull String workspaceName,
                                   @Nonnull RestrictionProvider restrictionProvider,
                                   @Nonnull ConfigurationParameters options,
                                   @Nonnull Context ctx) {
        this.root = root;
        this.workspaceName = workspaceName;

        bitsProvider = new PrivilegeBitsProvider(root);

        Set<String> readPaths = options.getConfigValue(PARAM_READ_PATHS, DEFAULT_READ_PATHS);
        readPolicy = (readPaths.isEmpty()) ? EmptyReadPolicy.INSTANCE : new DefaultReadPolicy(readPaths);

        // setup
        store = new PermissionStoreImpl(root, workspaceName, restrictionProvider);
        Set<String> userNames = new HashSet<String>(principals.size());
        Set<String> groupNames = new HashSet<String>(principals.size());
        for (Principal principal : principals) {
            if (principal instanceof Group) {
                groupNames.add(principal.getName());
            } else {
                userNames.add(principal.getName());
            }
        }

        PermissionEntryCache cache = new PermissionEntryCache();
        userStore = new PermissionEntryProviderImpl(store, cache, userNames, options);
        groupStore = new PermissionEntryProviderImpl(store, cache, groupNames, options);

        typeProvider = new TreeTypeProvider(ctx);
    }","private CompiledPermissionImpl(@Nonnull Set<Principal> principals,
                                   @Nonnull Root root, @Nonnull String workspaceName,
                                   @Nonnull RestrictionProvider restrictionProvider,
                                   @Nonnull ConfigurationParameters options,
                                   @Nonnull Context ctx) {
        this.root = root;
        this.workspaceName = workspaceName;

        bitsProvider = new PrivilegeBitsProvider(root);

        Set<String> readPaths = options.getConfigValue(PARAM_READ_PATHS, DEFAULT_READ_PATHS);
        readPolicy = (readPaths.isEmpty()) ? EmptyReadPolicy.INSTANCE : new DefaultReadPolicy(readPaths);

        // setup
        store = new PermissionStoreImpl(root, workspaceName, restrictionProvider);
        Set<String> userNames = new HashSet<String>(principals.size());
        Set<String> groupNames = new HashSet<String>(principals.size());
        for (Principal principal : principals) {
            if (principal instanceof Group) {
                groupNames.add(principal.getName());
            } else {
                userNames.add(principal.getName());
            }
        }

        PermissionEntryCache cache = new PermissionEntryCache();
        userStore = new PermissionEntryProviderImpl(store, cache, userNames, options);
        groupStore = new PermissionEntryProviderImpl(store, cache, groupNames, options);

        typeProvider = new TreeTypeProvider(ctx);
    }",0,[0]
32656,bugs-dot-jar_WICKET-4370_7ca927c1,"public MockRequestParameters getPostParameters()
	{
		return post;
	}","public MockRequestParameters getPostParameters()
	{
		return post;
	}",0,[0]
14214,bugs-dot-jar_LOG4J2-392_731c84b5,"@Override
    public void setAdvertiser(final Advertiser advertiser) {
        this.advertiser = advertiser;
    }","@Override
    public void setAdvertiser(final Advertiser advertiser) {
        this.advertiser = advertiser;
    }",0,[0]
28049,bugs-dot-jar_CAMEL-8053_cac72b14,"public void setRestRegistry(RestRegistry restRegistry) {
        this.restRegistry = restRegistry;
    }","public void setRestRegistry(RestRegistry restRegistry) {
        this.restRegistry = restRegistry;
    }",0,[0]
14533,bugs-dot-jar_WICKET-4116_4624ab3d,"private IRequestablePage getStoredPage(final int pageId)
	{
		IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
		if (storedPageInstance != null &&
			(pageClass == null || pageClass.equals(storedPageInstance.getClass())))
		{
			pageInstance = storedPageInstance;
		}
		return storedPageInstance;
	}","private IRequestablePage getStoredPage(final int pageId)
	{
		IRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);
		if (storedPageInstance != null &&
			(pageClass == null || pageClass.equals(storedPageInstance.getClass())))
		{
			pageInstance = storedPageInstance;

			if (pageInstance != null)
			{
				if (renderCount != null && pageInstance.getRenderCount() != renderCount)
				{
					throw new StalePageException(pageInstance);
				}
			}
		}
		return storedPageInstance;
	}",1,[]
31551,bugs-dot-jar_OAK-3433_b76b31f7,"BackgroundReadStats backgroundRead(boolean dispatchChange) {
        BackgroundReadStats stats = new BackgroundReadStats();
        long time = clock.getTime();
        String id = Utils.getIdFromPath(""/"");
        NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
        if (doc == null) {
            return stats;
        }
        Map<Integer, Revision> lastRevMap = doc.getLastRev();

        Revision.RevisionComparator revisionComparator = getRevisionComparator();
        // the (old) head occurred first
        Revision headSeen = Revision.newRevision(0);
        // then we saw this new revision (from another cluster node)
        Revision otherSeen = Revision.newRevision(0);

        StringSort externalSort = JournalEntry.newSorter();

        try {
            Map<Revision, Revision> externalChanges = Maps.newHashMap();
            for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
                int machineId = e.getKey();
                if (machineId == clusterId) {
                    // ignore own lastRev
                    continue;
                }
                Revision r = e.getValue();
                Revision last = lastKnownRevision.get(machineId);
                if (last == null || r.compareRevisionTime(last) > 0) {
                    lastKnownRevision.put(machineId, r);
                    // OAK-2345
                    // only consider as external change if
                    // - the revision changed for the machineId
                    // or
                    // - the revision is within the time frame we remember revisions
                    if (last != null
                            || r.getTimestamp() > revisionPurgeMillis()) {
                        externalChanges.put(r, otherSeen);
                    }
                    // collect external changes
                    if (last != null && externalSort != null) {
                        // add changes for this particular clusterId to the externalSort
                        try {
                            fillExternalChanges(externalSort, last, r, store);
                        } catch (IOException e1) {
                            LOG.error(""backgroundRead: Exception while reading external changes from journal: "" + e1, e1);
                            IOUtils.closeQuietly(externalSort);
                            externalSort = null;
                        }
                    }
                }
            }

            stats.readHead = clock.getTime() - time;
            time = clock.getTime();

            if (!externalChanges.isEmpty()) {
                // invalidate caches
                if (externalSort == null) {
                    // if no externalSort available, then invalidate the classic way: everything
                    stats.cacheStats = store.invalidateCache();
                    docChildrenCache.invalidateAll();
                } else {
                    try {
                        externalSort.sort();
                        stats.cacheStats = store.invalidateCache(pathToId(externalSort));
                        // OAK-3002: only invalidate affected items (using journal)
                        long origSize = docChildrenCache.size();
                        if (origSize == 0) {
                            // if docChildrenCache is empty, don't bother
                            // calling invalidateAll either way
                            // (esp calling invalidateAll(Iterable) will
                            // potentially iterate over all keys even though
                            // there's nothing to be deleted)
                            LOG.trace(""backgroundRead: docChildrenCache nothing to invalidate"");
                        } else {
                            // however, if the docChildrenCache is not empty,
                            // use the invalidateAll(Iterable) variant,
                            // passing it a Iterable<StringValue>, as that's
                            // what is contained in the cache
                            docChildrenCache.invalidateAll(asStringValueIterable(externalSort));
                            long newSize = docChildrenCache.size();
                            LOG.trace(""backgroundRead: docChildrenCache invalidation result: orig: {}, new: {} "", origSize, newSize);
                        }
                    } catch (Exception ioe) {
                        LOG.error(""backgroundRead: got IOException during external sorting/cache invalidation (as a result, invalidating entire cache): ""+ioe, ioe);
                        stats.cacheStats = store.invalidateCache();
                        docChildrenCache.invalidateAll();
                    }
                }
                stats.cacheInvalidationTime = clock.getTime() - time;
                time = clock.getTime();

                // make sure update to revision comparator is atomic
                // and no local commit is in progress
                backgroundOperationLock.writeLock().lock();
                try {
                    stats.lock = clock.getTime() - time;

                    // the latest revisions of the current cluster node
                    // happened before the latest revisions of other cluster nodes
                    revisionComparator.add(newRevision(), headSeen);
                    // then we saw other revisions
                    for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {
                        revisionComparator.add(e.getKey(), e.getValue());
                    }

                    Revision oldHead = headRevision;
                    // the new head revision is after other revisions
                    setHeadRevision(newRevision());
                    if (dispatchChange) {
                        commitQueue.headRevisionChanged();
                        time = clock.getTime();
                        if (externalSort != null) {
                            // then there were external changes and reading them
                            // was successful -> apply them to the diff cache
                            try {
                                JournalEntry.applyTo(externalSort, diffCache, oldHead, headRevision);
                            } catch (Exception e1) {
                                LOG.error(""backgroundRead: Exception while processing external changes from journal: {}"", e1, e1);
                            }
                        }
                        stats.populateDiffCache = clock.getTime() - time;
                        time = clock.getTime();

                        dispatcher.contentChanged(getRoot().fromExternalChange(), null);
                    }
                } finally {
                    backgroundOperationLock.writeLock().unlock();
                }
                stats.dispatchChanges = clock.getTime() - time;
                time = clock.getTime();
            }
        } finally {
            IOUtils.closeQuietly(externalSort);
        }
        revisionComparator.purge(revisionPurgeMillis());
        stats.purge = clock.getTime() - time;

        return stats;
    }","BackgroundReadStats backgroundRead(boolean dispatchChange) {
        BackgroundReadStats stats = new BackgroundReadStats();
        long time = clock.getTime();
        String id = Utils.getIdFromPath(""/"");
        NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
        if (doc == null) {
            return stats;
        }
        Map<Integer, Revision> lastRevMap = doc.getLastRev();

        Revision.RevisionComparator revisionComparator = getRevisionComparator();
        // the (old) head occurred first
        Revision headSeen = Revision.newRevision(0);
        // then we saw this new revision (from another cluster node)
        Revision otherSeen = Revision.newRevision(0);

        StringSort externalSort = JournalEntry.newSorter();

        try {
            Map<Revision, Revision> externalChanges = Maps.newHashMap();
            for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
                int machineId = e.getKey();
                if (machineId == clusterId) {
                    // ignore own lastRev
                    continue;
                }
                Revision r = e.getValue();
                Revision last = lastKnownRevision.get(machineId);
                if (last == null || r.compareRevisionTime(last) > 0) {
                    lastKnownRevision.put(machineId, r);
                    // OAK-2345
                    // only consider as external change if
                    // - the revision changed for the machineId
                    // or
                    // - the revision is within the time frame we remember revisions
                    if (last != null
                            || r.getTimestamp() > revisionPurgeMillis()) {
                        externalChanges.put(r, otherSeen);
                    }
                    // collect external changes
                    if (last != null && externalSort != null) {
                        // add changes for this particular clusterId to the externalSort
                        try {
                            fillExternalChanges(externalSort, last, r, store);
                        } catch (IOException e1) {
                            LOG.error(""backgroundRead: Exception while reading external changes from journal: "" + e1, e1);
                            IOUtils.closeQuietly(externalSort);
                            externalSort = null;
                        }
                    }
                }
            }

            stats.readHead = clock.getTime() - time;
            time = clock.getTime();

            if (!externalChanges.isEmpty()) {
                // invalidate caches
                if (externalSort == null) {
                    // if no externalSort available, then invalidate the classic way: everything
                    stats.cacheStats = store.invalidateCache();
                    docChildrenCache.invalidateAll();
                } else {
                    try {
                        externalSort.sort();
                        stats.cacheStats = store.invalidateCache(pathToId(externalSort));
                        // OAK-3002: only invalidate affected items (using journal)
                        long origSize = docChildrenCache.size();
                        if (origSize == 0) {
                            // if docChildrenCache is empty, don't bother
                            // calling invalidateAll either way
                            // (esp calling invalidateAll(Iterable) will
                            // potentially iterate over all keys even though
                            // there's nothing to be deleted)
                            LOG.trace(""backgroundRead: docChildrenCache nothing to invalidate"");
                        } else {
                            // however, if the docChildrenCache is not empty,
                            // use the invalidateAll(Iterable) variant,
                            // passing it a Iterable<StringValue>, as that's
                            // what is contained in the cache
                            docChildrenCache.invalidateAll(asStringValueIterable(externalSort));
                            long newSize = docChildrenCache.size();
                            LOG.trace(""backgroundRead: docChildrenCache invalidation result: orig: {}, new: {} "", origSize, newSize);
                        }
                    } catch (Exception ioe) {
                        LOG.error(""backgroundRead: got IOException during external sorting/cache invalidation (as a result, invalidating entire cache): ""+ioe, ioe);
                        stats.cacheStats = store.invalidateCache();
                        docChildrenCache.invalidateAll();
                    }
                }
                stats.cacheInvalidationTime = clock.getTime() - time;
                time = clock.getTime();

                // make sure update to revision comparator is atomic
                // and no local commit is in progress
                backgroundOperationLock.writeLock().lock();
                try {
                    stats.lock = clock.getTime() - time;

                    // the latest revisions of the current cluster node
                    // happened before the latest revisions of other cluster nodes
                    revisionComparator.add(newRevision(), headSeen);
                    // then we saw other revisions
                    for (Map.Entry<Revision, Revision> e : externalChanges.entrySet()) {
                        revisionComparator.add(e.getKey(), e.getValue());
                    }

                    Revision oldHead = headRevision;
                    // the new head revision is after other revisions
                    setHeadRevision(newRevision());
                    if (dispatchChange) {
                        commitQueue.headRevisionChanged();
                        time = clock.getTime();
                        if (externalSort != null) {
                            // then there were external changes and reading them
                            // was successful -> apply them to the diff cache
                            try {
                                JournalEntry.applyTo(externalSort, diffCache, oldHead, headRevision);
                            } catch (Exception e1) {
                                LOG.error(""backgroundRead: Exception while processing external changes from journal: {}"", e1, e1);
                            }
                        }
                        stats.populateDiffCache = clock.getTime() - time;
                        time = clock.getTime();

                        dispatcher.contentChanged(getRoot().fromExternalChange(), null);
                    }
                } finally {
                    backgroundOperationLock.writeLock().unlock();
                }
                stats.dispatchChanges = clock.getTime() - time;
                time = clock.getTime();
            }
        } finally {
            IOUtils.closeQuietly(externalSort);
        }
        revisionComparator.purge(revisionPurgeMillis());
        stats.purge = clock.getTime() - time;

        return stats;
    }",0,[0]
3723,bugs-dot-jar_OAK-3324_5f863af6,"@Nonnull
    @Override
    public TreePermission getTreePermission(@Nonnull Tree tree, @Nonnull TreePermission parentPermission) {
        if (tree.isRoot()) {
            return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_DEFAULT, EMPTY);
        }
        int parentType = getParentType(parentPermission);
        int type = typeProvider.getType(tree, parentType);
        switch (type) {
            case TreeTypeProvider.TYPE_HIDDEN:
                return ALL;
            case TreeTypeProvider.TYPE_VERSION:
                String ntName = TreeUtil.getPrimaryTypeName(tree);
                if (ntName == null) {
                    return EMPTY;
                }
                if (VersionConstants.VERSION_STORE_NT_NAMES.contains(ntName) || VersionConstants.NT_ACTIVITY.equals(ntName)) {
                    return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_VERSION, parentPermission);
                } else {
                    Tree versionableTree = getVersionableTree(tree);
                    if (versionableTree == null) {
                        log.warn(""Cannot retrieve versionable node for "" + tree.getPath());
                        return EMPTY;
                    } else {
                        /**
                         * NOTE: may return wrong results in case of restrictions
                         * that would match the path of the versionable node
                         * (or item in the subtree) but that item no longer exists
                         * -> evaluation by path might be more accurate (-> see #isGranted)
                         */
                        while (!versionableTree.exists()) {
                            versionableTree = versionableTree.getParent();
                        }
                        TreePermission pp = getParentPermission(versionableTree, TreeTypeProvider.TYPE_VERSION);
                        return new TreePermissionImpl(versionableTree, TreeTypeProvider.TYPE_VERSION, pp);
                    }
                }
            case TreeTypeProvider.TYPE_INTERNAL:
                return EMPTY;
            default:
                return new TreePermissionImpl(tree, type, parentPermission);
        }
    }","@Nonnull
    @Override
    public TreePermission getTreePermission(@Nonnull Tree tree, @Nonnull TreePermission parentPermission) {
        if (tree.isRoot()) {
            return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_DEFAULT, EMPTY);
        }
        int parentType = getParentType(parentPermission);
        int type = typeProvider.getType(tree, parentType);
        switch (type) {
            case TreeTypeProvider.TYPE_HIDDEN:
                return ALL;
            case TreeTypeProvider.TYPE_VERSION:
                String ntName = TreeUtil.getPrimaryTypeName(tree);
                if (ntName == null) {
                    return EMPTY;
                }
                if (VersionConstants.VERSION_STORE_NT_NAMES.contains(ntName) || VersionConstants.NT_ACTIVITY.equals(ntName)) {
                    return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_VERSION, parentPermission);
                } else {
                    Tree versionableTree = getVersionableTree(tree);
                    if (versionableTree == null) {
                        log.warn(""Cannot retrieve versionable node for "" + tree.getPath());
                        return EMPTY;
                    } else {
                        /**
                         * NOTE: may return wrong results in case of restrictions
                         * that would match the path of the versionable node
                         * (or item in the subtree) but that item no longer exists
                         * -> evaluation by path might be more accurate (-> see #isGranted)
                         */
                        while (!versionableTree.exists()) {
                            versionableTree = versionableTree.getParent();
                        }
                        TreePermission pp = getParentPermission(versionableTree, TreeTypeProvider.TYPE_VERSION);
                        return new TreePermissionImpl(versionableTree, TreeTypeProvider.TYPE_VERSION, pp);
                    }
                }
            case TreeTypeProvider.TYPE_INTERNAL:
                return EMPTY;
            default:
                return new TreePermissionImpl(tree, type, parentPermission);
        }
    }",0,[0]
26929,bugs-dot-jar_WICKET-5724_b92591f6,"@Override
	public final String toUserDebugString()
	{
		return xmlTag.toUserDebugString();
	}","@Override
	public final String toUserDebugString()
	{
		return xmlTag.toUserDebugString();
	}",0,[0]
360,Bears-15,"@Override
    public JsonSerialize.Typing findSerializationTyping(Annotated a)
    {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        return (ann == null) ? null : ann.typing();
    }","@Override
    public JsonSerialize.Typing findSerializationTyping(Annotated a)
    {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        return (ann == null) ? null : ann.typing();
    }",0,[0]
15991,bugs-dot-jar_FLINK-3684_e3759a5e,"@Override
	@SuppressWarnings(""unchecked"")
	public void restoreState(StreamTaskState state, long recoveryTimestamp) throws Exception {
		super.restoreState(state, recoveryTimestamp);

		StreamStateHandle stream = (StreamStateHandle)state.getOperatorState();

		final InputStream is = stream.getState(getUserCodeClassloader());
		final ObjectInputStream ois = new ObjectInputStream(is);
		final DataInputViewStreamWrapper div = new DataInputViewStreamWrapper(is);

		nfa = (NFA<IN>)ois.readObject();

		int numberPriorityQueueEntries = div.readInt();

		priorityQueue = new PriorityQueue<StreamRecord<IN>>(numberPriorityQueueEntries, new StreamRecordComparator<IN>());

		for (int i = 0; i <numberPriorityQueueEntries; i++) {
			priorityQueue.offer(streamRecordSerializer.deserialize(div));
		}

		div.close();
	}","@Override
	@SuppressWarnings(""unchecked"")
	public void restoreState(StreamTaskState state, long recoveryTimestamp) throws Exception {
		super.restoreState(state, recoveryTimestamp);

		StreamStateHandle stream = (StreamStateHandle)state.getOperatorState();

		final InputStream is = stream.getState(getUserCodeClassloader());
		final ObjectInputStream ois = new ObjectInputStream(is);
		final DataInputViewStreamWrapper div = new DataInputViewStreamWrapper(is);

		nfa = (NFA<IN>)ois.readObject();

		int numberPriorityQueueEntries = div.readInt();

		priorityQueue = new PriorityQueue<StreamRecord<IN>>(numberPriorityQueueEntries, new StreamRecordComparator<IN>());

		for (int i = 0; i <numberPriorityQueueEntries; i++) {
			priorityQueue.offer(streamRecordSerializer.deserialize(div));
		}

		div.close();
	}",0,[0]
29272,bugs-dot-jar_CAMEL-7586_1f92fa42,"public void setTimeUnit(TimeUnit timeUnit) {
        context.getShutdownStrategy().setTimeUnit(timeUnit);
    }","public void setTimeUnit(TimeUnit timeUnit) {
        context.getShutdownStrategy().setTimeUnit(timeUnit);
    }",0,[0]
29763,bugs-dot-jar_FLINK-2763_af477563,"final void ensureNumBuffersReturned(final int minRequiredAvailable) {
		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {
			throw new IllegalArgumentException(""More buffers requested available than totally available."");
		}
		
		try {
			while (this.availableMemory.size() < minRequiredAvailable) {
				this.availableMemory.add(this.writeBehindBuffers.take());
				this.writeBehindBuffersAvailable--;
			}
		}
		catch (InterruptedException iex) {
			throw new RuntimeException(""Hash Join was interrupted."");
		}
	}","final void ensureNumBuffersReturned(final int minRequiredAvailable) {
		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {
			throw new IllegalArgumentException(""More buffers requested available than totally available."");
		}
		
		try {
			while (this.availableMemory.size() < minRequiredAvailable) {
				this.availableMemory.add(this.writeBehindBuffers.take());
				this.writeBehindBuffersAvailable--;
			}
		}
		catch (InterruptedException iex) {
			throw new RuntimeException(""Hash Join was interrupted."");
		}
	}",0,[0]
1218,bugs-dot-jar_WICKET-5546_f1af9e03,"protected final void checkComponentTagAttribute(final ComponentTag tag, final String key,
		final String... values)
	{
		if (key != null)
		{
			final String tagAttributeValue = tag.getAttributes().getString(key);

			boolean found = false;
			if (tagAttributeValue != null)
			{
				for (String value : values)
				{
					if (value.equalsIgnoreCase(tagAttributeValue))
					{
						found = true;
						break;
					}
				}
			}

			if (found == false)
			{
				String msg = String.format(""Component [%s] (path = [%s]) must be applied to a tag ""
						+ ""with [%s] attribute matching any of %s, not [%s]"", getId(), getPath(), key,
						Arrays.toString(values), tagAttributeValue);

				findMarkupStream().throwMarkupException(msg);
			}
		}
	}","protected final void checkComponentTagAttribute(final ComponentTag tag, final String key,
		final String... values)
	{
		if (key != null)
		{
			final String tagAttributeValue = tag.getAttributes().getString(key);

			boolean found = false;
			if (tagAttributeValue != null)
			{
				for (String value : values)
				{
					if (value.equalsIgnoreCase(tagAttributeValue))
					{
						found = true;
						break;
					}
				}
			}

			if (found == false)
			{
				String msg = String.format(""Component [%s] (path = [%s]) must be applied to a tag ""
						+ ""with [%s] attribute matching any of %s, not [%s]"", getId(), getPath(), key,
						Arrays.toString(values), tagAttributeValue);

				findMarkupStream().throwMarkupException(msg);
			}
		}
	}",0,[0]
25302,bugs-dot-jar_ACCUMULO-193_8ad5a888,"byte[] getColFamily() {
    return colFamily;
  }","byte[] getColFamily() {
    return colFamily;
  }",0,[0]
18474,bugs-dot-jar_OAK-1093_531aca78,"@Override
    public String getPath() throws RepositoryException {
        try {
            return result.getLocalPath(row.getPath(pathSelector));
        } catch (IllegalArgumentException e) {
            throw new RepositoryException(e);
        }
    }","@Override
    public String getPath() throws RepositoryException {
        try {
            return result.getLocalPath(row.getPath(pathSelector));
        } catch (IllegalArgumentException e) {
            throw new RepositoryException(e);
        }
    }",0,[0]
26472,bugs-dot-jar_WICKET-3510_292a2582,"public static DateTextField forDatePattern(String id, IModel<Date> model, String datePattern)
	{
		return new DateTextField(id, model, new PatternDateConverter(datePattern, true));
	}","public static DateTextField forDatePattern(String id, IModel<Date> model, String datePattern)
	{
		return new DateTextField(id, model, new PatternDateConverter(datePattern, true));
	}",0,[0]
32727,bugs-dot-jar_WICKET-4138_7c89598a,"@Override
	public boolean shouldPreserveClientUrl()
	{
		return errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri());
	}","@Override
	public boolean shouldPreserveClientUrl()
	{
		return (errorAttributes != null && !Strings.isEmpty(errorAttributes.getRequestUri()) || forwardAttributes != null &&
			!Strings.isEmpty(forwardAttributes.getRequestUri()));
	}",1,[3]
9291,bugs-dot-jar_WICKET-4185_5fd03973,"public void respond(final IRequestCycle requestCycle)
	{
		final IRequestablePage page = getPage();
		final boolean freshPage = pageComponentProvider.isPageInstanceFresh();
		final boolean isAjax = ((WebRequest)requestCycle.getRequest()).isAjax();

		if (getComponent().getPage() == page)
		{
			if (page instanceof Page)
			{
				// initialize the page to be able to check whether it is stateless
				((Page)page).internalInitialize();
			}
			final boolean isStateless = page.isPageStateless();

			RedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT
				: RedirectPolicy.AUTO_REDIRECT;
			final IPageProvider pageProvider = new PageProvider(page);

			if (freshPage && isStateless == false)
			{
				// A listener interface is invoked on an expired page.

				// If the page is stateful then we cannot assume that the listener interface is
				// invoked on its initial state (right after page initialization) and that its
				// component and/or behavior will be available. That's why the listener interface
				// should be ignored and the best we can do is to re-paint the newly constructed
				// page.

				if (LOG.isDebugEnabled())
				{
					LOG.debug(
						""A ListenerInterface '{}' assigned to '{}' is executed on an expired stateful page. ""
							+ ""Scheduling re-create of the page and ignoring the listener interface..."",
						listenerInterface, getComponentPath());
				}

				if (isAjax)
				{
					policy = RedirectPolicy.ALWAYS_REDIRECT;
				}

				requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(
					pageProvider, policy));
				return;
			}

			if (isAjax == false && listenerInterface.isRenderPageAfterInvocation())
			{
				// schedule page render after current request handler is done. this can be
				// overridden during invocation of listener
				// method (i.e. by calling RequestCycle#setResponsePage)
				requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(
					pageProvider, policy));
			}

			invokeListener();

		}
		else
		{
			throw new WicketRuntimeException(""Component "" + getComponent() +
				"" has been removed from page."");
		}
	}","public void respond(final IRequestCycle requestCycle)
	{
		final IRequestablePage page = getPage();
		final boolean freshPage = pageComponentProvider.isPageInstanceFresh();
		final boolean isAjax = ((WebRequest)requestCycle.getRequest()).isAjax();

		if (getComponent().getPage() == page)
		{
			if (page instanceof Page)
			{
				// initialize the page to be able to check whether it is stateless
				((Page)page).internalInitialize();
			}
			final boolean isStateless = page.isPageStateless();

			RedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT
				: RedirectPolicy.AUTO_REDIRECT;
			final IPageProvider pageProvider = new PageProvider(page);

			if (freshPage && isStateless == false)
			{
				// A listener interface is invoked on an expired page.

				// If the page is stateful then we cannot assume that the listener interface is
				// invoked on its initial state (right after page initialization) and that its
				// component and/or behavior will be available. That's why the listener interface
				// should be ignored and the best we can do is to re-paint the newly constructed
				// page.

				if (LOG.isDebugEnabled())
				{
					LOG.debug(
						""A ListenerInterface '{}' assigned to '{}' is executed on an expired stateful page. ""
							+ ""Scheduling re-create of the page and ignoring the listener interface..."",
						listenerInterface, getComponentPath());
				}

				if (isAjax)
				{
					policy = RedirectPolicy.ALWAYS_REDIRECT;
				}

				requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(
					pageProvider, policy));
				return;
			}

			if (isAjax == false && listenerInterface.isRenderPageAfterInvocation())
			{
				// schedule page render after current request handler is done. this can be
				// overridden during invocation of listener
				// method (i.e. by calling RequestCycle#setResponsePage)
				requestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(
					pageProvider, policy));
			}

			invokeListener();

		}
		else
		{
			throw new WicketRuntimeException(""Component "" + getComponent() +
				"" has been removed from page."");
		}
	}",0,[0]
36705,bugs-dot-jar_ACCUMULO-3424_27d4ee21,"public void printInfo() throws IOException {
    reader.print(""\n"" + SHELL_DESCRIPTION + ""\n"" + ""- \n"" + ""- version: "" + Constants.VERSION + ""\n"" + ""- instance name: ""
        + connector.getInstance().getInstanceName() + ""\n"" + ""- instance id: "" + connector.getInstance().getInstanceID() + ""\n"" + ""- \n""
        + ""- type 'help' for a list of available commands\n"" + ""- \n"");
    reader.flush();
  }","public void printInfo() throws IOException {
    reader.print(""\n"" + SHELL_DESCRIPTION + ""\n"" + ""- \n"" + ""- version: "" + Constants.VERSION + ""\n"" + ""- instance name: ""
        + connector.getInstance().getInstanceName() + ""\n"" + ""- instance id: "" + connector.getInstance().getInstanceID() + ""\n"" + ""- \n""
        + ""- type 'help' for a list of available commands\n"" + ""- \n"");
    reader.flush();
  }",0,[0]
36318,bugs-dot-jar_CAMEL-9444_baece126,"public SplitDefinition parallelProcessing() {
        setParallelProcessing(true);
        return this;
    }","public SplitDefinition parallelProcessing() {
        setParallelProcessing(true);
        return this;
    }",0,[0]
19678,bugs-dot-jar_WICKET-4259_1f128536,"public AjaxEditableLabel(final String id, final IModel<T> model)
	{
		super(id, model);
		setOutputMarkupId(true);
	}","public AjaxEditableLabel(final String id, final IModel<T> model)
	{
		super(id, model);
		setOutputMarkupId(true);
	}",0,[0]
4320,bugs-dot-jar_CAMEL-4682_1e54865c,"protected synchronized void suspendRouteService(RouteService routeService) throws Exception {
        routeService.setRemovingRoutes(false);
        routeService.suspend();
        for (Route route : routeService.getRoutes()) {
            if (log.isInfoEnabled()) {
                log.info(""Route: "" + route.getId() + "" suspended, was consuming from: "" + route.getConsumer().getEndpoint());
            }
        }
    }","protected synchronized void suspendRouteService(RouteService routeService) throws Exception {
        routeService.setRemovingRoutes(false);
        routeService.suspend();
        for (Route route : routeService.getRoutes()) {
            if (log.isInfoEnabled()) {
                log.info(""Route: "" + route.getId() + "" suspended, was consuming from: "" + route.getConsumer().getEndpoint());
            }
        }
    }",0,[0]
16268,bugs-dot-jar_FLINK-3189_a5b05566,"private static Options getInfoOptionsWithoutDeprecatedOptions(Options options) {
		options.addOption(CLASS_OPTION);
		options.addOption(PARALLELISM_OPTION);
		options = getJobManagerAddressOption(options);
		return options;
	}","private static Options getInfoOptionsWithoutDeprecatedOptions(Options options) {
		options.addOption(CLASS_OPTION);
		options.addOption(PARALLELISM_OPTION);
		options = getJobManagerAddressOption(options);
		return options;
	}",0,[0]
2798,bugs-dot-jar_OAK-2174_5931a4a7,"private void mergeWithConcurrencyCheck(
            NodeBuilder builder, final String checkpoint, final long lease)
            throws CommitFailedException {
        CommitHook concurrentUpdateCheck = new CommitHook() {
            @Override @Nonnull
            public NodeState processCommit(
                    NodeState before, NodeState after, CommitInfo info)
                    throws CommitFailedException {
                // check for concurrent updates by this async task
                NodeState async = before.getChildNode(ASYNC);
                if (checkpoint == null || Objects.equal(checkpoint, async.getString(name))
                        && lease == async.getLong(name + ""-lease"")) {
                    return after;
                } else {
                    throw CONCURRENT_UPDATE;
                }
            }
        };
        CompositeHook hooks = new CompositeHook(
                new ConflictHook(new AnnotatingConflictHandler()),
                new EditorHook(new ConflictValidatorProvider()),
                concurrentUpdateCheck);
        store.merge(builder, hooks, CommitInfo.EMPTY);
    }","private void mergeWithConcurrencyCheck(
            NodeBuilder builder, final String checkpoint, final long lease)
            throws CommitFailedException {
        CommitHook concurrentUpdateCheck = new CommitHook() {
            @Override @Nonnull
            public NodeState processCommit(
                    NodeState before, NodeState after, CommitInfo info)
                    throws CommitFailedException {
                // check for concurrent updates by this async task
                NodeState async = before.getChildNode(ASYNC);
                if (checkpoint == null || Objects.equal(checkpoint, async.getString(name))
                        && lease == async.getLong(name + ""-lease"")) {
                    return after;
                } else {
                    throw CONCURRENT_UPDATE;
                }
            }
        };
        CompositeHook hooks = new CompositeHook(
                new ConflictHook(new AnnotatingConflictHandler()),
                new EditorHook(new ConflictValidatorProvider()),
                concurrentUpdateCheck);
        store.merge(builder, hooks, CommitInfo.EMPTY);
    }",0,[0]
23251,bugs-dot-jar_OAK-1308_69ba2a54,"private Expression parsePropertyOrFunction() throws ParseException {
        StringBuilder buff = new StringBuilder();
        boolean isPath = false;
        while (true) {
            if (currentTokenType == IDENTIFIER) {
                String name = readIdentifier();
                buff.append(name);
            } else if (readIf(""*"")) {
                // any node
                buff.append('*');
                isPath = true;
            } else if (readIf(""."")) {
                buff.append('.');
                if (readIf(""."")) {
                    buff.append('.');
                }
                isPath = true;
            } else if (readIf(""@"")) {
                if (readIf(""*"")) {
                    // xpath supports @*, even thought jackrabbit may not
                    buff.append('*');
                } else {
                    buff.append(readIdentifier());
                }
                return new Expression.Property(currentSelector, buff.toString());
            } else {
                break;
            }
            if (readIf(""/"")) {
                isPath = true;
                buff.append('/');
            } else {
                break;
            }
        }
        if (!isPath && readIf(""("")) {
            return parseFunction(buff.toString());
        } else if (buff.length() > 0) {
            // path without all attributes, as in:
            // jcr:contains(jcr:content, 'x')
            if (buff.toString().equals(""."")) {
                buff = new StringBuilder(""*"");
            } else {
                buff.append(""/*"");
            }
            return new Expression.Property(currentSelector, buff.toString());
        }
        throw getSyntaxError();
    }","private Expression parsePropertyOrFunction() throws ParseException {
        StringBuilder buff = new StringBuilder();
        boolean isPath = false;
        while (true) {
            if (currentTokenType == IDENTIFIER) {
                String name = readPathSegment();
                buff.append(name);
            } else if (readIf(""*"")) {
                // any node
                buff.append('*');
                isPath = true;
            } else if (readIf(""."")) {
                buff.append('.');
                if (readIf(""."")) {
                    buff.append('.');
                }
                isPath = true;
            } else if (readIf(""@"")) {
                if (readIf(""*"")) {
                    // xpath supports @*, even thought jackrabbit may not
                    buff.append('*');
                } else {
                    buff.append(readPathSegment());
                }
                return new Expression.Property(currentSelector, buff.toString());
            } else {
                break;
            }
            if (readIf(""/"")) {
                isPath = true;
                buff.append('/');
            } else {
                break;
            }
        }
        if (!isPath && readIf(""("")) {
            return parseFunction(buff.toString());
        } else if (buff.length() > 0) {
            // path without all attributes, as in:
            // jcr:contains(jcr:content, 'x')
            if (buff.toString().equals(""."")) {
                buff = new StringBuilder(""*"");
            } else {
                buff.append(""/*"");
            }
            return new Expression.Property(currentSelector, buff.toString());
        }
        throw getSyntaxError();
    }",1,"[5, 22]"
31473,bugs-dot-jar_OAK-3433_b76b31f7,"public DocumentNodeStore(DocumentMK.Builder builder) {
        this.blobStore = builder.getBlobStore();
        if (builder.isUseSimpleRevision()) {
            this.simpleRevisionCounter = new AtomicInteger(0);
        }
        DocumentStore s = builder.getDocumentStore();
        if (builder.getTiming()) {
            s = new TimingDocumentStoreWrapper(s);
        }
        if (builder.getLogging()) {
            s = new LoggingDocumentStoreWrapper(s);
        }
        this.changes = Collection.JOURNAL.newDocument(s);
        this.executor = builder.getExecutor();
        this.clock = builder.getClock();
        int cid = builder.getClusterId();
        cid = Integer.getInteger(""oak.documentMK.clusterId"", cid);
        if (cid == 0) {
            clusterNodeInfo = ClusterNodeInfo.getInstance(s);
            // TODO we should ensure revisions generated from now on
            // are never ""older"" than revisions already in the repository for
            // this cluster id
            cid = clusterNodeInfo.getId();
        } else {
            clusterNodeInfo = null;
        }
        if (builder.getLeaseCheck()) {
            s = new LeaseCheckDocumentStoreWrapper(s, clusterNodeInfo);
            if (clusterNodeInfo!=null) {
                clusterNodeInfo.setLeaseFailureHandler(builder.getLeaseFailureHandler());
            }
        }
        this.store = s;
        this.clusterId = cid;
        this.revisionComparator = new Revision.RevisionComparator(clusterId);
        this.branches = new UnmergedBranches(getRevisionComparator());
        this.asyncDelay = builder.getAsyncDelay();
        this.versionGarbageCollector = new VersionGarbageCollector(
                this, builder.createVersionGCSupport());
        this.journalGarbageCollector = new JournalGarbageCollector(this);
        this.referencedBlobs = builder.createReferencedBlobs(this);
        this.lastRevRecoveryAgent = new LastRevRecoveryAgent(this);
        this.disableBranches = builder.isDisableBranches();
        this.missing = new DocumentNodeState(this, ""MISSING"", new Revision(0, 0, 0)) {
            @Override
            public int getMemory() {
                return 8;
            }
        };

        //TODO Make stats collection configurable as it add slight overhead

        nodeCache = builder.buildNodeCache(this);
        nodeCacheStats = new CacheStats(nodeCache, ""Document-NodeState"",
                builder.getWeigher(), builder.getNodeCacheSize());

        nodeChildrenCache = builder.buildChildrenCache();
        nodeChildrenCacheStats = new CacheStats(nodeChildrenCache, ""Document-NodeChildren"",
                builder.getWeigher(), builder.getChildrenCacheSize());

        docChildrenCache = builder.buildDocChildrenCache();
        docChildrenCacheStats = new CacheStats(docChildrenCache, ""Document-DocChildren"",
                builder.getWeigher(), builder.getDocChildrenCacheSize());

        diffCache = builder.getDiffCache();
        checkpoints = new Checkpoints(this);

        // check if root node exists
        NodeDocument rootDoc = store.find(NODES, Utils.getIdFromPath(""/""));
        if (rootDoc == null) {
            // root node is missing: repository is not initialized
            Revision head = newRevision();
            Commit commit = new Commit(this, head, null, null);
            DocumentNodeState n = new DocumentNodeState(this, ""/"", head);
            commit.addNode(n);
            commit.applyToDocumentStore();
            // use dummy Revision as before
            commit.applyToCache(new Revision(0, 0, clusterId), false);
            setHeadRevision(commit.getRevision());
            // make sure _lastRev is written back to store
            backgroundWrite();
        } else {
            // initialize branchCommits
            branches.init(store, this);
            // initial reading of the revisions of other cluster nodes
            backgroundRead(false);
            if (headRevision == null) {
                // no revision read from other cluster nodes
                setHeadRevision(newRevision());
            }
            // check if _lastRev for our clusterId exists
            if (!rootDoc.getLastRev().containsKey(clusterId)) {
                unsavedLastRevisions.put(""/"", headRevision);
                backgroundWrite();
            }
        }
        checkLastRevRecovery();
        // Renew the lease because it may have been stale
        renewClusterIdLease();

        getRevisionComparator().add(headRevision, Revision.newRevision(0));

        dispatcher = new ChangeDispatcher(getRoot());
        commitQueue = new CommitQueue(this);
        String threadNamePostfix = ""("" + clusterId + "")"";
        batchCommitQueue = new BatchCommitQueue(store, revisionComparator);
        backgroundReadThread = new Thread(
                new BackgroundReadOperation(this, isDisposed),
                ""DocumentNodeStore background read thread "" + threadNamePostfix);
        backgroundReadThread.setDaemon(true);
        backgroundUpdateThread = new Thread(
                new BackgroundOperation(this, isDisposed),
                ""DocumentNodeStore background update thread "" + threadNamePostfix);
        backgroundUpdateThread.setDaemon(true);

        backgroundReadThread.start();
        backgroundUpdateThread.start();

        if (clusterNodeInfo != null) {
            leaseUpdateThread = new Thread(
                    new BackgroundLeaseUpdate(this, isDisposed),
                    ""DocumentNodeStore lease update thread "" + threadNamePostfix);
            leaseUpdateThread.setDaemon(true);
            // OAK-3398 : make lease updating more robust by ensuring it
            // has higher likelihood of succeeding than other threads
            // on a very busy machine - so as to prevent lease timeout.
            leaseUpdateThread.setPriority(Thread.MAX_PRIORITY);
            leaseUpdateThread.start();
        }

        this.mbean = createMBean();
        LOG.info(""Initialized DocumentNodeStore with clusterNodeId: {} ({})"", clusterId,
                getClusterNodeInfoDisplayString());
    }","public DocumentNodeStore(DocumentMK.Builder builder) {
        this.blobStore = builder.getBlobStore();
        if (builder.isUseSimpleRevision()) {
            this.simpleRevisionCounter = new AtomicInteger(0);
        }
        DocumentStore s = builder.getDocumentStore();
        if (builder.getTiming()) {
            s = new TimingDocumentStoreWrapper(s);
        }
        if (builder.getLogging()) {
            s = new LoggingDocumentStoreWrapper(s);
        }
        this.changes = Collection.JOURNAL.newDocument(s);
        this.executor = builder.getExecutor();
        this.clock = builder.getClock();
        int cid = builder.getClusterId();
        cid = Integer.getInteger(""oak.documentMK.clusterId"", cid);
        if (cid == 0) {
            clusterNodeInfo = ClusterNodeInfo.getInstance(s);
            // TODO we should ensure revisions generated from now on
            // are never ""older"" than revisions already in the repository for
            // this cluster id
            cid = clusterNodeInfo.getId();
        } else {
            clusterNodeInfo = null;
        }
        if (builder.getLeaseCheck()) {
            s = new LeaseCheckDocumentStoreWrapper(s, clusterNodeInfo);
            if (clusterNodeInfo!=null) {
                clusterNodeInfo.setLeaseFailureHandler(builder.getLeaseFailureHandler());
            }
        }
        this.store = s;
        this.clusterId = cid;
        this.revisionComparator = new Revision.RevisionComparator(clusterId);
        this.branches = new UnmergedBranches(getRevisionComparator());
        this.asyncDelay = builder.getAsyncDelay();
        this.versionGarbageCollector = new VersionGarbageCollector(
                this, builder.createVersionGCSupport());
        this.journalGarbageCollector = new JournalGarbageCollector(this);
        this.referencedBlobs = builder.createReferencedBlobs(this);
        this.lastRevRecoveryAgent = new LastRevRecoveryAgent(this);
        this.disableBranches = builder.isDisableBranches();
        this.missing = new DocumentNodeState(this, ""MISSING"", new Revision(0, 0, 0)) {
            @Override
            public int getMemory() {
                return 8;
            }
        };

        //TODO Make stats collection configurable as it add slight overhead

        nodeCache = builder.buildNodeCache(this);
        nodeCacheStats = new CacheStats(nodeCache, ""Document-NodeState"",
                builder.getWeigher(), builder.getNodeCacheSize());

        nodeChildrenCache = builder.buildChildrenCache();
        nodeChildrenCacheStats = new CacheStats(nodeChildrenCache, ""Document-NodeChildren"",
                builder.getWeigher(), builder.getChildrenCacheSize());

        docChildrenCache = builder.buildDocChildrenCache();
        docChildrenCacheStats = new CacheStats(docChildrenCache, ""Document-DocChildren"",
                builder.getWeigher(), builder.getDocChildrenCacheSize());

        diffCache = builder.getDiffCache();
        checkpoints = new Checkpoints(this);

        // check if root node exists
        NodeDocument rootDoc = store.find(NODES, Utils.getIdFromPath(""/""));
        if (rootDoc == null) {
            // root node is missing: repository is not initialized
            Revision head = newRevision();
            Commit commit = new Commit(this, head, null, null);
            DocumentNodeState n = new DocumentNodeState(this, ""/"", head);
            commit.addNode(n);
            commit.applyToDocumentStore();
            // use dummy Revision as before
            commit.applyToCache(new Revision(0, 0, clusterId), false);
            setHeadRevision(commit.getRevision());
            // make sure _lastRev is written back to store
            backgroundWrite();
        } else {
            // initialize branchCommits
            branches.init(store, this);
            // initial reading of the revisions of other cluster nodes
            backgroundRead(false);
            if (headRevision == null) {
                // no revision read from other cluster nodes
                setHeadRevision(newRevision());
            }
            // check if _lastRev for our clusterId exists
            if (!rootDoc.getLastRev().containsKey(clusterId)) {
                unsavedLastRevisions.put(""/"", headRevision);
                backgroundWrite();
            }
        }
        checkLastRevRecovery();
        // Renew the lease because it may have been stale
        renewClusterIdLease();

        getRevisionComparator().add(headRevision, Revision.newRevision(0));

        dispatcher = new ChangeDispatcher(getRoot());
        commitQueue = new CommitQueue(this);
        String threadNamePostfix = ""("" + clusterId + "")"";
        batchCommitQueue = new BatchCommitQueue(store, revisionComparator);
        backgroundReadThread = new Thread(
                new BackgroundReadOperation(this, isDisposed),
                ""DocumentNodeStore background read thread "" + threadNamePostfix);
        backgroundReadThread.setDaemon(true);
        backgroundUpdateThread = new Thread(
                new BackgroundOperation(this, isDisposed),
                ""DocumentNodeStore background update thread "" + threadNamePostfix);
        backgroundUpdateThread.setDaemon(true);

        backgroundReadThread.start();
        backgroundUpdateThread.start();

        if (clusterNodeInfo != null) {
            leaseUpdateThread = new Thread(
                    new BackgroundLeaseUpdate(this, isDisposed),
                    ""DocumentNodeStore lease update thread "" + threadNamePostfix);
            leaseUpdateThread.setDaemon(true);
            // OAK-3398 : make lease updating more robust by ensuring it
            // has higher likelihood of succeeding than other threads
            // on a very busy machine - so as to prevent lease timeout.
            leaseUpdateThread.setPriority(Thread.MAX_PRIORITY);
            leaseUpdateThread.start();
        }

        this.mbean = createMBean();
        LOG.info(""Initialized DocumentNodeStore with clusterNodeId: {} ({})"", clusterId,
                getClusterNodeInfoDisplayString());
    }",0,[0]
40413,bugs-dot-jar_WICKET-442_246d53c5,"public final Page newPage(final Class c, final PageParameters parameters)
	{
		return getPageFactory().newPage(c, parameters);
	}","public final Page newPage(final Class c, final PageParameters parameters)
	{
		return getPageFactory().newPage(c, parameters);
	}",0,[0]
7923,bugs-dot-jar_MATH-812_6eb46555,"public double getLInfNorm() {
        double norm = 0;
        Iterator<Entry> it = sparseIterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            norm = FastMath.max(norm, FastMath.abs(e.getValue()));
        }
        return norm;
    }","public double getLInfNorm() {
        double norm = 0;
        Iterator<Entry> it = sparseIterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            norm = FastMath.max(norm, FastMath.abs(e.getValue()));
        }
        return norm;
    }",0,[0]
32613,bugs-dot-jar_WICKET-4370_7ca927c1,"@Override
	public RequestDispatcher getRequestDispatcher(String name)
	{
		return context.getRequestDispatcher(name);
	}","@Override
	public RequestDispatcher getRequestDispatcher(String name)
	{
		return context.getRequestDispatcher(name);
	}",0,[0]
19944,bugs-dot-jar_FLINK-3052_8dc70f2e,"public TwoInputNode getSingleRootOfStepFunction() {
		return this.singleRoot;
	}","public TwoInputNode getSingleRootOfStepFunction() {
		return this.singleRoot;
	}",0,[0]
4321,bugs-dot-jar_CAMEL-4682_1e54865c,"protected synchronized void safelyStartRouteServices(boolean checkClash, boolean startConsumer, boolean resumeConsumer,
                                                         boolean addingRoutes, Collection<RouteService> routeServices) throws Exception {
        // list of inputs to start when all the routes have been prepared for starting
        // we use a tree map so the routes will be ordered according to startup order defined on the route
        Map<Integer, DefaultRouteStartupOrder> inputs = new TreeMap<Integer, DefaultRouteStartupOrder>();

        // figure out the order in which the routes should be started
        for (RouteService routeService : routeServices) {
            DefaultRouteStartupOrder order = doPrepareRouteToBeStarted(routeService);
            // check for clash before we add it as input
            if (checkClash) {
                doCheckStartupOrderClash(order, inputs);
            }
            inputs.put(order.getStartupOrder(), order);
        }

        // warm up routes before we start them
        doWarmUpRoutes(inputs, startConsumer);

        if (startConsumer) {
            if (resumeConsumer) {
                // and now resume the routes
                doResumeRouteConsumers(inputs, addingRoutes);
            } else {
                // and now start the routes
                // and check for clash with multiple consumers of the same endpoints which is not allowed
                doStartRouteConsumers(inputs, addingRoutes);
            }
        }

        // inputs no longer needed
        inputs.clear();
    }","protected synchronized void safelyStartRouteServices(boolean checkClash, boolean startConsumer, boolean resumeConsumer,
                                                         boolean addingRoutes, Collection<RouteService> routeServices) throws Exception {
        // list of inputs to start when all the routes have been prepared for starting
        // we use a tree map so the routes will be ordered according to startup order defined on the route
        Map<Integer, DefaultRouteStartupOrder> inputs = new TreeMap<Integer, DefaultRouteStartupOrder>();

        // figure out the order in which the routes should be started
        for (RouteService routeService : routeServices) {
            DefaultRouteStartupOrder order = doPrepareRouteToBeStarted(routeService);
            // check for clash before we add it as input
            if (checkClash) {
                doCheckStartupOrderClash(order, inputs);
            }
            inputs.put(order.getStartupOrder(), order);
        }

        // warm up routes before we start them
        doWarmUpRoutes(inputs, startConsumer);

        if (startConsumer) {
            if (resumeConsumer) {
                // and now resume the routes
                doResumeRouteConsumers(inputs, addingRoutes);
            } else {
                // and now start the routes
                // and check for clash with multiple consumers of the same endpoints which is not allowed
                doStartRouteConsumers(inputs, addingRoutes);
            }
        }

        // inputs no longer needed
        inputs.clear();
    }",0,[0]
193,Bears-6,"private <T> Linked<T> _trimByVisibility(Linked<T> node)
    {
        if (node == null) {
            return node;
        }
        return node.trimByVisibility();
    }","private <T> Linked<T> _trimByVisibility(Linked<T> node)
    {
        if (node == null) {
            return node;
        }
        return node.trimByVisibility();
    }",0,[0]
24919,bugs-dot-jar_CAMEL-7146_b6981cfd,"public boolean process(Exchange exchange, AsyncCallback callback) {
        try {
            doProcess(exchange);
        } catch (Throwable e) {
            exchange.setException(e);
        }
        callback.done(true);
        return true;
    }","public boolean process(Exchange exchange, AsyncCallback callback) {
        try {
            doProcess(exchange);
        } catch (Throwable e) {
            exchange.setException(e);
        }
        callback.done(true);
        return true;
    }",0,[0]
36264,bugs-dot-jar_CAMEL-9444_baece126,"public RecipientListDefinition<Type> stopOnException() {
        setStopOnException(true);
        return this;
    }","public RecipientListDefinition<Type> stopOnException() {
        setStopOnException(true);
        return this;
    }",0,[0]
21145,bugs-dot-jar_WICKET-5442_a382917f,"public static Time parseDate(final Calendar calendar, final String string)
		throws ParseException
	{
		synchronized (dateFormat)
		{
			synchronized (calendar)
			{
				dateFormat.setCalendar(calendar);

				return valueOf(dateFormat.parse(string));
			}
		}
	}","public static Time parseDate(final Calendar calendar, final String string)
		throws ParseException
	{
		synchronized (dateFormat)
		{
			synchronized (calendar)
			{
				dateFormat.setCalendar(calendar);

				return valueOf(dateFormat.parse(string));
			}
		}
	}",0,[0]
13781,bugs-dot-jar_CAMEL-6936_4954d573,"protected boolean isInProgress(GenericFile<T> file) {
        String key = file.getAbsoluteFilePath();
        return !endpoint.getInProgressRepository().add(key);
    }","protected boolean isInProgress(GenericFile<T> file) {
        String key = file.getAbsoluteFilePath();
        // must use add, to have operation as atomic
        return !endpoint.getInProgressRepository().add(key);
    }",1,[]
12406,bugs-dot-jar_OAK-1225_3535afe2,"public SessionImpl(SessionContext sessionContext) {
        this.sessionContext = sessionContext;
        this.sd = sessionContext.getSessionDelegate();
    }","public SessionImpl(SessionContext sessionContext) {
        this.sessionContext = sessionContext;
        this.sd = sessionContext.getSessionDelegate();
    }",0,[0]
9099,bugs-dot-jar_WICKET-4777_eccb3b11,"public void write(final CharSequence script)
	{
		response.write(script);
	}","public void write(final CharSequence script)
	{
		response.write(script);
	}",0,[0]
36260,bugs-dot-jar_CAMEL-9444_baece126,"public RecipientListDefinition<Type> parallelProcessing() {
        setParallelProcessing(true);
        return this;
    }","public RecipientListDefinition<Type> parallelProcessing() {
        setParallelProcessing(true);
        return this;
    }",0,[0]
33539,bugs-dot-jar_WICKET-4520_b91154ea,"public abstract Session newSession(Request request, Response response);","public abstract Session newSession(Request request, Response response);",0,[0]
9469,bugs-dot-jar_WICKET-5319_c863b032,"protected Url encryptUrl(final Url url)
	{
		if (url.getSegments().isEmpty())
		{
			return url;
		}
		String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());

		Url encryptedUrl = new Url(url.getCharset());
		encryptedUrl.getSegments().add(encryptedUrlString);

		int numberOfSegments = url.getSegments().size();
		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
		for (int segNo = 0; segNo < numberOfSegments; segNo++)
		{
			encryptedUrl.getSegments().add(generator.next());
		}
		return encryptedUrl;
	}","protected Url encryptUrl(final Url url)
	{
		if (url.getSegments().isEmpty())
		{
			return url;
		}
		String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());

		Url encryptedUrl = new Url(url.getCharset());
		encryptedUrl.getSegments().add(encryptedUrlString);

		int numberOfSegments = url.getSegments().size();
		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
		for (int segNo = 0; segNo < numberOfSegments; segNo++)
		{
			encryptedUrl.getSegments().add(generator.next());
		}
		return encryptedUrl;
	}",0,[0]
33274,bugs-dot-jar_ACCUMULO-795_9453bcfa,"public TableOperationsImpl(Instance instance, AuthInfo credentials) {
    ArgumentChecker.notNull(instance, credentials);
    this.instance = instance;
    this.credentials = credentials;
  }","public TableOperationsImpl(Instance instance, AuthInfo credentials) {
    ArgumentChecker.notNull(instance, credentials);
    this.instance = instance;
    this.credentials = credentials;
  }",0,[0]
1921,Bears-228,"private String getSetterFunction(Widget widget) {
		if (widget == null) {
			return null;
        }
		if (widget instanceof AutocompleteWidget) {
			return ""autocompleteSetterFunction"";
        }
		return null;
	}","private String getSetterFunction(Widget widget) {
		if (widget == null) {
			return null;
        }
		if (widget instanceof AutocompleteWidget) {
			return ""autocompleteSetterFunction"";
        }
		return null;
	}",0,[0]
6982,bugs-dot-jar_OAK-3411_978c77ff,"@Nonnull
    private Value getLatestValue(@Nonnull RevisionContext context,
                                 @Nonnull Map<Revision, String> valueMap,
                                 @Nullable Revision min,
                                 @Nonnull Revision readRevision,
                                 @Nonnull Map<Revision, String> validRevisions,
                                 @Nonnull LastRevs lastRevs) {
        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
            Revision propRev = entry.getKey();
            String commitValue = validRevisions.get(propRev);
            if (commitValue == null) {
                // resolve revision
                NodeDocument commitRoot = getCommitRoot(propRev);
                if (commitRoot == null) {
                    continue;
                }
                commitValue = commitRoot.getCommitValue(propRev);
                if (commitValue == null) {
                    continue;
                }
            }

            Revision commitRev = resolveCommitRevision(propRev, commitValue);
            if (Utils.isCommitted(commitValue)) {
                lastRevs.update(commitRev);
            } else {
                // branch commit
                lastRevs.updateBranch(commitRev.asBranchRevision());
            }

            if (min != null && isRevisionNewer(context, min, commitRev)) {
                continue;
            }
            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {
                // TODO: need to check older revisions as well?
                return new Value(commitRev, entry.getValue());
            }
        }

        Revision r = min != null ? min : readRevision;
        return new Value(r, null);
    }","@Nonnull
    private Value getLatestValue(@Nonnull RevisionContext context,
                                 @Nonnull Map<Revision, String> valueMap,
                                 @Nullable Revision min,
                                 @Nonnull Revision readRevision,
                                 @Nonnull Map<Revision, String> validRevisions,
                                 @Nonnull LastRevs lastRevs) {
        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
            Revision propRev = entry.getKey();
            String commitValue = validRevisions.get(propRev);
            if (commitValue == null) {
                // resolve revision
                NodeDocument commitRoot = getCommitRoot(propRev);
                if (commitRoot == null) {
                    continue;
                }
                commitValue = commitRoot.getCommitValue(propRev);
                if (commitValue == null) {
                    continue;
                }
            }

            Revision commitRev = resolveCommitRevision(propRev, commitValue);
            if (Utils.isCommitted(commitValue)) {
                lastRevs.update(commitRev);
            } else {
                // branch commit
                lastRevs.updateBranch(commitRev.asBranchRevision());
            }

            if (min != null && isRevisionNewer(context, min, commitRev)) {
                continue;
            }
            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {
                // TODO: need to check older revisions as well?
                return new Value(commitRev, entry.getValue());
            }
        }

        Revision r = min != null ? min : readRevision;
        return new Value(r, null);
    }",0,[0]
29765,bugs-dot-jar_FLINK-2763_af477563,"@Override
	public MemorySegment nextSegment() {
		final MemorySegment seg = getNextBuffer();
		if (seg != null) {
			return seg;
		} else {
			try {
				spillPartition();
			} catch (IOException ioex) {
				throw new RuntimeException(""Error spilling Hash Join Partition"" + (ioex.getMessage() == null ?
					""."" : "": "" + ioex.getMessage()), ioex);
			}
			
			MemorySegment fromSpill = getNextBuffer();
			if (fromSpill == null) {
				throw new RuntimeException(""BUG in Hybrid Hash Join: Spilling did not free a buffer."");
			} else {
				return fromSpill;
			}
		}
	}","@Override
	public MemorySegment nextSegment() {
		final MemorySegment seg = getNextBuffer();
		if (seg != null) {
			return seg;
		} else {
			try {
				spillPartition();
			} catch (IOException ioex) {
				throw new RuntimeException(""Error spilling Hash Join Partition"" + (ioex.getMessage() == null ?
					""."" : "": "" + ioex.getMessage()), ioex);
			}
			
			MemorySegment fromSpill = getNextBuffer();
			if (fromSpill == null) {
				throw new RuntimeException(""BUG in Hybrid Hash Join: Spilling did not free a buffer."");
			} else {
				return fromSpill;
			}
		}
	}",0,[0]
23979,bugs-dot-jar_OAK-579_7d72e6ed,"Iterator<ResultRowImpl> getRows() {
        prepare();
        Iterator<ResultRowImpl> it;
        if (explain) {
            String plan = source.getPlan(rootState);
            columns = new ColumnImpl[] { new ColumnImpl(""explain"", ""plan"", ""plan"")};
            ResultRowImpl r = new ResultRowImpl(this,
                    new String[0], 
                    new PropertyValue[] { PropertyValues.newString(plan)},
                    null);
            it = Arrays.asList(r).iterator();
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""plan: "" + source.getPlan(rootState));
            }
            if (orderings == null) {
                // can apply limit and offset directly
                it = new RowIterator(rootState, limit, offset);
            } else {
                // read and order first; skip and limit afterwards
                it = new RowIterator(rootState, Long.MAX_VALUE, 0);
            }
            long readCount = 0;
            if (orderings != null) {
                // TODO ""order by"" is not necessary if the used index returns
                // rows in the same order
                    
                // avoid overflow (both offset and limit could be Long.MAX_VALUE)
                int keep = (int) Math.min(Integer.MAX_VALUE, 
                        Math.min(Integer.MAX_VALUE, offset) + 
                        Math.min(Integer.MAX_VALUE, limit));
                
                ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();
                while (it.hasNext()) {
                    readCount++;
                    ResultRowImpl r = it.next();
                    list.add(r);
                    // from time to time, sort and truncate
                    // this should results in O(n*log(2*keep)) operations,
                    // which is close to the optimum O(n*log(keep))
                    if (list.size() > keep * 2) {
                        // remove tail entries right now, to save memory
                        Collections.sort(list);
                        keepFirst(list, keep);
                    }
                }
                Collections.sort(list);
                keepFirst(list, keep);
                
                it = list.iterator();
                // skip the head (this is more efficient than removing
                // if there are many entries)
                for (int i = 0; i < offset && it.hasNext(); i++) {
                    it.next();
                }
                size = list.size() - offset;
            } else if (measure) {
                while (it.hasNext()) {
                    readCount++;
                    it.next();
                }
            }
            if (measure) {
                columns = new ColumnImpl[] {
                        new ColumnImpl(""measure"", ""selector"", ""selector""),
                        new ColumnImpl(""measure"", ""scanCount"", ""scanCount"")
                };
                ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();
                ResultRowImpl r = new ResultRowImpl(this,
                        new String[0],
                        new PropertyValue[] {
                                PropertyValues.newString(""query""),
                                PropertyValues.newLong(readCount)
                            },
                        null);
                list.add(r);
                for (SelectorImpl selector : selectors) {
                    r = new ResultRowImpl(this,
                            new String[0],
                            new PropertyValue[] {
                                    PropertyValues.newString(selector.getSelectorName()),
                                    PropertyValues.newLong(selector.getScanCount()),
                                },
                            null);
                    list.add(r);
                }
                it = list.iterator();
            }
        }
        return it;
    }","Iterator<ResultRowImpl> getRows() {
        prepare();
        Iterator<ResultRowImpl> it;
        if (explain) {
            String plan = getPlan();
            columns = new ColumnImpl[] { new ColumnImpl(""explain"", ""plan"", ""plan"")};
            ResultRowImpl r = new ResultRowImpl(this,
                    new String[0], 
                    new PropertyValue[] { PropertyValues.newString(plan)},
                    null);
            it = Arrays.asList(r).iterator();
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""plan: "" + getPlan());
            }
            if (orderings == null) {
                // can apply limit and offset directly
                it = new RowIterator(rootState, limit, offset);
            } else {
                // read and order first; skip and limit afterwards
                it = new RowIterator(rootState, Long.MAX_VALUE, 0);
            }
            long readCount = 0;
            if (orderings != null) {
                // TODO ""order by"" is not necessary if the used index returns
                // rows in the same order
                    
                // avoid overflow (both offset and limit could be Long.MAX_VALUE)
                int keep = (int) Math.min(Integer.MAX_VALUE, 
                        Math.min(Integer.MAX_VALUE, offset) + 
                        Math.min(Integer.MAX_VALUE, limit));
                
                ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();
                while (it.hasNext()) {
                    readCount++;
                    ResultRowImpl r = it.next();
                    list.add(r);
                    // from time to time, sort and truncate
                    // this should results in O(n*log(2*keep)) operations,
                    // which is close to the optimum O(n*log(keep))
                    if (list.size() > keep * 2) {
                        // remove tail entries right now, to save memory
                        Collections.sort(list);
                        keepFirst(list, keep);
                    }
                }
                Collections.sort(list);
                keepFirst(list, keep);
                
                it = list.iterator();
                // skip the head (this is more efficient than removing
                // if there are many entries)
                for (int i = 0; i < offset && it.hasNext(); i++) {
                    it.next();
                }
                size = list.size() - offset;
            } else if (measure) {
                while (it.hasNext()) {
                    readCount++;
                    it.next();
                }
            }
            if (measure) {
                columns = new ColumnImpl[] {
                        new ColumnImpl(""measure"", ""selector"", ""selector""),
                        new ColumnImpl(""measure"", ""scanCount"", ""scanCount"")
                };
                ArrayList<ResultRowImpl> list = new ArrayList<ResultRowImpl>();
                ResultRowImpl r = new ResultRowImpl(this,
                        new String[0],
                        new PropertyValue[] {
                                PropertyValues.newString(""query""),
                                PropertyValues.newLong(readCount)
                            },
                        null);
                list.add(r);
                for (SelectorImpl selector : selectors) {
                    r = new ResultRowImpl(this,
                            new String[0],
                            new PropertyValue[] {
                                    PropertyValues.newString(selector.getSelectorName()),
                                    PropertyValues.newLong(selector.getScanCount()),
                                },
                            null);
                    list.add(r);
                }
                it = list.iterator();
            }
        }
        return it;
    }",1,"[4, 13]"
14908,bugs-dot-jar_OAK-3318_e12e2052,"private static Iterable<String> getMixinTypeNames(Tree tree) {
        PropertyState property = tree.getProperty(JcrConstants.JCR_MIMETYPE);
        return property != null ? property.getValue(Type.NAMES) : Collections.<String>emptyList();
    }","private static Iterable<String> getMixinTypeNames(Tree tree) {
        PropertyState property = tree.getProperty(JcrConstants.JCR_MIXINTYPES);
        return property != null ? property.getValue(Type.NAMES) : Collections.<String>emptyList();
    }",1,[1]
37485,bugs-dot-jar_MATH-367_3a15d8ce,"public double getL1Norm() {
        double norm = 0;
        Iterator<Entry> it = sparseIterator();
        Entry e;
        while (it.hasNext() && (e = it.next()) != null) {
            norm += Math.abs(e.getValue());
        }
        return norm;
    }","public double getL1Norm() {
        double norm = 0;
        Iterator<Entry> it = sparseIterator();
        Entry e;
        while (it.hasNext() && (e = it.next()) != null) {
            norm += Math.abs(e.getValue());
        }
        return norm;
    }",0,[0]
179,bugs-dot-jar_WICKET-2368_fae1601b,"public final void dirty()
	{
		Session.get().dirtyPage(this);
	}","public final void dirty()
	{
		Session.get().dirtyPage(this);
	}",0,[0]
28614,bugs-dot-jar_CAMEL-9143_08077733,"public boolean isExtendedStatistics() {
        return extendedStatistics;
    }","public boolean isExtendedStatistics() {
        return extendedStatistics;
    }",0,[0]
431,bugs-dot-jar_FLINK-2874_17e7b423,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <X> TypeInformation<X> privateGetForObject(X value) {
		Preconditions.checkNotNull(value);

		// check if we can extract the types from tuples, otherwise work with the class
		if (value instanceof Tuple) {
			Tuple t = (Tuple) value;
			int numFields = t.getArity();
			if(numFields != countFieldsInClass(value.getClass())) {
				// not a tuple since it has more fields. 
				return analyzePojo((Class<X>) value.getClass(), new ArrayList<Type>(), null, null, null); // we immediately call analyze Pojo here, because
				// there is currently no other type that can handle such a class.
			}
			
			TypeInformation<?>[] infos = new TypeInformation[numFields];
			for (int i = 0; i < numFields; i++) {
				Object field = t.getField(i);
				
				if (field == null) {
					throw new InvalidTypesException(""Automatic type extraction is not possible on candidates with null values. ""
							+ ""Please specify the types directly."");
				}
				
				infos[i] = privateGetForObject(field);
			}
			return new TupleTypeInfo(value.getClass(), infos);
		} else {
			return privateGetForClass((Class<X>) value.getClass(), new ArrayList<Type>());
		}
	}","@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <X> TypeInformation<X> privateGetForObject(X value) {
		Preconditions.checkNotNull(value);

		// check if we can extract the types from tuples, otherwise work with the class
		if (value instanceof Tuple) {
			Tuple t = (Tuple) value;
			int numFields = t.getArity();
			if(numFields != countFieldsInClass(value.getClass())) {
				// not a tuple since it has more fields. 
				return analyzePojo((Class<X>) value.getClass(), new ArrayList<Type>(), null, null, null); // we immediately call analyze Pojo here, because
				// there is currently no other type that can handle such a class.
			}
			
			TypeInformation<?>[] infos = new TypeInformation[numFields];
			for (int i = 0; i < numFields; i++) {
				Object field = t.getField(i);
				
				if (field == null) {
					throw new InvalidTypesException(""Automatic type extraction is not possible on candidates with null values. ""
							+ ""Please specify the types directly."");
				}
				
				infos[i] = privateGetForObject(field);
			}
			return new TupleTypeInfo(value.getClass(), infos);
		} else {
			return privateGetForClass((Class<X>) value.getClass(), new ArrayList<Type>());
		}
	}",0,[0]
12386,bugs-dot-jar_OAK-2430_be3a9114,"@Override
    public boolean propertyAdded(PropertyState after) {
        if (!loader.isRunning()) {
            return false;
        }
        builder.setProperty(binaryCheck(after));
        return true;
    }","@Override
    public boolean propertyAdded(PropertyState after) {
        if (!loader.isRunning()) {
            return false;
        }
        if (!logOnly) {
            builder.setProperty(binaryCheck(after));
        }
        return true;
    }",1,[5]
1835,bugs-dot-jar_CAMEL-8146_17475d80,"private void doRun() {
        if (isSuspended()) {
            LOG.trace(""Cannot start to poll: {} as its suspended"", this.getEndpoint());
            return;
        }

        // should we backoff if its enabled, and either the idle or error counter is > the threshold
        if (backoffMultiplier > 0
                // either idle or error threshold could be not in use, so check for that and use MAX_VALUE if not in use
                && (idleCounter >= (backoffIdleThreshold > 0 ? backoffIdleThreshold : Integer.MAX_VALUE))
                || errorCounter >= (backoffErrorThreshold > 0 ? backoffErrorThreshold : Integer.MAX_VALUE)) {
            if (backoffCounter++ < backoffMultiplier) {
                // yes we should backoff
                if (idleCounter > 0) {
                    LOG.debug(""doRun() backoff due subsequent {} idles (backoff at {}/{})"", new Object[]{idleCounter, backoffCounter, backoffMultiplier});
                } else {
                    LOG.debug(""doRun() backoff due subsequent {} errors (backoff at {}/{})"", new Object[]{errorCounter, backoffCounter, backoffMultiplier});
                }
                return;
            } else {
                // we are finished with backoff so reset counters
                idleCounter = 0;
                errorCounter = 0;
                backoffCounter = 0;
                LOG.trace(""doRun() backoff finished, resetting counters."");
            }
        }

        int retryCounter = -1;
        boolean done = false;
        Throwable cause = null;
        int polledMessages = 0;

        while (!done) {
            try {
                cause = null;
                // eager assume we are done
                done = true;
                if (isPollAllowed()) {

                    if (retryCounter == -1) {
                        LOG.trace(""Starting to poll: {}"", this.getEndpoint());
                    } else {
                        LOG.debug(""Retrying attempt {} to poll: {}"", retryCounter, this.getEndpoint());
                    }

                    // mark we are polling which should also include the begin/poll/commit
                    polling = true;
                    try {
                        boolean begin = pollStrategy.begin(this, getEndpoint());
                        if (begin) {
                            retryCounter++;
                            polledMessages = poll();
                            LOG.trace(""Polled {} messages"", polledMessages);

                            if (polledMessages == 0 && isSendEmptyMessageWhenIdle()) {
                                // send an ""empty"" exchange
                                processEmptyMessage();
                            }

                            pollStrategy.commit(this, getEndpoint(), polledMessages);

                            if (polledMessages > 0 && isGreedy()) {
                                done = false;
                                retryCounter = -1;
                                LOG.trace(""Greedy polling after processing {} messages"", polledMessages);
                            }
                        } else {
                            LOG.debug(""Cannot begin polling as pollStrategy returned false: {}"", pollStrategy);
                        }
                    } finally {
                        polling = false;
                    }
                }

                LOG.trace(""Finished polling: {}"", this.getEndpoint());
            } catch (Exception e) {
                try {
                    boolean retry = pollStrategy.rollback(this, getEndpoint(), retryCounter, e);
                    if (retry) {
                        // do not set cause as we retry
                        done = false;
                    } else {
                        cause = e;
                        done = true;
                    }
                } catch (Throwable t) {
                    cause = t;
                    done = true;
                }
            } catch (Throwable t) {
                cause = t;
                done = true;
            }

            if (cause != null && isRunAllowed()) {
                // let exception handler deal with the caused exception
                // but suppress this during shutdown as the logs may get flooded with exceptions during shutdown/forced shutdown
                try {
                    getExceptionHandler().handleException(""Consumer "" + this + "" failed polling endpoint: "" + getEndpoint()
                            + "". Will try again at next poll"", cause);
                } catch (Throwable e) {
                    LOG.warn(""Error handling exception. This exception will be ignored."", e);
                }
            }
        }

        if (cause != null) {
            idleCounter = 0;
            errorCounter++;
        } else {
            idleCounter = polledMessages == 0 ? ++idleCounter : 0;
            errorCounter = 0;
        }
        LOG.trace(""doRun() done with idleCounter={}, errorCounter={}"", idleCounter, errorCounter);

        // avoid this thread to throw exceptions because the thread pool wont re-schedule a new thread
    }","private void doRun() {
        if (isSuspended()) {
            LOG.trace(""Cannot start to poll: {} as its suspended"", this.getEndpoint());
            return;
        }

        // should we backoff if its enabled, and either the idle or error counter is > the threshold
        if (backoffMultiplier > 0
                // either idle or error threshold could be not in use, so check for that and use MAX_VALUE if not in use
                && (idleCounter >= (backoffIdleThreshold > 0 ? backoffIdleThreshold : Integer.MAX_VALUE))
                || errorCounter >= (backoffErrorThreshold > 0 ? backoffErrorThreshold : Integer.MAX_VALUE)) {
            if (backoffCounter++ < backoffMultiplier) {
                // yes we should backoff
                if (idleCounter > 0) {
                    LOG.debug(""doRun() backoff due subsequent {} idles (backoff at {}/{})"", new Object[]{idleCounter, backoffCounter, backoffMultiplier});
                } else {
                    LOG.debug(""doRun() backoff due subsequent {} errors (backoff at {}/{})"", new Object[]{errorCounter, backoffCounter, backoffMultiplier});
                }
                return;
            } else {
                // we are finished with backoff so reset counters
                idleCounter = 0;
                errorCounter = 0;
                backoffCounter = 0;
                LOG.trace(""doRun() backoff finished, resetting counters."");
            }
        }

        int retryCounter = -1;
        boolean done = false;
        Throwable cause = null;
        int polledMessages = 0;

        while (!done) {
            try {
                cause = null;
                // eager assume we are done
                done = true;
                if (isPollAllowed()) {

                    if (retryCounter == -1) {
                        LOG.trace(""Starting to poll: {}"", this.getEndpoint());
                    } else {
                        LOG.debug(""Retrying attempt {} to poll: {}"", retryCounter, this.getEndpoint());
                    }

                    // mark we are polling which should also include the begin/poll/commit
                    polling = true;
                    try {
                        boolean begin = pollStrategy.begin(this, getEndpoint());
                        if (begin) {
                            retryCounter++;
                            polledMessages = poll();
                            LOG.trace(""Polled {} messages"", polledMessages);

                            if (polledMessages == 0 && isSendEmptyMessageWhenIdle()) {
                                // send an ""empty"" exchange
                                processEmptyMessage();
                            }

                            pollStrategy.commit(this, getEndpoint(), polledMessages);

                            if (polledMessages > 0 && isGreedy()) {
                                done = false;
                                retryCounter = -1;
                                LOG.trace(""Greedy polling after processing {} messages"", polledMessages);
                            }
                        } else {
                            LOG.debug(""Cannot begin polling as pollStrategy returned false: {}"", pollStrategy);
                        }
                    } finally {
                        polling = false;
                    }
                }

                LOG.trace(""Finished polling: {}"", this.getEndpoint());
            } catch (Exception e) {
                try {
                    boolean retry = pollStrategy.rollback(this, getEndpoint(), retryCounter, e);
                    if (retry) {
                        // do not set cause as we retry
                        done = false;
                    } else {
                        cause = e;
                        done = true;
                    }
                } catch (Throwable t) {
                    cause = t;
                    done = true;
                }
            } catch (Throwable t) {
                cause = t;
                done = true;
            }

            if (cause != null && isRunAllowed()) {
                // let exception handler deal with the caused exception
                // but suppress this during shutdown as the logs may get flooded with exceptions during shutdown/forced shutdown
                try {
                    getExceptionHandler().handleException(""Consumer "" + this + "" failed polling endpoint: "" + getEndpoint()
                            + "". Will try again at next poll"", cause);
                } catch (Throwable e) {
                    LOG.warn(""Error handling exception. This exception will be ignored."", e);
                }
            }
        }

        if (cause != null) {
            idleCounter = 0;
            errorCounter++;
        } else {
            idleCounter = polledMessages == 0 ? ++idleCounter : 0;
            errorCounter = 0;
        }
        LOG.trace(""doRun() done with idleCounter={}, errorCounter={}"", idleCounter, errorCounter);

        // avoid this thread to throw exceptions because the thread pool wont re-schedule a new thread
    }",0,[0]
18704,bugs-dot-jar_ACCUMULO-3218_1b35d263,"public ClientConfiguration withInstance(UUID instanceId) {
    ArgumentChecker.notNull(instanceId);
    return with(ClientProperty.INSTANCE_ID, instanceId.toString());
  }","public ClientConfiguration withInstance(UUID instanceId) {
    ArgumentChecker.notNull(instanceId);
    return with(ClientProperty.INSTANCE_ID, instanceId.toString());
  }",0,[0]
2246,bugs-dot-jar_MNG-4918_691a03a7,"public void setOrganization( Organization organization )
    {
        getModel().setOrganization( organization );
    }","public void setOrganization( Organization organization )
    {
        getModel().setOrganization( organization );
    }",0,[0]
12504,bugs-dot-jar_FLINK-2968_59685903,"@VisibleForTesting
	public KeySelector<IN, K> getKeySelector() {
		return keySelector;
	}","@VisibleForTesting
	public KeySelector<IN, K> getKeySelector() {
		return keySelector;
	}",0,[0]
9505,bugs-dot-jar_OAK-1697_1552be04,"TokenProviderImpl(Root root, ConfigurationParameters options, UserConfiguration userConfiguration) {
        this.root = root;
        this.options = options;

        this.tokenExpiration = options.getConfigValue(PARAM_TOKEN_EXPIRATION, Long.valueOf(DEFAULT_TOKEN_EXPIRATION));
        this.userManager = userConfiguration.getUserManager(root, NamePathMapper.DEFAULT);
        this.identifierManager = new IdentifierManager(root);
    }","TokenProviderImpl(Root root, ConfigurationParameters options, UserConfiguration userConfiguration) {
        this.root = root;
        this.options = options;

        this.tokenExpiration = options.getConfigValue(PARAM_TOKEN_EXPIRATION, Long.valueOf(DEFAULT_TOKEN_EXPIRATION));
        this.userManager = userConfiguration.getUserManager(root, NamePathMapper.DEFAULT);
        this.identifierManager = new IdentifierManager(root);
    }",0,[0]
26481,bugs-dot-jar_WICKET-3510_292a2582,"public final String getTextFormat()
	{
		return converter.getDatePattern();
	}","public final String getTextFormat()
	{
		return converter.getDatePattern();
	}",0,[0]
34290,bugs-dot-jar_WICKET-4184_a0150366,"public AppendingStringBuffer insert(final int offset, final double d)
	{
		return insert(offset, String.valueOf(d));
	}","public AppendingStringBuffer insert(final int offset, final double d)
	{
		return insert(offset, String.valueOf(d));
	}",0,[0]
623,bugs-dot-jar_MNG-5727_ce6f0bfd,"public void injectMirror( List<ArtifactRepository> repositories, List<Mirror> mirrors )
    {
        if ( repositories != null && mirrors != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                Mirror mirror = getMirror( repository, mirrors );
                injectMirror( repository, mirror );
            }
        }
    }","public void injectMirror( List<ArtifactRepository> repositories, List<Mirror> mirrors )
    {
        if ( repositories != null && mirrors != null )
        {
            for ( ArtifactRepository repository : repositories )
            {
                Mirror mirror = getMirror( repository, mirrors );
                injectMirror( repository, mirror );
            }
        }
    }",0,[0]
30579,bugs-dot-jar_WICKET-4000_38e928c1,"@Override
	public void renderHeader(final HtmlHeaderContainer headerContainer,
		HeaderStreamState headerStreamState, final Component rootComponent)
	{
		Args.notNull(headerContainer, ""headerContainer"");
		Args.notNull(rootComponent, ""rootComponent"");

		// First the application level headers
		renderApplicationLevelHeaders(headerContainer);

		// Then its child hierarchy
		renderChildHeaders(headerContainer, rootComponent);

		// Then the root component's headers
		renderRootComponent(headerContainer, headerStreamState, rootComponent);
	}","@Override
	public void renderHeader(final HtmlHeaderContainer headerContainer,
		HeaderStreamState headerStreamState, final Component rootComponent)
	{
		Args.notNull(headerContainer, ""headerContainer"");
		Args.notNull(rootComponent, ""rootComponent"");

		// First the application level headers
		renderApplicationLevelHeaders(headerContainer);

		// Then its child hierarchy
		renderChildHeaders(headerContainer, rootComponent);

		// Then the root component's headers
		renderRootComponent(headerContainer, headerStreamState, rootComponent);
	}",0,[0]
6711,bugs-dot-jar_OAK-4431_7441a3d5,"protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {
        String indexPath = definition.getIndexPathFromConfig();
        File indexDir = getIndexDir(indexPath);
        String newVersion = String.valueOf(definition.getReindexCount());
        File indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);

        //By design indexing in Oak is single threaded so Lucene locking
        //can be disabled
        Directory dir = FSDirectory.open(indexWriterDir, NoLockFactory.getNoLockFactory());

        log.debug(""IndexWriter would use {}"", indexWriterDir);
        return dir;
    }","protected Directory createLocalDirForIndexWriter(IndexDefinition definition) throws IOException {
        String indexPath = definition.getIndexPathFromConfig();
        File indexDir = getIndexDir(indexPath);
        String newVersion = String.valueOf(definition.getReindexCount());
        File indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);

        //By design indexing in Oak is single threaded so Lucene locking
        //can be disabled
        Directory dir = FSDirectory.open(indexWriterDir, NoLockFactory.getNoLockFactory());

        log.debug(""IndexWriter would use {}"", indexWriterDir);
        return dir;
    }",0,[0]
1497,Bears-169,"private boolean catchupToFinalOffset(long endOffset, long timeoutMs) {
    _finalOffset = endOffset;
    _consumeEndTime = now() + timeoutMs;
    _state = State.CONSUMING_TO_ONLINE;
    _shouldStop = false;
    try {
      consumeLoop();
    } catch (Exception e) {
      // We will end up downloading the segment, so this is not a serious problem
      segmentLogger.warn(""Exception when catching up to final offset"", e);
      return false;
    }
    if (_currentOffset != endOffset) {
      // Timeout?
      segmentLogger.error(""Could not consume up to {} (current offset {})"", endOffset, _currentOffset);
      return false;
    }

    return true;
  }","private boolean catchupToFinalOffset(long endOffset, long timeoutMs) {
    _finalOffset = endOffset;
    _consumeEndTime = now() + timeoutMs;
    _state = State.CONSUMING_TO_ONLINE;
    _shouldStop = false;
    try {
      consumeLoop();
    } catch (Exception e) {
      // We will end up downloading the segment, so this is not a serious problem
      segmentLogger.warn(""Exception when catching up to final offset"", e);
      return false;
    }
    if (_currentOffset != endOffset) {
      // Timeout?
      segmentLogger.error(""Could not consume up to {} (current offset {})"", endOffset, _currentOffset);
      return false;
    }

    return true;
  }",0,[0]
1090,Bears-141,"public void setType(String type) {
        this.type = type;
    }","public void setType(String type) {
        this.type = type;
    }",0,[0]
148,bugs-dot-jar_WICKET-2065_9da430fb,"protected String urlEncodePathComponent(String string)
	{
		return WicketURLEncoder.PATH_INSTANCE.encode(string);
	}","protected String urlEncodePathComponent(String string)
	{
		return WicketURLEncoder.PATH_INSTANCE.encode(string);
	}",0,[0]
24215,bugs-dot-jar_WICKET-2839_15477252,"public AbstractResource()
	{
	}","public AbstractResource()
	{
	}",0,[0]
15535,bugs-dot-jar_ACCUMULO-1190_e29dc4f5,"private TException translateException(Exception ex) {
    try {
      throw ex;
    } catch (MutationsRejectedException e) {
        logger.debug(e,e);
        return new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());
    } catch (AccumuloException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());
    } catch (AccumuloSecurityException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.AccumuloSecurityException(e.toString());
    } catch (TableNotFoundException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());
    } catch (TableExistsException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.TableExistsException(e.toString());
    } catch (RuntimeException e) {
      if (e.getCause() != null) {
        if (e.getCause() instanceof Exception)
          return translateException((Exception) e.getCause());
      }
      return new TException(e);
    } catch (Exception e) {
      return new TException(ex);
    }
  }","private TException translateException(Exception ex) {
    try {
      throw ex;
    } catch (MutationsRejectedException e) {
        logger.debug(e,e);
        return new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());
    } catch (AccumuloException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());
    } catch (AccumuloSecurityException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.AccumuloSecurityException(e.toString());
    } catch (TableNotFoundException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());
    } catch (TableExistsException e) {
      logger.debug(e,e);
      return new org.apache.accumulo.proxy.thrift.TableExistsException(e.toString());
    } catch (RuntimeException e) {
      if (e.getCause() != null) {
        if (e.getCause() instanceof Exception)
          return translateException((Exception) e.getCause());
      }
      return new TException(e);
    } catch (Exception e) {
      return new TException(ex);
    }
  }",0,[0]
18480,bugs-dot-jar_OAK-1093_531aca78,"private static PropertyValue mvpToString(PropertyValue pv) {
        String v = Joiner.on(' ')
                .appendTo(new StringBuilder(), pv.getValue(Type.STRINGS))
                .toString();
        return PropertyValues.newString(v);
    }","private static PropertyValue mvpToString(PropertyValue pv) {
        String v = Joiner.on(' ')
                .appendTo(new StringBuilder(), pv.getValue(Type.STRINGS))
                .toString();
        return PropertyValues.newString(v);
    }",0,[0]
11402,bugs-dot-jar_CAMEL-7344_91228815,"public void setEndpointConfiguration(EndpointConfiguration endpointConfiguration) {
        this.endpointConfiguration = endpointConfiguration;
    }","public void setEndpointConfiguration(EndpointConfiguration endpointConfiguration) {
        this.endpointConfiguration = endpointConfiguration;
    }",0,[0]
5805,bugs-dot-jar_MATH-1230_96eb80ef,"protected void doIteration(final SimplexTableau tableau)
        throws TooManyIterationsException,
               UnboundedSolutionException {

        incrementIterationCount();

        Integer pivotCol = getPivotColumn(tableau);
        Integer pivotRow = getPivotRow(tableau, pivotCol);
        if (pivotRow == null) {
            throw new UnboundedSolutionException();
        }

        tableau.performRowOperations(pivotCol, pivotRow);
    }","protected void doIteration(final SimplexTableau tableau)
        throws TooManyIterationsException,
               UnboundedSolutionException {

        incrementIterationCount();

        Integer pivotCol = getPivotColumn(tableau);
        Integer pivotRow = getPivotRow(tableau, pivotCol);
        if (pivotRow == null) {
            throw new UnboundedSolutionException();
        }

        tableau.performRowOperations(pivotCol, pivotRow);
    }",0,[0]
233,Bears-8,"@Override
    public boolean hasSingleElement(Map<?,?> value) {
        return (value.size() == 1);
    }","@Override
    public boolean hasSingleElement(Map<?,?> value) {
        return (value.size() == 1);
    }",0,[0]
22782,bugs-dot-jar_MNG-4837_3fca2bb2,"protected void interpolateObject( Object obj, Model model, File projectDir, ModelBuildingRequest config,
                                      ModelProblemCollector problems )
    {
        try
        {
            List<? extends ValueSource> valueSources = createValueSources( model, projectDir, config, problems );
            List<? extends InterpolationPostProcessor> postProcessors = createPostProcessors( model, projectDir,
                                                                                              config );

            InterpolateObjectAction action =
                new InterpolateObjectAction( obj, valueSources, postProcessors, this, problems );

            AccessController.doPrivileged( action );
        }
        finally
        {
            getInterpolator().clearAnswers();
        }
    }","protected void interpolateObject( Object obj, Model model, File projectDir, ModelBuildingRequest config,
                                      ModelProblemCollector problems )
    {
        try
        {
            List<? extends ValueSource> valueSources = createValueSources( model, projectDir, config, problems );
            List<? extends InterpolationPostProcessor> postProcessors = createPostProcessors( model, projectDir,
                                                                                              config );

            InterpolateObjectAction action =
                new InterpolateObjectAction( obj, valueSources, postProcessors, this, problems );

            AccessController.doPrivileged( action );
        }
        finally
        {
            getInterpolator().clearAnswers();
        }
    }",0,[0]
20869,bugs-dot-jar_CAMEL-5215_033eb6fe,"public static BufferedInputStream buffered(InputStream in) {
        ObjectHelper.notNull(in, ""in"");
        return (in instanceof BufferedInputStream) ? (BufferedInputStream)in : new BufferedInputStream(in);
    }","public static BufferedInputStream buffered(InputStream in) {
        ObjectHelper.notNull(in, ""in"");
        return (in instanceof BufferedInputStream) ? (BufferedInputStream)in : new BufferedInputStream(in);
    }",0,[0]
12387,bugs-dot-jar_OAK-2430_be3a9114,"@Override
    public boolean propertyChanged(PropertyState before, PropertyState after) {
        if (!loader.isRunning()) {
            return false;
        }
        builder.setProperty(binaryCheck(after));
        return true;
    }","@Override
    public boolean propertyChanged(PropertyState before, PropertyState after) {
        if (!loader.isRunning()) {
            return false;
        }
        if (!logOnly) {
            builder.setProperty(binaryCheck(after));
        }
        return true;
    }",1,[5]
26950,bugs-dot-jar_WICKET-5724_b92591f6,"@Override
	public Component resolve(final MarkupContainer container, final MarkupStream markupStream,
		final ComponentTag tag)
	{
		if ((tag instanceof WicketTag) && ((WicketTag)tag).isEnclosureTag())
		{
			// Yes, we handled the tag
			return new Enclosure(tag.getId() + container.getPage().getAutoIndex(),
				tag.getAttribute(EnclosureHandler.CHILD_ATTRIBUTE));
		}

		// We were not able to handle the tag
		return null;
	}","@Override
	public Component resolve(final MarkupContainer container, final MarkupStream markupStream,
		final ComponentTag tag)
	{
		if ((tag instanceof WicketTag) && ((WicketTag)tag).isEnclosureTag())
		{
			// Yes, we handled the tag
			return new Enclosure(tag.getId() + container.getPage().getAutoIndex(),
				tag.getAttribute(EnclosureHandler.CHILD_ATTRIBUTE));
		}

		// We were not able to handle the tag
		return null;
	}",0,[0]
23157,bugs-dot-jar_WICKET-3764_48454f4d,"public void unbind(Component component)
	{
	}","public void unbind(Component component)
	{
	}",0,[0]
2012,bugs-dot-jar_WICKET-2961_3d8c9d75,"public final void configure()
	{
		if (!getFlag(FLAG_CONFIGURED))
		{
			onConfigure();
			setFlag(FLAG_CONFIGURED, true);
		}
	}","public final void configure()
	{
		if (!getFlag(FLAG_CONFIGURED))
		{
			onConfigure();
			setFlag(FLAG_CONFIGURED, true);
		}
	}",0,[0]
19221,bugs-dot-jar_WICKET-4119_bb7a6995,"@Override
	public String toString()
	{
		final StringBuilder result = new StringBuilder();
		result.append('[')
			.append(getClass().getSimpleName())
			.append(' ')
			.append(""name = "")
			.append(path)
			.append("", scope = "")
			.append(scopeName)
			.append("", locale = "")
			.append(locale)
			.append("", style = "")
			.append(style)
			.append("", variation = "")
			.append(variation)
			.append(']');
		return result.toString();
	}","@Override
	public String toString()
	{
		final StringBuilder result = new StringBuilder();
		result.append('[')
			.append(getClass().getSimpleName())
			.append(' ')
			.append(""name = "")
			.append(path)
			.append("", scope = "")
			.append(scopeName)
			.append("", locale = "")
			.append(locale)
			.append("", style = "")
			.append(style)
			.append("", variation = "")
			.append(variation)
			.append(']');
		return result.toString();
	}",0,[0]
20779,bugs-dot-jar_CAMEL-5215_033eb6fe,"public FileOperations() {
    }","public FileOperations() {
    }",0,[0]
3121,bugs-dot-jar_OAK-1216_e403e003,"@Override
    @Nonnull
    public String getOakName(String jcrName) throws RepositoryException {
        return namePathMapper.getOakName(jcrName);
    }","@Override
    @Nonnull
    public String getOakName(String jcrName) throws RepositoryException {
        return namePathMapper.getOakName(jcrName);
    }",0,[0]
33506,bugs-dot-jar_OAK-3792_94110f21,"private static void checkSuccess(boolean success, String msg) throws LoginException {
        if (!success) {
            throw new FailedLoginException(msg);
        }
    }","private static void checkSuccess(boolean success, String msg) throws LoginException {
        if (!success) {
            throw new FailedLoginException(msg);
        }
    }",0,[0]
39584,bugs-dot-jar_OAK-1674_073b814c,"@Override
    public boolean hasProperty(String name) {
        return (!isHidden(checkNotNull(name))) && nodeBuilder.hasProperty(name);
    }","@Override
    public boolean hasProperty(String name) {
        return (!isHidden(checkNotNull(name))) && nodeBuilder.hasProperty(name);
    }",0,[0]
10774,bugs-dot-jar_OAK-1035_b2ca8baa,"@Override
    public long count(NodeState indexMeta, Set<String> values, int max) {
        NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);
        int count = 0;
        if (values == null) {
            PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);
            if (ec != null) {
                return ec.getValue(Type.LONG);
            }
            CountingNodeVisitor v = new CountingNodeVisitor(max);
            v.visit(index);
            count = v.getEstimatedCount();
            // ""is not null"" queries typically read more data
            count *= 10;
        } else {
            int size = values.size();
            if (size == 0) {
                return 0;
            }
            max = Math.max(10, max / size);
            int i = 0;
            for (String p : values) {
                if (count > max && i > 3) {
                    count = count / size / i;
                    break;
                }
                NodeState s = index.getChildNode(p);
                if (s.exists()) {
                    CountingNodeVisitor v = new CountingNodeVisitor(max);
                    v.visit(s);
                    count += v.getEstimatedCount();
                }
                i++;
            }
        }
        return count;
    }","@Override
    public long count(NodeState indexMeta, Set<String> values, int max) {
        NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);
        int count = 0;
        if (values == null) {
            PropertyState ec = indexMeta.getProperty(ENTRY_COUNT_PROPERTY_NAME);
            if (ec != null) {
                return ec.getValue(Type.LONG);
            }
            CountingNodeVisitor v = new CountingNodeVisitor(max);
            v.visit(index);
            count = v.getEstimatedCount();
            // ""is not null"" queries typically read more data
            count *= 10;
        } else {
            int size = values.size();
            if (size == 0) {
                return 0;
            }
            max = Math.max(10, max / size);
            int i = 0;
            for (String p : values) {
                if (count > max && i > 3) {
                    // the total count is extrapolated from the the number 
                    // of values counted so far to the total number of values
                    count = count * size / i;
                    break;
                }
                NodeState s = index.getChildNode(p);
                if (s.exists()) {
                    CountingNodeVisitor v = new CountingNodeVisitor(max);
                    v.visit(s);
                    count += v.getEstimatedCount();
                }
                i++;
            }
        }
        return count;
    }",1,[23]
1155,bugs-dot-jar_WICKET-5546_f1af9e03,"public final boolean isRenderAllowed()
	{
		return getFlag(FLAG_IS_RENDER_ALLOWED);
	}","public final boolean isRenderAllowed()
	{
		return getFlag(FLAG_IS_RENDER_ALLOWED);
	}",0,[0]
38105,bugs-dot-jar_OAK-3013_eabb4066,"@Override
    public void setOrderings(OrderingImpl[] orderings) {
        if (orderings == null) {
            left.setOrderings(null);
            right.setOrderings(null);
            return;
        }
        OrderingImpl[] l = new OrderingImpl[orderings.length];
        OrderingImpl[] r = new OrderingImpl[orderings.length];
        for (int i = 0; i < orderings.length; i++) {
            OrderingImpl o = orderings[i];
            l[i] = o.createCopy();
            r[i] = o.createCopy();
        }
        left.setOrderings(l);
        right.setOrderings(r);
        this.orderings = orderings;
    }","@Override
    public void setOrderings(OrderingImpl[] orderings) {
        if (orderings == null) {
            left.setOrderings(null);
            right.setOrderings(null);
            return;
        }
        OrderingImpl[] l = new OrderingImpl[orderings.length];
        OrderingImpl[] r = new OrderingImpl[orderings.length];
        for (int i = 0; i < orderings.length; i++) {
            OrderingImpl o = orderings[i];
            l[i] = o.createCopy();
            r[i] = o.createCopy();
        }
        left.setOrderings(l);
        right.setOrderings(r);
        this.orderings = orderings;
    }",0,[0]
20268,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Override
  public int getZooKeepersSessionTimeOut() {
    return 30 * 1000;
  }","@Override
  public int getZooKeepersSessionTimeOut() {
    return 30 * 1000;
  }",0,[0]
7811,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public ArrayRealVector ebeDivide(RealVector v) {
        if (v instanceof ArrayRealVector) {
            final double[] vData = ((ArrayRealVector) v).data;
            final int dim = vData.length;
            checkVectorDimensions(dim);
            ArrayRealVector result = new ArrayRealVector(dim);
            double[] resultData = result.data;
            for (int i = 0; i < dim; i++) {
                resultData[i] = data[i] / vData[i];
            }
            return result;
        } else {
            checkVectorDimensions(v);
            double[] out = data.clone();
            for (int i = 0; i < data.length; i++) {
                out[i] /= v.getEntry(i);
            }
            return new ArrayRealVector(out, false);
        }
    }","@Override
    public ArrayRealVector ebeDivide(RealVector v) {
        if (v instanceof ArrayRealVector) {
            final double[] vData = ((ArrayRealVector) v).data;
            final int dim = vData.length;
            checkVectorDimensions(dim);
            ArrayRealVector result = new ArrayRealVector(dim);
            double[] resultData = result.data;
            for (int i = 0; i < dim; i++) {
                resultData[i] = data[i] / vData[i];
            }
            return result;
        } else {
            checkVectorDimensions(v);
            double[] out = data.clone();
            for (int i = 0; i < data.length; i++) {
                out[i] /= v.getEntry(i);
            }
            return new ArrayRealVector(out, false);
        }
    }",0,[0]
2200,bugs-dot-jar_MNG-4918_691a03a7,"public DependencyManagement getDependencyManagement()
    {
        return getModel().getDependencyManagement();
    }","public DependencyManagement getDependencyManagement()
    {
        return getModel().getDependencyManagement();
    }",0,[0]
15913,bugs-dot-jar_MNG-1205_1bdeeccc,"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,
                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,
                          ArtifactFilter filter, List listeners )
        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException
    {
        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );

        // TODO: use as a conflict resolver
        Object key = node.getKey();
        if ( managedVersions.containsKey( key ) )
        {
            Artifact artifact = (Artifact) managedVersions.get( key );

            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );

            if ( artifact.getVersion() != null )
            {
                node.getArtifact().setVersion( artifact.getVersion() );
            }
            if ( artifact.getScope() != null )
            {
                node.getArtifact().setScope( artifact.getScope() );
            }
        }

        List previousNodes = (List) resolvedArtifacts.get( key );
        if ( previousNodes != null )
        {
            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )
            {
                ResolutionNode previous = (ResolutionNode) i.next();

                if ( previous.isActive() )
                {
                    // Version mediation
                    VersionRange previousRange = previous.getArtifact().getVersionRange();
                    VersionRange currentRange = node.getArtifact().getVersionRange();

                    // TODO: why do we force the version on it? what if they don't match?
                    if ( previousRange == null )
                    {
                        // version was already resolved
                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );
                    }
                    else if ( currentRange == null )
                    {
                        // version was already resolved
                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );
                    }
                    else
                    {
                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended
                        // version but the restriction is identical
                        VersionRange newRange = previousRange.restrict( currentRange );
                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct
                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )
                        {
                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),
                                       newRange );
                        }
                        previous.getArtifact().setVersionRange( newRange );
                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );

                        //Select an appropriate available version from the (now restricted) range
                        //Note this version was selected before to get the appropriate POM
                        //But it was reset by the call to setVersionRange on restricting the version
                        ResolutionNode[] resetNodes = {previous, node};
                        for ( int j = 0; j < 2; j++ )
                        {
                            Artifact resetArtifact = resetNodes[j].getArtifact();
                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&
                                resetArtifact.getAvailableVersions() != null )
                            {

                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(
                                    resetArtifact.getAvailableVersions() ).toString() );
                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );
                            }
                        }
                    }

                    // Conflict Resolution
                    // TODO: use as conflict resolver(s), chain

                    // TODO: should this be part of mediation?
                    // previous one is more dominant
                    if ( previous.getDepth() <= node.getDepth() )
                    {
                        checkScopeUpdate( node, previous, listeners );
                    }
                    else
                    {
                        checkScopeUpdate( previous, node, listeners );
                    }

                    if ( previous.getDepth() <= node.getDepth() )
                    {
                        // previous was nearer
                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );
                        node.disable();
                    }
                    else
                    {
                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );
                        previous.disable();
                    }
                }
            }
        }
        else
        {
            previousNodes = new ArrayList();
            resolvedArtifacts.put( key, previousNodes );
        }
        previousNodes.add( node );

        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );

        if ( node.isActive() )
        {
            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );

            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )
            {
                ResolutionNode child = (ResolutionNode) i.next();
                // We leave in optional ones, but don't pick up its dependencies
                if ( !child.isResolved() && !child.getArtifact().isOptional() )
                {
                    Artifact artifact = child.getArtifact();
                    try
                    {
                        if ( artifact.getVersion() == null )
                        {
                            // set the recommended version
                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?
                            ArtifactVersion version;
                            if ( !artifact.isSelectedVersionKnown() )
                            {
                                List versions = artifact.getAvailableVersions();
                                if ( versions == null )
                                {
                                    versions = source.retrieveAvailableVersions( artifact, localRepository,
                                                                                 remoteRepositories );
                                    artifact.setAvailableVersions( versions );
                                }

                                VersionRange versionRange = artifact.getVersionRange();

                                version = versionRange.matchVersion( versions );

                                if ( version == null )
                                {
                                    if ( versions.isEmpty() )
                                    {
                                        throw new OverConstrainedVersionException(
                                            ""No versions are present in the repository for the artifact with a range "" +
                                                versionRange, artifact, remoteRepositories );
                                    }
                                    else
                                    {
                                        throw new OverConstrainedVersionException( ""Couldn't find a version in "" +
                                            versions + "" to match range "" + versionRange, artifact,
                                                                                          remoteRepositories );
                                    }
                                }
                            }
                            else
                            {
                                version = artifact.getSelectedVersion();
                            }

                            artifact.selectVersion( version.toString() );
                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );
                        }

                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );

                        //TODO might be better to have source.retreive() throw a specific exception for this situation
                        //and catch here rather than have it return null
                        if ( rGroup == null )
                        {
                            //relocated dependency artifact is declared excluded, no need to add and recurse further
                            continue;
                        }

                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );
                    }
                    catch ( CyclicDependencyException e )
                    {
                        // would like to throw this, but we have crappy stuff in the repo

                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,
                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );
                    }
                    catch ( ArtifactMetadataRetrievalException e )
                    {
                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        throw new ArtifactResolutionException(
                            ""Unable to get dependency information: "" + e.getMessage(), artifact, remoteRepositories,
                            e );
                    }

                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,
                             filter, listeners );
                }
            }

            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );
        }
    }","private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,
                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,
                          ArtifactFilter filter, List listeners )
        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException
    {
        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );

        // TODO: use as a conflict resolver
        Object key = node.getKey();
        if ( managedVersions.containsKey( key ) )
        {
            Artifact artifact = (Artifact) managedVersions.get( key );

            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );

            if ( artifact.getVersion() != null )
            {
                node.getArtifact().setVersion( artifact.getVersion() );
            }
            if ( artifact.getScope() != null )
            {
                node.getArtifact().setScope( artifact.getScope() );
            }
        }

        List previousNodes = (List) resolvedArtifacts.get( key );
        if ( previousNodes != null )
        {
            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )
            {
                ResolutionNode previous = (ResolutionNode) i.next();

                if ( previous.isActive() )
                {
                    // Version mediation
                    VersionRange previousRange = previous.getArtifact().getVersionRange();
                    VersionRange currentRange = node.getArtifact().getVersionRange();

                    // TODO: why do we force the version on it? what if they don't match?
                    if ( previousRange == null )
                    {
                        // version was already resolved
                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );
                    }
                    else if ( currentRange == null )
                    {
                        // version was already resolved
                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );
                    }
                    else
                    {
                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended
                        // version but the restriction is identical
                        VersionRange newRange = previousRange.restrict( currentRange );
                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct
                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )
                        {
                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),
                                       newRange );
                        }
                        previous.getArtifact().setVersionRange( newRange );
                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );

                        //Select an appropriate available version from the (now restricted) range
                        //Note this version was selected before to get the appropriate POM
                        //But it was reset by the call to setVersionRange on restricting the version
                        ResolutionNode[] resetNodes = {previous, node};
                        for ( int j = 0; j < 2; j++ )
                        {
                            Artifact resetArtifact = resetNodes[j].getArtifact();
                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&
                                resetArtifact.getAvailableVersions() != null )
                            {

                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(
                                    resetArtifact.getAvailableVersions() ).toString() );
                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );
                            }
                        }
                    }

                    // Conflict Resolution
                    // TODO: use as conflict resolver(s), chain

                    // TODO: should this be part of mediation?
                    // previous one is more dominant
                    if ( previous.getDepth() <= node.getDepth() )
                    {
                        checkScopeUpdate( node, previous, listeners );
                    }
                    else
                    {
                        checkScopeUpdate( previous, node, listeners );
                    }

                    if ( previous.getDepth() <= node.getDepth() )
                    {
                        // previous was nearer
                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, node, previous.getArtifact() );
                        node.disable();
                    }
                    else
                    {
                        fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, previous, node.getArtifact() );
                        previous.disable();
                    }
                }
            }
        }
        else
        {
            previousNodes = new ArrayList();
            resolvedArtifacts.put( key, previousNodes );
        }
        previousNodes.add( node );

        fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );

        if ( node.isActive() )
        {
            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );

            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )
            {
                ResolutionNode child = (ResolutionNode) i.next();
                // We leave in optional ones, but don't pick up its dependencies
                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )
                {
                    Artifact artifact = child.getArtifact();
                    try
                    {
                        if ( artifact.getVersion() == null )
                        {
                            // set the recommended version
                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?
                            ArtifactVersion version;
                            if ( !artifact.isSelectedVersionKnown() )
                            {
                                List versions = artifact.getAvailableVersions();
                                if ( versions == null )
                                {
                                    versions = source.retrieveAvailableVersions( artifact, localRepository,
                                                                                 remoteRepositories );
                                    artifact.setAvailableVersions( versions );
                                }

                                VersionRange versionRange = artifact.getVersionRange();

                                version = versionRange.matchVersion( versions );

                                if ( version == null )
                                {
                                    if ( versions.isEmpty() )
                                    {
                                        throw new OverConstrainedVersionException(
                                            ""No versions are present in the repository for the artifact with a range "" +
                                                versionRange, artifact, remoteRepositories );
                                    }
                                    else
                                    {
                                        throw new OverConstrainedVersionException( ""Couldn't find a version in "" +
                                            versions + "" to match range "" + versionRange, artifact,
                                                                                          remoteRepositories );
                                    }
                                }
                            }
                            else
                            {
                                version = artifact.getSelectedVersion();
                            }

                            artifact.selectVersion( version.toString() );
                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );
                        }

                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );

                        //TODO might be better to have source.retreive() throw a specific exception for this situation
                        //and catch here rather than have it return null
                        if ( rGroup == null )
                        {
                            //relocated dependency artifact is declared excluded, no need to add and recurse further
                            continue;
                        }

                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );
                    }
                    catch ( CyclicDependencyException e )
                    {
                        // would like to throw this, but we have crappy stuff in the repo

                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,
                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );
                    }
                    catch ( ArtifactMetadataRetrievalException e )
                    {
                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        throw new ArtifactResolutionException(
                            ""Unable to get dependency information: "" + e.getMessage(), artifact, remoteRepositories,
                            e );
                    }

                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,
                             filter, listeners );
                }
            }

            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );
        }
    }",1,[126]
26048,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"protected void setEncoder(String encoderClass) {
    try {
      @SuppressWarnings(""unchecked"")
      Class<? extends Encoder<V>> clazz = (Class<? extends Encoder<V>>) AccumuloClassLoader.loadClass(encoderClass, Encoder.class);
      encoder = clazz.newInstance();
    } catch (ClassNotFoundException e) {
      throw new IllegalArgumentException(e);
    } catch (InstantiationException e) {
      throw new IllegalArgumentException(e);
    } catch (IllegalAccessException e) {
      throw new IllegalArgumentException(e);
    }
  }","protected void setEncoder(String encoderClass) {
    try {
      @SuppressWarnings(""unchecked"")
      Class<? extends Encoder<V>> clazz = (Class<? extends Encoder<V>>) AccumuloClassLoader.loadClass(encoderClass, Encoder.class);
      encoder = clazz.newInstance();
    } catch (ClassNotFoundException e) {
      throw new IllegalArgumentException(e);
    } catch (InstantiationException e) {
      throw new IllegalArgumentException(e);
    } catch (IllegalAccessException e) {
      throw new IllegalArgumentException(e);
    }
  }",0,[0]
3050,bugs-dot-jar_CAMEL-5261_55c2e2d8,"public String getQueueKey(String uri) {
        if (uri.contains(""?"")) {
            // strip parameters
            uri = uri.substring(0, uri.indexOf('?'));
        }
        return uri;
    }","public String getQueueKey(String uri) {
        if (uri.contains(""?"")) {
            // strip parameters
            uri = uri.substring(0, uri.indexOf('?'));
        }
        return uri;
    }",0,[0]
4341,bugs-dot-jar_CAMEL-4682_1e54865c,"public void setDataFormats(Map<String, DataFormatDefinition> dataFormats) {
        this.dataFormats = dataFormats;
    }","public void setDataFormats(Map<String, DataFormatDefinition> dataFormats) {
        this.dataFormats = dataFormats;
    }",0,[0]
7362,bugs-dot-jar_MATH-657_97b440fc,"public Complex subtract(Complex subtrahend)
        throws NullArgumentException {
        MathUtils.checkNotNull(subtrahend);
        if (isNaN || subtrahend.isNaN) {
            return NaN;
        }

        return createComplex(real - subtrahend.getReal(),
                             imaginary - subtrahend.getImaginary());
    }","public Complex subtract(Complex subtrahend)
        throws NullArgumentException {
        MathUtils.checkNotNull(subtrahend);
        if (isNaN || subtrahend.isNaN) {
            return NaN;
        }

        return createComplex(real - subtrahend.getReal(),
                             imaginary - subtrahend.getImaginary());
    }",0,[0]
20734,bugs-dot-jar_WICKET-5960_03663750,"@Override
	public IMarkupFragment getMarkup()
	{
		if (getParent() == null)
		{
			throw new WicketRuntimeException(
				""Bug: The Wicket internal instance of HtmlHeaderContainer is not connected to a parent"");
		}

		// Get the page markup
		IMarkupFragment markup = getPage().getMarkup();
		if (markup == null)
		{
			throw new MarkupException(""Unable to get page markup: "" + getPage().toString());
		}

		// Find the markup fragment
		MarkupStream stream = new MarkupStream(markup);
		IMarkupFragment headerMarkup = null;
		while (stream.skipUntil(ComponentTag.class))
		{
			ComponentTag tag = stream.getTag();
			if (tag.isOpen() || tag.isOpenClose())
			{
				if (tag instanceof WicketTag)
				{
					WicketTag wtag = (WicketTag)tag;
					if (wtag.isHeadTag() || wtag.isHeaderItemsTag())
					{
						headerMarkup = stream.getMarkupFragment();
						break;
					}
				}
				else if (tag.getName().equalsIgnoreCase(""head"") && tag.isAutoComponentTag())
				{
					headerMarkup = stream.getMarkupFragment();
					break;
				}
			}

			stream.next();
		}

		setMarkup(headerMarkup);
		return headerMarkup;
	}","@Override
	public IMarkupFragment getMarkup()
	{
		if (getParent() == null)
		{
			throw new WicketRuntimeException(
				""Bug: The Wicket internal instance of HtmlHeaderContainer is not connected to a parent"");
		}

		// Get the page markup
		IMarkupFragment markup = getPage().getMarkup();
		if (markup == null)
		{
			throw new MarkupException(""Unable to get page markup: "" + getPage().toString());
		}

		// Find the markup fragment
		MarkupStream stream = new MarkupStream(markup);
		IMarkupFragment headerMarkup = null;
		while (stream.skipUntil(ComponentTag.class))
		{
			ComponentTag tag = stream.getTag();
			if (tag.isOpen() || tag.isOpenClose())
			{
				if (tag instanceof WicketTag)
				{
					WicketTag wtag = (WicketTag)tag;
					if (wtag.isHeadTag() || wtag.isHeaderItemsTag())
					{
						headerMarkup = stream.getMarkupFragment();
						break;
					}
				}
				else if (tag.getName().equalsIgnoreCase(""head"") && tag.isAutoComponentTag())
				{
					headerMarkup = stream.getMarkupFragment();
					break;
				}
			}

			stream.next();
		}

		setMarkup(headerMarkup);
		return headerMarkup;
	}",0,[0]
1372,bugs-dot-jar_WICKET-4109_8f7805f8,"public Class<? extends IRequestablePage> getPageClass()
	{
		if (pageClass != null)
		{
			return pageClass;
		}
		else
		{
			return getPageInstance().getClass();
		}
	}","public Class<? extends IRequestablePage> getPageClass()
	{
		if (pageClass != null)
		{
			return pageClass;
		}
		else
		{
			return getPageInstance().getClass();
		}
	}",0,[0]
8024,bugs-dot-jar_WICKET-4338_9decad35,"public StringValue getParameterValue(final String name)
	{
		for (IRequestParameters p : parameters)
		{
			StringValue value = p.getParameterValue(name);
			if (!value.isNull())
			{
				return value;
			}
		}
		return StringValue.valueOf((String)null);
	}","public StringValue getParameterValue(final String name)
	{
		for (IRequestParameters p : parameters)
		{
			StringValue value = p.getParameterValue(name);
			if (!value.isNull())
			{
				return value;
			}
		}
		return StringValue.valueOf((String)null);
	}",0,[0]
9174,bugs-dot-jar_MATH-377_c640932d,"public RealMatrix getCovariance(final double minSingularValue) {

        // get the number of singular values to consider
        final int p = singularValues.length;
        int dimension = 0;
        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {
            ++dimension;
        }

        if (dimension == 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,
                    minSingularValue, singularValues[0]);
        }

        final double[][] data = new double[dimension][p];
        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column,
                    final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, dimension - 1, 0, p - 1);

        RealMatrix jv = new Array2DRowRealMatrix(data, false);
        return jv.transpose().multiply(jv);

    }","public RealMatrix getCovariance(final double minSingularValue) {

        // get the number of singular values to consider
        final int p = singularValues.length;
        int dimension = 0;
        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {
            ++dimension;
        }

        if (dimension == 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                    LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,
                    minSingularValue, singularValues[0]);
        }

        final double[][] data = new double[dimension][p];
        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column,
                    final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, dimension - 1, 0, p - 1);

        RealMatrix jv = new Array2DRowRealMatrix(data, false);
        return jv.transpose().multiply(jv);

    }",0,[0]
13313,bugs-dot-jar_CAMEL-4486_f98ac676,"protected boolean processExchange(final Endpoint endpoint, final Exchange exchange, final Exchange original,
                                      final AsyncCallback callback, final RoutingSlipIterator iter) {

        // this does the actual processing so log at trace level
        log.trace(""Processing exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);

        boolean sync = producerCache.doInAsyncProducer(endpoint, exchange, null, callback, new AsyncProducerCallback() {
            public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange,
                                             ExchangePattern exchangePattern, final AsyncCallback callback) {
                // set property which endpoint we send to
                exchange.setProperty(Exchange.TO_ENDPOINT, endpoint.getEndpointUri());
                exchange.setProperty(Exchange.SLIP_ENDPOINT, endpoint.getEndpointUri());

                boolean sync = AsyncProcessorHelper.process(asyncProducer, exchange, new AsyncCallback() {
                    public void done(boolean doneSync) {
                        // we only have to handle async completion of the routing slip
                        if (doneSync) {
                            return;
                        }

                        // continue processing the routing slip asynchronously
                        Exchange current = exchange;

                        while (iter.hasNext(current)) {

                            // we ignore some kind of exceptions and allow us to continue
                            if (isIgnoreInvalidEndpoints()) {
                                FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);
                                if (e != null) {
                                    if (log.isDebugEnabled()) {
                                        log.debug(""Endpoint uri is invalid: "" + endpoint + "". This exception will be ignored."", e);
                                    }
                                    current.setException(null);
                                }
                            }

                            // Decide whether to continue with the recipients or not; similar logic to the Pipeline
                            // check for error if so we should break out
                            if (!continueProcessing(current, ""so breaking out of the routing slip"", log)) {
                                break;
                            }

                            Endpoint endpoint;
                            try {
                                endpoint = resolveEndpoint(iter, exchange);
                                // if no endpoint was resolved then try the next
                                if (endpoint == null) {
                                    continue;
                                }
                            } catch (Exception e) {
                                // error resolving endpoint so we should break out
                                exchange.setException(e);
                                break;
                            }

                            // prepare and process the routing slip
                            Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);
                            boolean sync = processExchange(endpoint, copy, original, callback, iter);
                            current = copy;

                            if (!sync) {
                                log.trace(""Processing exchangeId: {} is continued being processed asynchronously"", original.getExchangeId());
                                return;
                            }
                        }

                        // logging nextExchange as it contains the exchange that might have altered the payload and since
                        // we are logging the completion if will be confusing if we log the original instead
                        // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots
                        log.trace(""Processing complete for exchangeId: {} >>> {}"", original.getExchangeId(), current);

                        // copy results back to the original exchange
                        ExchangeHelper.copyResults(original, current);
                        callback.done(false);
                    }
                });

                return sync;
            }
        });

        return sync;
    }","protected boolean processExchange(final Endpoint endpoint, final Exchange exchange, final Exchange original,
                                      final AsyncCallback callback, final RoutingSlipIterator iter) {

        // this does the actual processing so log at trace level
        log.trace(""Processing exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);

        boolean sync = producerCache.doInAsyncProducer(endpoint, exchange, null, callback, new AsyncProducerCallback() {
            public boolean doInAsyncProducer(Producer producer, AsyncProcessor asyncProducer, final Exchange exchange,
                                             ExchangePattern exchangePattern, final AsyncCallback callback) {
                // set property which endpoint we send to
                exchange.setProperty(Exchange.TO_ENDPOINT, endpoint.getEndpointUri());
                exchange.setProperty(Exchange.SLIP_ENDPOINT, endpoint.getEndpointUri());

                boolean sync = AsyncProcessorHelper.process(asyncProducer, exchange, new AsyncCallback() {
                    public void done(boolean doneSync) {
                        // we only have to handle async completion of the routing slip
                        if (doneSync) {
                            return;
                        }

                        // continue processing the routing slip asynchronously
                        Exchange current = exchange;

                        while (iter.hasNext(current)) {

                            // we ignore some kind of exceptions and allow us to continue
                            if (isIgnoreInvalidEndpoints()) {
                                FailedToCreateProducerException e = current.getException(FailedToCreateProducerException.class);
                                if (e != null) {
                                    if (log.isDebugEnabled()) {
                                        log.debug(""Endpoint uri is invalid: "" + endpoint + "". This exception will be ignored."", e);
                                    }
                                    current.setException(null);
                                }
                            }

                            // Decide whether to continue with the recipients or not; similar logic to the Pipeline
                            // check for error if so we should break out
                            if (!continueProcessing(current, ""so breaking out of the routing slip"", log)) {
                                break;
                            }

                            Endpoint endpoint;
                            try {
                                endpoint = resolveEndpoint(iter, exchange);
                                // if no endpoint was resolved then try the next
                                if (endpoint == null) {
                                    continue;
                                }
                            } catch (Exception e) {
                                // error resolving endpoint so we should break out
                                exchange.setException(e);
                                break;
                            }

                            // prepare and process the routing slip
                            Exchange copy = prepareExchangeForRoutingSlip(current, endpoint);
                            boolean sync = processExchange(endpoint, copy, original, callback, iter);
                            current = copy;

                            if (!sync) {
                                log.trace(""Processing exchangeId: {} is continued being processed asynchronously"", original.getExchangeId());
                                return;
                            }
                        }

                        // logging nextExchange as it contains the exchange that might have altered the payload and since
                        // we are logging the completion if will be confusing if we log the original instead
                        // we could also consider logging the original and the nextExchange then we have *before* and *after* snapshots
                        log.trace(""Processing complete for exchangeId: {} >>> {}"", original.getExchangeId(), current);

                        // copy results back to the original exchange
                        ExchangeHelper.copyResults(original, current);
                        callback.done(false);
                    }
                });

                return sync;
            }
        });

        return sync;
    }",0,[0]
3183,bugs-dot-jar_CAMEL-7736_7ad36e3d,"@Override
    public String toString() {
        return ""ProducerCache for source: "" + source + "", capacity: "" + getCapacity();
    }","@Override
    public String toString() {
        return ""ProducerCache for source: "" + source + "", capacity: "" + getCapacity();
    }",0,[0]
39186,bugs-dot-jar_OAK-4353_b0014b7d,"int getRefCount() {
        return (data.get(REF_COUNT_OFFSET) & 0xff) + 1;
    }","int getRefCount() {
        return (data.get(REF_COUNT_OFFSET) & 0xff) + 1;
    }",0,[0]
1006,bugs-dot-jar_ACCUMULO-3408_81d25bc2,"public NumberType(T warnMin, T warnMax, T errMin, T errMax) {
    this.warnMin = warnMin;
    this.warnMax = warnMax;
    this.errMin = errMin;
    this.errMax = errMax;
  }","public NumberType(T warnMin, T warnMax, T errMin, T errMax) {
    this.warnMin = warnMin;
    this.warnMax = warnMax;
    this.errMin = errMin;
    this.errMax = errMax;
  }",0,[0]
8823,bugs-dot-jar_CAMEL-7275_44cad623,"public MulticastProcessor(CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy) {
        this(camelContext, processors, aggregationStrategy, false, null, false, false, false, 0, null, false);
    }","public MulticastProcessor(CamelContext camelContext, Collection<Processor> processors, AggregationStrategy aggregationStrategy) {
        this(camelContext, processors, aggregationStrategy, false, null, false, false, false, 0, null, false);
    }",0,[0]
18175,bugs-dot-jar_MATH-554_fbbb96eb,"public double getX() {
    return x;
  }","public double getX() {
    return x;
  }",0,[0]
1936,bugs-dot-jar_CAMEL-3535_b56d2962,"public Predicate getCompletionPredicate() {
        return completionPredicate;
    }","public Predicate getCompletionPredicate() {
        return completionPredicate;
    }",0,[0]
160,Bears-6,"@Override
    public Iterator<AnnotatedParameter> getConstructorParameters() {
        if (_ctorParameters == null) {
            return ClassUtil.emptyIterator();
        }
        return new MemberIterator<AnnotatedParameter>(_ctorParameters);
    }","@Override
    public Iterator<AnnotatedParameter> getConstructorParameters() {
        if (_ctorParameters == null) {
            return ClassUtil.emptyIterator();
        }
        return new MemberIterator<AnnotatedParameter>(_ctorParameters);
    }",0,[0]
16993,bugs-dot-jar_OAK-766_6fc5ea9d,"@Override
    public PropertyState getProperty(String name) {
        enter();
        PropertyState property = internalGetProperty(name);
        if (canRead(property)) {
            return property;
        } else {
            return null;
        }
    }","@Override
    public PropertyState getProperty(String name) {
        enter();
        PropertyState property = internalGetProperty(name);
        if (canRead(property)) {
            return property;
        } else {
            return null;
        }
    }",0,[0]
40415,bugs-dot-jar_WICKET-442_246d53c5,"public final void remove()
	{
		if (parent == null)
		{
			throw new IllegalStateException(""Cannot remove "" + this + "" from null parent!"");
		}

		parent.remove(this);
	}","public final void remove()
	{
		if (parent == null)
		{
			throw new IllegalStateException(""Cannot remove "" + this + "" from null parent!"");
		}

		parent.remove(this);
	}",0,[0]
403,Bears-15,public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { return _generator; },public Class<? extends ObjectIdGenerator<?>> getGeneratorType() { return _generator; },0,[0]
1357,bugs-dot-jar_MATH-1252_09fe956a,"@Override
    public void setElement(int index, double value) {
        if (index < 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        if (index + 1 > numElements) {
            numElements = index + 1;
        }
        if ((startIndex + index) >= internalArray.length) {
            expandTo(startIndex + (index + 1));
        }
        internalArray[startIndex + index] = value;
    }","@Override
    public void setElement(int index, double value) {
        if (index < 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        if (index + 1 > numElements) {
            numElements = index + 1;
        }
        if ((startIndex + index) >= internalArray.length) {
            expandTo(startIndex + (index + 1));
        }
        internalArray[startIndex + index] = value;
    }",0,[0]
6259,bugs-dot-jar_WICKET-2079_ceac38b1,"private final void init(final IPageMap pageMap)
	{
		if (isBookmarkable())
			setStatelessHint(true);

		// Set the page map
		if (pageMap != null)
		{
			setPageMap(pageMap);
		}
		else
		{
			throw new IllegalStateException(""PageMap cannot be null"");
		}

		setNextAvailableId();

		// Set versioning of page based on default
		setVersioned(Application.get().getPageSettings().getVersionPagesByDefault());

		// All Pages are born dirty so they get clustered right away
		dirty();
	}","private final void init(final IPageMap pageMap)
	{
		if (isBookmarkable())
			setStatelessHint(true);

		// Set the page map
		if (pageMap != null)
		{
			setPageMap(pageMap);
		}
		else
		{
			throw new IllegalStateException(""PageMap cannot be null"");
		}

		setNextAvailableId();

		// Set versioning of page based on default
		setVersioned(Application.get().getPageSettings().getVersionPagesByDefault());

		// All Pages are born dirty so they get clustered right away
		dirty();
	}",0,[0]
33160,bugs-dot-jar_FLINK-1686_1f726e48,"protected void forwardRecords() throws Exception {
		StreamRecord<IN> reuse = inputHandler.getInputSerializer().createInstance();
		while ((reuse = inputHandler.getInputIter().next(reuse)) != null) {
			if (!pushToQueue(reuse)) {
				break;
			}
			reuse = inputHandler.getInputSerializer().createInstance();
		}
	}","protected void forwardRecords() throws Exception {
		StreamRecord<IN> reuse = inputHandler.getInputSerializer().createInstance();
		while ((reuse = inputHandler.getInputIter().next(reuse)) != null) {
			if (!pushToQueue(reuse)) {
				break;
			}
			reuse = inputHandler.getInputSerializer().createInstance();
		}
	}",0,[0]
28601,bugs-dot-jar_MATH-704_3f645310,"public double evaluate(final double[] values, final double mean) {
        return evaluate(values, mean, 0, values.length);
    }","public double evaluate(final double[] values, final double mean) {
        return evaluate(values, mean, 0, values.length);
    }",0,[0]
1651,Bears-194,"private boolean isAnyArgumentTainted(Node simpleNode) {
		ASTArgumentList argListNode = simpleNode.getFirstDescendantOfType(ASTArgumentList.class);
		if (argListNode != null) {
			int numChildren = argListNode.jjtGetNumChildren();
			for (int i = 0; i < numChildren; i++) {
				Node argument = argListNode.jjtGetChild(i);
				if (isTainted(argument)) {
					return true;
				}
			}
		}
		return false;
	}","private boolean isAnyArgumentTainted(Node simpleNode) {
		ASTArgumentList argListNode = simpleNode.getFirstDescendantOfType(ASTArgumentList.class);
		if (argListNode != null) {
			if (isSanitized(argListNode)) {
				return false;
			}
			int numChildren = argListNode.jjtGetNumChildren();
			for (int i = 0; i < numChildren; i++) {
				Node argument = argListNode.jjtGetChild(i);
				if (isTainted(argument)) {
					return true;
				}
			}
		}
		return false;
	}",1,[]
30268,bugs-dot-jar_OAK-1208_cb3ac20d,"private static NodeState getIndexDataNode(NodeState node) {
        if (node.hasChildNode(INDEX_DATA_CHILD_NAME)) {
            return node.getChildNode(INDEX_DATA_CHILD_NAME);
        }
        // unusable index (not initialized yet)
        return null;
    }","private static NodeState getIndexDataNode(NodeState node) {
        if (node.hasChildNode(INDEX_DATA_CHILD_NAME)) {
            return node.getChildNode(INDEX_DATA_CHILD_NAME);
        }
        // unusable index (not initialized yet)
        return null;
    }",0,[0]
36177,bugs-dot-jar_CAMEL-9444_baece126,"@SuppressWarnings(""unchecked"")
    @Deprecated
    public Type bean(Class<?> beanType, String method, boolean multiParameterArray) {
        BeanDefinition answer = new BeanDefinition();
        answer.setBeanType(beanType);
        answer.setMethod(method);
        answer.setMultiParameterArray(multiParameterArray);
        addOutput(answer);
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    @Deprecated
    public Type bean(Class<?> beanType, String method, boolean multiParameterArray) {
        BeanDefinition answer = new BeanDefinition();
        answer.setBeanType(beanType);
        answer.setMethod(method);
        answer.setMultiParameterArray(multiParameterArray);
        addOutput(answer);
        return (Type) this;
    }",0,[0]
8425,bugs-dot-jar_ACCUMULO-366_db4a291f,"public boolean needsMajorCompaction(MajorCompactionReason reason) {
    if (majorCompactionInProgress)
      return false;
    if (reason == MajorCompactionReason.CHOP || reason == MajorCompactionReason.ALL)
      return true;
    return tabletResources.needsMajorCompaction(datafileManager.getDatafileSizes(), reason);
  }","public boolean needsMajorCompaction(MajorCompactionReason reason) {
    if (majorCompactionInProgress)
      return false;
    if (reason == MajorCompactionReason.CHOP || reason == MajorCompactionReason.ALL)
      return true;
    return tabletResources.needsMajorCompaction(datafileManager.getDatafileSizes(), reason);
  }",0,[0]
1723,Bears-197,"public URIBuilder removeQuery() {
        this.queryParams = null;
        this.query = null;
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        return this;
    }","public URIBuilder removeQuery() {
        this.queryParams = null;
        this.query = null;
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        return this;
    }",0,[0]
8289,bugs-dot-jar_MATH-934_724795b5,"public Complex acos() {
        if (isNaN) {
            return NaN;
        }

        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());
    }","public Complex acos() {
        if (isNaN) {
            return NaN;
        }

        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());
    }",0,[0]
7573,bugs-dot-jar_ACCUMULO-2713_6138a80f,"public static SecretKeyEncryptionStrategy getSecretKeyEncryptionStrategy(AccumuloConfiguration conf) {
    String className = conf.get(Property.CRYPTO_SECRET_KEY_ENCRYPTION_STRATEGY_CLASS);
    return getSecretKeyEncryptionStrategy(className);
  }","public static SecretKeyEncryptionStrategy getSecretKeyEncryptionStrategy(AccumuloConfiguration conf) {
    String className = conf.get(Property.CRYPTO_SECRET_KEY_ENCRYPTION_STRATEGY_CLASS);
    return getSecretKeyEncryptionStrategy(className);
  }",0,[0]
12654,bugs-dot-jar_WICKET-4309_b4274415,"public final Character toOptionalCharacter() throws StringValueConversionException
	{
		return (text == null) ? null : toCharacter();
	}","public final Character toOptionalCharacter() throws StringValueConversionException
	{
		return Strings.isEmpty(text) ? null : toCharacter();
	}",1,[2]
20728,bugs-dot-jar_WICKET-5960_03663750,"public void renderHeaderTagBody(HeaderStreamState headerStreamState)
	{
		if (headerStreamState == null)
			return;

		final Response oldResponse = getRequestCycle().getResponse();
		try
		{
			// Create a separate (string) response for the header container itself
			final StringResponse bodyResponse = new StringResponse();
			getRequestCycle().setResponse(bodyResponse);

			// render the header section directly associated with the markup
			super.onComponentTagBody(headerStreamState.getMarkupStream(),
				headerStreamState.getOpenTag());
			CharSequence bodyOutput = getCleanResponse(bodyResponse);
			if (bodyOutput.length() > 0)
			{
				getHeaderResponse().render(new PageHeaderItem(bodyOutput));
			}
		}
		finally
		{
			getRequestCycle().setResponse(oldResponse);
		}
	}","public void renderHeaderTagBody(HeaderStreamState headerStreamState)
	{
		if (headerStreamState == null)
			return;

		final Response oldResponse = getRequestCycle().getResponse();
		try
		{
			// Create a separate (string) response for the header container itself
			final StringResponse bodyResponse = new StringResponse();
			getRequestCycle().setResponse(bodyResponse);

			// render the header section directly associated with the markup
			super.onComponentTagBody(headerStreamState.getMarkupStream(),
				headerStreamState.getOpenTag());
			CharSequence bodyOutput = getCleanResponse(bodyResponse);
			if (bodyOutput.length() > 0)
			{
				getHeaderResponse().render(new PageHeaderItem(bodyOutput));
			}
		}
		finally
		{
			getRequestCycle().setResponse(oldResponse);
		}
	}",0,[0]
36427,bugs-dot-jar_MATH-705_645d642b,"public ClassicalRungeKuttaStepInterpolator() {
    }","public ClassicalRungeKuttaStepInterpolator() {
    }",0,[0]
30490,bugs-dot-jar_CAMEL-8626_d063f471,"public String dumpRouteAsXml() throws Exception {
        String id = route.getId();
        RouteDefinition def = context.getRouteDefinition(id);
        if (def != null) {
            return ModelHelper.dumpModelAsXml(context, def);
        }
        return null;
    }","public String dumpRouteAsXml() throws Exception {
        String id = route.getId();
        RouteDefinition def = context.getRouteDefinition(id);
        if (def != null) {
            return ModelHelper.dumpModelAsXml(context, def);
        }
        return null;
    }",0,[0]
1367,Bears-160,"protected void parseAlterSpecificationList(Marker start, TableEditor table, Consumer<TableId> newTableName) {
        parseAlterSpecification(start, table, newTableName);
        while (tokens.canConsume(',')) {
            parseAlterSpecification(start, table, newTableName);
        }
    }","protected void parseAlterSpecificationList(Marker start, TableEditor table, Consumer<TableId> newTableName) {
        parseAlterSpecification(start, table, newTableName);
        while (tokens.canConsume(',')) {
            parseAlterSpecification(start, table, newTableName);
        }
    }",0,[0]
33276,bugs-dot-jar_ACCUMULO-795_9453bcfa,"public boolean exists(String tableName) {
    ArgumentChecker.notNull(tableName);
    if (tableName.equals(Constants.METADATA_TABLE_NAME))
      return true;
    
    OpTimer opTimer = new OpTimer(log, Level.TRACE).start(""Checking if table "" + tableName + ""exists..."");
    boolean exists = Tables.getNameToIdMap(instance).containsKey(tableName);
    opTimer.stop(""Checked existance of "" + exists + "" in %DURATION%"");
    return exists;
  }","public boolean exists(String tableName) {
    ArgumentChecker.notNull(tableName);
    if (tableName.equals(Constants.METADATA_TABLE_NAME))
      return true;
    
    OpTimer opTimer = new OpTimer(log, Level.TRACE).start(""Checking if table "" + tableName + ""exists..."");
    boolean exists = Tables.getNameToIdMap(instance).containsKey(tableName);
    opTimer.stop(""Checked existance of "" + exists + "" in %DURATION%"");
    return exists;
  }",0,[0]
32693,bugs-dot-jar_CAMEL-3617_02626724,"public void error(SAXParseException exception) throws SAXException {
        throw exception;
    }","public void error(SAXParseException exception) throws SAXException {
        throw exception;
    }",0,[0]
8044,bugs-dot-jar_OAK-2147_a1556c30,"static void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {
        if (node != null && next != null) {
            String n1 = (next.length > 0) ? next[0] : """";
            String n2 = (next.length > 1) ? next[1] : """";
            String n3 = (next.length > 2) ? next[2] : """";
            String n4 = (next.length > 3) ? next[3] : """";
            
            node.setProperty(NEXT, ImmutableList.of(n1, n2, n3, n4), Type.STRINGS);
        }
    }","static void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {
        if (node != null && next != null) {
            int len = next.length - 1;
            for (; len >= 0; len--) {
                if (next[len].length() != 0) {
               	    break;
                }
            }
            len++;
            List<String> list = new ArrayList<String>(len);
            for (int i = 0; i < len; i++) {
                list.add(next[i]);
            }
            node.setProperty(NEXT, list, Type.STRINGS);
        }
    }",1,"[2, 3, 4, 5, 7]"
538,Bears-16,"protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {
        return new BeanSerializerBuilder(beanDesc);
    }","protected BeanSerializerBuilder constructBeanSerializerBuilder(BeanDescription beanDesc) {
        return new BeanSerializerBuilder(beanDesc);
    }",0,[0]
33705,bugs-dot-jar_WICKET-5981_eb125865,"private void removedComponent(final Component component)
	{
		// Notify Page that component is being removed
		final Page page = component.findPage();
		if (page != null)
		{
			page.componentRemoved(component);
		}
		
		component.detach();

		component.internalOnRemove();

		// Component is removed
		component.setParent(null);
	}","private void removedComponent(final Component component)
	{
		// Notify Page that component is being removed
		final Page page = component.findPage();
		if (page != null)
		{
			page.componentRemoved(component);
		}
		
		component.detach();

		component.internalOnRemove();

		// Component is removed
		component.setParent(null);
	}",0,[0]
26228,bugs-dot-jar_LOG4J2-430_238ce8aa,"private void appendTimestamp(final StringBuilder buffer, final long milliseconds)  {
        buffer.append(computeTimeStampString(milliseconds));
    }","private void appendTimestamp(final StringBuilder buffer, final long milliseconds)  {
        buffer.append(computeTimeStampString(milliseconds));
    }",0,[0]
3698,bugs-dot-jar_OAK-369_4e245a76,"private TreeLocation getChildLocation(String relPath) throws InvalidItemStateException {
        return getLocation().getChild(relPath);
    }","private TreeLocation getChildLocation(String relPath) throws RepositoryException {
        if (PathUtils.isAbsolute(relPath)) {
            throw new RepositoryException(""Not a relative path: "" + relPath);
        }

        TreeLocation loc = getLocation();
        for (String element : PathUtils.elements(relPath)) {
            if (PathUtils.denotesParent(element)) {
                loc = loc.getParent();
            } else if (!PathUtils.denotesCurrent(element)) {
                loc = loc.getChild(element);
            }  // else . -> skip to next element
        }
        return loc;
    }",1,"[0, 1]"
36383,bugs-dot-jar_CAMEL-9444_baece126,"public void setParallelAggregate(boolean parallelAggregate) {
        this.parallelAggregate = parallelAggregate;
    }","public void setParallelAggregate(boolean parallelAggregate) {
        this.parallelAggregate = parallelAggregate;
    }",0,[0]
33627,bugs-dot-jar_WICKET-4520_b91154ea,"public final boolean add(final IMarkupFilter filter,
		final Class<? extends IMarkupFilter> beforeFilter)
	{
		return getMarkupFilters().add(filter, beforeFilter);
	}","public final boolean add(final IMarkupFilter filter,
		final Class<? extends IMarkupFilter> beforeFilter)
	{
		return getMarkupFilters().add(filter, beforeFilter);
	}",0,[0]
11069,bugs-dot-jar_MATH-1269_a94ff90a,"public static float nextUp(final float a) {
        return nextAfter(a, Float.POSITIVE_INFINITY);
    }","public static float nextUp(final float a) {
        return nextAfter(a, Float.POSITIVE_INFINITY);
    }",0,[0]
2349,bugs-dot-jar_MNG-4918_691a03a7,"public void setExtensionDependencyFilter( DependencyFilter extensionDependencyFilter )
    {
        this.extensionDependencyFilter = extensionDependencyFilter;
    }","public void setExtensionDependencyFilter( DependencyFilter extensionDependencyFilter )
    {
        this.extensionDependencyFilter = extensionDependencyFilter;
    }",0,[0]
875,bugs-dot-jar_WICKET-4572_dfc56674,"private PageWindowInternal allocatePageWindow(int index, int size)
	{
		final PageWindowInternal window;

		// new window
		if (index == windows.size())
		{
			// new page window
			window = new PageWindowInternal();
			window.filePartOffset = getWindowFileOffset(index);
			totalSize += size;
			window.filePartSize = size;
			windows.add(window);
		}
		else
		{
			// get the window
			window = windows.get(index);

			// adjust if necessary
			if (window.filePartSize != size)
			{
				adjustWindowSize(index, size);
			}
		}

		return window;
	}","private PageWindowInternal allocatePageWindow(int index, int size)
	{
		final PageWindowInternal window;

		// new window
		if (index == windows.size())
		{
			// new page window
			window = new PageWindowInternal();
			window.filePartOffset = getWindowFileOffset(index);
			totalSize += size;
			window.filePartSize = size;
			windows.add(window);
		}
		else
		{
			// get the window
			window = windows.get(index);

			// adjust if necessary
			if (window.filePartSize != size)
			{
				adjustWindowSize(index, size);
			}
		}

		return window;
	}",0,[0]
3774,bugs-dot-jar_FLINK-2460_a17d4e82,"@Override
	public String toString() {
		synchronized (buffers) {
			return String.format(""PipelinedSubpartition [number of buffers: %d (%d bytes), "" +
							""finished? %s, read view? %s]"",
					getTotalNumberOfBuffers(), getTotalNumberOfBytes(), isFinished, readView != null);
		}
	}","@Override
	public String toString() {
		synchronized (buffers) {
			return String.format(""PipelinedSubpartition [number of buffers: %d (%d bytes), "" +
							""finished? %s, read view? %s]"",
					getTotalNumberOfBuffers(), getTotalNumberOfBytes(), isFinished, readView != null);
		}
	}",0,[0]
6864,bugs-dot-jar_OAK-2062_5c4589bd,"public SelectorImpl(NodeState nodeType, String selectorName) {
        this.nodeType = checkNotNull(nodeType);
        this.selectorName = checkNotNull(selectorName);

        this.nodeTypeName = nodeType.getName(JCR_NODETYPENAME);
        this.matchesAllTypes = NT_BASE.equals(nodeTypeName);

        if (!this.matchesAllTypes) {
            this.supertypes = newHashSet(nodeType.getNames(REP_SUPERTYPES));
            supertypes.add(nodeTypeName);

            this.primaryTypes = newHashSet(nodeType
                    .getNames(REP_PRIMARY_SUBTYPES));
            this.mixinTypes = newHashSet(nodeType.getNames(REP_MIXIN_SUBTYPES));
            if (nodeType.getBoolean(JCR_ISMIXIN)) {
                mixinTypes.add(nodeTypeName);
            } else {
                primaryTypes.add(nodeTypeName);
            }
        } else {
            this.supertypes = ImmutableSet.of();
            this.primaryTypes = ImmutableSet.of();
            this.mixinTypes = ImmutableSet.of();
        }
    }","public SelectorImpl(NodeState nodeType, String selectorName) {
        this.nodeType = checkNotNull(nodeType);
        this.selectorName = checkNotNull(selectorName);

        this.nodeTypeName = nodeType.getName(JCR_NODETYPENAME);
        this.matchesAllTypes = NT_BASE.equals(nodeTypeName);

        if (!this.matchesAllTypes) {
            this.supertypes = newHashSet(nodeType.getNames(REP_SUPERTYPES));
            supertypes.add(nodeTypeName);

            this.primaryTypes = newHashSet(nodeType
                    .getNames(REP_PRIMARY_SUBTYPES));
            this.mixinTypes = newHashSet(nodeType.getNames(REP_MIXIN_SUBTYPES));
            if (nodeType.getBoolean(JCR_ISMIXIN)) {
                mixinTypes.add(nodeTypeName);
            } else {
                primaryTypes.add(nodeTypeName);
            }
        } else {
            this.supertypes = ImmutableSet.of();
            this.primaryTypes = ImmutableSet.of();
            this.mixinTypes = ImmutableSet.of();
        }
    }",0,[0]
19172,bugs-dot-jar_ACCUMULO-776_dc9f23d9,"public static void setStart(IteratorSetting is, long start, boolean startInclusive) {
    SimpleDateFormat dateParser = initDateParser();
    is.addOption(START, dateParser.format(new Date(start)));
    is.addOption(START_INCL, Boolean.toString(startInclusive));
  }","public static void setStart(IteratorSetting is, long start, boolean startInclusive) {
    is.addOption(START, LONG_PREFIX + Long.toString(start));
    is.addOption(START_INCL, Boolean.toString(startInclusive));
  }",1,"[1, 2]"
25321,bugs-dot-jar_OAK-4038_557eec4f,"@Override
    public String toString() {
        StringBuilder buffer = new StringBuilder(""property "");
        buffer.append(name);
        if (values == null) {
            buffer.append("" IS NOT NULL"");
        } else if (values.isEmpty()) {
            buffer.append("" NOT APPLICABLE"");
        } else if (values.size() == 1) {
            buffer.append("" = "");
            buffer.append(values.iterator().next());
        } else {
            buffer.append("" IN ("");
            boolean comma = false;
            for (String value : values) {
                if (comma) {
                    buffer.append("", "");
                }
                buffer.append(value);
                comma = true;
            }
            buffer.append("")"");
        }
        return buffer.toString();
    }","@Override
    public String toString() {
        StringBuilder buffer = new StringBuilder(""property "");
        buffer.append(name);
        if (values == null) {
            buffer.append("" IS NOT NULL"");
        } else if (values.isEmpty()) {
            buffer.append("" NOT APPLICABLE"");
        } else if (values.size() == 1) {
            buffer.append("" = "");
            buffer.append(values.iterator().next());
        } else {
            buffer.append("" IN ("");
            boolean comma = false;
            for (String value : values) {
                if (comma) {
                    buffer.append("", "");
                }
                buffer.append(value);
                comma = true;
            }
            buffer.append("")"");
        }
        return buffer.toString();
    }",0,[0]
26969,bugs-dot-jar_LOG4J2-793_73400bfb,"@Override
    public void trace(final String format, final Object... args) {
        logger.logIfEnabled(FQCN, Level.TRACE, null, format, args);
    }","@Override
    public void trace(final String format, final Object... args) {
        logger.logIfEnabled(FQCN, Level.TRACE, null, format, args);
    }",0,[0]
29757,bugs-dot-jar_FLINK-2763_af477563,"protected void initTable(int numBuckets, byte numPartitions) {
		final int bucketsPerSegment = this.bucketsPerSegmentMask + 1;
		final int numSegs = (numBuckets >>> this.bucketsPerSegmentBits) + ( (numBuckets & this.bucketsPerSegmentMask) == 0 ? 0 : 1);
		final MemorySegment[] table = new MemorySegment[numSegs];
		
		ensureNumBuffersReturned(numSegs);
		
		// go over all segments that are part of the table
		for (int i = 0, bucket = 0; i < numSegs && bucket < numBuckets; i++) {
			final MemorySegment seg = getNextBuffer();
			
			// go over all buckets in the segment
			for (int k = 0; k < bucketsPerSegment && bucket < numBuckets; k++, bucket++) {
				final int bucketOffset = k * HASH_BUCKET_SIZE;	
				
				// compute the partition that the bucket corresponds to
				final byte partition = assignPartition(bucket, numPartitions);
				
				// initialize the header fields
				seg.put(bucketOffset + HEADER_PARTITION_OFFSET, partition);
				seg.put(bucketOffset + HEADER_STATUS_OFFSET, BUCKET_STATUS_IN_MEMORY);
				seg.putShort(bucketOffset + HEADER_COUNT_OFFSET, (short) 0);
				seg.putLong(bucketOffset + HEADER_FORWARD_OFFSET, BUCKET_FORWARD_POINTER_NOT_SET);
			}
			
			table[i] = seg;
		}
		this.buckets = table;
		this.numBuckets = numBuckets;
		
		if (useBloomFilters) {
			initBloomFilter(numBuckets);
		}
	}","protected void initTable(int numBuckets, byte numPartitions) {
		final int bucketsPerSegment = this.bucketsPerSegmentMask + 1;
		final int numSegs = (numBuckets >>> this.bucketsPerSegmentBits) + ( (numBuckets & this.bucketsPerSegmentMask) == 0 ? 0 : 1);
		final MemorySegment[] table = new MemorySegment[numSegs];
		
		ensureNumBuffersReturned(numSegs);
		
		// go over all segments that are part of the table
		for (int i = 0, bucket = 0; i < numSegs && bucket < numBuckets; i++) {
			final MemorySegment seg = getNextBuffer();
			
			// go over all buckets in the segment
			for (int k = 0; k < bucketsPerSegment && bucket < numBuckets; k++, bucket++) {
				final int bucketOffset = k * HASH_BUCKET_SIZE;	
				
				// compute the partition that the bucket corresponds to
				final byte partition = assignPartition(bucket, numPartitions);
				
				// initialize the header fields
				seg.put(bucketOffset + HEADER_PARTITION_OFFSET, partition);
				seg.put(bucketOffset + HEADER_STATUS_OFFSET, BUCKET_STATUS_IN_MEMORY);
				seg.putShort(bucketOffset + HEADER_COUNT_OFFSET, (short) 0);
				seg.putLong(bucketOffset + HEADER_FORWARD_OFFSET, BUCKET_FORWARD_POINTER_NOT_SET);
			}
			
			table[i] = seg;
		}
		this.buckets = table;
		this.numBuckets = numBuckets;
		
		if (useBloomFilters) {
			initBloomFilter(numBuckets);
		}
	}",0,[0]
18390,bugs-dot-jar_LOG4J2-832_411dad65,"private void formatElements(final StringBuilder sb, final int commonCount, final StackTraceElement[] causedTrace,
            final ExtendedStackTraceElement[] extStackTrace, final List<String> ignorePackages) {
        if (ignorePackages == null || ignorePackages.isEmpty()) {
            for (int i = 0; i < extStackTrace.length; ++i) {
                this.formatEntry(extStackTrace[i], sb);
            }
        } else {
            int count = 0;
            for (int i = 0; i < extStackTrace.length; ++i) {
                if (!this.ignoreElement(causedTrace[i], ignorePackages)) {
                    if (count > 0) {
                        if (count == 1) {
                            sb.append(""\t....\n"");
                        } else {
                            sb.append(""\t... suppressed "").append(count).append("" lines\n"");
                        }
                        count = 0;
                    }
                    this.formatEntry(extStackTrace[i], sb);
                } else {
                    ++count;
                }
            }
            if (count > 0) {
                if (count == 1) {
                    sb.append(""\t...\n"");
                } else {
                    sb.append(""\t... suppressed "").append(count).append("" lines\n"");
                }
            }
        }
        if (commonCount != 0) {
            sb.append(""\t... "").append(commonCount).append("" more"").append('\n');
        }
    }","private void formatElements(final StringBuilder sb, final int commonCount, final StackTraceElement[] causedTrace,
            final ExtendedStackTraceElement[] extStackTrace, final List<String> ignorePackages) {
        if (ignorePackages == null || ignorePackages.isEmpty()) {
            for (int i = 0; i < extStackTrace.length; ++i) {
                this.formatEntry(extStackTrace[i], sb);
            }
        } else {
            int count = 0;
            for (int i = 0; i < extStackTrace.length; ++i) {
                if (!this.ignoreElement(causedTrace[i], ignorePackages)) {
                    if (count > 0) {
                        if (count == 1) {
                            sb.append(""\t....\n"");
                        } else {
                            sb.append(""\t... suppressed "").append(count).append("" lines\n"");
                        }
                        count = 0;
                    }
                    this.formatEntry(extStackTrace[i], sb);
                } else {
                    ++count;
                }
            }
            if (count > 0) {
                if (count == 1) {
                    sb.append(""\t...\n"");
                } else {
                    sb.append(""\t... suppressed "").append(count).append("" lines\n"");
                }
            }
        }
        if (commonCount != 0) {
            sb.append(""\t... "").append(commonCount).append("" more"").append('\n');
        }
    }",0,[0]
37452,bugs-dot-jar_OAK-3137_c65b07c3,"IndexPlan getPlan() {
        IndexPlan.Builder builder = getPlanBuilder();

        if (definition.isTestMode()){
            if ( builder == null) {
                if (notSupportedFeature()) {
                    return null;
                }
                String msg = String.format(""No plan found for filter [%s] "" +
                        ""while using definition [%s] and testMode is found to be enabled"", filter, definition);
                throw new IllegalStateException(msg);
            } else {
                builder.setEstimatedEntryCount(1)
                        .setCostPerExecution(1e-3)
                        .setCostPerEntry(1e-3);
            }
        }

        return builder != null ? builder.build() : null;
    }","IndexPlan getPlan() {
        IndexPlan.Builder builder = getPlanBuilder();

        if (definition.isTestMode()){
            if ( builder == null) {
                if (notSupportedFeature()) {
                    return null;
                }
                String msg = String.format(""No plan found for filter [%s] "" +
                        ""while using definition [%s] and testMode is found to be enabled"", filter, definition);
                throw new IllegalStateException(msg);
            } else {
                builder.setEstimatedEntryCount(1)
                        .setCostPerExecution(1e-3)
                        .setCostPerEntry(1e-3);
            }
        }

        return builder != null ? builder.build() : null;
    }",0,[0]
73,Bears-5,"public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,
            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,
            HashSet<String> ignorableProps, boolean ignoreAllUnknown,
            boolean hasViews)
    {
        super(builder, beanDesc, properties, backRefs,
                ignorableProps, ignoreAllUnknown, hasViews);
    }","public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,
            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,
            HashSet<String> ignorableProps, boolean ignoreAllUnknown,
            boolean hasViews)
    {
        super(builder, beanDesc, properties, backRefs,
                ignorableProps, ignoreAllUnknown, hasViews);
    }",0,[0]
29155,bugs-dot-jar_WICKET-3861_d1e0e411,"public Markup getBaseMarkup()
	{
		return baseMarkup;
	}","public Markup getBaseMarkup()
	{
		return baseMarkup;
	}",0,[0]
39275,bugs-dot-jar_OAK-4353_b0014b7d,"@Nonnull
    private TarEntry[] getEntries() {
        TarEntry[] entries = new TarEntry[index.remaining() / TarEntry.SIZE];
        int position = index.position();
        for (int i = 0; position < index.limit(); i++) {
            entries[i]  = new TarEntry(
                    index.getLong(position),
                    index.getLong(position + 8),
                    index.getInt(position + 16),
                    index.getInt(position + 20),
                    index.getInt(position + 24));
            position += TarEntry.SIZE;
        }
        Arrays.sort(entries, TarEntry.OFFSET_ORDER);
        return entries;
    }","@Nonnull
    private TarEntry[] getEntries() {
        TarEntry[] entries = new TarEntry[index.remaining() / TarEntry.SIZE];
        int position = index.position();
        for (int i = 0; position < index.limit(); i++) {
            entries[i]  = new TarEntry(
                    index.getLong(position),
                    index.getLong(position + 8),
                    index.getInt(position + 16),
                    index.getInt(position + 20),
                    index.getInt(position + 24));
            position += TarEntry.SIZE;
        }
        Arrays.sort(entries, TarEntry.OFFSET_ORDER);
        return entries;
    }",0,[0]
15240,bugs-dot-jar_WICKET-4070_d450acb0,"private void inputChanged()
	{
		visitFormComponentsPostOrder(new IVisitor<FormComponent<?>, Void>()
		{
			public void component(final FormComponent<?> formComponent, IVisit<Void> visit)
			{
				formComponent.inputChanged();
			}
		});
	}","private void inputChanged()
	{
		visitFormComponentsPostOrder(new IVisitor<FormComponent<?>, Void>()
		{
			public void component(final FormComponent<?> formComponent, IVisit<Void> visit)
			{
				formComponent.inputChanged();
			}
		});
	}",0,[0]
17786,bugs-dot-jar_OAK-740_35a7f014,"public void apply(SolrServer solrServer) throws CommitFailedException {
        if (remove.isEmpty() && insert.isEmpty()) {
            return;
        }
        try {
            for (String p : remove) {
                deleteSubtreeWriter(solrServer, p);
            }
            for (String p : insert.keySet()) {
                NodeState ns = insert.get(p);
                addSubtreeWriter(solrServer, p, ns);
            }
            OakSolrUtils.commitByPolicy(solrServer,  configuration.getCommitPolicy());
        } catch (IOException e) {
            throw new CommitFailedException(
                    ""Failed to update the full text search index"", e);
        } catch (SolrServerException e) {
            throw new CommitFailedException(
                    ""Failed to update the full text search index"", e);
        } finally {
            remove.clear();
            insert.clear();
        }
    }","public void apply(SolrServer solrServer) throws CommitFailedException {
        if (remove.isEmpty() && insert.isEmpty()) {
            return;
        }
        try {
            for (String p : remove) {
                deleteSubtreeWriter(solrServer, p);
            }
            for (String p : insert.keySet()) {
                NodeState ns = insert.get(p);
                addSubtreeWriter(solrServer, p, ns);
            }
            OakSolrUtils.commitByPolicy(solrServer,  configuration.getCommitPolicy());
        } catch (IOException e) {
            throw new CommitFailedException(
                    ""Failed to update the full text search index"", e);
        } catch (SolrServerException e) {
            throw new CommitFailedException(
                    ""Failed to update the full text search index"", e);
        } finally {
            remove.clear();
            insert.clear();
        }
    }",0,[0]
30154,bugs-dot-jar_MATH-801_118e94b5,"public double[] getAngles(RotationOrder order)
    throws CardanEulerSingularityException {

    if (order == RotationOrder.XYZ) {

      // r (Vector3D.plusK) coordinates are :
      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(-(v1.getY()), v1.getZ()),
        FastMath.asin(v2.getZ()),
        FastMath.atan2(-(v2.getY()), v2.getX())
      };

    } else if (order == RotationOrder.XZY) {

      // r (Vector3D.plusJ) coordinates are :
      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(v1.getZ(), v1.getY()),
       -FastMath.asin(v2.getY()),
        FastMath.atan2(v2.getZ(), v2.getX())
      };

    } else if (order == RotationOrder.YXZ) {

      // r (Vector3D.plusK) coordinates are :
      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(v1.getX(), v1.getZ()),
       -FastMath.asin(v2.getZ()),
        FastMath.atan2(v2.getX(), v2.getY())
      };

    } else if (order == RotationOrder.YZX) {

      // r (Vector3D.plusI) coordinates are :
      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(-(v1.getZ()), v1.getX()),
        FastMath.asin(v2.getX()),
        FastMath.atan2(-(v2.getZ()), v2.getY())
      };

    } else if (order == RotationOrder.ZXY) {

      // r (Vector3D.plusJ) coordinates are :
      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
      // (-r) (Vector3D.plusK) coordinates are :
      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(-(v1.getX()), v1.getY()),
        FastMath.asin(v2.getY()),
        FastMath.atan2(-(v2.getX()), v2.getZ())
      };

    } else if (order == RotationOrder.ZYX) {

      // r (Vector3D.plusI) coordinates are :
      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
      // (-r) (Vector3D.plusK) coordinates are :
      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(v1.getY(), v1.getX()),
       -FastMath.asin(v2.getX()),
        FastMath.atan2(v2.getY(), v2.getZ())
      };

    } else if (order == RotationOrder.XYX) {

      // r (Vector3D.plusI) coordinates are :
      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
      // and we can choose to have theta in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getY(), -v1.getZ()),
        FastMath.acos(v2.getX()),
        FastMath.atan2(v2.getY(), v2.getZ())
      };

    } else if (order == RotationOrder.XZX) {

      // r (Vector3D.plusI) coordinates are :
      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
      // and we can choose to have psi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getZ(), v1.getY()),
        FastMath.acos(v2.getX()),
        FastMath.atan2(v2.getZ(), -v2.getY())
      };

    } else if (order == RotationOrder.YXY) {

      // r (Vector3D.plusJ) coordinates are :
      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
      // and we can choose to have phi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getX(), v1.getZ()),
        FastMath.acos(v2.getY()),
        FastMath.atan2(v2.getX(), -v2.getZ())
      };

    } else if (order == RotationOrder.YZY) {

      // r (Vector3D.plusJ) coordinates are :
      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
      // and we can choose to have psi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getZ(), -v1.getX()),
        FastMath.acos(v2.getY()),
        FastMath.atan2(v2.getZ(), v2.getX())
      };

    } else if (order == RotationOrder.ZXZ) {

      // r (Vector3D.plusK) coordinates are :
      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
      // (-r) (Vector3D.plusK) coordinates are :
      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
      // and we can choose to have phi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getX(), -v1.getY()),
        FastMath.acos(v2.getZ()),
        FastMath.atan2(v2.getX(), v2.getY())
      };

    } else { // last possibility is ZYZ

      // r (Vector3D.plusK) coordinates are :
      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
      // (-r) (Vector3D.plusK) coordinates are :
      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
      // and we can choose to have theta in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getY(), v1.getX()),
        FastMath.acos(v2.getZ()),
        FastMath.atan2(v2.getY(), -v2.getX())
      };

    }

  }","public double[] getAngles(RotationOrder order)
    throws CardanEulerSingularityException {

    if (order == RotationOrder.XYZ) {

      // r (Vector3D.plusK) coordinates are :
      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)
      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(-(v1.getY()), v1.getZ()),
        FastMath.asin(v2.getZ()),
        FastMath.atan2(-(v2.getY()), v2.getX())
      };

    } else if (order == RotationOrder.XZY) {

      // r (Vector3D.plusJ) coordinates are :
      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)
      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(v1.getZ(), v1.getY()),
       -FastMath.asin(v2.getY()),
        FastMath.atan2(v2.getZ(), v2.getX())
      };

    } else if (order == RotationOrder.YXZ) {

      // r (Vector3D.plusK) coordinates are :
      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)
      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(v1.getX(), v1.getZ()),
       -FastMath.asin(v2.getZ()),
        FastMath.atan2(v2.getX(), v2.getY())
      };

    } else if (order == RotationOrder.YZX) {

      // r (Vector3D.plusI) coordinates are :
      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)
      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(-(v1.getZ()), v1.getX()),
        FastMath.asin(v2.getX()),
        FastMath.atan2(-(v2.getZ()), v2.getY())
      };

    } else if (order == RotationOrder.ZXY) {

      // r (Vector3D.plusJ) coordinates are :
      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)
      // (-r) (Vector3D.plusK) coordinates are :
      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)
      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(-(v1.getX()), v1.getY()),
        FastMath.asin(v2.getY()),
        FastMath.atan2(-(v2.getX()), v2.getZ())
      };

    } else if (order == RotationOrder.ZYX) {

      // r (Vector3D.plusI) coordinates are :
      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)
      // (-r) (Vector3D.plusK) coordinates are :
      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)
      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(true);
      }
      return new double[] {
        FastMath.atan2(v1.getY(), v1.getX()),
       -FastMath.asin(v2.getX()),
        FastMath.atan2(v2.getY(), v2.getZ())
      };

    } else if (order == RotationOrder.XYX) {

      // r (Vector3D.plusI) coordinates are :
      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)
      // and we can choose to have theta in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getY(), -v1.getZ()),
        FastMath.acos(v2.getX()),
        FastMath.atan2(v2.getY(), v2.getZ())
      };

    } else if (order == RotationOrder.XZX) {

      // r (Vector3D.plusI) coordinates are :
      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)
      // (-r) (Vector3D.plusI) coordinates are :
      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)
      // and we can choose to have psi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_I);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);
      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getZ(), v1.getY()),
        FastMath.acos(v2.getX()),
        FastMath.atan2(v2.getZ(), -v2.getY())
      };

    } else if (order == RotationOrder.YXY) {

      // r (Vector3D.plusJ) coordinates are :
      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)
      // and we can choose to have phi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getX(), v1.getZ()),
        FastMath.acos(v2.getY()),
        FastMath.atan2(v2.getX(), -v2.getZ())
      };

    } else if (order == RotationOrder.YZY) {

      // r (Vector3D.plusJ) coordinates are :
      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)
      // (-r) (Vector3D.plusJ) coordinates are :
      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)
      // and we can choose to have psi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_J);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);
      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getZ(), -v1.getX()),
        FastMath.acos(v2.getY()),
        FastMath.atan2(v2.getZ(), v2.getX())
      };

    } else if (order == RotationOrder.ZXZ) {

      // r (Vector3D.plusK) coordinates are :
      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)
      // (-r) (Vector3D.plusK) coordinates are :
      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)
      // and we can choose to have phi in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getX(), -v1.getY()),
        FastMath.acos(v2.getZ()),
        FastMath.atan2(v2.getX(), v2.getY())
      };

    } else { // last possibility is ZYZ

      // r (Vector3D.plusK) coordinates are :
      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)
      // (-r) (Vector3D.plusK) coordinates are :
      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)
      // and we can choose to have theta in the interval [0 ; PI]
      Vector3D v1 = applyTo(Vector3D.PLUS_K);
      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);
      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {
        throw new CardanEulerSingularityException(false);
      }
      return new double[] {
        FastMath.atan2(v1.getY(), v1.getX()),
        FastMath.acos(v2.getZ()),
        FastMath.atan2(v2.getY(), -v2.getX())
      };

    }

  }",0,[0]
28811,bugs-dot-jar_WICKET-3719_5ad32df9,"public final void replace(final int index, final MarkupElement elem)
	{
		Args.notNull(elem, ""elem"");

		if ((index < 0) || (index >= size()))
		{
			throw new IndexOutOfBoundsException(""'index' must be smaller than size(). Index:"" +
				index + ""; size:"" + size());
		}

		markupElements.set(index, elem);
	}","public final void replace(final int index, final MarkupElement elem)
	{
		Args.notNull(elem, ""elem"");

		if ((index < 0) || (index >= size()))
		{
			throw new IndexOutOfBoundsException(""'index' must be smaller than size(). Index:"" +
				index + ""; size:"" + size());
		}

		markupElements.set(index, elem);
	}",0,[0]
33497,bugs-dot-jar_OAK-4066_9a109aa3,"public void recordTextExtractionStats(long timeInMillis, long bytesRead, int textLength) {
        textExtractionStats.addStats(timeInMillis, bytesRead, textLength);
    }","public void recordTextExtractionStats(long timeInMillis, long bytesRead, int textLength) {
        textExtractionStats.addStats(timeInMillis, bytesRead, textLength);
    }",0,[0]
2977,bugs-dot-jar_OAK-3733_a5ff019e,"@Nonnull
    Revision getRevision() {
        return revision;
    }","@Nonnull
    Revision getRevision() {
        return revision;
    }",0,[0]
2752,bugs-dot-jar_OAK-1932_913c2f53,"@Override
    public void gc() {
        compactionThread.trigger();
    }","@Override
    public void gc() {
        compactionThread.trigger();
    }",0,[0]
32874,bugs-dot-jar_WICKET-4038_f3d7565c,"public IRequestHandler mapRequest(Request request)
	{
		UrlInfo urlInfo = parseRequest(request);

		// check if the URL is long enough and starts with the proper segments
		if (urlInfo != null)
		{
			PageComponentInfo info = urlInfo.getPageComponentInfo();
			Class<? extends IRequestablePage> pageClass = urlInfo.getPageClass();
			PageParameters pageParameters = urlInfo.getPageParameters();

			if (info == null || info.getPageInfo().getPageId() == null)
			{
				// if there are is no page instance information (only page map name - optionally)
				// then this is a simple bookmarkable URL
				return processBookmarkable(pageClass, pageParameters);
			}
			else if (info.getPageInfo().getPageId() != null && info.getComponentInfo() == null)
			{
				// if there is page instance information in the URL but no component and listener
				// interface then this is a hybrid URL - we need to try to reuse existing page
				// instance
				return processHybrid(info.getPageInfo(), pageClass, pageParameters, null);
			}
			else if (info.getComponentInfo() != null)
			{
				// with both page instance and component+listener this is a listener interface URL
				return processListener(info, pageClass, pageParameters);
			}
		}
		return null;
	}","public IRequestHandler mapRequest(Request request)
	{
		UrlInfo urlInfo = parseRequest(request);

		// check if the URL is long enough and starts with the proper segments
		if (urlInfo != null)
		{
			PageComponentInfo info = urlInfo.getPageComponentInfo();
			Class<? extends IRequestablePage> pageClass = urlInfo.getPageClass();
			PageParameters pageParameters = urlInfo.getPageParameters();

			if (info == null || info.getPageInfo().getPageId() == null)
			{
				// if there are is no page instance information (only page map name - optionally)
				// then this is a simple bookmarkable URL
				return processBookmarkable(pageClass, pageParameters);
			}
			else if (info.getPageInfo().getPageId() != null && info.getComponentInfo() == null)
			{
				// if there is page instance information in the URL but no component and listener
				// interface then this is a hybrid URL - we need to try to reuse existing page
				// instance
				return processHybrid(info.getPageInfo(), pageClass, pageParameters, null);
			}
			else if (info.getComponentInfo() != null)
			{
				// with both page instance and component+listener this is a listener interface URL
				return processListener(info, pageClass, pageParameters);
			}
		}
		return null;
	}",0,[0]
35420,bugs-dot-jar_WICKET-4505_a4caaa57,"@Override
	public void parse(final InputStream in) throws IOException, ResourceStreamNotFoundException
	{
		// When XML declaration does not specify encoding, it defaults to UTF-8
		parse(in, ""UTF-8"");
	}","@Override
	public void parse(final InputStream in) throws IOException, ResourceStreamNotFoundException
	{
		// When XML declaration does not specify encoding, it defaults to UTF-8
		parse(in, ""UTF-8"");
	}",0,[0]
15288,bugs-dot-jar_FLINK-3314_8fc7e7af,protected abstract void run() throws Exception;,protected abstract void run() throws Exception;,0,[0]
40775,bugs-dot-jar_OAK-3424_f4349a96,"public void performLeaseCheck() {
        if (leaseCheckDisabled || !renewed) {
            // if leaseCheckDisabled is set we never do the check, so return fast

            // the 'renewed' flag indicates if this instance *ever* renewed the lease after startup
            // until that is not set, we cannot do the lease check (otherwise startup wouldn't work)
            return;
        }
        if (leaseCheckFailed) {
            // unsynchronized access to leaseCheckFailed is fine
            // since it only ever changes from false to true once
            // and should the current thread read it erroneously
            // as false here, it would further down find out that
            // the lease has indeed still expired and then
            // go into the synchronized.
            // (note that once a lease check failed it would not
            // be updated again, ever, as guaranteed by checking
            // for leaseCheckFailed in renewLease() )
            LOG.error(LEASE_CHECK_FAILED_MSG);
            throw new AssertionError(LEASE_CHECK_FAILED_MSG);
        }
        long now = getCurrentTime();
        // OAK-3238 put the barrier 1/3 of 60sec=20sec before the end
        // OAK-3398 keeps this the same but uses an explicit leaseFailureMargin for this
        if (now < (leaseEndTime - leaseFailureMargin)) {
            // then all is good
            return;
        }
        // synchronized: we need to guard leaseCheckFailed in order to ensure
        //               that it is only set by 1 thread - thus handleLeaseFailure
        //               is guaranteed to be only called once
        synchronized(this) {
            if (leaseCheckFailed) {
                // someone else won and marked leaseCheckFailed - so we only log/throw
                LOG.error(LEASE_CHECK_FAILED_MSG);
                throw new AssertionError(LEASE_CHECK_FAILED_MSG);
            }
            for(int i=0; i<MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE; i++) {
                now = getCurrentTime();
                if (now < (leaseEndTime - leaseFailureMargin)) {
                    // if lease is OK here, then there was a race
                    // between performLeaseCheck and renewLease()
                    // where the winner was: renewLease().
                    // so: luckily we can continue here
                    return;
                }
                // OAK-3399 : in case of running into the leaseFailureMargin
                // (shortly, 20sec, before the lease times out), we're now doing
                // a short retry loop of 1sec sleeps (default 5x1sec=5sec),
                // to give this instance 'one last chance' before we have to
                // declare the lease as failed.
                // This sort of retry loop would allow situations such as
                // when running a single-node cluster and interrupting/pausing
                // the process temporarily: in this case when waking up, the
                // lease might momentarily be timed out, but the lease would
                // still be 'updateable' and that would happen pretty soon
                // after waking up. So in that case, doing these retry-sleeps
                // would help.
                // in most other cases where the local instance is not doing
                // lease updates due to 'GC-death' or 'lease-thread-crashed'
                // or the like, it would not help. But it would also not hurt
                // as the margin is 20sec and we're just reducing it by 5sec
                // (in the un-paused case)
                try {
                    LOG.info(""performLeaseCheck: lease within ""+leaseFailureMargin+
                            ""ms of failing (""+(leaseEndTime-now)+"" ms precisely) - ""
                            + ""waiting 1sec to retry (up to another ""+
                            (MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE-1-i)+"" times)..."");
                    wait(1000); // directly use this to sleep on - to allow renewLease() to work
                } catch (InterruptedException e) {
                    LOG.warn(""performLeaseCheck: got interrupted - giving up: ""+e, e);
                    break;
                }
            }
            leaseCheckFailed = true; // make sure only one thread 'wins', ie goes any further
        }

        final String errorMsg = LEASE_CHECK_FAILED_MSG+"" (leaseEndTime: ""+leaseEndTime+
                "", leaseTime: ""+leaseTime+
                "", leaseFailureMargin: ""+leaseFailureMargin+
                "", lease check end time (leaseEndTime-leaseFailureMargin): ""+(leaseEndTime - leaseFailureMargin)+
                "", now: ""+now+
                "", remaining: ""+((leaseEndTime - leaseFailureMargin) - now)+
                "") Need to stop oak-core/DocumentNodeStoreService."";
        LOG.error(errorMsg);

        handleLeaseFailure(errorMsg);
    }","public void performLeaseCheck() {
        if (leaseCheckDisabled || !renewed) {
            // if leaseCheckDisabled is set we never do the check, so return fast

            // the 'renewed' flag indicates if this instance *ever* renewed the lease after startup
            // until that is not set, we cannot do the lease check (otherwise startup wouldn't work)
            return;
        }
        if (leaseCheckFailed) {
            // unsynchronized access to leaseCheckFailed is fine
            // since it only ever changes from false to true once
            // and should the current thread read it erroneously
            // as false here, it would further down find out that
            // the lease has indeed still expired and then
            // go into the synchronized.
            // (note that once a lease check failed it would not
            // be updated again, ever, as guaranteed by checking
            // for leaseCheckFailed in renewLease() )
            LOG.error(LEASE_CHECK_FAILED_MSG);
            throw new AssertionError(LEASE_CHECK_FAILED_MSG);
        }
        long now = getCurrentTime();
        // OAK-3238 put the barrier 1/3 of 60sec=20sec before the end
        // OAK-3398 keeps this the same but uses an explicit leaseFailureMargin for this
        if (now < (leaseEndTime - leaseFailureMargin)) {
            // then all is good
            return;
        }
        // synchronized: we need to guard leaseCheckFailed in order to ensure
        //               that it is only set by 1 thread - thus handleLeaseFailure
        //               is guaranteed to be only called once
        synchronized(this) {
            if (leaseCheckFailed) {
                // someone else won and marked leaseCheckFailed - so we only log/throw
                LOG.error(LEASE_CHECK_FAILED_MSG);
                throw new AssertionError(LEASE_CHECK_FAILED_MSG);
            }
            for(int i=0; i<MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE; i++) {
                now = getCurrentTime();
                if (now < (leaseEndTime - leaseFailureMargin)) {
                    // if lease is OK here, then there was a race
                    // between performLeaseCheck and renewLease()
                    // where the winner was: renewLease().
                    // so: luckily we can continue here
                    return;
                }
                // OAK-3399 : in case of running into the leaseFailureMargin
                // (shortly, 20sec, before the lease times out), we're now doing
                // a short retry loop of 1sec sleeps (default 5x1sec=5sec),
                // to give this instance 'one last chance' before we have to
                // declare the lease as failed.
                // This sort of retry loop would allow situations such as
                // when running a single-node cluster and interrupting/pausing
                // the process temporarily: in this case when waking up, the
                // lease might momentarily be timed out, but the lease would
                // still be 'updateable' and that would happen pretty soon
                // after waking up. So in that case, doing these retry-sleeps
                // would help.
                // in most other cases where the local instance is not doing
                // lease updates due to 'GC-death' or 'lease-thread-crashed'
                // or the like, it would not help. But it would also not hurt
                // as the margin is 20sec and we're just reducing it by 5sec
                // (in the un-paused case)
                try {
                    LOG.info(""performLeaseCheck: lease within ""+leaseFailureMargin+
                            ""ms of failing (""+(leaseEndTime-now)+"" ms precisely) - ""
                            + ""waiting 1sec to retry (up to another ""+
                            (MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE-1-i)+"" times)..."");
                    wait(1000); // directly use this to sleep on - to allow renewLease() to work
                } catch (InterruptedException e) {
                    LOG.warn(""performLeaseCheck: got interrupted - giving up: ""+e, e);
                    break;
                }
            }
            leaseCheckFailed = true; // make sure only one thread 'wins', ie goes any further
        }

        final String errorMsg = LEASE_CHECK_FAILED_MSG+"" (leaseEndTime: ""+leaseEndTime+
                "", leaseTime: ""+leaseTime+
                "", leaseFailureMargin: ""+leaseFailureMargin+
                "", lease check end time (leaseEndTime-leaseFailureMargin): ""+(leaseEndTime - leaseFailureMargin)+
                "", now: ""+now+
                "", remaining: ""+((leaseEndTime - leaseFailureMargin) - now)+
                "") Need to stop oak-core/DocumentNodeStoreService."";
        LOG.error(errorMsg);

        handleLeaseFailure(errorMsg);
    }",0,[0]
28558,bugs-dot-jar_OAK-2740_429baf4d,"static Context getInstance() {
        return INSTANCE;
    }","static Context getInstance() {
        return INSTANCE;
    }",0,[0]
20837,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Deprecated
    public static String toString(byte[] data) throws IOException {
        return toString(data, null);
    }","@Deprecated
    public static String toString(byte[] data) throws IOException {
        return toString(data, null);
    }",0,[0]
4078,bugs-dot-jar_WICKET-3620_1a2bc1bc,"private void respondComponents(Response response)
	{
		// TODO: We might need to call prepareRender on all components upfront

		// process component markup
		for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet())
		{
			final Component component = stringComponentEntry.getValue();
			// final String markupId = stringComponentEntry.getKey();

			if (!containsAncestorFor(component))
			{
				respondComponent(response, getAjaxRegionMarkupId(component), component);
			}
		}

		if (header != null)
		{
			// some header responses buffer all calls to render*** until close is called.
			// when they are closed, they do something (i.e. aggregate all JS resource urls to a
			// single url), and then ""flush"" (by writing to the real response) before closing.
			// to support this, we need to allow header contributions to be written in the close
			// tag, which we do here:
			headerRendering = true;
			// save old response, set new
			Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);
			encodingHeaderResponse.reset();

			// now, close the response (which may render things)
			header.getHeaderResponse().close();

			// revert to old response
			RequestCycle.get().setResponse(oldResponse);

			// write the XML tags and we're done
			writeHeaderContribution(response);
			headerRendering = false;
		}
	}","private void respondComponents(Response response)
	{
		// TODO: We might need to call prepareRender on all components upfront

		// process component markup
		for (Map.Entry<String, Component> stringComponentEntry : markupIdToComponent.entrySet())
		{
			final Component component = stringComponentEntry.getValue();
			// final String markupId = stringComponentEntry.getKey();

			if (!containsAncestorFor(component))
			{
				respondComponent(response, getAjaxRegionMarkupId(component), component);
			}
		}

		if (header != null)
		{
			// some header responses buffer all calls to render*** until close is called.
			// when they are closed, they do something (i.e. aggregate all JS resource urls to a
			// single url), and then ""flush"" (by writing to the real response) before closing.
			// to support this, we need to allow header contributions to be written in the close
			// tag, which we do here:
			headerRendering = true;
			// save old response, set new
			Response oldResponse = RequestCycle.get().setResponse(encodingHeaderResponse);
			encodingHeaderResponse.reset();

			// now, close the response (which may render things)
			header.getHeaderResponse().close();

			// revert to old response
			RequestCycle.get().setResponse(oldResponse);

			// write the XML tags and we're done
			writeHeaderContribution(response);
			headerRendering = false;
		}
	}",0,[0]
39223,bugs-dot-jar_OAK-4353_b0014b7d,"public int readerCount(){
        fileStoreLock.readLock().lock();
        try {
            return readers.size();
        } finally {
            fileStoreLock.readLock().unlock();
        }
    }","public int readerCount(){
        fileStoreLock.readLock().lock();
        try {
            return readers.size();
        } finally {
            fileStoreLock.readLock().unlock();
        }
    }",0,[0]
3256,bugs-dot-jar_CAMEL-5699_6d63a502,"public boolean isShowBodyType() {
        return showBodyType;
    }","public boolean isShowBodyType() {
        return showBodyType;
    }",0,[0]
3830,bugs-dot-jar_ACCUMULO-1544_0cf2ff72,"public Set<Pair<ServerType,Integer>> getDebugPorts() {
    return debugPorts;
  }","public Set<Pair<ServerType,Integer>> getDebugPorts() {
    return debugPorts;
  }",0,[0]
34932,bugs-dot-jar_CAMEL-5570_a57830ed,"public void setRedeliveryPolicyRef(String redeliveryPolicyRef) {
        this.redeliveryPolicyRef = redeliveryPolicyRef;
    }","public void setRedeliveryPolicyRef(String redeliveryPolicyRef) {
        this.redeliveryPolicyRef = redeliveryPolicyRef;
    }",0,[0]
20935,bugs-dot-jar_WICKET-5784_b6259e5f,"@Override
	public long getRequestsPerMinute()
	{
		synchronized (requestWindow)
		{
			int windowSize = getWindowSize();
			if (windowSize == 0)
				return 0;
			long start = startTimeOfOldestRequest.getTime();
			long end = System.currentTimeMillis();
			double diff = end - start;
			return Math.round(windowSize / (diff / 60000.0));
		}
	}","@Override
	public long getRequestsPerMinute()
	{
		synchronized (requestWindow)
		{
			int windowSize = getWindowSize();
			if (windowSize == 0)
				return 0;
			long start = startTimeOfOldestRequest.getTime();
			long end = System.currentTimeMillis();
			double diff = end - start;
			return Math.round(windowSize / (diff / 60000.0));
		}
	}",0,[0]
38496,bugs-dot-jar_CAMEL-9124_9da2c05a,"public RedeliveryPolicyDefinition logContinued(boolean logContinued) {
        return logContinued(Boolean.toString(logContinued));
    }","public RedeliveryPolicyDefinition logContinued(boolean logContinued) {
        return logContinued(Boolean.toString(logContinued));
    }",0,[0]
28808,bugs-dot-jar_WICKET-3719_5ad32df9,"public Markup(final MarkupResourceStream markupResourceStream)
	{
		if (markupResourceStream == null)
		{
			throw new IllegalArgumentException(""Parameter 'markupResourceStream' must not be null"");
		}

		this.markupResourceStream = markupResourceStream;
		markupElements = new ArrayList<MarkupElement>();
	}","public Markup(final MarkupResourceStream markupResourceStream)
	{
		if (markupResourceStream == null)
		{
			throw new IllegalArgumentException(""Parameter 'markupResourceStream' must not be null"");
		}

		this.markupResourceStream = markupResourceStream;
		markupElements = new ArrayList<MarkupElement>();
	}",0,[0]
1220,bugs-dot-jar_WICKET-5546_f1af9e03,"protected void detachModel()
	{
		IModel<?> model = getModelImpl();
		if (model != null)
		{
			model.detach();
		}
		// also detach the wrapped model of a component assigned wrap (not
		// inherited)
		if (model instanceof IWrapModel && !getFlag(FLAG_INHERITABLE_MODEL))
		{
			((IWrapModel<?>)model).getWrappedModel().detach();
		}
	}","protected void detachModel()
	{
		IModel<?> model = getModelImpl();
		if (model != null)
		{
			model.detach();
		}
		// also detach the wrapped model of a component assigned wrap (not
		// inherited)
		if (model instanceof IWrapModel && !getFlag(FLAG_INHERITABLE_MODEL))
		{
			((IWrapModel<?>)model).getWrappedModel().detach();
		}
	}",0,[0]
30171,bugs-dot-jar_WICKET-4345_4f08e6f2,"private Url encryptUrl(final Url url)
	{
		if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty())
		{
			return url;
		}
		String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());

		Url encryptedUrl = new Url(url.getCharset());
		encryptedUrl.getSegments().add(encryptedUrlString);

		int numberOfSegments = url.getSegments().size();
		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
		for (int segNo = 0; segNo < numberOfSegments; segNo++)
		{
			encryptedUrl.getSegments().add(generator.next());
		}
		return encryptedUrl;
	}","private Url encryptUrl(final Url url)
	{
		if (url.getSegments().isEmpty() && url.getQueryParameters().isEmpty())
		{
			return url;
		}
		String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());

		Url encryptedUrl = new Url(url.getCharset());
		encryptedUrl.getSegments().add(encryptedUrlString);

		int numberOfSegments = url.getSegments().size();
		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
		for (int segNo = 0; segNo < numberOfSegments; segNo++)
		{
			encryptedUrl.getSegments().add(generator.next());
		}
		return encryptedUrl;
	}",0,[0]
31309,bugs-dot-jar_MNG-4695_bb39b480,"public void validateEffectiveModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        validateStringNotEmpty( ""modelVersion"", problems, Severity.ERROR, model.getModelVersion(), model );

        validateId( ""groupId"", problems, model.getGroupId(), model );

        validateId( ""artifactId"", problems, model.getArtifactId(), model );

        validateStringNotEmpty( ""packaging"", problems, Severity.ERROR, model.getPackaging(), model );

        if ( !model.getModules().isEmpty() )
        {
            if ( !""pom"".equals( model.getPackaging() ) )
            {
                addViolation( problems, Severity.ERROR, ""packaging"", null, ""with value '"" + model.getPackaging()
                    + ""' is invalid. Aggregator projects "" + ""require 'pom' as packaging."", model );
            }

            for ( int i = 0, n = model.getModules().size(); i < n; i++ )
            {
                String module = model.getModules().get( i );
                if ( StringUtils.isBlank( module ) )
                {
                    addViolation( problems, Severity.WARNING, ""modules.module["" + i + ""]"", null,
                                  ""has been specified without a path to the project directory."",
                                  model.getLocation( ""modules"" ) );
                }
            }
        }

        validateStringNotEmpty( ""version"", problems, Severity.ERROR, model.getVersion(), model );

        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

        validateEffectiveDependencies( problems, model.getDependencies(), false, request );

        DependencyManagement mgmt = model.getDependencyManagement();
        if ( mgmt != null )
        {
            validateEffectiveDependencies( problems, mgmt.getDependencies(), true, request );
        }

        if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            Set<String> modules = new HashSet<String>();
            for ( int i = 0, n = model.getModules().size(); i < n; i++ )
            {
                String module = model.getModules().get( i );
                if ( !modules.add( module ) )
                {
                    addViolation( problems, Severity.ERROR, ""modules.module["" + i + ""]"", null,
                                  ""specifies duplicate child module "" + module, model.getLocation( ""modules"" ) );
                }
            }

            Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );

            Build build = model.getBuild();
            if ( build != null )
            {
                for ( Plugin p : build.getPlugins() )
                {
                    validateStringNotEmpty( ""build.plugins.plugin.artifactId"", problems, Severity.ERROR,
                                            p.getArtifactId(), p );

                    validateStringNotEmpty( ""build.plugins.plugin.groupId"", problems, Severity.ERROR, p.getGroupId(), p );

                    validatePluginVersion( ""build.plugins.plugin.version"", problems, p.getVersion(), p.getKey(), p,
                                           request );

                    validateBoolean( ""build.plugins.plugin.inherited"", problems, errOn30, p.getInherited(), p.getKey(),
                                     p );

                    validateBoolean( ""build.plugins.plugin.extensions"", problems, errOn30, p.getExtensions(),
                                     p.getKey(), p );

                    validateEffectivePluginDependencies( problems, p, request );
                }

                validateResources( problems, build.getResources(), ""build.resources.resource"", request );

                validateResources( problems, build.getTestResources(), ""build.testResources.testResource"", request );
            }

            Reporting reporting = model.getReporting();
            if ( reporting != null )
            {
                for ( ReportPlugin p : reporting.getPlugins() )
                {
                    validateStringNotEmpty( ""reporting.plugins.plugin.artifactId"", problems, Severity.ERROR,
                                            p.getArtifactId(), p );

                    validateStringNotEmpty( ""reporting.plugins.plugin.groupId"", problems, Severity.ERROR,
                                            p.getGroupId(), p );

                    validateStringNotEmpty( ""reporting.plugins.plugin.version"", problems, errOn31, p.getVersion(),
                                            p.getKey(), p );
                }
            }

            for ( Repository repository : model.getRepositories() )
            {
                validateRepository( problems, repository, ""repositories.repository"", request );
            }

            for ( Repository repository : model.getPluginRepositories() )
            {
                validateRepository( problems, repository, ""pluginRepositories.pluginRepository"", request );
            }

            DistributionManagement distMgmt = model.getDistributionManagement();
            if ( distMgmt != null )
            {
                if ( distMgmt.getStatus() != null )
                {
                    addViolation( problems, Severity.ERROR, ""distributionManagement.status"", null,
                                  ""must not be specified."", distMgmt );
                }

                validateRepository( problems, distMgmt.getRepository(), ""distributionManagement.repository"", request );
                validateRepository( problems, distMgmt.getSnapshotRepository(),
                                    ""distributionManagement.snapshotRepository"", request );
            }
        }
    }","public void validateEffectiveModel( Model model, ModelBuildingRequest request, ModelProblemCollector problems )
    {
        validateStringNotEmpty( ""modelVersion"", problems, Severity.ERROR, model.getModelVersion(), model );

        validateId( ""groupId"", problems, model.getGroupId(), model );

        validateId( ""artifactId"", problems, model.getArtifactId(), model );

        validateStringNotEmpty( ""packaging"", problems, Severity.ERROR, model.getPackaging(), model );

        if ( !model.getModules().isEmpty() )
        {
            if ( !""pom"".equals( model.getPackaging() ) )
            {
                addViolation( problems, Severity.ERROR, ""packaging"", null, ""with value '"" + model.getPackaging()
                    + ""' is invalid. Aggregator projects "" + ""require 'pom' as packaging."", model );
            }

            for ( int i = 0, n = model.getModules().size(); i < n; i++ )
            {
                String module = model.getModules().get( i );
                if ( StringUtils.isBlank( module ) )
                {
                    addViolation( problems, Severity.WARNING, ""modules.module["" + i + ""]"", null,
                                  ""has been specified without a path to the project directory."",
                                  model.getLocation( ""modules"" ) );
                }
            }
        }

        validateStringNotEmpty( ""version"", problems, Severity.ERROR, model.getVersion(), model );

        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

        validateEffectiveDependencies( problems, model.getDependencies(), false, request );

        DependencyManagement mgmt = model.getDependencyManagement();
        if ( mgmt != null )
        {
            validateEffectiveDependencies( problems, mgmt.getDependencies(), true, request );
        }

        if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )
        {
            Set<String> modules = new HashSet<String>();
            for ( int i = 0, n = model.getModules().size(); i < n; i++ )
            {
                String module = model.getModules().get( i );
                if ( !modules.add( module ) )
                {
                    addViolation( problems, Severity.ERROR, ""modules.module["" + i + ""]"", null,
                                  ""specifies duplicate child module "" + module, model.getLocation( ""modules"" ) );
                }
            }

            Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );

            Build build = model.getBuild();
            if ( build != null )
            {
                for ( Plugin p : build.getPlugins() )
                {
                    validateStringNotEmpty( ""build.plugins.plugin.artifactId"", problems, Severity.ERROR,
                                            p.getArtifactId(), p );

                    validateStringNotEmpty( ""build.plugins.plugin.groupId"", problems, Severity.ERROR, p.getGroupId(), p );

                    validatePluginVersion( ""build.plugins.plugin.version"", problems, p.getVersion(), p.getKey(), p,
                                           request );

                    validateBoolean( ""build.plugins.plugin.inherited"", problems, errOn30, p.getInherited(), p.getKey(),
                                     p );

                    validateBoolean( ""build.plugins.plugin.extensions"", problems, errOn30, p.getExtensions(),
                                     p.getKey(), p );

                    validateEffectivePluginDependencies( problems, p, request );
                }

                validateResources( problems, build.getResources(), ""build.resources.resource"", request );

                validateResources( problems, build.getTestResources(), ""build.testResources.testResource"", request );
            }

            Reporting reporting = model.getReporting();
            if ( reporting != null )
            {
                for ( ReportPlugin p : reporting.getPlugins() )
                {
                    validateStringNotEmpty( ""reporting.plugins.plugin.artifactId"", problems, Severity.ERROR,
                                            p.getArtifactId(), p );

                    validateStringNotEmpty( ""reporting.plugins.plugin.groupId"", problems, Severity.ERROR,
                                            p.getGroupId(), p );

                    validateStringNotEmpty( ""reporting.plugins.plugin.version"", problems, errOn31, p.getVersion(),
                                            p.getKey(), p );
                }
            }

            for ( Repository repository : model.getRepositories() )
            {
                validateRepository( problems, repository, ""repositories.repository"", request );
            }

            for ( Repository repository : model.getPluginRepositories() )
            {
                validateRepository( problems, repository, ""pluginRepositories.pluginRepository"", request );
            }

            DistributionManagement distMgmt = model.getDistributionManagement();
            if ( distMgmt != null )
            {
                if ( distMgmt.getStatus() != null )
                {
                    addViolation( problems, Severity.ERROR, ""distributionManagement.status"", null,
                                  ""must not be specified."", distMgmt );
                }

                validateRepository( problems, distMgmt.getRepository(), ""distributionManagement.repository"", request );
                validateRepository( problems, distMgmt.getSnapshotRepository(),
                                    ""distributionManagement.snapshotRepository"", request );
            }
        }
    }",0,[0]
1204,Bears-152,"private boolean isRunning() {
        Collection<Channel> channels = getChannels();
        for (Channel channel : channels) {
            if (DefaultFuture.hasFuture(channel)) {
                return true;
            }
        }
        return false;
    }","private boolean isRunning() {
        Collection<Channel> channels = getChannels();
        for (Channel channel : channels) {

            /**
             *  If there are any client connections,
             *  our server should be running.
             */

            if (channel.isConnected()) {
                return true;
            }
        }
        return false;
    }",1,[3]
9416,bugs-dot-jar_ACCUMULO-2857_9fcca2ed,"@Override
  public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {
    if (!exists(tableName))
      throw new TableNotFoundException(tableName, tableName, """");
    return acu.tables.get(tableName).getLocalityGroups();
  }","@Override
  public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {
    if (!exists(tableName))
      throw new TableNotFoundException(tableName, tableName, """");
    return acu.tables.get(tableName).getLocalityGroups();
  }",0,[0]
33346,bugs-dot-jar_LOG4J2-639_a5a1f1a2,"private static StackTraceElement location(final String fqcnOfLogger) {
        return Log4jLogEvent.calcLocation(fqcnOfLogger);
    }","private static StackTraceElement location(final String fqcnOfLogger) {
        return Log4jLogEvent.calcLocation(fqcnOfLogger);
    }",0,[0]
7401,bugs-dot-jar_OAK-1369_ce0b0955,"private Expression parsePropertyOrFunction() throws ParseException {
        StringBuilder buff = new StringBuilder();
        boolean isPath = false;
        while (true) {
            if (currentTokenType == IDENTIFIER) {
                String name = readPathSegment();
                buff.append(name);
            } else if (readIf(""*"")) {
                // any node
                buff.append('*');
                isPath = true;
            } else if (readIf(""."")) {
                buff.append('.');
                if (readIf(""."")) {
                    buff.append('.');
                }
                isPath = true;
            } else if (readIf(""@"")) {
                if (readIf(""*"")) {
                    // xpath supports @*, even thought jackrabbit may not
                    buff.append('*');
                } else {
                    buff.append(readPathSegment());
                }
                return new Expression.Property(currentSelector, buff.toString(), false);
            } else {
                break;
            }
            if (readIf(""/"")) {
                isPath = true;
                buff.append('/');
            } else {
                break;
            }
        }
        if (!isPath && readIf(""("")) {
            return parseFunction(buff.toString());
        } else if (buff.length() > 0) {
            // path without all attributes, as in:
            // jcr:contains(jcr:content, 'x')
            if (buff.toString().equals(""."")) {
                buff = new StringBuilder(""*"");
            } else {
                buff.append(""/*"");
            }
            return new Expression.Property(currentSelector, buff.toString(), true);
        }
        throw getSyntaxError();
    }","private Expression parsePropertyOrFunction() throws ParseException {
        StringBuilder buff = new StringBuilder();
        boolean isPath = false;
        while (true) {
            if (currentTokenType == IDENTIFIER) {
                String name = readPathSegment();
                buff.append(name);
            } else if (readIf(""*"")) {
                // any node
                buff.append('*');
                isPath = true;
            } else if (readIf(""."")) {
                buff.append('.');
                if (readIf(""."")) {
                    buff.append('.');
                }
                isPath = true;
            } else if (readIf(""@"")) {
                if (readIf(""*"")) {
                    // xpath supports @*, even thought jackrabbit may not
                    buff.append('*');
                } else {
                    buff.append(readPathSegment());
                }
                return new Expression.Property(currentSelector, buff.toString(), false);
            } else {
                break;
            }
            if (readIf(""/"")) {
                isPath = true;
                buff.append('/');
            } else {
                break;
            }
        }
        if (!isPath && readIf(""("")) {
            return parseFunction(buff.toString());
        } else if (buff.length() > 0) {
            // path without all attributes, as in:
            // jcr:contains(jcr:content, 'x')
            if (buff.toString().equals(""."")) {
                return new Expression.Property(currentSelector, ""*"", false);
            }
            return new Expression.Property(currentSelector, buff.toString(), true);
        }
        throw getSyntaxError();
    }",1,"[41, 42, 43]"
7474,bugs-dot-jar_WICKET-4030_5f69685d,"public void renderJavaScriptReference(ResourceReference reference, String id)
	{
		renderJavaScriptReference(reference, null, id);
	}","public void renderJavaScriptReference(ResourceReference reference, String id)
	{
		renderJavaScriptReference(reference, null, id);
	}",0,[0]
9080,bugs-dot-jar_CAMEL-4354_96e40c3c,"protected void doStart() throws Exception {
        ServiceHelper.startServices(pool, producers);
    }","protected void doStart() throws Exception {
        ServiceHelper.startServices(pool, producers);
    }",0,[0]
19352,bugs-dot-jar_OAK-2442_ea7a6199,"@Nonnull
    private NavigableMap<Revision, Range> createPreviousRanges(boolean includeStale) {
        NavigableMap<Revision, Range> ranges;
        Map<Revision, String> map = getLocalMap(PREVIOUS);
        if (map.isEmpty()) {
            ranges = EMPTY_RANGE_MAP;
        } else {
            Map<Revision, String> stale = Collections.emptyMap();
            if (!includeStale) {
                stale = getLocalMap(STALE_PREV);
            }
            NavigableMap<Revision, Range> transformed = new TreeMap<Revision, Range>(
                    StableRevisionComparator.REVERSE);
            for (Map.Entry<Revision, String> entry : map.entrySet()) {
                Range r = Range.fromEntry(entry.getKey(), entry.getValue());
                if (String.valueOf(r.height).equals(stale.get(r.high))) {
                    continue;
                }
                transformed.put(r.high, r);
            }
            ranges = Maps.unmodifiableNavigableMap(transformed);
        }
        return ranges;
    }","@Nonnull
    private NavigableMap<Revision, Range> createPreviousRanges(boolean includeStale) {
        NavigableMap<Revision, Range> ranges;
        Map<Revision, String> map = getLocalMap(PREVIOUS);
        if (map.isEmpty()) {
            ranges = EMPTY_RANGE_MAP;
        } else {
            Map<Revision, String> stale = Collections.emptyMap();
            if (!includeStale) {
                stale = getLocalMap(STALE_PREV);
            }
            NavigableMap<Revision, Range> transformed = new TreeMap<Revision, Range>(
                    StableRevisionComparator.REVERSE);
            for (Map.Entry<Revision, String> entry : map.entrySet()) {
                Range r = Range.fromEntry(entry.getKey(), entry.getValue());
                if (String.valueOf(r.height).equals(stale.get(r.high))) {
                    continue;
                }
                transformed.put(r.high, r);
            }
            ranges = Maps.unmodifiableNavigableMap(transformed);
        }
        return ranges;
    }",0,[0]
943,Bears-125,"private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {
        Parser parser = new Parser(PATTERN_ERI, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        LinkedList<Position> positions = new LinkedList<>();

        int power = parser.nextInt(0);

        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());
        while (itemParser.find()) {
            Position position = new Position();
            position.setProtocol(getProtocolName());
            position.setDeviceId(deviceSession.getDeviceId());

            decodeLocation(position, itemParser);

            positions.add(position);
        }

        Position position = positions.getLast();

        decodeLocation(position, parser);

        position.set(Position.KEY_POWER, power);
        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);
        position.set(Position.KEY_HOURS, parser.next());
        position.set(Position.PREFIX_ADC + 1, parser.next());
        position.set(Position.PREFIX_ADC + 2, parser.next());
        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());

        decodeStatus(position, parser);

        int index = 0;
        String[] data = parser.next().split("","");
        if (data.length > 1) {
            int deviceType = Integer.parseInt(data[index++]);
            if (deviceType == 2) {
                int deviceCount = Integer.parseInt(data[index++]);
                for (int i = 1; i <= deviceCount; i++) {
                    index++; // id
                    index++; // type
                    position.set(Position.PREFIX_TEMP + i, Short.parseShort(data[index++], 16) * 0.0625);
                }
            }
        }

        decodeDeviceTime(position, parser);

        return positions;
    }","private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {
        Parser parser = new Parser(PATTERN_ERI, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        LinkedList<Position> positions = new LinkedList<>();

        int power = parser.nextInt(0);

        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());
        while (itemParser.find()) {
            Position position = new Position();
            position.setProtocol(getProtocolName());
            position.setDeviceId(deviceSession.getDeviceId());

            decodeLocation(position, itemParser);

            positions.add(position);
        }

        Position position = positions.getLast();

        decodeLocation(position, parser);

        position.set(Position.KEY_POWER, power);
        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);
        position.set(Position.KEY_HOURS, parser.next());
        position.set(Position.PREFIX_ADC + 1, parser.next());
        position.set(Position.PREFIX_ADC + 2, parser.next());
        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());

        decodeStatus(position, parser);

        int index = 0;
        String[] data = parser.next().split("","");
        if (data.length > 1) {
            int deviceType = Integer.parseInt(data[index++]);
            if (deviceType == 2) {
                int deviceCount = Integer.parseInt(data[index++]);
                for (int i = 1; i <= deviceCount; i++) {
                    index++; // id
                    index++; // type
                    position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(data[index++], 16) * 0.0625);
                }
            }
        }

        decodeDeviceTime(position, parser);

        return positions;
    }",1,[48]
14928,bugs-dot-jar_CAMEL-5683_0c3c7d1b,"public Exchange receive(Endpoint endpoint, long timeout) {
        LOG.debug(""<<<< {}"", endpoint);

        PollingConsumer consumer = getConsumer(endpoint);
        return consumer.receive(timeout);
    }","public Exchange receive(Endpoint endpoint, long timeout) {
        LOG.debug(""<<<< {}"", endpoint);

        PollingConsumer consumer = getConsumer(endpoint);
        return consumer.receive(timeout);
    }",0,[0]
38677,bugs-dot-jar_ACCUMULO-2487_f2920c26,"public Value(byte[] bytes, boolean copy) {
    if (!copy) {
      this.value = bytes;
    } else {
      this.value = new byte[bytes.length];
      System.arraycopy(bytes, 0, this.value, 0, bytes.length);
    }
    
  }","public Value(byte[] bytes, boolean copy) {
    Preconditions.checkNotNull(bytes);
    if (!copy) {
      this.value = bytes;
    } else {
      this.value = new byte[bytes.length];
      System.arraycopy(bytes, 0, this.value, 0, bytes.length);
    }
    
  }",1,[]
16121,bugs-dot-jar_WICKET-4816_66bfc885,"public static boolean isEqual(final String string1, final String string2)
	{
		if ((string1 == null) && (string2 == null))
		{
			return true;
		}

		if (isEmpty(string1) && isEmpty(string2))
		{
			return true;
		}
		if ((string1 == null) || (string2 == null))
		{
			return false;
		}

		return string1.equals(string2);
	}","public static boolean isEqual(final String string1, final String string2)
	{
		if ((string1 == null) && (string2 == null))
		{
			return true;
		}

		if (isEmpty(string1) && isEmpty(string2))
		{
			return true;
		}
		if ((string1 == null) || (string2 == null))
		{
			return false;
		}

		return string1.equals(string2);
	}",0,[0]
35572,bugs-dot-jar_OAK-621_00b4b8a0,"@CheckForNull
    protected NodeState getBaseState() {
        if (isDisconnected()) {
            throw new IllegalStateException(""Cannot get the base state of a disconnected tree"");
        }

        NodeState parentBaseState = parent.getBaseState();
        return parentBaseState == null
                ? null
                : parentBaseState.getChildNode(name);
    }","@CheckForNull
    protected NodeState getBaseState() {
        if (isDisconnected()) {
            throw new IllegalStateException(""Cannot get the base state of a disconnected tree"");
        }

        NodeState parentBaseState = parent.getBaseState();
        return parentBaseState == null
                ? null
                : parentBaseState.getChildNode(name);
    }",0,[0]
35273,bugs-dot-jar_ACCUMULO-1732_941e3cb1,"protected static TabletLocator getTabletLocator(JobConf job, String tableId) throws TableNotFoundException {
    return InputConfigurator.getTabletLocator(CLASS, job, tableId);
  }","protected static TabletLocator getTabletLocator(JobConf job, String tableId) throws TableNotFoundException {
    return InputConfigurator.getTabletLocator(CLASS, job, tableId);
  }",0,[0]
13116,bugs-dot-jar_CAMEL-6987_37e0e6bb,"public static String extractBodyAsString(Message message) {
        if (message == null) {
            return null;
        }

        StreamCache newBody = message.getBody(StreamCache.class);
        if (newBody != null) {
            message.setBody(newBody);
        }

        Object answer = message.getBody(String.class);
        if (answer == null) {
            answer = message.getBody();
        }

        if (newBody != null) {
            // Reset the InputStreamCache
            newBody.reset();
        }

        return answer != null ? answer.toString() : null;
    }","public static String extractBodyAsString(Message message) {
        if (message == null) {
            return null;
        }

        StreamCache newBody = message.getBody(StreamCache.class);
        if (newBody != null) {
            message.setBody(newBody);
        }

        Object answer = message.getBody(String.class);
        if (answer == null) {
            answer = message.getBody();
        }

        if (newBody != null) {
            // Reset the InputStreamCache
            newBody.reset();
        }

        return answer != null ? answer.toString() : null;
    }",0,[0]
3760,bugs-dot-jar_MATH-1135_a7363a2a,"public MonotoneChain(final boolean includeCollinearPoints, final double tolerance) {
        super(includeCollinearPoints, tolerance);
    }","public MonotoneChain(final boolean includeCollinearPoints, final double tolerance) {
        super(includeCollinearPoints, tolerance);
    }",0,[0]
30603,bugs-dot-jar_CAMEL-3531_41e4b5b9,"public static boolean contains(Object collectionOrArray, Object value) {
        if (collectionOrArray instanceof Collection) {
            Collection collection = (Collection)collectionOrArray;
            return collection.contains(value);
        } else if (collectionOrArray instanceof String && value instanceof String) {
            String str = (String)collectionOrArray;
            String subStr = (String)value;
            return str.contains(subStr);
        } else {
            Iterator iter = createIterator(collectionOrArray);
            while (iter.hasNext()) {
                if (equal(value, iter.next())) {
                    return true;
                }
            }
        }
        return false;
    }","public static boolean contains(Object collectionOrArray, Object value) {
        if (collectionOrArray instanceof Collection) {
            Collection collection = (Collection)collectionOrArray;
            return collection.contains(value);
        } else if (collectionOrArray instanceof String && value instanceof String) {
            String str = (String)collectionOrArray;
            String subStr = (String)value;
            return str.contains(subStr);
        } else {
            Iterator iter = createIterator(collectionOrArray);
            while (iter.hasNext()) {
                if (equal(value, iter.next())) {
                    return true;
                }
            }
        }
        return false;
    }",0,[0]
33447,bugs-dot-jar_WICKET-3618_fbfd17e6,"public void writeTo(final WebResponse response)
	{
		Args.notNull(response, ""response"");

		for (Action action : actions)
		{
			action.invoke(response);
		}
	}","public void writeTo(final WebResponse response)
	{
		Args.notNull(response, ""response"");

		Collections.sort(actions);

		for (Action action : actions)
		{
			action.invoke(response);
		}
	}",1,[]
18703,bugs-dot-jar_ACCUMULO-3218_1b35d263,"public ClientConfiguration withInstance(String instanceName) {
    ArgumentChecker.notNull(instanceName);
    return with(ClientProperty.INSTANCE_NAME, instanceName);
  }","public ClientConfiguration withInstance(String instanceName) {
    ArgumentChecker.notNull(instanceName);
    return with(ClientProperty.INSTANCE_NAME, instanceName);
  }",0,[0]
25090,bugs-dot-jar_OAK-1227_117b0a3d,"@Override
    public void removeShare() throws RepositoryException {
        remove();
    }","@Override
    public void removeShare() throws RepositoryException {
        remove();
    }",0,[0]
6182,bugs-dot-jar_OAK-3028_89317b28,"public void increment(@Nonnull String property, long value) {
        Operation op = new Operation(Operation.Type.INCREMENT, value);
        changes.put(new Key(property, null), op);
    }","public void increment(@Nonnull String property, long value) {
        Operation op = new Operation(Operation.Type.INCREMENT, value);
        changes.put(new Key(property, null), op);
    }",0,[0]
1302,Bears-158,"private Cell getCell(ColumnType type) {
        Integer index = mapping.getIndex(type);
        return index != null ? row.getCell(index) : null;
    }","private Cell getCell(ColumnType type) {
        Integer index = mapping.getIndex(type);
        return index != null ? row.getCell(index) : null;
    }",0,[0]
30669,bugs-dot-jar_MATH-559_fc409e88,"public static boolean equals(double x, double y, int maxUlps) {
        // Check that ""maxUlps"" is non-negative and small enough so that
        // NaN won't compare as equal to anything (except another NaN).
        assert maxUlps > 0 && maxUlps < NAN_GAP;

        long xInt = Double.doubleToLongBits(x);
        long yInt = Double.doubleToLongBits(y);

        // Make lexicographically ordered as a two's-complement integer.
        if (xInt < 0) {
            xInt = SGN_MASK - xInt;
        }
        if (yInt < 0) {
            yInt = SGN_MASK - yInt;
        }

        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;

        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
    }","public static boolean equals(double x, double y, int maxUlps) {
        long xInt = Double.doubleToLongBits(x);
        long yInt = Double.doubleToLongBits(y);

        // Make lexicographically ordered as a two's-complement integer.
        if (xInt < 0) {
            xInt = SGN_MASK - xInt;
        }
        if (yInt < 0) {
            yInt = SGN_MASK - yInt;
        }

        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;

        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
    }",1,"[1, 2, 3]"
1976,bugs-dot-jar_LOG4J2-258_7b38965d,"@Override
    public byte[] getHeader() {
        final StringBuilder sbuf = new StringBuilder();
        sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" "");
        sbuf.append(""\""http://www.w3.org/TR/html4/loose.dtd\"">"");
        sbuf.append(Constants.LINE_SEP);
        sbuf.append(""<html>"").append(Constants.LINE_SEP);
        sbuf.append(""<head>"").append(Constants.LINE_SEP);
        sbuf.append(""<title>"").append(title).append(""</title>"").append(Constants.LINE_SEP);
        sbuf.append(""<style type=\""text/css\"">"").append(Constants.LINE_SEP);
        sbuf.append(""<!--"").append(Constants.LINE_SEP);
        sbuf.append(""body, table {font-family:"").append(font).append(""; font-size: "");
        sbuf.append(headerSize).append("";}"").append(Constants.LINE_SEP);
        sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"").append(Constants.LINE_SEP);
        sbuf.append(""-->"").append(Constants.LINE_SEP);
        sbuf.append(""</style>"").append(Constants.LINE_SEP);
        sbuf.append(""</head>"").append(Constants.LINE_SEP);
        sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"").append(Constants.LINE_SEP);
        sbuf.append(""<hr size=\""1\"" noshade>"").append(Constants.LINE_SEP);
        sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"").append(Constants.LINE_SEP);
        sbuf.append(""<br>"").append(Constants.LINE_SEP);
        sbuf.append(
            ""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"");
        sbuf.append(Constants.LINE_SEP);
        sbuf.append(""<tr>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Time</th>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Thread</th>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Level</th>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Logger</th>"").append(Constants.LINE_SEP);
        if (locationInfo) {
            sbuf.append(""<th>File:Line</th>"").append(Constants.LINE_SEP);
        }
        sbuf.append(""<th>Message</th>"").append(Constants.LINE_SEP);
        sbuf.append(""</tr>"").append(Constants.LINE_SEP);
        return sbuf.toString().getBytes(getCharset());
    }","@Override
    public byte[] getHeader() {
        final StringBuilder sbuf = new StringBuilder();
        sbuf.append(""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" "");
        sbuf.append(""\""http://www.w3.org/TR/html4/loose.dtd\"">"");
        sbuf.append(Constants.LINE_SEP);
        sbuf.append(""<html>"").append(Constants.LINE_SEP);
        sbuf.append(""<head>"").append(Constants.LINE_SEP);
        sbuf.append(""<meta charset=\"""").append(getCharset()).append(""\""/>"").append(Constants.LINE_SEP);
        sbuf.append(""<title>"").append(title).append(""</title>"").append(Constants.LINE_SEP);
        sbuf.append(""<style type=\""text/css\"">"").append(Constants.LINE_SEP);
        sbuf.append(""<!--"").append(Constants.LINE_SEP);
        sbuf.append(""body, table {font-family:"").append(font).append(""; font-size: "");
        sbuf.append(headerSize).append("";}"").append(Constants.LINE_SEP);
        sbuf.append(""th {background: #336699; color: #FFFFFF; text-align: left;}"").append(Constants.LINE_SEP);
        sbuf.append(""-->"").append(Constants.LINE_SEP);
        sbuf.append(""</style>"").append(Constants.LINE_SEP);
        sbuf.append(""</head>"").append(Constants.LINE_SEP);
        sbuf.append(""<body bgcolor=\""#FFFFFF\"" topmargin=\""6\"" leftmargin=\""6\"">"").append(Constants.LINE_SEP);
        sbuf.append(""<hr size=\""1\"" noshade>"").append(Constants.LINE_SEP);
        sbuf.append(""Log session start time "" + new java.util.Date() + ""<br>"").append(Constants.LINE_SEP);
        sbuf.append(""<br>"").append(Constants.LINE_SEP);
        sbuf.append(
            ""<table cellspacing=\""0\"" cellpadding=\""4\"" border=\""1\"" bordercolor=\""#224466\"" width=\""100%\"">"");
        sbuf.append(Constants.LINE_SEP);
        sbuf.append(""<tr>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Time</th>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Thread</th>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Level</th>"").append(Constants.LINE_SEP);
        sbuf.append(""<th>Logger</th>"").append(Constants.LINE_SEP);
        if (locationInfo) {
            sbuf.append(""<th>File:Line</th>"").append(Constants.LINE_SEP);
        }
        sbuf.append(""<th>Message</th>"").append(Constants.LINE_SEP);
        sbuf.append(""</tr>"").append(Constants.LINE_SEP);
        return sbuf.toString().getBytes(getCharset());
    }",1,[]
7208,bugs-dot-jar_WICKET-5881_8c83c5c5,"public final FormComponent<T> add(final IValidator<? super T>... validators)
	{
		Args.notNull(validators, ""validators"");

		for (IValidator<? super T> validator : validators)
		{
			add(validator);
		}

		// return this for chaining
		return this;
	}","public final FormComponent<T> add(final IValidator<? super T>... validators)
	{
		Args.notNull(validators, ""validators"");

		for (IValidator<? super T> validator : validators)
		{
			add(validator);
		}

		// return this for chaining
		return this;
	}",0,[0]
37047,bugs-dot-jar_OAK-1883_9c2421ed,"public boolean isRecoveryNeeded(long currentTime) {
        for(ClusterNodeInfoDocument nodeInfo : getAllClusters()){
            // Check if _lastRev recovery needed for this cluster node
            // state is Active && currentTime past the leaseEnd time && recoveryLock not held by someone
            if (nodeInfo.isActive()
                    && currentTime > nodeInfo.getLeaseEndTime()
                    && !nodeInfo.isBeingRecovered()) {
                return true;
            }
        }
        return false;
    }","public boolean isRecoveryNeeded(long currentTime) {
        for(ClusterNodeInfoDocument nodeInfo : getAllClusters()){
            // Check if _lastRev recovery needed for this cluster node
            // state is Active && currentTime past the leaseEnd time && recoveryLock not held by someone
            if (nodeInfo.isActive()
                    && currentTime > nodeInfo.getLeaseEndTime()
                    && !nodeInfo.isBeingRecovered()) {
                return true;
            }
        }
        return false;
    }",0,[0]
6190,bugs-dot-jar_OAK-510_f63d745a,"@Override
    @Nonnull
    public String getPath() throws RepositoryException {
        return perform(new ItemReadOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                return toJcrPath(dlg.getPath());
            }
        });
    }","@Override
    @Nonnull
    public String getPath() throws RepositoryException {
        return perform(new ItemReadOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                return toJcrPath(dlg.getPath());
            }
        });
    }",0,[0]
17352,bugs-dot-jar_FLINK-1951_adb321d6,"private static String getDescriptionForUserCode(UserCodeWrapper<?> wrapper) {
		try {
			if (wrapper.hasObject()) {
				try {
					return wrapper.getUserCodeObject().toString();
				}
				catch (Throwable t) {
					return wrapper.getUserCodeClass().getName();
				}
			}
			else {
				return wrapper.getUserCodeClass().getName();
			}
		}
		catch (Throwable t) {
			return null;
		}
	}","private static String getDescriptionForUserCode(UserCodeWrapper<?> wrapper) {
		try {
			if (wrapper.hasObject()) {
				try {
					return wrapper.getUserCodeObject().toString();
				}
				catch (Throwable t) {
					return wrapper.getUserCodeClass().getName();
				}
			}
			else {
				return wrapper.getUserCodeClass().getName();
			}
		}
		catch (Throwable t) {
			return null;
		}
	}",0,[0]
19107,bugs-dot-jar_OAK-1215_a9efe3c4,"@Override
    public void restrictList(FilterImpl f, List<PropertyValue> list) {
        if (f.getSelector() == selector) {
            String pn = normalizePropertyName(propertyName);            
            f.restrictPropertyAsList(pn, list);
        }
    }","@Override
    public void restrictList(FilterImpl f, List<PropertyValue> list) {
        if (f.getSelector() == selector) {
            String pn = normalizePropertyName(propertyName);            
            f.restrictPropertyAsList(pn, list);
        }
    }",0,[0]
8541,bugs-dot-jar_WICKET-3309_debca73b,"@SuppressWarnings(""unchecked"")
	public IModel<? extends TreeModel> getModel()
	{
		return (IModel<? extends TreeModel>)getDefaultModel();
	}","@SuppressWarnings(""unchecked"")
	public IModel<? extends TreeModel> getModel()
	{
		return (IModel<? extends TreeModel>)getDefaultModel();
	}",0,[0]
29721,bugs-dot-jar_FLINK-2763_af477563,"public BlockChannelWriter<MemorySegment> getProbeSideChannel() {
		return this.probeSideChannel;
	}","public BlockChannelWriter<MemorySegment> getProbeSideChannel() {
		return this.probeSideChannel;
	}",0,[0]
5476,bugs-dot-jar_OAK-1186_52372042,"public boolean isDeleted(RevisionContext context,
                             Revision readRevision,
                             Set<Revision> validRevisions) {
        return getLiveRevision(context, readRevision, validRevisions) == null;
    }","public boolean isDeleted(RevisionContext context,
                             Revision readRevision,
                             Set<Revision> validRevisions) {
        return getLiveRevision(context, readRevision, validRevisions) == null;
    }",0,[0]
1518,bugs-dot-jar_OAK-4307_f303c916,"SegmentPropertyState writeProperty(final PropertyState state) throws IOException {
        RecordId id = writeOperationHandler.execute(new SegmentWriteOperation() {
            @Override
            public RecordId execute(SegmentBufferWriter writer) throws IOException {
                return with(writer).writeProperty(state);
            }
        });
        return new SegmentPropertyState(id, state.getName(), state.getType());
    }","SegmentPropertyState writeProperty(final PropertyState state) throws IOException {
        RecordId id = writeOperationHandler.execute(new SegmentWriteOperation() {
            @Override
            public RecordId execute(SegmentBufferWriter writer) throws IOException {
                return with(writer).writeProperty(state);
            }
        });
        return new SegmentPropertyState(id, state.getName(), state.getType());
    }",0,[0]
8383,bugs-dot-jar_ACCUMULO-366_db4a291f,"private static String rel2abs(String relPath, KeyExtent extent) {
    if (relPath.startsWith(""../""))
      return ServerConstants.getTablesDir() + relPath.substring(2);
    else
      return ServerConstants.getTablesDir() + ""/"" + extent.getTableId() + relPath;
  }","private static String rel2abs(String relPath, KeyExtent extent) {
    if (relPath.startsWith(""../""))
      return ServerConstants.getTablesDir() + relPath.substring(2);
    else
      return ServerConstants.getTablesDir() + ""/"" + extent.getTableId() + relPath;
  }",0,[0]
13127,bugs-dot-jar_CAMEL-6987_37e0e6bb,"public static String dumpAsXml(Message message, boolean includeBody, int indent, boolean allowStreams, boolean allowFiles, int maxChars) {
        StringBuilder sb = new StringBuilder();

        StringBuilder prefix = new StringBuilder();
        for (int i = 0; i < indent; i++) {
            prefix.append("" "");
        }

        // include exchangeId as attribute on the <message> tag
        sb.append(prefix);
        sb.append(""<message exchangeId=\"""").append(message.getExchange().getExchangeId()).append(""\"">\n"");

        // headers
        if (message.hasHeaders()) {
            sb.append(prefix);
            sb.append(""  <headers>\n"");
            // sort the headers so they are listed A..Z
            Map<String, Object> headers = new TreeMap<String, Object>(message.getHeaders());
            for (Map.Entry<String, Object> entry : headers.entrySet()) {
                Object value = entry.getValue();
                String type = ObjectHelper.classCanonicalName(value);
                sb.append(prefix);
                sb.append(""    <header key=\"""").append(entry.getKey()).append(""\"""");
                if (type != null) {
                    sb.append("" type=\"""").append(type).append(""\"""");
                }
                sb.append("">"");

                // dump header value as XML, use Camel type converter to convert
                // to String
                if (value != null) {
                    try {
                        String xml = message.getExchange().getContext().getTypeConverter().convertTo(String.class, 
                                message.getExchange(), value);
                        if (xml != null) {
                            // must always xml encode
                            sb.append(StringHelper.xmlEncode(xml));
                        }
                    } catch (Exception e) {
                        // ignore as the body is for logging purpose
                    }
                }

                sb.append(""</header>\n"");
            }
            sb.append(prefix);
            sb.append(""  </headers>\n"");
        }

        if (includeBody) {
            sb.append(prefix);
            sb.append(""  <body"");
            String type = ObjectHelper.classCanonicalName(message.getBody());
            if (type != null) {
                sb.append("" type=\"""").append(type).append(""\"""");
            }
            sb.append("">"");

            String xml = extractBodyForLogging(message, """", allowStreams, allowFiles, maxChars);
            if (xml != null) {
                // must always xml encode
                sb.append(StringHelper.xmlEncode(xml));
            }

            sb.append(""</body>\n"");
        }

        sb.append(prefix);
        sb.append(""</message>"");
        return sb.toString();
    }","public static String dumpAsXml(Message message, boolean includeBody, int indent, boolean allowStreams, boolean allowFiles, int maxChars) {
        StringBuilder sb = new StringBuilder();

        StringBuilder prefix = new StringBuilder();
        for (int i = 0; i < indent; i++) {
            prefix.append("" "");
        }

        // include exchangeId as attribute on the <message> tag
        sb.append(prefix);
        sb.append(""<message exchangeId=\"""").append(message.getExchange().getExchangeId()).append(""\"">\n"");

        // headers
        if (message.hasHeaders()) {
            sb.append(prefix);
            sb.append(""  <headers>\n"");
            // sort the headers so they are listed A..Z
            Map<String, Object> headers = new TreeMap<String, Object>(message.getHeaders());
            for (Map.Entry<String, Object> entry : headers.entrySet()) {
                Object value = entry.getValue();
                String type = ObjectHelper.classCanonicalName(value);
                sb.append(prefix);
                sb.append(""    <header key=\"""").append(entry.getKey()).append(""\"""");
                if (type != null) {
                    sb.append("" type=\"""").append(type).append(""\"""");
                }
                sb.append("">"");

                // dump header value as XML, use Camel type converter to convert
                // to String
                if (value != null) {
                    try {
                        String xml = message.getExchange().getContext().getTypeConverter().convertTo(String.class, 
                                message.getExchange(), value);
                        if (xml != null) {
                            // must always xml encode
                            sb.append(StringHelper.xmlEncode(xml));
                        }
                    } catch (Exception e) {
                        // ignore as the body is for logging purpose
                    }
                }

                sb.append(""</header>\n"");
            }
            sb.append(prefix);
            sb.append(""  </headers>\n"");
        }

        if (includeBody) {
            sb.append(prefix);
            sb.append(""  <body"");
            String type = ObjectHelper.classCanonicalName(message.getBody());
            if (type != null) {
                sb.append("" type=\"""").append(type).append(""\"""");
            }
            sb.append("">"");

            String xml = extractBodyForLogging(message, """", allowStreams, allowFiles, maxChars);
            if (xml != null) {
                // must always xml encode
                sb.append(StringHelper.xmlEncode(xml));
            }

            sb.append(""</body>\n"");
        }

        sb.append(prefix);
        sb.append(""</message>"");
        return sb.toString();
    }",0,[0]
29316,bugs-dot-jar_WICKET-2057_e2d88568,"public CharSequence decorateOnFailureScript(CharSequence script)
	{
		CharSequence s = (delegate == null) ? script : delegate.decorateOnFailureScript(script);
		return preDecorateOnFailureScript(s);
	}","public CharSequence decorateOnFailureScript(CharSequence script)
	{
		CharSequence s = preDecorateOnFailureScript(script);

		return (delegate == null) ? s : delegate.decorateOnFailureScript(s);
	}",1,"[2, 3]"
27121,bugs-dot-jar_WICKET-4020_081cdeb2,"public ResourceMapper(String path, ResourceReference resourceReference,
		IPageParametersEncoder encoder)
	{
		Args.notEmpty(path, ""path"");
		Args.notNull(resourceReference, ""resourceReference"");
		Args.notNull(encoder, ""encoder"");

		this.resourceReference = resourceReference;
		mountSegments = getMountSegments(path);
		parametersEncoder = encoder;
	}","public ResourceMapper(String path, ResourceReference resourceReference,
		IPageParametersEncoder encoder)
	{
		Args.notEmpty(path, ""path"");
		Args.notNull(resourceReference, ""resourceReference"");
		Args.notNull(encoder, ""encoder"");

		this.resourceReference = resourceReference;
		mountSegments = getMountSegments(path);
		parametersEncoder = encoder;
	}",0,[0]
5203,bugs-dot-jar_ACCUMULO-3475_7651b777,"@Override
  protected void setInstance(CommandLine cl) {
    // We always want a MockInstance for this test
    instance = new MockInstance();
  }","@Override
  protected void setInstance(CommandLine cl) {
    // We always want a MockInstance for this test
    instance = new MockInstance();
  }",0,[0]
22118,bugs-dot-jar_WICKET-1677_01a3dd66,"public Radio<T> setLabel(IModel<String> labelModel)
	{
		setLabelInternal(labelModel);
		return this;
	}","public Radio<T> setLabel(IModel<String> labelModel)
	{
		setLabelInternal(labelModel);
		return this;
	}",0,[0]
12486,bugs-dot-jar_FLINK-2968_59685903,"@VisibleForTesting
	public Trigger<? super IN, ? super W> getTrigger() {
		return trigger;
	}","@VisibleForTesting
	public Trigger<? super IN, ? super W> getTrigger() {
		return trigger;
	}",0,[0]
24955,bugs-dot-jar_CAMEL-7146_b6981cfd,"public void setOptimisticLocking(boolean optimisticLocking) {
        this.optimisticLocking = optimisticLocking;
    }","public void setOptimisticLocking(boolean optimisticLocking) {
        this.optimisticLocking = optimisticLocking;
    }",0,[0]
7067,bugs-dot-jar_LOG4J2-763_97203de8,"public ObjectMessage(Object obj) {
        if (obj == null) {
            obj = ""null"";
        }
        this.obj = obj;
    }","public ObjectMessage(Object obj) {
        if (obj == null) {
            obj = ""null"";
        }
        this.obj = obj;
        
        // LOG4J2-763: take snapshot of parameters at message construction time
        objectString = String.valueOf(obj);
    }",1,[]
19059,bugs-dot-jar_ACCUMULO-633_8dad5e0f,"@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    return new FirstEntryInRowIterator(this, env);
  }","@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    return new FirstEntryInRowIterator(this, env);
  }",0,[0]
36148,bugs-dot-jar_CAMEL-9444_baece126,"public Type rollback(String message) {
        RollbackDefinition answer = new RollbackDefinition(message);
        addOutput(answer);
        return (Type) this;
    }","public Type rollback(String message) {
        RollbackDefinition answer = new RollbackDefinition(message);
        addOutput(answer);
        return (Type) this;
    }",0,[0]
13773,bugs-dot-jar_CAMEL-6936_4954d573,"public void setOperations(GenericFileOperations<T> operations) {
        this.operations = operations;
    }","public void setOperations(GenericFileOperations<T> operations) {
        this.operations = operations;
    }",0,[0]
2123,bugs-dot-jar_WICKET-2961_3d8c9d75,"protected final void checkComponentTag(final ComponentTag tag, final String name)
	{
		if (!tag.getName().equalsIgnoreCase(name))
		{
			findMarkupStream().throwMarkupException(
				""Component "" + getId() + "" must be applied to a tag of type '"" + name + ""', not "" +
					tag.toUserDebugString());
		}
	}","protected final void checkComponentTag(final ComponentTag tag, final String name)
	{
		if (!tag.getName().equalsIgnoreCase(name))
		{
			findMarkupStream().throwMarkupException(
				""Component "" + getId() + "" must be applied to a tag of type '"" + name + ""', not "" +
					tag.toUserDebugString());
		}
	}",0,[0]
32540,bugs-dot-jar_OAK-4300_06c367af,"public boolean isSpellcheckEnabled() {
        return spellcheckEnabled;
    }","public boolean isSpellcheckEnabled() {
        return spellcheckEnabled;
    }",0,[0]
9603,bugs-dot-jar_WICKET-2281_6e0b40bc,"public boolean isRequestedSessionIdFromURL()
	{
		return false;
	}","public boolean isRequestedSessionIdFromURL()
	{
		return false;
	}",0,[0]
16684,bugs-dot-jar_WICKET-5689_2ac29d30,"private static boolean neverRedirect(RedirectPolicy redirectPolicy)
	{
		return redirectPolicy == RedirectPolicy.NEVER_REDIRECT;
	}","private static boolean neverRedirect(RedirectPolicy redirectPolicy)
	{
		return redirectPolicy == RedirectPolicy.NEVER_REDIRECT;
	}",0,[0]
4401,bugs-dot-jar_WICKET-4251_53bcb78d,"static void continueToOriginalDestination()
	{
		InterceptData data = InterceptData.get();
		if (data != null)
		{
			data.continueOk = true;
			String url = RequestCycle.get().getUrlRenderer().renderUrl(data.originalUrl);
			RequestCycle.get().replaceAllRequestHandlers(new RedirectRequestHandler(url));
		}
	}","static void continueToOriginalDestination()
	{
		InterceptData data = InterceptData.get();
		if (data != null)
		{
			data.continueOk = true;
			String url = RequestCycle.get().getUrlRenderer().renderUrl(data.originalUrl);
			RequestCycle.get().replaceAllRequestHandlers(new RedirectRequestHandler(url));
		}
	}",0,[0]
486,Bears-16,"public final void defaultSerializeNull(JsonGenerator gen) throws IOException
    {
        if (_stdNullValueSerializer) { // minor perf optimization
            gen.writeNull();
        } else {
            _nullValueSerializer.serialize(null, gen, this);
        }
    }","public final void defaultSerializeNull(JsonGenerator gen) throws IOException
    {
        if (_stdNullValueSerializer) { // minor perf optimization
            gen.writeNull();
        } else {
            _nullValueSerializer.serialize(null, gen, this);
        }
    }",0,[0]
23607,bugs-dot-jar_OAK-4423_08f0b280,"@Override
    public Blob getBlob(@Nonnull String reference) {
        //Use of 'reference' here is bit overloaded. In terms of NodeStore API
        //a blob reference refers to the secure reference obtained from Blob#getReference()
        //However in SegmentStore terminology a blob is referred via 'external reference'
        //That 'external reference' would map to blobId obtained from BlobStore#getBlobId
        if (blobStore != null) {
            String blobId = blobStore.getBlobId(reference);
            if (blobId != null) {
                return new BlobStoreBlob(blobStore, blobId);
            }
            return null;
        }
        throw new IllegalStateException(""Attempt to read external blob with blobId ["" + reference + ""] "" +
                ""without specifying BlobStore"");
    }","@Override
    public Blob getBlob(@Nonnull String reference) {
        //Use of 'reference' here is bit overloaded. In terms of NodeStore API
        //a blob reference refers to the secure reference obtained from Blob#getReference()
        //However in SegmentStore terminology a blob is referred via 'external reference'
        //That 'external reference' would map to blobId obtained from BlobStore#getBlobId
        if (blobStore != null) {
            String blobId = blobStore.getBlobId(reference);
            if (blobId != null) {
                return new BlobStoreBlob(blobStore, blobId);
            }
            return null;
        }
        throw new IllegalStateException(""Attempt to read external blob with blobId ["" + reference + ""] "" +
                ""without specifying BlobStore"");
    }",0,[0]
34930,bugs-dot-jar_CAMEL-5570_a57830ed,"public void setRedeliveryPolicy(RedeliveryPolicyDefinition redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }","public void setRedeliveryPolicy(RedeliveryPolicyDefinition redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }",0,[0]
21068,bugs-dot-jar_OAK-846_7acb091a,"@Override
    public long getLength(String blobId) throws MicroKernelException {
        try {
            return blobStore.getBlobLength(blobId);
        } catch (Exception e) {
            throw new MicroKernelException(e);
        }
    }","@Override
    public long getLength(String blobId) throws MicroKernelException {
        try {
            return blobStore.getBlobLength(blobId);
        } catch (Exception e) {
            throw new MicroKernelException(e);
        }
    }",0,[0]
13262,bugs-dot-jar_OAK-1287_14849e22,"public MapRecord writeMap(MapRecord base, Map<String, RecordId> changes) {
        if (base != null && base.isDiff()) {
            Segment segment = base.getSegment();
            RecordId key = segment.readRecordId(base.getOffset(8));
            String name = segment.readString(key);
            if (!changes.containsKey(name)) {
                changes.put(name, segment.readRecordId(base.getOffset(8, 1)));
            }
            base = new MapRecord(
                    segment, segment.readRecordId(base.getOffset(8, 2)));
        }

        if (base != null && changes.size() == 1) {
            Map.Entry<String, RecordId> change =
                    changes.entrySet().iterator().next();
            RecordId value = change.getValue();
            if (value != null) {
                MapEntry entry = base.getEntry(change.getKey());
                if (entry != null) {
                    if (value.equals(entry.getValue())) {
                        return base;
                    } else {
                        synchronized (this) {
                            RecordId id = prepare(RecordType.BRANCH, 8, asList(
                                    entry.getKey(), value, base.getRecordId()));
                            writeInt(-1);
                            writeInt(entry.getHash());
                            writeRecordId(entry.getKey());
                            writeRecordId(value);
                            writeRecordId(base.getRecordId());
                            return new MapRecord(dummySegment, id);
                        }
                    }
                }
            }
        }

        List<MapEntry> entries = Lists.newArrayList();
        for (Map.Entry<String, RecordId> entry : changes.entrySet()) {
            String key = entry.getKey();

            RecordId keyId = null;
            if (base != null) {
                MapEntry e = base.getEntry(key);
                if (e != null) {
                    keyId = e.getKey();
                }
            }
            if (keyId == null) {
                keyId = writeString(key);
            }

            entries.add(new MapEntry(
                    dummySegment, key, keyId, entry.getValue()));
        }

        return writeMapBucket(base, entries, 0);
    }","public MapRecord writeMap(MapRecord base, Map<String, RecordId> changes) {
        if (base != null && base.isDiff()) {
            Segment segment = base.getSegment();
            RecordId key = segment.readRecordId(base.getOffset(8));
            String name = segment.readString(key);
            if (!changes.containsKey(name)) {
                changes.put(name, segment.readRecordId(base.getOffset(8, 1)));
            }
            base = new MapRecord(
                    segment, segment.readRecordId(base.getOffset(8, 2)));
        }

        if (base != null && changes.size() == 1) {
            Map.Entry<String, RecordId> change =
                    changes.entrySet().iterator().next();
            RecordId value = change.getValue();
            if (value != null) {
                MapEntry entry = base.getEntry(change.getKey());
                if (entry != null) {
                    if (value.equals(entry.getValue())) {
                        return base;
                    } else {
                        synchronized (this) {
                            RecordId id = prepare(RecordType.BRANCH, 8, asList(
                                    entry.getKey(), value, base.getRecordId()));
                            writeInt(-1);
                            writeInt(entry.getHash());
                            writeRecordId(entry.getKey());
                            writeRecordId(value);
                            writeRecordId(base.getRecordId());
                            return new MapRecord(dummySegment, id);
                        }
                    }
                }
            }
        }

        List<MapEntry> entries = Lists.newArrayList();
        for (Map.Entry<String, RecordId> entry : changes.entrySet()) {
            String key = entry.getKey();

            RecordId keyId = null;
            if (base != null) {
                MapEntry e = base.getEntry(key);
                if (e != null) {
                    keyId = e.getKey();
                }
            }
            if (keyId == null) {
                keyId = writeString(key);
            }

            entries.add(new MapEntry(
                    dummySegment, key, keyId, entry.getValue()));
        }

        return writeMapBucket(base, entries, 0);
    }",0,[0]
26904,bugs-dot-jar_WICKET-5724_b92591f6,"public final boolean isOpen(String id)
	{
		return xmlTag.isOpen() && this.id.equals(id);
	}","public final boolean isOpen(String id)
	{
		return xmlTag.isOpen() && this.id.equals(id);
	}",0,[0]
1833,bugs-dot-jar_CAMEL-8146_17475d80,"public ScheduledPollConsumer(Endpoint endpoint, Processor processor, ScheduledExecutorService scheduledExecutorService) {
        super(endpoint, processor);
        // we have been given an existing thread pool, so we should not manage its lifecycle
        // so we should keep shutdownExecutor as false
        this.scheduledExecutorService = scheduledExecutorService;
        ObjectHelper.notNull(scheduledExecutorService, ""scheduledExecutorService"");
    }","public ScheduledPollConsumer(Endpoint endpoint, Processor processor, ScheduledExecutorService scheduledExecutorService) {
        super(endpoint, processor);
        // we have been given an existing thread pool, so we should not manage its lifecycle
        // so we should keep shutdownExecutor as false
        this.scheduledExecutorService = scheduledExecutorService;
        ObjectHelper.notNull(scheduledExecutorService, ""scheduledExecutorService"");
    }",0,[0]
13223,bugs-dot-jar_MATH-393_d4b02f6a,"public void setAbsoluteAccuracy(double accuracy) {
        optimizer.setAbsoluteAccuracy(accuracy);
    }","public void setAbsoluteAccuracy(double accuracy) {
        optimizer.setAbsoluteAccuracy(accuracy);
    }",0,[0]
1164,Bears-152,"public void setTelnet(String telnet) {
        checkMultiExtension(TelnetHandler.class, ""telnet"", telnet);
        this.telnet = telnet;
    }","public void setTelnet(String telnet) {
        checkMultiExtension(TelnetHandler.class, ""telnet"", telnet);
        this.telnet = telnet;
    }",0,[0]
17435,bugs-dot-jar_MATH-1045_a4ffd393,"public RealVector getEigenvector(final int i) {
        return eigenvectors[i].copy();
    }","public RealVector getEigenvector(final int i) {
        return eigenvectors[i].copy();
    }",0,[0]
7096,bugs-dot-jar_LOG4J2-763_97203de8,"protected void setId(final String id) {
        this.id = new StructuredDataId(id, null, null);
    }","protected void setId(final String id) {
        this.id = new StructuredDataId(id, null, null);
    }",0,[0]
26718,bugs-dot-jar_WICKET-3989_6a8fc1cc,"private String getHeaderId(final Component container, final MarkupStream markupStream)
	{
		Class<?> markupClass = markupStream.getTag().getMarkupClass();
		if (markupClass == null)
		{
			markupClass = markupStream.getContainerClass();
		}

		// create a unique id for the HtmlHeaderContainer
		StringBuilder builder = new StringBuilder(100);
		builder.append(""_"");
		builder.append(Classes.simpleName(markupClass));
		if (container.getVariation() != null)
		{
			builder.append(container.getVariation());
		}
		builder.append(""Header"");
		builder.append(markupStream.getCurrentIndex());
		return builder.toString();
	}","private String getHeaderId(final Component container, final MarkupStream markupStream)
	{
		Class<?> markupClass = markupStream.getTag().getMarkupClass();
		if (markupClass == null)
		{
			markupClass = markupStream.getContainerClass();
		}

		// create a unique id for the HtmlHeaderContainer
		StringBuilder builder = new StringBuilder(100);
		builder.append(""_"");
		builder.append(Classes.simpleName(markupClass));
		if (container.getVariation() != null)
		{
			builder.append(container.getVariation());
		}
		builder.append(""Header"");
		builder.append(markupStream.getCurrentIndex());
		return builder.toString();
	}",0,[0]
24143,bugs-dot-jar_MATH-618_2123f780,"public Complex log() {
        if (isNaN) {
            return NaN;
        }

        return createComplex(FastMath.log(abs()),
            FastMath.atan2(imaginary, real));
    }","public Complex log() {
        if (isNaN) {
            return NaN;
        }

        return createComplex(FastMath.log(abs()),
            FastMath.atan2(imaginary, real));
    }",0,[0]
446,bugs-dot-jar_WICKET-4927_8c827e33,"@Override
	public String encodeRedirectURL(CharSequence url)
	{
		return originalResponse.encodeRedirectURL(url);
	}","@Override
	public String encodeRedirectURL(CharSequence url)
	{
		return originalResponse.encodeRedirectURL(url);
	}",0,[0]
37398,bugs-dot-jar_CAMEL-4482_e38494f1,"private void doProcessParallel(final ProcessorExchangePair pair) throws Exception {
        final Exchange exchange = pair.getExchange();
        Processor processor = pair.getProcessor();
        Producer producer = pair.getProducer();

        TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null;

        // compute time taken if sending to another endpoint
        StopWatch watch = null;
        if (producer != null) {
            watch = new StopWatch();
        }

        try {
            // prepare tracing starting from a new block
            if (traced != null) {
                traced.pushBlock();
            }

            // let the prepared process it, remember to begin the exchange pair
            // we invoke it synchronously as parallel async routing is too hard
            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
            pair.begin();
            AsyncProcessorHelper.process(async, exchange);
        } finally {
            pair.done();
            // pop the block so by next round we have the same staring point and thus the tracing looks accurate
            if (traced != null) {
                traced.popBlock();
            }
            if (producer != null) {
                long timeTaken = watch.stop();
                Endpoint endpoint = producer.getEndpoint();
                // emit event that the exchange was sent to the endpoint
                EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);
            }
        }
    }","private void doProcessParallel(final ProcessorExchangePair pair) throws Exception {
        final Exchange exchange = pair.getExchange();
        Processor processor = pair.getProcessor();
        Producer producer = pair.getProducer();

        TracedRouteNodes traced = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getTracedRouteNodes() : null;

        // compute time taken if sending to another endpoint
        StopWatch watch = null;
        if (producer != null) {
            watch = new StopWatch();
        }

        try {
            // prepare tracing starting from a new block
            if (traced != null) {
                traced.pushBlock();
            }

            // let the prepared process it, remember to begin the exchange pair
            // we invoke it synchronously as parallel async routing is too hard
            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);
            pair.begin();
            AsyncProcessorHelper.process(async, exchange);
        } finally {
            pair.done();
            // pop the block so by next round we have the same staring point and thus the tracing looks accurate
            if (traced != null) {
                traced.popBlock();
            }
            if (producer != null) {
                long timeTaken = watch.stop();
                Endpoint endpoint = producer.getEndpoint();
                // emit event that the exchange was sent to the endpoint
                EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);
            }
        }
    }",0,[0]
17204,bugs-dot-jar_WICKET-294_5c592d85,"protected CharSequence encode(RequestCycle requestCycle,
			IBookmarkablePageRequestTarget requestTarget)
	{
		// Begin encoding URL
		final AppendingStringBuffer url = new AppendingStringBuffer(64);

		// Get page Class
		final Class pageClass = requestTarget.getPageClass();
		final Application application = Application.get();

		// Find pagemap name
		String pageMapName = requestTarget.getPageMapName();
		if (pageMapName == null)
		{
			IRequestTarget currentTarget = requestCycle.getRequestTarget();
			if (currentTarget instanceof IPageRequestTarget)
			{
				Page currentPage = ((IPageRequestTarget)currentTarget).getPage();
				final IPageMap pageMap = currentPage.getPageMap();
				if (pageMap.isDefault())
				{
					pageMapName = """";
				}
				else
				{
					pageMapName = pageMap.getName();
				}
			}
			else
			{
				pageMapName = """";
			}
		}

		boolean firstParameter = true;
		if (!application.getHomePage().equals(pageClass) || !"""".equals(pageMapName) ||
				(application.getHomePage().equals(pageClass) && requestTarget instanceof BookmarkableListenerInterfaceRequestTarget) )
		{
			firstParameter = false;
			url.append('?');
			url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);
			url.append('=');


			// Add <page-map-name>:<bookmarkable-page-class>
			String pageClassName = pageClass.getName();

			/*
			 * Encode the url so it is correct even for class names containing
			 * non ASCII characters, like , , ,  etc.
			 * 
			 * The reason for this is that when redirecting to these
			 * bookmarkable pages, we need to have the url encoded correctly
			 * because we can't rely on the browser to interpret the unencoded
			 * url correctly.
			 */
			try
			{
				url.append(URLEncoder.encode(pageMapName + Component.PATH_SEPARATOR + pageClassName, ""UTF-8""));
			}
			catch (UnsupportedEncodingException ex)
			{
				log.error(ex.getMessage(), ex);
				url.append(pageMapName + Component.PATH_SEPARATOR + pageClassName);
			}
		}

		// Get page parameters
		final PageParameters parameters = requestTarget.getPageParameters();
		if (parameters != null)
		{
			Iterator it = parameters.keySet().iterator();
			while (it.hasNext())
			{
				final String key = (String)it.next();
				final String value = parameters.getString(key);
				if (value != null)
				{
					String escapedValue = value;
					try
					{
						escapedValue = URLEncoder.encode(escapedValue, application
								.getRequestCycleSettings().getResponseRequestEncoding());
					}
					catch (UnsupportedEncodingException ex)
					{
						log.error(ex.getMessage(), ex);
					}
					if (!firstParameter)
					{
						url.append('&');
					}
					else
					{
						firstParameter = false;
						url.append('?');
					}
					url.append(key);
					url.append('=');
					url.append(escapedValue);
				}
			}
		}
		return url;
	}","protected CharSequence encode(RequestCycle requestCycle,
			IBookmarkablePageRequestTarget requestTarget)
	{
		// Begin encoding URL
		final AppendingStringBuffer url = new AppendingStringBuffer(64);

		// Get page Class
		final Class pageClass = requestTarget.getPageClass();
		final Application application = Application.get();

		// Find pagemap name
		String pageMapName = requestTarget.getPageMapName();
		if (pageMapName == null)
		{
			IRequestTarget currentTarget = requestCycle.getRequestTarget();
			if (currentTarget instanceof IPageRequestTarget)
			{
				Page currentPage = ((IPageRequestTarget)currentTarget).getPage();
				final IPageMap pageMap = currentPage.getPageMap();
				if (pageMap.isDefault())
				{
					pageMapName = """";
				}
				else
				{
					pageMapName = pageMap.getName();
				}
			}
			else
			{
				pageMapName = """";
			}
		}

		boolean firstParameter = true;
		if (!application.getHomePage().equals(pageClass) || !"""".equals(pageMapName) ||
				(application.getHomePage().equals(pageClass) && requestTarget instanceof BookmarkableListenerInterfaceRequestTarget) )
		{
			firstParameter = false;
			url.append('?');
			url.append(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);
			url.append('=');


			// Add <page-map-name>:<bookmarkable-page-class>
			String pageClassName = pageClass.getName();

			/*
			 * Encode the url so it is correct even for class names containing
			 * non ASCII characters, like , , ,  etc.
			 * 
			 * The reason for this is that when redirecting to these
			 * bookmarkable pages, we need to have the url encoded correctly
			 * because we can't rely on the browser to interpret the unencoded
			 * url correctly.
			 */
			try
			{
				url.append(URLEncoder.encode(pageMapName + Component.PATH_SEPARATOR + pageClassName, ""UTF-8""));
			}
			catch (UnsupportedEncodingException ex)
			{
				log.error(ex.getMessage(), ex);
				url.append(pageMapName + Component.PATH_SEPARATOR + pageClassName);
			}
		}

		// Get page parameters
		final PageParameters parameters = requestTarget.getPageParameters();
		if (parameters != null)
		{
			Iterator it = parameters.keySet().iterator();
			while (it.hasNext())
			{
				final String key = (String)it.next();
				final String value = parameters.getString(key);
				if (value != null)
				{
					String escapedValue = value;
					try
					{
						escapedValue = URLEncoder.encode(escapedValue, application
								.getRequestCycleSettings().getResponseRequestEncoding());
					}
					catch (UnsupportedEncodingException ex)
					{
						log.error(ex.getMessage(), ex);
					}
					if (!firstParameter)
					{
						url.append('&');
					}
					else
					{
						firstParameter = false;
						url.append('?');
					}
					url.append(key);
					url.append('=');
					url.append(escapedValue);
				}
			}
		}
		return url;
	}",0,[0]
26712,bugs-dot-jar_WICKET-3989_6a8fc1cc,"protected final void renderAssociatedMarkup(final Component component)
	{
		((MarkupContainer)component).renderAssociatedMarkup(tagName, ""Markup for a "" + tagName +
			"" component must begin a tag like '<wicket:"" + tagName + "">'"");
	}","protected final void renderAssociatedMarkup(final Component component)
	{
		((MarkupContainer)component).renderAssociatedMarkup(tagName, ""Markup for a "" + tagName +
			"" component must begin a tag like '<wicket:"" + tagName + "">'"");
	}",0,[0]
22608,bugs-dot-jar_OAK-47_b62f1c26,"public void moveCache(BTree tree, String oldPath) {
        String indexRoot = PathUtils.concat(indexRootNode, tree.getName());
        String o = PathUtils.concat(indexRoot, oldPath);
        HashMap<String, BTreePage> moved = new HashMap<String, BTreePage>();
        for (Entry<String, BTreePage> e : modified.entrySet()) {
            if (e.getKey().startsWith(o)) {
                moved.put(e.getKey(), e.getValue());
            }
        }
        for (String s : moved.keySet()) {
            modified.remove(s);
        }
        for (BTreePage p : moved.values()) {
            String n = PathUtils.concat(indexRoot, p.getPath());
            modified.put(n, p);
        }
    }","public void moveCache(BTree tree, String oldPath) {
        String indexRoot = PathUtils.concat(indexRootNode, tree.getName());
        String o = PathUtils.concat(indexRoot, oldPath);
        HashMap<String, BTreePage> moved = new HashMap<String, BTreePage>();
        for (Entry<String, BTreePage> e : modified.entrySet()) {
            if (e.getKey().startsWith(o)) {
                moved.put(e.getKey(), e.getValue());
            }
        }
        for (String s : moved.keySet()) {
            modified.remove(s);
        }
        for (BTreePage p : moved.values()) {
            String n = PathUtils.concat(indexRoot, p.getPath());
            modified.put(n, p);
        }
    }",0,[0]
11729,bugs-dot-jar_CAMEL-5796_de6dd425,"public DataFormatClause<ProcessorDefinition<Type>> unmarshal() {
        return new DataFormatClause<ProcessorDefinition<Type>>(this, DataFormatClause.Operation.Unmarshal);
    }","public DataFormatClause<ProcessorDefinition<Type>> unmarshal() {
        return new DataFormatClause<ProcessorDefinition<Type>>(this, DataFormatClause.Operation.Unmarshal);
    }",0,[0]
25819,bugs-dot-jar_CAMEL-6723_b92d6237,"@Deprecated
    public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloadException {
        return exchange.getOut().getMandatoryBody();
    }","@Deprecated
    public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloadException {
        return exchange.getOut().getMandatoryBody();
    }",0,[0]
3418,bugs-dot-jar_LOG4J2-102_7f391872,"public static int getPriority(Facility facility, Level level) {
        return facility.getCode() << 3 + Severity.getSeverity(level).getCode();
    }","public static int getPriority(Facility facility, Level level) {
        return (facility.getCode() << 3) + Severity.getSeverity(level).getCode();
    }",1,[1]
36513,bugs-dot-jar_MATH-1093_7cfbc0da,"private boolean isDirect(final BSPTree<Sphere1D> node) {
        return ((LimitAngle) node.getCut().getHyperplane()).isDirect();
    }","private boolean isDirect(final BSPTree<Sphere1D> node) {
        return ((LimitAngle) node.getCut().getHyperplane()).isDirect();
    }",0,[0]
32121,bugs-dot-jar_MATH-724_9c8bb934,"private RandomGenerator getRan() {
        if (rand == null) {
            initRan();
        }
        return rand;
    }","private RandomGenerator getRan() {
        if (rand == null) {
            initRan();
        }
        return rand;
    }",0,[0]
1322,Bears-160,"public MySqlDdlParser() {
        super("";"");
    }","public MySqlDdlParser() {
        super("";"");
    }",0,[0]
35721,bugs-dot-jar_FLINK-1978_0078c44e,"protected void initializeFields(T t) {
		for (int i = 0; i < numFields; i++) {
			try {
				fields[i].set(t, fieldSerializers[i].createInstance());
			} catch (IllegalAccessException e) {
				throw new RuntimeException(""Cannot initialize fields."", e);
			}
		}
	}","protected void initializeFields(T t) {
		for (int i = 0; i < numFields; i++) {
			try {
				fields[i].set(t, fieldSerializers[i].createInstance());
			} catch (IllegalAccessException e) {
				throw new RuntimeException(""Cannot initialize fields."", e);
			}
		}
	}",0,[0]
38733,bugs-dot-jar_OAK-276_1bf5c550,"@Override
    public boolean markNode(Id id) throws NotFoundException {
        return markObject(id);
    }","@Override
    public boolean markNode(Id id) throws NotFoundException {
        return markObject(id);
    }",0,[0]
16399,bugs-dot-jar_CAMEL-7163_5f726d0b,"public void step() {
        backlogDebugger.step();
    }","public void step() {
        backlogDebugger.step();
    }",0,[0]
39207,bugs-dot-jar_OAK-4353_b0014b7d,"private String loadString(int offset) {
        int pos = pos(offset, 1);
        long length = internalReadLength(pos);
        if (length < SMALL_LIMIT) {
            byte[] bytes = new byte[(int) length];
            ByteBuffer buffer = data.duplicate();
            buffer.position(pos + 1);
            buffer.get(bytes);
            return new String(bytes, Charsets.UTF_8);
        } else if (length < MEDIUM_LIMIT) {
            byte[] bytes = new byte[(int) length];
            ByteBuffer buffer = data.duplicate();
            buffer.position(pos + 2);
            buffer.get(bytes);
            return new String(bytes, Charsets.UTF_8);
        } else if (length < Integer.MAX_VALUE) {
            int size = (int) ((length + BLOCK_SIZE - 1) / BLOCK_SIZE);
            ListRecord list =
                    new ListRecord(internalReadRecordId(pos + 8), size);
            SegmentStream stream = new SegmentStream(
                    new RecordId(id, offset), list, length);
            try {
                return stream.getString();
            } finally {
                stream.close();
            }
        } else {
            throw new IllegalStateException(""String is too long: "" + length);
        }
    }","private String loadString(int offset) {
        int pos = pos(offset, 1);
        long length = internalReadLength(pos);
        if (length < SMALL_LIMIT) {
            byte[] bytes = new byte[(int) length];
            ByteBuffer buffer = data.duplicate();
            buffer.position(pos + 1);
            buffer.get(bytes);
            return new String(bytes, Charsets.UTF_8);
        } else if (length < MEDIUM_LIMIT) {
            byte[] bytes = new byte[(int) length];
            ByteBuffer buffer = data.duplicate();
            buffer.position(pos + 2);
            buffer.get(bytes);
            return new String(bytes, Charsets.UTF_8);
        } else if (length < Integer.MAX_VALUE) {
            int size = (int) ((length + BLOCK_SIZE - 1) / BLOCK_SIZE);
            ListRecord list =
                    new ListRecord(internalReadRecordId(pos + 8), size);
            SegmentStream stream = new SegmentStream(
                    new RecordId(id, offset), list, length);
            try {
                return stream.getString();
            } finally {
                stream.close();
            }
        } else {
            throw new IllegalStateException(""String is too long: "" + length);
        }
    }",0,[0]
8732,bugs-dot-jar_WICKET-5883_cd3b9234,"protected boolean handleMultiPart()
	{
		if (isMultiPart())
		{
			// Change the request to a multipart web request so parameters are
			// parsed out correctly
			try
			{
				ServletWebRequest request = (ServletWebRequest)getRequest();
				final MultipartServletWebRequest multipartWebRequest = request.newMultipartWebRequest(getMaxSize(), getPage().getId());
				multipartWebRequest.setFileMaxSize(getFileMaxSize());
				multipartWebRequest.parseFileParts();

				// TODO: Can't this be detected from header?
				getRequestCycle().setRequest(multipartWebRequest);
			}
			catch (final FileUploadException fux)
			{
				// Create model with exception and maximum size values
				final Map<String, Object> model = new HashMap<>();
				model.put(""exception"", fux);
				model.put(""maxSize"", getMaxSize());
				model.put(""fileMaxSize"", getFileMaxSize());

				onFileUploadException(fux, model);

				// don't process the form if there is a FileUploadException
				return false;
			}
		}
		return true;
	}","protected boolean handleMultiPart()
	{
		if (isMultiPart())
		{
			// Change the request to a multipart web request so parameters are
			// parsed out correctly
			try
			{
				ServletWebRequest request = (ServletWebRequest)getRequest();
				final MultipartServletWebRequest multipartWebRequest = request.newMultipartWebRequest(getMaxSize(), getPage().getId());
				multipartWebRequest.setFileMaxSize(getFileMaxSize());
				multipartWebRequest.parseFileParts();

				// TODO: Can't this be detected from header?
				getRequestCycle().setRequest(multipartWebRequest);
			}
			catch (final FileUploadException fux)
			{
				// Create model with exception and maximum size values
				final Map<String, Object> model = new HashMap<>();
				model.put(""exception"", fux);
				model.put(""maxSize"", getMaxSize());
				model.put(""fileMaxSize"", getFileMaxSize());

				onFileUploadException(fux, model);

				// don't process the form if there is a FileUploadException
				return false;
			}
		}
		return true;
	}",0,[0]
38681,bugs-dot-jar_ACCUMULO-2487_f2920c26,"public void set(final byte[] b) {
    this.value = b;
  }","public void set(final byte[] b) {
    Preconditions.checkNotNull(b);
    this.value = b;
  }",1,[]
16609,bugs-dot-jar_FLINK-1848_7164b2b6,"@Override
	public void write(DataOutputView out) throws IOException {

		if (uri == null) {
			out.writeBoolean(false);
		} else {
			out.writeBoolean(true);
			StringUtils.writeNullableString(uri.getScheme(), out);
			StringUtils.writeNullableString(uri.getUserInfo(), out);
			StringUtils.writeNullableString(uri.getHost(), out);
			out.writeInt(uri.getPort());
			StringUtils.writeNullableString(uri.getPath(), out);
			StringUtils.writeNullableString(uri.getQuery(), out);
			StringUtils.writeNullableString(uri.getFragment(), out);
		}

	}","@Override
	public void write(DataOutputView out) throws IOException {

		if (uri == null) {
			out.writeBoolean(false);
		} else {
			out.writeBoolean(true);
			StringUtils.writeNullableString(uri.getScheme(), out);
			StringUtils.writeNullableString(uri.getUserInfo(), out);
			StringUtils.writeNullableString(uri.getHost(), out);
			out.writeInt(uri.getPort());
			StringUtils.writeNullableString(uri.getPath(), out);
			StringUtils.writeNullableString(uri.getQuery(), out);
			StringUtils.writeNullableString(uri.getFragment(), out);
		}

	}",0,[0]
36326,bugs-dot-jar_CAMEL-9444_baece126,"public SplitDefinition onPrepareRef(String onPrepareRef) {
        setOnPrepareRef(onPrepareRef);
        return this;
    }","public SplitDefinition onPrepareRef(String onPrepareRef) {
        setOnPrepareRef(onPrepareRef);
        return this;
    }",0,[0]
1537,bugs-dot-jar_MATH-290_b01fcc31,"private int getConstraintTypeCounts(final Relationship relationship) {
        int count = 0;
        for (final LinearConstraint constraint : constraints) {
            if (constraint.getRelationship() == relationship) {
                ++count;
            }
        }
        return count;
    }","private int getConstraintTypeCounts(final Relationship relationship) {
        int count = 0;
        for (final LinearConstraint constraint : constraints) {
            if (constraint.getRelationship() == relationship) {
                ++count;
            }
        }
        return count;
    }",0,[0]
6894,bugs-dot-jar_OAK-2062_5c4589bd,"private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {
        boolean asterisk = oakPropertyName.indexOf('*') >= 0;
        if (asterisk) {
            Tree t = currentTree();
            ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();
            readOakProperties(list, t, oakPropertyName, propertyType);
            if (list.size() == 0) {
                return null;
            } else if (list.size() == 1) {
                return list.get(0);
            }
            Type<?> type = list.get(0).getType();
            for (int i = 1; i < list.size(); i++) {
                Type<?> t2 = list.get(i).getType();
                if (t2 != type) {
                    // types don't match
                    type = Type.STRING;
                    break;
                }
            }
            if (type == Type.STRING) {
                ArrayList<String> strings = new ArrayList<String>();
                for (PropertyValue p : list) {
                    Iterables.addAll(strings, p.getValue(Type.STRINGS));
                }
                return PropertyValues.newString(strings);
            }
            @SuppressWarnings(""unchecked"")
            PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);
            builder.setName("""");
            for (PropertyValue v : list) {
                builder.addValue(v.getValue(type));
            }
            PropertyState s = builder.getPropertyState();
            return PropertyValues.create(s);
        }
        boolean relative = oakPropertyName.indexOf('/') >= 0;
        Tree t = currentTree();
        if (relative) {
            for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
                if (t == null) {
                    return null;
                }
                if (p.equals("".."")) {
                    t = t.isRoot() ? null : t.getParent();
                } else if (p.equals(""."")) {
                    // same node
                } else {
                    t = t.getChild(p);
                }
            }
            oakPropertyName = PathUtils.getName(oakPropertyName);
        }
        return currentOakProperty(t, oakPropertyName, propertyType);
    }","private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {
        boolean asterisk = oakPropertyName.indexOf('*') >= 0;
        if (asterisk) {
            Tree t = currentTree();
            if (t != null) {
                LOG.trace(""currentOakProperty() - '*' case. looking for '{}' in '{}'"",
                    oakPropertyName, t.getPath());
            }
            ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();
            readOakProperties(list, t, oakPropertyName, propertyType);
            if (list.size() == 0) {
                return null;
            } else if (list.size() == 1) {
                return list.get(0);
            }
            Type<?> type = list.get(0).getType();
            for (int i = 1; i < list.size(); i++) {
                Type<?> t2 = list.get(i).getType();
                if (t2 != type) {
                    // types don't match
                    type = Type.STRING;
                    break;
                }
            }
            if (type == Type.STRING) {
                ArrayList<String> strings = new ArrayList<String>();
                for (PropertyValue p : list) {
                    Iterables.addAll(strings, p.getValue(Type.STRINGS));
                }
                return PropertyValues.newString(strings);
            }
            @SuppressWarnings(""unchecked"")
            PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);
            builder.setName("""");
            for (PropertyValue v : list) {
                builder.addValue(v.getValue(type));
            }
            PropertyState s = builder.getPropertyState();
            return PropertyValues.create(s);
        }
        boolean relative = oakPropertyName.indexOf('/') >= 0;
        Tree t = currentTree();
        if (relative) {
            for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
                if (t == null) {
                    return null;
                }
                if (p.equals("".."")) {
                    t = t.isRoot() ? null : t.getParent();
                } else if (p.equals(""."")) {
                    // same node
                } else {
                    t = t.getChild(p);
                }
            }
            oakPropertyName = PathUtils.getName(oakPropertyName);
        }
        return currentOakProperty(t, oakPropertyName, propertyType);
    }",1,[]
2321,bugs-dot-jar_MNG-4918_691a03a7,"public void addProjectReference( MavenProject project )
    {
        projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );
    }","public void addProjectReference( MavenProject project )
    {
        projectReferences.put( getProjectReferenceId( project.getGroupId(), project.getArtifactId(), project.getVersion() ), project );
    }",0,[0]
6359,bugs-dot-jar_ACCUMULO-3015_f848178e,"public void setTable(String table) {
    this.table = table;
  }","public void setTable(String table) {
    this.table = table;
  }",0,[0]
31403,bugs-dot-jar_CAMEL-9340_1cab39f6,"public void setCacheSize(int size) {
        if (cache != null) {
            cache.clear();
        }
        cache = new LRUCache<String, Object>(size);
    }","public void setCacheSize(int size) {
        if (cache != null) {
            cache.clear();
        }
        cache = new LRUCache<String, Object>(size);
    }",0,[0]
10898,bugs-dot-jar_CAMEL-5437_da05f5aa,"@Override
    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {
        this.maxMessagesPerPoll = maxMessagesPerPoll;
    }","@Override
    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {
        this.maxMessagesPerPoll = maxMessagesPerPoll;
    }",0,[0]
13421,bugs-dot-jar_MATH-434_133cbc2d,"public SimplexSolver() {
        this(DEFAULT_EPSILON);
    }","public SimplexSolver() {
        this(DEFAULT_EPSILON, DEFAULT_ULPS);
    }",1,[1]
13753,bugs-dot-jar_MATH-318_83f18d52,"private void dqds(final int start, final int end) {

        eMin = work[4 * start + pingPong + 4];
        double d = work[4 * start + pingPong] - tau;
        dMin = d;
        dMin1 = -work[4 * start + pingPong];

        if (pingPong == 0) {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                final double tmp = work[j4 + 1] / work[j4 - 2];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4] = work[j4 - 1] * tmp;
                eMin = Math.min(work[j4], eMin);
            }
        } else {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                final double tmp = work[j4 + 2] / work[j4 - 3];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4 - 1] = work[j4] * tmp;
                eMin = Math.min(work[j4 - 1], eMin);
            }
        }

        // unroll last two steps.
        dN2 = d;
        dMin2 = dMin;
        int j4 = 4 * (end - 2) - pingPong - 1;
        int j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN2 + work[j4p2];
        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;
        dMin = Math.min(dMin, dN1);

        dMin1 = dMin;
        j4 = j4 + 4;
        j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN1 + work[j4p2];
        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;
        dMin = Math.min(dMin, dN);

        work[j4 + 2] = dN;
        work[4 * end - pingPong - 1] = eMin;

    }","private void dqds(final int start, final int end) {

        eMin = work[4 * start + pingPong + 4];
        double d = work[4 * start + pingPong] - tau;
        dMin = d;
        dMin1 = -work[4 * start + pingPong];

        if (pingPong == 0) {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 2] = d + work[j4 - 1];
                final double tmp = work[j4 + 1] / work[j4 - 2];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4] = work[j4 - 1] * tmp;
                eMin = Math.min(work[j4], eMin);
            }
        } else {
            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {
                work[j4 - 3] = d + work[j4];
                final double tmp = work[j4 + 2] / work[j4 - 3];
                d = d * tmp - tau;
                dMin = Math.min(dMin, d);
                work[j4 - 1] = work[j4] * tmp;
                eMin = Math.min(work[j4 - 1], eMin);
            }
        }

        // unroll last two steps.
        dN2 = d;
        dMin2 = dMin;
        int j4 = 4 * (end - 2) - pingPong - 1;
        int j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN2 + work[j4p2];
        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;
        dMin = Math.min(dMin, dN1);

        dMin1 = dMin;
        j4 = j4 + 4;
        j4p2 = j4 + 2 * pingPong - 1;
        work[j4 - 2] = dN1 + work[j4p2];
        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;
        dMin = Math.min(dMin, dN);

        work[j4 + 2] = dN;
        work[4 * end - pingPong - 1] = eMin;

    }",0,[0]
6361,bugs-dot-jar_ACCUMULO-3015_f848178e,"public String getInstanceName() {
    return instanceName;
  }","public String getInstanceName() {
    return instanceName;
  }",0,[0]
1312,Bears-158,"public Double getLatitude() {
        return getCellAsDouble(Latitude);
    }","public Double getLatitude() {
        return getCellAsDouble(Latitude);
    }",0,[0]
9037,bugs-dot-jar_OAK-3879_4faf31e3,"private IndexNode acquireIndexNode(IndexPlan plan) {
        return tracker.acquireIndexNode(getPlanResult(plan).indexPath);
    }","private IndexNode acquireIndexNode(IndexPlan plan) {
        return tracker.acquireIndexNode(getPlanResult(plan).indexPath);
    }",0,[0]
13358,bugs-dot-jar_WICKET-4775_1ac05533,"public PageParameters(final PageParameters copy)
	{
		if (copy != null)
		{
			if (copy.indexedParameters != null)
			{
				indexedParameters = new ArrayList<String>(copy.indexedParameters);
			}

			if (copy.namedParameters != null)
			{
				namedParameters = new ArrayList<Entry>(copy.namedParameters);
			}
		}
	}","public PageParameters(final PageParameters copy)
	{
		if (copy != null)
		{
			if (copy.indexedParameters != null)
			{
				indexedParameters = new ArrayList<String>(copy.indexedParameters);
			}

			if (copy.namedParameters != null)
			{
				namedParameters = new ArrayList<Entry>(copy.namedParameters);
			}
		}
	}",0,[0]
202,bugs-dot-jar_WICKET-2368_fae1601b,"public final <C extends Form<?>> void removePersistedFormData(final Class<C> formClass,
		final boolean disablePersistence)
	{
		// Check that formClass is an instanceof Form
		if (!Form.class.isAssignableFrom(formClass))
		{
			throw new WicketRuntimeException(""Form class "" + formClass.getName() +
				"" is not a subclass of Form"");
		}

		// Visit all children which are an instance of formClass
		visitChildren(formClass, new IVisitor<Component>()
		{
			public Object component(final Component component)
			{
				// They must be of type Form as well
				if (component instanceof Form)
				{
					// Delete persistent FormComponent data and disable
					// persistence
					((Form<?>)component).removePersistentFormComponentValues(disablePersistence);
				}
				return CONTINUE_TRAVERSAL;
			}
		});
	}","public final <C extends Form<?>> void removePersistedFormData(final Class<C> formClass,
		final boolean disablePersistence)
	{
		// Check that formClass is an instanceof Form
		if (!Form.class.isAssignableFrom(formClass))
		{
			throw new WicketRuntimeException(""Form class "" + formClass.getName() +
				"" is not a subclass of Form"");
		}

		// Visit all children which are an instance of formClass
		visitChildren(formClass, new IVisitor<Component>()
		{
			public Object component(final Component component)
			{
				// They must be of type Form as well
				if (component instanceof Form)
				{
					// Delete persistent FormComponent data and disable
					// persistence
					((Form<?>)component).removePersistentFormComponentValues(disablePersistence);
				}
				return CONTINUE_TRAVERSAL;
			}
		});
	}",0,[0]
201,bugs-dot-jar_WICKET-2368_fae1601b,"public final void onRedirect()
	{
	}","public final void onRedirect()
	{
	}",0,[0]
8009,bugs-dot-jar_ACCUMULO-3242_15e83709,"public static boolean exists(ZooKeeperConnectionInfo info, String zPath) throws KeeperException, InterruptedException {
    return getStatus(info, zPath) != null;
  }","public static boolean exists(ZooKeeperConnectionInfo info, String zPath) throws KeeperException, InterruptedException {
    return getStatus(info, zPath) != null;
  }",0,[0]
37151,bugs-dot-jar_CAMEL-7239_ae419224,"public String getHeaderName() {
        return headerName;
    }","public String getHeaderName() {
        return headerName;
    }",0,[0]
28708,bugs-dot-jar_FLINK-2734_8b40bb7a,"public DataStreamSource<String> socketTextStream(String hostname, int port) {
		return socketTextStream(hostname, port, '\n');
	}","public DataStreamSource<String> socketTextStream(String hostname, int port) {
		return socketTextStream(hostname, port, '\n');
	}",0,[0]
32575,bugs-dot-jar_WICKET-4370_7ca927c1,"public void addFile(String fieldName, File file, String contentType)
	{
		if (file == null)
		{
			throw new IllegalArgumentException(""File must not be null"");
		}

		if (file.exists() == false)
		{
			throw new IllegalArgumentException(
				""File does not exists. You must provide an existing file: "" +
					file.getAbsolutePath());
		}

		if (file.isFile() == false)
		{
			throw new IllegalArgumentException(
				""You can only add a File, which is not a directory. Only files can be uploaded."");
		}

		if (uploadedFiles == null)
		{
			uploadedFiles = new HashMap<String, UploadedFile>();
		}

		UploadedFile uf = new UploadedFile(fieldName, file, contentType);

		uploadedFiles.put(fieldName, uf);
		setUseMultiPartContentType(true);
	}","public void addFile(String fieldName, File file, String contentType)
	{
		if (file == null)
		{
			throw new IllegalArgumentException(""File must not be null"");
		}

		if (file.exists() == false)
		{
			throw new IllegalArgumentException(
				""File does not exists. You must provide an existing file: "" +
					file.getAbsolutePath());
		}

		if (file.isFile() == false)
		{
			throw new IllegalArgumentException(
				""You can only add a File, which is not a directory. Only files can be uploaded."");
		}

		if (uploadedFiles == null)
		{
			uploadedFiles = new HashMap<String, UploadedFile>();
		}

		UploadedFile uf = new UploadedFile(fieldName, file, contentType);

		uploadedFiles.put(fieldName, uf);
		setUseMultiPartContentType(true);
	}",0,[0]
18725,bugs-dot-jar_CAMEL-8106_39ccf5d6,"public void setMode(char mode) {
        this.mode = mode;
    }","public void setMode(char mode) {
        this.mode = mode;
    }",0,[0]
38063,bugs-dot-jar_WICKET-4173_84bbbf68,"@Override
	public void respond(RequestCycle requestCycle)
	{
		Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
		Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());

		//
		// the code below is little hairy but we have to handle 3 redirect policies,
		// 3 rendering strategies and two kind of requests (ajax and normal)
		//

		// try to get an already rendered buffered response for current URL
		BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);

		boolean isAjax = isAjax(requestCycle);

		boolean shouldPreserveClientUrl = ((WebRequest)requestCycle.getRequest()).shouldPreserveClientUrl();

		if (bufferedResponse != null)
		{
			logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
			// if there is saved response for this URL render it
			bufferedResponse.writeTo((WebResponse)requestCycle.getResponse());
		}
		else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||
			(isOnePassRender() && isAjax == false) //
			||
			(!isAjax //
				&&
				(targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) //
			|| (targetUrl.equals(currentUrl) && isRedirectToRender()) //
			) //
			|| shouldPreserveClientUrl) //
		{
			// if the policy is never to redirect
			// or one pass render mode is on
			// or the targetUrl matches current url and the page is not stateless
			// or the targetUrl matches current url, page is stateless but it's redirect-to-render
			// or the request determines that the current url should be preserved
			// just render the page
			BufferedWebResponse response = renderPage(currentUrl, requestCycle);
			if (response != null)
			{
				response.writeTo((WebResponse)requestCycle.getResponse());
			}
		}
		else if (getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT //
			||
			isRedirectToRender() //
			|| (isAjax && targetUrl.equals(currentUrl)))
		{
			// if target URL is different
			// and render policy is always-redirect or it's redirect-to-render
			redirectTo(targetUrl, requestCycle);
		}
		else if (!targetUrl.equals(currentUrl) //
			&&
			(getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless())))
		{
			// if target URL is different and session is temporary and page is stateless
			// this is special case when page is stateless but there is no session so we can't
			// render it to buffer

			// alternatively if URLs are different and we have a page class and not an instance we
			// can redirect to the url which will instantiate the instance of us

			// note: if we had session here we would render the page to buffer and then redirect to
			// URL generated *after* page has been rendered (the statelessness may change during
			// render). this would save one redirect because now we have to render to URL generated
			// *before* page is rendered, render the page, get URL after render and if the URL is
			// different (meaning page is not stateless), save the buffer and redirect again (which
			// is pretty much what the next step does)
			redirectTo(targetUrl, requestCycle);
		}
		else
		{
			if (isRedirectToBuffer() == false && logger.isWarnEnabled())
			{
				logger.warn(""Falling back to Redirect_To_Buffer render strategy because none of the conditions matched."");
			}

			// redirect to buffer
			BufferedWebResponse response = renderPage(targetUrl, requestCycle);

			if (response == null)
			{
				return;
			}

			// check if the url hasn't changed after page has been rendered
			// (i.e. the stateless flag might have changed which could result in different page url)
			Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());

			if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false)
			{
				// the amount of segments is different - generated relative URLs will not work, we
				// need to rerender the page. This shouldn't happen, but in theory it can - with
				// RequestHandlerEncoders that produce different URLs with different amount of
				// segments for stateless and stateful pages
				response = renderPage(targetUrl2, requestCycle);
			}

			if (currentUrl.equals(targetUrl2))
			{
				// no need to redirect when both urls are exactly the same
				response.writeTo((WebResponse)requestCycle.getResponse());
			}
			// if page is still stateless after render
			else if (getPage().isPageStateless() && !enableRedirectForStatelessPage())
			{
				// we don't want the redirect to happen for stateless page
				// example:
				// when a normal mounted stateful page is hit at /mount/point
				// wicket renders the page to buffer and redirects to /mount/point?12
				// but for stateless page the redirect is not necessary
				// also for listener interface on stateful page we want to redirect
				// after the listener is invoked, but on stateless page the user
				// must ask for redirect explicitly
				response.writeTo((WebResponse)requestCycle.getResponse());
			}
			else
			{
				storeBufferedResponse(targetUrl2, response);

				redirectTo(targetUrl2, requestCycle);
			}
		}
	}","@Override
	public void respond(RequestCycle requestCycle)
	{
		Url currentUrl = requestCycle.getUrlRenderer().getBaseUrl();
		Url targetUrl = requestCycle.mapUrlFor(getRenderPageRequestHandler());

		//
		// the code below is little hairy but we have to handle 3 redirect policies,
		// 3 rendering strategies and two kind of requests (ajax and normal)
		//

		// try to get an already rendered buffered response for current URL
		BufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);

		boolean isAjax = isAjax(requestCycle);

		boolean shouldPreserveClientUrl = ((WebRequest)requestCycle.getRequest()).shouldPreserveClientUrl();

		if (bufferedResponse != null)
		{
			logger.warn(""The Buffered response should be handled by BufferedResponseRequestHandler"");
			// if there is saved response for this URL render it
			bufferedResponse.writeTo((WebResponse)requestCycle.getResponse());
		}
		else if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||
			(isOnePassRender() && isAjax == false && getRedirectPolicy() != RedirectPolicy.ALWAYS_REDIRECT) //
			||
			(!isAjax //
				&&
				(targetUrl.equals(currentUrl) && !getPageProvider().isNewPageInstance() && !getPage().isPageStateless()) //
			|| (targetUrl.equals(currentUrl) && isRedirectToRender()) //
			) //
			|| shouldPreserveClientUrl) //
		{
			// if the policy is never to redirect
			// or one pass render mode is on
			// or the targetUrl matches current url and the page is not stateless
			// or the targetUrl matches current url, page is stateless but it's redirect-to-render
			// or the request determines that the current url should be preserved
			// just render the page
			BufferedWebResponse response = renderPage(currentUrl, requestCycle);
			if (response != null)
			{
				response.writeTo((WebResponse)requestCycle.getResponse());
			}
		}
		else if (getRedirectPolicy() == RedirectPolicy.ALWAYS_REDIRECT //
			||
			isRedirectToRender() //
			|| (isAjax && targetUrl.equals(currentUrl)))
		{
			// if target URL is different
			// and render policy is always-redirect or it's redirect-to-render
			redirectTo(targetUrl, requestCycle);
		}
		else if (!targetUrl.equals(currentUrl) //
			&&
			(getPageProvider().isNewPageInstance() || (isSessionTemporary() && getPage().isPageStateless())))
		{
			// if target URL is different and session is temporary and page is stateless
			// this is special case when page is stateless but there is no session so we can't
			// render it to buffer

			// alternatively if URLs are different and we have a page class and not an instance we
			// can redirect to the url which will instantiate the instance of us

			// note: if we had session here we would render the page to buffer and then redirect to
			// URL generated *after* page has been rendered (the statelessness may change during
			// render). this would save one redirect because now we have to render to URL generated
			// *before* page is rendered, render the page, get URL after render and if the URL is
			// different (meaning page is not stateless), save the buffer and redirect again (which
			// is pretty much what the next step does)
			redirectTo(targetUrl, requestCycle);
		}
		else
		{
			if (isRedirectToBuffer() == false && logger.isWarnEnabled())
			{
				logger.warn(""Falling back to Redirect_To_Buffer render strategy because none of the conditions matched."");
			}

			// redirect to buffer
			BufferedWebResponse response = renderPage(targetUrl, requestCycle);

			if (response == null)
			{
				return;
			}

			// check if the url hasn't changed after page has been rendered
			// (i.e. the stateless flag might have changed which could result in different page url)
			Url targetUrl2 = requestCycle.mapUrlFor(getRenderPageRequestHandler());

			if (targetUrl.getSegments().equals(targetUrl2.getSegments()) == false)
			{
				// the amount of segments is different - generated relative URLs will not work, we
				// need to rerender the page. This shouldn't happen, but in theory it can - with
				// RequestHandlerEncoders that produce different URLs with different amount of
				// segments for stateless and stateful pages
				response = renderPage(targetUrl2, requestCycle);
			}

			if (currentUrl.equals(targetUrl2))
			{
				// no need to redirect when both urls are exactly the same
				response.writeTo((WebResponse)requestCycle.getResponse());
			}
			// if page is still stateless after render
			else if (getPage().isPageStateless() && !enableRedirectForStatelessPage())
			{
				// we don't want the redirect to happen for stateless page
				// example:
				// when a normal mounted stateful page is hit at /mount/point
				// wicket renders the page to buffer and redirects to /mount/point?12
				// but for stateless page the redirect is not necessary
				// also for listener interface on stateful page we want to redirect
				// after the listener is invoked, but on stateless page the user
				// must ask for redirect explicitly
				response.writeTo((WebResponse)requestCycle.getResponse());
			}
			else
			{
				storeBufferedResponse(targetUrl2, response);

				redirectTo(targetUrl2, requestCycle);
			}
		}
	}",1,[25]
13464,bugs-dot-jar_OAK-2219_f2740ce1,"@Override
    public String getPlan(Filter filter, NodeState root) {
        return getPlanDescription(getIndexPlanBuilder(filter).build(), root);
    }","@Override
    public String getPlan(Filter filter, NodeState root) {
        return getPlanDescription(getIndexPlanBuilder(filter).build(), root);
    }",0,[0]
33184,bugs-dot-jar_WICKET-2202_24ac1a35,"public final void onFormSubmitted()
	{
		markFormsSubmitted();

		if (handleMultiPart())
		{
			// Tells FormComponents that a new user input has come
			inputChanged();

			String url = getRequest().getParameter(getHiddenFieldId());
			if (!Strings.isEmpty(url))
			{
				dispatchEvent(getPage(), url);
			}
			else
			{
				// First, see if the processing was triggered by a Wicket IFormSubmittingComponent
				final IFormSubmittingComponent submittingComponent = findSubmittingButton();

				// When processing was triggered by a Wicket IFormSubmittingComponent and that
				// component indicates it wants to be called immediately
				// (without processing), call IFormSubmittingComponent.onSubmit() right away.
				if (submittingComponent != null && !submittingComponent.getDefaultFormProcessing())
				{
					submittingComponent.onSubmit();
				}
				else
				{
					// this is the root form
					Form<?> formToProcess = this;

					// find out whether it was a nested form that was submitted
					if (submittingComponent != null)
					{
						formToProcess = submittingComponent.getForm();
					}

					// process the form for this request
					formToProcess.process(submittingComponent);
				}
			}
		}
		// If multi part did fail check if an error is registered and call
		// onError
		else if (hasError())
		{
			callOnError();
		}
	}","public final void onFormSubmitted()
	{
		markFormsSubmitted();

		if (handleMultiPart())
		{
			// Tells FormComponents that a new user input has come
			inputChanged();

			String url = getRequest().getParameter(getHiddenFieldId());
			if (!Strings.isEmpty(url))
			{
				dispatchEvent(getPage(), url);
			}
			else
			{
				// First, see if the processing was triggered by a Wicket IFormSubmittingComponent
				final IFormSubmittingComponent submittingComponent = findSubmittingButton();

				// When processing was triggered by a Wicket IFormSubmittingComponent and that
				// component indicates it wants to be called immediately
				// (without processing), call IFormSubmittingComponent.onSubmit() right away.
				if (submittingComponent != null && !submittingComponent.getDefaultFormProcessing())
				{
					submittingComponent.onSubmit();
				}
				else
				{
					// this is the root form
					Form<?> formToProcess = this;

					// find out whether it was a nested form that was submitted
					if (submittingComponent != null)
					{
						formToProcess = submittingComponent.getForm();
					}

					// process the form for this request
					formToProcess.process(submittingComponent);
				}
			}
		}
		// If multi part did fail check if an error is registered and call
		// onError
		else if (hasError())
		{
			callOnError();
		}
	}",0,[0]
5427,bugs-dot-jar_OAK-1186_52372042,"Node.Children getChildren(final String path, final Revision rev, final int limit)
            throws MicroKernelException {
        checkRevisionAge(rev, path);

        //Preemptive check. If we know there are no child then
        //return straight away
        final Node node = getNode(path, rev);
        if (node.hasNoChildren()) {
            return new Node.Children();
        }

        String key = path + ""@"" + rev;
        Node.Children children;
        try {
            children = nodeChildrenCache.get(key, new Callable<Node.Children>() {
                @Override
                public Node.Children call() throws Exception {
                    return readChildren(path, rev, limit);
                }
            });
        } catch (ExecutionException e) {
            throw new MicroKernelException(""Error occurred while fetching children nodes for path ""+path, e);
        }

        //In case the limit > cached children size and there are more child nodes
        //available then refresh the cache
        if (children.hasMore) {
            if (limit > children.children.size()) {
                children = readChildren(path, rev, limit);
                if (children != null) {
                    nodeChildrenCache.put(key, children);
                }
            }
        }
        return children;
    }","Node.Children getChildren(final String path, final Revision rev, final int limit)
            throws MicroKernelException {
        checkRevisionAge(rev, path);

        //Preemptive check. If we know there are no child then
        //return straight away
        final Node node = getNode(path, rev);
        if (node.hasNoChildren()) {
            return new Node.Children();
        }

        String key = path + ""@"" + rev;
        Node.Children children;
        try {
            children = nodeChildrenCache.get(key, new Callable<Node.Children>() {
                @Override
                public Node.Children call() throws Exception {
                    return readChildren(path, rev, limit);
                }
            });
        } catch (ExecutionException e) {
            throw new MicroKernelException(""Error occurred while fetching children nodes for path ""+path, e);
        }

        //In case the limit > cached children size and there are more child nodes
        //available then refresh the cache
        if (children.hasMore) {
            if (limit > children.children.size()) {
                children = readChildren(path, rev, limit);
                if (children != null) {
                    nodeChildrenCache.put(key, children);
                }
            }
        }
        return children;
    }",0,[0]
17109,bugs-dot-jar_MATH-949_f83bbc1d,"private static RealMatrix log(final RealMatrix m) {
        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
        for (int r = 0; r < m.getRowDimension(); r++) {
            for (int c = 0; c < m.getColumnDimension(); c++) {
                d[r][c] = Math.log(m.getEntry(r, c));
            }
        }
        return new Array2DRowRealMatrix(d, false);
    }","private static RealMatrix log(final RealMatrix m) {
        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
        for (int r = 0; r < m.getRowDimension(); r++) {
            for (int c = 0; c < m.getColumnDimension(); c++) {
                d[r][c] = Math.log(m.getEntry(r, c));
            }
        }
        return new Array2DRowRealMatrix(d, false);
    }",0,[0]
35735,bugs-dot-jar_WICKET-3297_71499e17,"protected void encodeResourceReferenceAttributes(Url url, ResourceReference reference)
	{
		String encoded = encodeResourceReferenceAttributes(reference.getUrlAttributes());
		if (!Strings.isEmpty(encoded))
		{
			url.getQueryParameters().add(new Url.QueryParameter(encoded, """"));
		}
	}","protected void encodeResourceReferenceAttributes(Url url, ResourceReference reference)
	{
		String encoded = encodeResourceReferenceAttributes(reference.getUrlAttributes());
		if (!Strings.isEmpty(encoded))
		{
			url.getQueryParameters().add(new Url.QueryParameter(encoded, """"));
		}
	}",0,[0]
31300,bugs-dot-jar_CAMEL-8125_36e7b668,"public static String parseText(CamelContext camelContext, String text) throws Exception {
        // ensure we support property placeholders
        return camelContext.resolvePropertyPlaceholders(text);
    }","public static String parseText(CamelContext camelContext, String text) throws Exception {
        // ensure we support property placeholders
        return camelContext.resolvePropertyPlaceholders(text);
    }",0,[0]
4351,bugs-dot-jar_CAMEL-4682_1e54865c,"public void setPackageScanClassResolver(PackageScanClassResolver packageScanClassResolver) {
        this.packageScanClassResolver = packageScanClassResolver;
    }","public void setPackageScanClassResolver(PackageScanClassResolver packageScanClassResolver) {
        this.packageScanClassResolver = packageScanClassResolver;
    }",0,[0]
1224,Bears-153,"public Microservice create(String appId, String microserviceName) {
    MicroserviceDefinition microserviceDefinition = MicroserviceDefinition.create(appId, microserviceName);
    return create(microserviceDefinition);
  }","public Microservice create(String appId, String microserviceName) {
    MicroserviceDefinition microserviceDefinition = MicroserviceDefinition.create(appId, microserviceName);
    return create(microserviceDefinition);
  }",0,[0]
11044,bugs-dot-jar_LOG4J2-478_11763dee,"private Transform() {
    }","private Transform() {
    }",0,[0]
24546,bugs-dot-jar_CAMEL-6593_7f8a295a,"public String getLanguage() {
        return """";
    }","public String getLanguage() {
        return """";
    }",0,[0]
6294,bugs-dot-jar_OAK-2439_beaca1a4,"@CheckForNull
    private IndexingRule getApplicableRule() {
        if (filter.matchesAllTypes()){
            return defn.getApplicableIndexingRule(JcrConstants.NT_BASE);
        } else {
            //TODO May be better if filter.getSuperTypes returned a list which maintains
            //inheritance order and then we iterate over that
            for (IndexingRule rule : defn.getDefinedRules()){
                if (filter.getSupertypes().contains(rule.getNodeTypeName())){
                    //Theoretically there may be multiple rules for same nodeType with
                    //some condition defined. So again find a rule which applies
                    IndexingRule matchingRule = defn.getApplicableIndexingRule(rule.getNodeTypeName());
                    if (matchingRule != null){
                        log.debug(""Applicable IndexingRule found {}"", matchingRule);
                        return rule;
                    }
                }
                //nt:base is applicable for all. This specific condition is
                //required to support mixin case as filter.getSupertypes() for mixin based
                //query only includes the mixin type and not nt:base
                if (rule.getNodeTypeName().equals(JcrConstants.NT_BASE)){
                    return rule;
                }
            }
            log.trace(""No applicable IndexingRule found for any of the superTypes {}"",
                filter.getSupertypes());
        }
        return null;
    }","@CheckForNull
    private IndexingRule getApplicableRule() {
        if (filter.matchesAllTypes()){
            return defn.getApplicableIndexingRule(JcrConstants.NT_BASE);
        } else {
            //TODO May be better if filter.getSuperTypes returned a list which maintains
            //inheritance order and then we iterate over that
            for (IndexingRule rule : defn.getDefinedRules()){
                if (filter.getSupertypes().contains(rule.getNodeTypeName())){
                    //Theoretically there may be multiple rules for same nodeType with
                    //some condition defined. So again find a rule which applies
                    IndexingRule matchingRule = defn.getApplicableIndexingRule(rule.getNodeTypeName());
                    if (matchingRule != null){
                        log.debug(""Applicable IndexingRule found {}"", matchingRule);
                        return rule;
                    }
                }
                //nt:base is applicable for all. This specific condition is
                //required to support mixin case as filter.getSupertypes() for mixin based
                //query only includes the mixin type and not nt:base
                if (rule.getNodeTypeName().equals(JcrConstants.NT_BASE)){
                    return rule;
                }
            }
            log.trace(""No applicable IndexingRule found for any of the superTypes {}"",
                filter.getSupertypes());
        }
        return null;
    }",0,[0]
1991,Bears-242,"@Override
  public void visitNode(AstNode astNode) {
    AstNode idNode = getMethodName(astNode);
    if (idNode != null) {
      String identifier = idNode.getTokenValue();
      if (!pattern.matcher(identifier).matches()) {
        getContext().createLineViolation(this,
          ""Rename method \""{0}\"" to match the regular expression {1}."", idNode, identifier, format);
      }
    }
  }","@Override
  public void visitNode(AstNode astNode) {
    AstNode idNode = getMethodName(astNode);
    if (idNode != null) {
      String identifier = idNode.getTokenValue();
      if (!pattern.matcher(identifier).matches()) {
        getContext().createLineViolation(this,
          ""Rename method \""{0}\"" to match the regular expression {1}."", idNode, identifier, format);
      }
    }
  }",0,[0]
18202,bugs-dot-jar_MATH-554_fbbb96eb,"@Override
  public String toString() {
      return DEFAULT_FORMAT.format(this);
  }","@Override
  public String toString() {
      return DEFAULT_FORMAT.format(this);
  }",0,[0]
876,Bears-118,"private boolean filterApproximate(Position position) {
        return filterApproximate && position.getBoolean(Position.KEY_APPROXIMATE);
    }","private boolean filterApproximate(Position position) {
        return filterApproximate && position.getBoolean(Position.KEY_APPROXIMATE);
    }",0,[0]
1012,bugs-dot-jar_ACCUMULO-3408_81d25bc2,"public static String commas(long i, long errMin, long errMax) {
    if (i < errMin || i > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(i));
    return bigNumberForQuantity(i);
  }","public static String commas(long i, long errMin, long errMax) {
    if (i < errMin || i > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(i));
    return bigNumberForQuantity(i);
  }",0,[0]
112,bugs-dot-jar_OAK-1822_3e83a4c1,"@SuppressWarnings(""unchecked"")
    private <T extends Document> T find(final Collection<T> collection,
                                       final String key,
                                       boolean preferCached,
                                       final int maxCacheAge) {
        if (collection != Collection.NODES) {
            return findUncached(collection, key, DocumentReadPreference.PRIMARY);
        }
        CacheValue cacheKey = new StringValue(key);
        NodeDocument doc;
        if (maxCacheAge > 0 || preferCached) {
            // first try without lock
            doc = nodesCache.getIfPresent(cacheKey);
            if (doc != null) {
                if (preferCached ||
                        getTime() - doc.getCreated() < maxCacheAge) {
                    if (doc == NodeDocument.NULL) {
                        return null;
                    }
                    return (T) doc;
                }
            }
        }
        try {
            Lock lock = getAndLock(key);
            try {
                if (maxCacheAge == 0) {
                    invalidateCache(collection, key);
                }
                while (true) {
                    doc = nodesCache.get(cacheKey, new Callable<NodeDocument>() {
                        @Override
                        public NodeDocument call() throws Exception {
                            NodeDocument doc = (NodeDocument) findUncached(collection, key, getReadPreference(maxCacheAge));
                            if (doc == null) {
                                doc = NodeDocument.NULL;
                            }
                            return doc;
                        }
                    });
                    if (maxCacheAge == 0 || preferCached) {
                        break;
                    }
                    if (getTime() - doc.getCreated() < maxCacheAge) {
                        break;
                    }
                    // too old: invalidate, try again
                    invalidateCache(collection, key);
                }
            } finally {
                lock.unlock();
            }
            if (doc == NodeDocument.NULL) {
                return null;
            } else {
                return (T) doc;
            }
        } catch (ExecutionException e) {
            throw new IllegalStateException(""Failed to load document with "" + key, e);
        }
    }","@SuppressWarnings(""unchecked"")
    private <T extends Document> T find(final Collection<T> collection,
                                       final String key,
                                       boolean preferCached,
                                       final int maxCacheAge) {
        if (collection != Collection.NODES) {
            return findUncached(collection, key, DocumentReadPreference.PRIMARY);
        }
        CacheValue cacheKey = new StringValue(key);
        NodeDocument doc;
        if (maxCacheAge > 0 || preferCached) {
            // first try without lock
            doc = nodesCache.getIfPresent(cacheKey);
            if (doc != null) {
                if (preferCached ||
                        getTime() - doc.getCreated() < maxCacheAge) {
                    if (doc == NodeDocument.NULL) {
                        return null;
                    }
                    return (T) doc;
                }
            }
        }
        try {
            Lock lock = getAndLock(key);
            try {
                if (maxCacheAge == 0) {
                    invalidateCache(collection, key);
                }
                while (true) {
                    doc = nodesCache.get(cacheKey, new Callable<NodeDocument>() {
                        @Override
                        public NodeDocument call() throws Exception {
                            NodeDocument doc = (NodeDocument) findUncached(collection, key, getReadPreference(maxCacheAge));
                            if (doc == null) {
                                doc = NodeDocument.NULL;
                            }
                            return doc;
                        }
                    });
                    if (maxCacheAge == 0 || preferCached) {
                        break;
                    }
                    if (getTime() - doc.getCreated() < maxCacheAge) {
                        break;
                    }
                    // too old: invalidate, try again
                    invalidateCache(collection, key);
                }
            } finally {
                lock.unlock();
            }
            if (doc == NodeDocument.NULL) {
                return null;
            } else {
                return (T) doc;
            }
        } catch (ExecutionException e) {
            throw new IllegalStateException(""Failed to load document with "" + key, e);
        }
    }",0,[0]
1263,bugs-dot-jar_WICKET-5546_f1af9e03,"public final Component setVisibilityAllowed(boolean allowed)
	{
		setFlag(FLAG_VISIBILITY_ALLOWED, allowed);
		return this;
	}","public final Component setVisibilityAllowed(boolean allowed)
	{
		setFlag(FLAG_VISIBILITY_ALLOWED, allowed);
		return this;
	}",0,[0]
35634,bugs-dot-jar_WICKET-16_6c5083b4,"protected IRequestTargetUrlCodingStrategy getMountEncoder(IRequestTarget requestTarget)
	{
		// TODO Post 1.2: Performance: Optimize algorithm if possible and/ or
		// cache lookup results
		for (Iterator i = mountsOnPath.values().iterator(); i.hasNext();)
		{
			IRequestTargetUrlCodingStrategy encoder = (IRequestTargetUrlCodingStrategy)i.next();
			if (encoder.matches(requestTarget))
			{
				return encoder;
			}
		}

		return null;
	}","protected IRequestTargetUrlCodingStrategy getMountEncoder(IRequestTarget requestTarget)
	{
		// TODO Post 1.2: Performance: Optimize algorithm if possible and/ or
		// cache lookup results
		for (Iterator i = mountsOnPath.values().iterator(); i.hasNext();)
		{
			IRequestTargetUrlCodingStrategy encoder = (IRequestTargetUrlCodingStrategy)i.next();
			if (encoder.matches(requestTarget))
			{
				return encoder;
			}
		}

		return null;
	}",0,[0]
34477,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"private static long lookupFlushID(KeyExtent extent, SortedMap<Key,Value> tabletsKeyValues) {
    Text row = extent.getMetadataEntry();
    for (Entry<Key,Value> entry : tabletsKeyValues.entrySet()) {
      Key key = entry.getKey();
      if (key.getRow().equals(row) && TabletsSection.ServerColumnFamily.FLUSH_COLUMN.equals(key.getColumnFamily(), key.getColumnQualifier()))
        return Long.parseLong(entry.getValue().toString());
    }

    return -1;
  }","private static long lookupFlushID(KeyExtent extent, SortedMap<Key,Value> tabletsKeyValues) {
    Text row = extent.getMetadataEntry();
    for (Entry<Key,Value> entry : tabletsKeyValues.entrySet()) {
      Key key = entry.getKey();
      if (key.getRow().equals(row) && TabletsSection.ServerColumnFamily.FLUSH_COLUMN.equals(key.getColumnFamily(), key.getColumnQualifier()))
        return Long.parseLong(entry.getValue().toString());
    }

    return -1;
  }",0,[0]
104,Bears-6,"public List<BeanPropertyDefinition> getProperties() {
        // make sure we return a copy, so caller can remove entries if need be:
        Map<String, POJOPropertyBuilder> props = getPropertyMap();
        return new ArrayList<BeanPropertyDefinition>(props.values());
    }","public List<BeanPropertyDefinition> getProperties() {
        // make sure we return a copy, so caller can remove entries if need be:
        Map<String, POJOPropertyBuilder> props = getPropertyMap();
        return new ArrayList<BeanPropertyDefinition>(props.values());
    }",0,[0]
1601,bugs-dot-jar_WICKET-5345_3fc7234e,"public boolean isFull()
	{
		return getHost() != null;
	}","public boolean isFull()
	{
		return getHost() != null;
	}",0,[0]
1050,Bears-138,"private boolean decodeGps(Position position, ChannelBuffer buf, boolean hasLength) {

        DateBuilder dateBuilder = new DateBuilder(timeZone)
                .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())
                .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());
        position.setTime(dateBuilder.getDate());

        if (hasLength && buf.readUnsignedByte() == 0) {
            return false;
        }

        position.set(Position.KEY_SATELLITES, BitUtil.to(buf.readUnsignedByte(), 4));

        double latitude = buf.readUnsignedInt() / 60.0 / 30000.0;
        double longitude = buf.readUnsignedInt() / 60.0 / 30000.0;
        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));

        int flags = buf.readUnsignedShort();
        position.setCourse(BitUtil.to(flags, 10));
        position.setValid(BitUtil.check(flags, 12));

        if (!BitUtil.check(flags, 10)) {
            latitude = -latitude;
        }
        if (BitUtil.check(flags, 11)) {
            longitude = -longitude;
        }

        position.setLatitude(latitude);
        position.setLongitude(longitude);

        if (BitUtil.check(flags, 14)) {
            position.set(Position.KEY_IGNITION, BitUtil.check(flags, 15));
        }

        return true;
    }","private boolean decodeGps(Position position, ChannelBuffer buf, boolean hasLength) {

        DateBuilder dateBuilder = new DateBuilder(timeZone)
                .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())
                .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());
        position.setTime(dateBuilder.getDate());

        if (hasLength && buf.readUnsignedByte() == 0) {
            return false;
        }

        position.set(Position.KEY_SATELLITES, BitUtil.to(buf.readUnsignedByte(), 4));

        double latitude = buf.readUnsignedInt() / 60.0 / 30000.0;
        double longitude = buf.readUnsignedInt() / 60.0 / 30000.0;
        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));

        int flags = buf.readUnsignedShort();
        position.setCourse(BitUtil.to(flags, 10));
        position.setValid(BitUtil.check(flags, 12));

        if (!BitUtil.check(flags, 10)) {
            latitude = -latitude;
        }
        if (BitUtil.check(flags, 11)) {
            longitude = -longitude;
        }

        position.setLatitude(latitude);
        position.setLongitude(longitude);

        if (BitUtil.check(flags, 14)) {
            position.set(Position.KEY_IGNITION, BitUtil.check(flags, 15));
        }

        return true;
    }",0,[0]
2666,bugs-dot-jar_OAK-1932_913c2f53,"CompactionMap(int compressInterval) {
        this.compressInterval = compressInterval;
    }","CompactionMap(int compressInterval) {
        this.compressInterval = compressInterval;
    }",0,[0]
3713,bugs-dot-jar_CAMEL-3448_b345dd82,"private static int getInheritanceLevel(Class<?> clazz) {
        if (clazz == null || ""java.lang.Object"".equals(clazz.getName())) {
            return 0;
        }
        return 1 + getInheritanceLevel(clazz.getSuperclass());
    }","private static int getInheritanceLevel(Class<?> clazz) {
        if (clazz == null || ""java.lang.Object"".equals(clazz.getName())) {
            return 0;
        }
        return 1 + getInheritanceLevel(clazz.getSuperclass());
    }",0,[0]
27134,bugs-dot-jar_MATH-395_962315ba,"public void setMaximalIterationCount(int count) {
        maximalIterationCount = count;
    }","public void setMaximalIterationCount(int count) {
        maximalIterationCount = count;
    }",0,[0]
19677,bugs-dot-jar_WICKET-4259_1f128536,"public AjaxEditableLabel(final String id)
	{
		super(id);
		setOutputMarkupId(true);
	}","public AjaxEditableLabel(final String id)
	{
		super(id);
		setOutputMarkupId(true);
	}",0,[0]
7301,bugs-dot-jar_MATH-320_c06cc933,"public RealMatrix getCovariance(final double minSingularValue) {

        // get the number of singular values to consider
        int dimension = 0;
        while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {
            ++dimension;
        }

        if (dimension == 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""cutoff singular value is {0}, should be at most {1}"",
                  minSingularValue, singularValues[0]);
        }

        final double[][] data = new double[dimension][n];
        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column, final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, dimension - 1, 0, n - 1);

        RealMatrix jv = new Array2DRowRealMatrix(data, false);
        return jv.transpose().multiply(jv);

    }","public RealMatrix getCovariance(final double minSingularValue) {

        // get the number of singular values to consider
        final int p = singularValues.length;
        int dimension = 0;
        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {
            ++dimension;
        }

        if (dimension == 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""cutoff singular value is {0}, should be at most {1}"",
                  minSingularValue, singularValues[0]);
        }

        final double[][] data = new double[dimension][p];
        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {
            /** {@inheritDoc} */
            @Override
            public void visit(final int row, final int column, final double value) {
                data[row][column] = value / singularValues[row];
            }
        }, 0, dimension - 1, 0, p - 1);

        RealMatrix jv = new Array2DRowRealMatrix(data, false);
        return jv.transpose().multiply(jv);

    }",1,"[4, 14, 21]"
534,Bears-16,"@SuppressWarnings(""unchecked"")
    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,
            BeanDescription beanDesc)
        throws JsonMappingException
    {
        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object
        // 05-Jul-2012, tatu: ... but we should be able to just return ""unknown type"" serializer, right?
        if (beanDesc.getBeanClass() == Object.class) {
            return prov.getUnknownTypeSerializer(Object.class);
//            throw new IllegalArgumentException(""Can not create bean serializer for Object.class"");
        }
        final SerializationConfig config = prov.getConfig();
        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);
        builder.setConfig(config);

        // First: any detectable (auto-detect, annotations) properties to serialize?
        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);
        if (props == null) {
            props = new ArrayList<BeanPropertyWriter>();
        } else {
            props = removeOverlappingTypeIds(prov, beanDesc, builder, props);
        }
        
        // [databind#638]: Allow injection of ""virtual"" properties:
        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);

        // [JACKSON-440] Need to allow modification bean properties to serialize:
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.changeProperties(config, beanDesc, props);
            }
        }

        // Any properties to suppress?
        props = filterBeanProperties(config, beanDesc, props);

        // Need to allow reordering of properties to serialize
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.orderProperties(config, beanDesc, props);
            }
        }

        /* And if Object Id is needed, some preparation for that as well: better
         * do before view handling, mostly for the custom id case which needs
         * access to a property
         */
        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));
        
        builder.setProperties(props);
        builder.setFilterId(findFilterId(config, beanDesc));

        AnnotatedMember anyGetter = beanDesc.findAnyGetter();
        if (anyGetter != null) {
            JavaType type = anyGetter.getType();
            // copied from BasicSerializerFactory.buildMapSerializer():
            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);
            JavaType valueType = type.getContentType();
            TypeSerializer typeSer = createTypeSerializer(config, valueType);
            // last 2 nulls; don't know key, value serializers (yet)
            // 23-Feb-2015, tatu: As per [databind#705], need to support custom serializers
            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);
            if (anySer == null) {
                // TODO: support '@JsonIgnoreProperties' with any setter?
                anySer = MapSerializer.construct(/* ignored props*/ (Set<String>) null,
                        type, staticTyping, typeSer, null, null, /*filterId*/ null);
            }
            // TODO: can we find full PropertyName?
            PropertyName name = PropertyName.construct(anyGetter.getName());
            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,
                    anyGetter, PropertyMetadata.STD_OPTIONAL);
            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));
        }
        // Next: need to gather view information, if any:
        processViews(config, builder);

        // Finally: let interested parties mess with the result bit more...
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                builder = mod.updateBuilder(config, beanDesc, builder);
            }
        }

        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();
        if (ser == null) {
            // If we get this far, there were no properties found, so no regular BeanSerializer
            // would be constructed. But, couple of exceptions.
            // First: if there are known annotations, just create 'empty bean' serializer
            if (beanDesc.hasKnownClassAnnotations()) {
                return builder.createDummy();
            }
        }
        return ser;
    }","@SuppressWarnings(""unchecked"")
    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,
            BeanDescription beanDesc)
        throws JsonMappingException
    {
        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object
        // 05-Jul-2012, tatu: ... but we should be able to just return ""unknown type"" serializer, right?
        if (beanDesc.getBeanClass() == Object.class) {
            return prov.getUnknownTypeSerializer(Object.class);
//            throw new IllegalArgumentException(""Can not create bean serializer for Object.class"");
        }
        final SerializationConfig config = prov.getConfig();
        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);
        builder.setConfig(config);

        // First: any detectable (auto-detect, annotations) properties to serialize?
        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);
        if (props == null) {
            props = new ArrayList<BeanPropertyWriter>();
        } else {
            props = removeOverlappingTypeIds(prov, beanDesc, builder, props);
        }
        
        // [databind#638]: Allow injection of ""virtual"" properties:
        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);

        // [JACKSON-440] Need to allow modification bean properties to serialize:
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.changeProperties(config, beanDesc, props);
            }
        }

        // Any properties to suppress?
        props = filterBeanProperties(config, beanDesc, props);

        // Need to allow reordering of properties to serialize
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.orderProperties(config, beanDesc, props);
            }
        }

        /* And if Object Id is needed, some preparation for that as well: better
         * do before view handling, mostly for the custom id case which needs
         * access to a property
         */
        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));
        
        builder.setProperties(props);
        builder.setFilterId(findFilterId(config, beanDesc));

        AnnotatedMember anyGetter = beanDesc.findAnyGetter();
        if (anyGetter != null) {
            JavaType type = anyGetter.getType();
            // copied from BasicSerializerFactory.buildMapSerializer():
            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);
            JavaType valueType = type.getContentType();
            TypeSerializer typeSer = createTypeSerializer(config, valueType);
            // last 2 nulls; don't know key, value serializers (yet)
            // 23-Feb-2015, tatu: As per [databind#705], need to support custom serializers
            JsonSerializer<?> anySer = findSerializerFromAnnotation(prov, anyGetter);
            if (anySer == null) {
                // TODO: support '@JsonIgnoreProperties' with any setter?
                anySer = MapSerializer.construct(/* ignored props*/ (Set<String>) null,
                        type, staticTyping, typeSer, null, null, /*filterId*/ null);
            }
            // TODO: can we find full PropertyName?
            PropertyName name = PropertyName.construct(anyGetter.getName());
            BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,
                    anyGetter, PropertyMetadata.STD_OPTIONAL);
            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));
        }
        // Next: need to gather view information, if any:
        processViews(config, builder);

        // Finally: let interested parties mess with the result bit more...
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                builder = mod.updateBuilder(config, beanDesc, builder);
            }
        }

        JsonSerializer<Object> ser = null;
        try {
            ser = (JsonSerializer<Object>) builder.build();
        } catch (RuntimeException e) {
            prov.reportBadTypeDefinition(beanDesc, ""Failed to construct BeanSerializer for %s: (%s) %s"",
                    beanDesc.getType(), e.getClass().getName(), e.getMessage());
        }
        if (ser == null) {
            // If we get this far, there were no properties found, so no regular BeanSerializer
            // would be constructed. But, couple of exceptions.
            // First: if there are known annotations, just create 'empty bean' serializer
            if (beanDesc.hasKnownClassAnnotations()) {
                return builder.createDummy();
            }
        }
        return ser;
    }",1,[83]
2845,bugs-dot-jar_OAK-1364_05c89637,"boolean replace(K key, V oldValue, V newValue) {
        int hash = getHash(key);
        return getSegment(hash).replace(key, hash, oldValue, newValue, sizeOf(key, newValue));
    }","boolean replace(K key, V oldValue, V newValue) {
        int hash = getHash(key);
        return getSegment(hash).replace(key, hash, oldValue, newValue, sizeOf(key, newValue));
    }",0,[0]
36519,bugs-dot-jar_MATH-1093_7cfbc0da,"public Iterator<double[]> iterator() {
        return new SubArcsIterator();
    }","public Iterator<double[]> iterator() {
        return new SubArcsIterator();
    }",0,[0]
12599,bugs-dot-jar_CAMEL-3847_de9399f3,"@SuppressWarnings(""unchecked"")
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        if (!isRunAllowed()) {
            throw new IllegalStateException(this + "" is not started"");
        }

        Object answer;
        try {
            answer = doConvertTo(type, exchange, value);
        } catch (Exception e) {
            // if its a ExecutionException then we have rethrow it as its not due to failed conversion
            boolean execution = ObjectHelper.getException(ExecutionException.class, e) != null
                    || ObjectHelper.getException(CamelExecutionException.class, e) != null;
            if (execution) {
                throw ObjectHelper.wrapCamelExecutionException(exchange, e);
            }

            // we cannot convert so return null
            if (log.isDebugEnabled()) {
                log.debug(""{} Caused by: {}. Will ignore this and continue."", NoTypeConversionAvailableException.createMessage(value, type), e.getMessage());
            }
            return null;
        }
        if (answer == Void.TYPE) {
            // Could not find suitable conversion
            return null;
        } else {
            return (T) answer;
        }
    }","@SuppressWarnings(""unchecked"")
    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {
        if (!isRunAllowed()) {
            throw new IllegalStateException(this + "" is not started"");
        }

        Object answer;
        try {
            answer = doConvertTo(type, exchange, value);
        } catch (Exception e) {
            // if its a ExecutionException then we have rethrow it as its not due to failed conversion
            boolean execution = ObjectHelper.getException(ExecutionException.class, e) != null
                    || ObjectHelper.getException(CamelExecutionException.class, e) != null;
            if (execution) {
                throw ObjectHelper.wrapCamelExecutionException(exchange, e);
            }

            // we cannot convert so return null
            if (log.isDebugEnabled()) {
                log.debug(""{} Caused by: {}. Will ignore this and continue."", NoTypeConversionAvailableException.createMessage(value, type), e.getMessage());
            }
            return null;
        }
        if (answer == Void.TYPE) {
            // Could not find suitable conversion
            return null;
        } else {
            return (T) answer;
        }
    }",0,[0]
8747,bugs-dot-jar_WICKET-5883_cd3b9234,"@Override
	protected void onDetach()
	{
		setFlag(FLAG_SUBMITTED, false);

		super.onDetach();
	}","@Override
	protected void onDetach()
	{
		setFlag(FLAG_SUBMITTED, false);

		super.onDetach();
	}",0,[0]
34733,bugs-dot-jar_CAMEL-8964_ea8ee025,"protected synchronized void doStop() throws Exception {
        stopWatch.restart();
        log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") is shutting down"");
        EventHelper.notifyCamelContextStopping(this);

        // stop route inputs in the same order as they was started so we stop the very first inputs first
        try {
            // force shutting down routes as they may otherwise cause shutdown to hang
            shutdownStrategy.shutdownForced(this, getRouteStartupOrder());
        } catch (Throwable e) {
            log.warn(""Error occurred while shutting down routes. This exception will be ignored."", e);
        }
        getRouteStartupOrder().clear();

        // shutdown await manager to trigger interrupt of blocked threads to attempt to free these threads graceful
        shutdownServices(asyncProcessorAwaitManager);

        shutdownServices(routeServices.values());
        // do not clear route services or startup listeners as we can start Camel again and get the route back as before

        // but clear any suspend routes
        suspendedRouteServices.clear();

        // stop consumers from the services to close first, such as POJO consumer (eg @Consumer)
        // which we need to stop after the routes, as a POJO consumer is essentially a route also
        for (Service service : servicesToStop) {
            if (service instanceof Consumer) {
                shutdownServices(service);
            }
        }

        // the stop order is important

        // shutdown default error handler thread pool
        if (errorHandlerExecutorService != null) {
            // force shutting down the thread pool
            getExecutorServiceManager().shutdownNow(errorHandlerExecutorService);
            errorHandlerExecutorService = null;
        }

        // shutdown debugger
        ServiceHelper.stopAndShutdownService(getDebugger());

        shutdownServices(endpoints.values());
        endpoints.clear();

        shutdownServices(components.values());
        components.clear();

        shutdownServices(languages.values());
        languages.clear();

        try {
            for (LifecycleStrategy strategy : lifecycleStrategies) {
                strategy.onContextStop(this);
            }
        } catch (Throwable e) {
            log.warn(""Error occurred while stopping lifecycle strategies. This exception will be ignored."", e);
        }

        // shutdown services as late as possible
        shutdownServices(servicesToStop);
        servicesToStop.clear();

        // must notify that we are stopped before stopping the management strategy
        EventHelper.notifyCamelContextStopped(this);

        // stop the notifier service
        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
            shutdownServices(notifier);
        }

        // shutdown executor service and management as the last one
        shutdownServices(executorServiceManager);
        shutdownServices(managementStrategy);
        shutdownServices(managementMBeanAssembler);
        shutdownServices(lifecycleStrategies);
        // do not clear lifecycleStrategies as we can start Camel again and get the route back as before

        // stop the lazy created so they can be re-created on restart
        forceStopLazyInitialization();

        // stop to clear introspection cache
        IntrospectionSupport.stop();

        stopWatch.stop();
        if (log.isInfoEnabled()) {
            log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") uptime {}"", getUptime());
            log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") is shutdown in "" + TimeUtils.printDuration(stopWatch.taken()));
        }

        // and clear start date
        startDate = null;

        // [TODO] Remove in 3.0
        Container.Instance.unmanage(this);
    }","protected synchronized void doStop() throws Exception {
        stopWatch.restart();
        log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") is shutting down"");
        EventHelper.notifyCamelContextStopping(this);

        // stop route inputs in the same order as they was started so we stop the very first inputs first
        try {
            // force shutting down routes as they may otherwise cause shutdown to hang
            shutdownStrategy.shutdownForced(this, getRouteStartupOrder());
        } catch (Throwable e) {
            log.warn(""Error occurred while shutting down routes. This exception will be ignored."", e);
        }
        getRouteStartupOrder().clear();

        // shutdown await manager to trigger interrupt of blocked threads to attempt to free these threads graceful
        shutdownServices(asyncProcessorAwaitManager);

        shutdownServices(routeServices.values());
        // do not clear route services or startup listeners as we can start Camel again and get the route back as before

        // but clear any suspend routes
        suspendedRouteServices.clear();

        // stop consumers from the services to close first, such as POJO consumer (eg @Consumer)
        // which we need to stop after the routes, as a POJO consumer is essentially a route also
        for (Service service : servicesToStop) {
            if (service instanceof Consumer) {
                shutdownServices(service);
            }
        }

        // the stop order is important

        // shutdown default error handler thread pool
        if (errorHandlerExecutorService != null) {
            // force shutting down the thread pool
            getExecutorServiceManager().shutdownNow(errorHandlerExecutorService);
            errorHandlerExecutorService = null;
        }

        // shutdown debugger
        ServiceHelper.stopAndShutdownService(getDebugger());

        shutdownServices(endpoints.values());
        endpoints.clear();

        shutdownServices(components.values());
        components.clear();

        shutdownServices(languages.values());
        languages.clear();

        try {
            for (LifecycleStrategy strategy : lifecycleStrategies) {
                strategy.onContextStop(this);
            }
        } catch (Throwable e) {
            log.warn(""Error occurred while stopping lifecycle strategies. This exception will be ignored."", e);
        }

        // shutdown services as late as possible
        shutdownServices(servicesToStop);
        servicesToStop.clear();

        // must notify that we are stopped before stopping the management strategy
        EventHelper.notifyCamelContextStopped(this);

        // stop the notifier service
        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
            shutdownServices(notifier);
        }

        // shutdown executor service and management as the last one
        shutdownServices(executorServiceManager);
        shutdownServices(managementStrategy);
        shutdownServices(managementMBeanAssembler);
        shutdownServices(lifecycleStrategies);
        // do not clear lifecycleStrategies as we can start Camel again and get the route back as before

        // stop the lazy created so they can be re-created on restart
        forceStopLazyInitialization();

        // stop to clear introspection cache
        IntrospectionSupport.stop();

        stopWatch.stop();
        if (log.isInfoEnabled()) {
            log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") uptime {}"", getUptime());
            log.info(""Apache Camel "" + getVersion() + "" (CamelContext: "" + getName() + "") is shutdown in "" + TimeUtils.printDuration(stopWatch.taken()));
        }

        // and clear start date
        startDate = null;

        // [TODO] Remove in 3.0
        Container.Instance.unmanage(this);
    }",0,[0]
21020,bugs-dot-jar_OAK-846_7acb091a,"public void applyToCache() {
        HashMap<String, ArrayList<String>> nodesWithChangedChildren = new HashMap<String, ArrayList<String>>();
        ArrayList<String> addOrRemove = new ArrayList<String>();
        addOrRemove.addAll(addedNodes);
        addOrRemove.addAll(removedNodes);
        for (String p : addOrRemove) {
            String parent = PathUtils.getParentPath(p);
            ArrayList<String> list = nodesWithChangedChildren.get(parent);
            if (list == null) {
                list = new ArrayList<String>();
                nodesWithChangedChildren.put(parent, list);
            }
            list.add(p);
        }
        for (String path : changedNodes) {
            ArrayList<String> added = new ArrayList<String>();
            ArrayList<String> removed = new ArrayList<String>();
            ArrayList<String> changed = nodesWithChangedChildren.get(path);
            if (changed != null) {
                for (String s : changed) {
                    if (addedNodes.contains(s)) {
                        added.add(s);
                    } else if (removedNodes.contains(s)) {
                        removed.add(s);
                    }
                }
            }
            UpdateOp op = operations.get(path);
            boolean isNew = op != null && op.isNew;
            boolean isWritten = op != null;
            boolean isDelete = op != null && op.isDelete;
            mk.applyChanges(revision, path, 
                    isNew, isDelete, isWritten, 
                    added, removed);
        }
    }","public void applyToCache() {
        HashMap<String, ArrayList<String>> nodesWithChangedChildren = new HashMap<String, ArrayList<String>>();
        ArrayList<String> addOrRemove = new ArrayList<String>();
        addOrRemove.addAll(addedNodes);
        addOrRemove.addAll(removedNodes);
        for (String p : addOrRemove) {
            String parent = PathUtils.getParentPath(p);
            ArrayList<String> list = nodesWithChangedChildren.get(parent);
            if (list == null) {
                list = new ArrayList<String>();
                nodesWithChangedChildren.put(parent, list);
            }
            list.add(p);
        }
        for (String path : changedNodes) {
            ArrayList<String> added = new ArrayList<String>();
            ArrayList<String> removed = new ArrayList<String>();
            ArrayList<String> changed = nodesWithChangedChildren.get(path);
            if (changed != null) {
                for (String s : changed) {
                    if (addedNodes.contains(s)) {
                        added.add(s);
                    } else if (removedNodes.contains(s)) {
                        removed.add(s);
                    }
                }
            }
            UpdateOp op = operations.get(path);
            boolean isNew = op != null && op.isNew;
            boolean isWritten = op != null;
            boolean isDelete = op != null && op.isDelete;
            mk.applyChanges(revision, path, 
                    isNew, isDelete, isWritten, 
                    added, removed);
        }
    }",0,[0]
40115,bugs-dot-jar_OAK-1429_c2f5ca6c,"private String diffImpl(DocumentNodeState from, DocumentNodeState to)
            throws MicroKernelException {
        JsopWriter w = new JsopStream();
        diffProperties(from, to, w);
        // TODO this does not work well for large child node lists
        // use a document store index instead
        int max = MANY_CHILDREN_THRESHOLD;
        DocumentNodeState.Children fromChildren, toChildren;
        fromChildren = getChildren(from, null, max);
        toChildren = getChildren(to, null, max);
        if (!fromChildren.hasMore && !toChildren.hasMore) {
            diffFewChildren(w, fromChildren, from.getLastRevision(),
                    toChildren, to.getLastRevision());
        } else {
            if (FAST_DIFF) {
                diffManyChildren(w, from.getPath(),
                        from.getLastRevision(), to.getLastRevision());
            } else {
                max = Integer.MAX_VALUE;
                fromChildren = getChildren(from, null, max);
                toChildren = getChildren(to, null, max);
                diffFewChildren(w, fromChildren, from.getLastRevision(),
                        toChildren, to.getLastRevision());
            }
        }
        return w.toString();
    }","private String diffImpl(DocumentNodeState from, DocumentNodeState to)
            throws MicroKernelException {
        JsopWriter w = new JsopStream();
        // TODO this does not work well for large child node lists
        // use a document store index instead
        int max = MANY_CHILDREN_THRESHOLD;
        DocumentNodeState.Children fromChildren, toChildren;
        fromChildren = getChildren(from, null, max);
        toChildren = getChildren(to, null, max);
        if (!fromChildren.hasMore && !toChildren.hasMore) {
            diffFewChildren(w, from.getPath(), fromChildren,
                    from.getLastRevision(), toChildren, to.getLastRevision());
        } else {
            if (FAST_DIFF) {
                diffManyChildren(w, from.getPath(),
                        from.getLastRevision(), to.getLastRevision());
            } else {
                max = Integer.MAX_VALUE;
                fromChildren = getChildren(from, null, max);
                toChildren = getChildren(to, null, max);
                diffFewChildren(w, from.getPath(), fromChildren,
                        from.getLastRevision(), toChildren, to.getLastRevision());
            }
        }
        return w.toString();
    }",1,"[3, 11, 12, 21, 22]"
20289,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Override
  public Set<TokenProperty> getProperties() {
    Set<TokenProperty> internal = new LinkedHashSet<TokenProperty>();
    internal.add(new TokenProperty(""password"", ""the password for the principal"", true));
    return internal;
  }","@Override
  public Set<TokenProperty> getProperties() {
    Set<TokenProperty> internal = new LinkedHashSet<TokenProperty>();
    internal.add(new TokenProperty(""password"", ""the password for the principal"", true));
    return internal;
  }",0,[0]
4268,bugs-dot-jar_CAMEL-4682_1e54865c,"public LanguageResolver getLanguageResolver() {
        if (languageResolver == null) {
            languageResolver = new DefaultLanguageResolver();
        }
        return languageResolver;
    }","public LanguageResolver getLanguageResolver() {
        if (languageResolver == null) {
            languageResolver = new DefaultLanguageResolver();
        }
        return languageResolver;
    }",0,[0]
20726,bugs-dot-jar_WICKET-5960_03663750,"public HtmlHeaderContainer(final String id)
	{
		super(id);

		// We will render the tags manually, because if no component asked to
		// contribute to the header, the tags will not be printed either.
		// No contribution usually only happens if none of the components
		// including the page does have a <head> or <wicket:head> tag.
		setRenderBodyOnly(true);

		setAuto(true);
	}","public HtmlHeaderContainer(final String id)
	{
		super(id);

		// We will render the tags manually, because if no component asked to
		// contribute to the header, the tags will not be printed either.
		// No contribution usually only happens if none of the components
		// including the page does have a <head> or <wicket:head> tag.
		setRenderBodyOnly(true);

		setAuto(true);
	}",0,[0]
15902,bugs-dot-jar_LOG4J2-177_f91ce934,"@Override
    public synchronized void flush() throws IOException {
        if (this.ds != null && this.address != null) {
            final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
            ds.send(packet);
        }
        data = null;
    }","@Override
    public synchronized void flush() throws IOException {
        if (this.data != null && this.ds != null && this.address != null) {
            final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
            ds.send(packet);
        }
        data = null;
    }",1,[2]
18726,bugs-dot-jar_CAMEL-8106_39ccf5d6,"public void setMode(String mode) {
        this.mode = mode != null ? mode.charAt(0) : 0;
    }","public void setMode(String mode) {
        this.mode = mode != null ? mode.charAt(0) : 0;
    }",0,[0]
636,Bears-18,"@Override
    public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a) {
        JsonCreator ann = _findAnnotation(a, JsonCreator.class);
        if (ann != null) {
            return ann.mode();
        }

        if (_cfgConstructorPropertiesImpliesCreator
                && config.isEnabled(MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES)
            ) {
            if (a instanceof AnnotatedConstructor) {
                if (_java7Helper != null) {
                    Boolean b = _java7Helper.hasCreatorAnnotation(a);
                    if ((b != null) && b.booleanValue()) {
                        // 13-Sep-2016, tatu: Judgment call, but I don't think JDK ever implies
                        //    use of delegate; assumes as-properties implicitly
                        return JsonCreator.Mode.PROPERTIES;
                    }
                }
            }
        }
        return null;
    }","@Override
    public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a) {
        JsonCreator ann = _findAnnotation(a, JsonCreator.class);
        if (ann != null) {
            return ann.mode();
        }

        if (_cfgConstructorPropertiesImpliesCreator
                && config.isEnabled(MapperFeature.INFER_CREATOR_FROM_CONSTRUCTOR_PROPERTIES)
            ) {
            if (a instanceof AnnotatedConstructor) {
                if (_java7Helper != null) {
                    Boolean b = _java7Helper.hasCreatorAnnotation(a);
                    if ((b != null) && b.booleanValue()) {
                        // 13-Sep-2016, tatu: Judgment call, but I don't think JDK ever implies
                        //    use of delegate; assumes as-properties implicitly
                        return JsonCreator.Mode.PROPERTIES;
                    }
                }
            }
        }
        return null;
    }",0,[0]
13806,bugs-dot-jar_OAK-596_9b268da0,"public void setProperties(Map<String, Object> properties) {
        if (properties != null && !properties.isEmpty()) {
            put(KEY_PROPERTIES, properties);
        } else {
            removeField(KEY_PROPERTIES);
        }
    }","public void setProperties(Map<String, Object> properties) {
        if (properties != null && !properties.isEmpty()) {
            put(KEY_PROPERTIES, properties);
        } else {
            removeField(KEY_PROPERTIES);
        }
    }",0,[0]
35295,bugs-dot-jar_ACCUMULO-1732_941e3cb1,"protected static TabletLocator getTabletLocator(JobContext context, String table) throws TableNotFoundException {
    return InputConfigurator.getTabletLocator(CLASS, getConfiguration(context), table);
  }","protected static TabletLocator getTabletLocator(JobContext context, String table) throws TableNotFoundException {
    return InputConfigurator.getTabletLocator(CLASS, getConfiguration(context), table);
  }",0,[0]
32453,bugs-dot-jar_CAMEL-3878_b9094cb5,"private boolean shouldRedeliver(Exchange exchange, RedeliveryData data) {
        // if marked as rollback only then do not redeliver
        boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class);
        if (rollbackOnly) {
            log.trace(""This exchange is marked as rollback only, should not be redelivered: {}"", exchange);
            return false;
        }
        return data.currentRedeliveryPolicy.shouldRedeliver(exchange, data.redeliveryCounter, data.retryWhilePredicate);
    }","private boolean shouldRedeliver(Exchange exchange, RedeliveryData data) {
        // if marked as rollback only then do not redeliver
        boolean rollbackOnly = exchange.getProperty(Exchange.ROLLBACK_ONLY, false, Boolean.class);
        if (rollbackOnly) {
            log.trace(""This exchange is marked as rollback only, should not be redelivered: {}"", exchange);
            return false;
        }
        return data.currentRedeliveryPolicy.shouldRedeliver(exchange, data.redeliveryCounter, data.retryWhilePredicate);
    }",0,[0]
6947,bugs-dot-jar_OAK-3411_978c77ff,"Iterable<Revision> getAllChanges() {
        final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);
        // initialize with local revisions and commitRoot entries
        stack.addAll(getLocalCommitRoot().keySet());
        stack.addAll(getLocalRevisions().keySet());
        if (getPreviousRanges().isEmpty()) {
            return stack;
        }
        return new Iterable<Revision>() {
            @Override
            public Iterator<Revision> iterator() {
                final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();
                return new AbstractIterator<Revision>() {
                    private NodeDocument nextDoc;
                    private Revision nextRevision;
                    @Override
                    protected Revision computeNext() {
                        if (stack.isEmpty()) {
                            return endOfData();
                        }
                        Revision next = stack.first();
                        stack.remove(next);
                        fillStackIfNeeded();
                        return next;
                    }

                    private void fillStackIfNeeded() {
                        for (;;) {
                            fetchNextDoc();

                            // no more changes to compare with
                            if (nextDoc == null) {
                                return;
                            }

                            // check if current top revision is still newer than
                            // most recent revision of next document
                            if (!stack.isEmpty()) {
                                Revision top = stack.first();
                                if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {
                                    return;
                                }
                            }

                            // if we get here, we need to pull in changes
                            // from nextDoc
                            Iterables.addAll(stack, nextDoc.getAllChanges());
                            nextDoc = null;
                            nextRevision = null;
                        }
                    }

                    /**
                     * Fetch the next document if {@code nextDoc} is
                     * {@code null} and there are more documents.
                     */
                    private void fetchNextDoc() {
                        for (;;) {
                            if (nextDoc != null) {
                                break;
                            }
                            if (!previousDocs.hasNext()) {
                                // no more previous docs
                                break;
                            }
                            nextDoc = previousDocs.next();
                            Iterator<Revision> changes = nextDoc.getAllChanges().iterator();
                            if (changes.hasNext()) {
                                nextRevision = changes.next();
                                break;
                            } else {
                                // empty document, try next
                                nextDoc = null;
                            }
                        }
                    }
                };
            }
        };
    }","Iterable<Revision> getAllChanges() {
        final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);
        // initialize with local revisions and commitRoot entries
        stack.addAll(getLocalCommitRoot().keySet());
        stack.addAll(getLocalRevisions().keySet());
        if (getPreviousRanges().isEmpty()) {
            return stack;
        }
        return new Iterable<Revision>() {
            @Override
            public Iterator<Revision> iterator() {
                final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();
                return new AbstractIterator<Revision>() {
                    private NodeDocument nextDoc;
                    private Revision nextRevision;
                    @Override
                    protected Revision computeNext() {
                        if (stack.isEmpty()) {
                            return endOfData();
                        }
                        Revision next = stack.first();
                        stack.remove(next);
                        fillStackIfNeeded();
                        return next;
                    }

                    private void fillStackIfNeeded() {
                        for (;;) {
                            fetchNextDoc();

                            // no more changes to compare with
                            if (nextDoc == null) {
                                return;
                            }

                            // check if current top revision is still newer than
                            // most recent revision of next document
                            if (!stack.isEmpty()) {
                                Revision top = stack.first();
                                if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {
                                    return;
                                }
                            }

                            // if we get here, we need to pull in changes
                            // from nextDoc
                            Iterables.addAll(stack, nextDoc.getAllChanges());
                            nextDoc = null;
                            nextRevision = null;
                        }
                    }

                    /**
                     * Fetch the next document if {@code nextDoc} is
                     * {@code null} and there are more documents.
                     */
                    private void fetchNextDoc() {
                        for (;;) {
                            if (nextDoc != null) {
                                break;
                            }
                            if (!previousDocs.hasNext()) {
                                // no more previous docs
                                break;
                            }
                            nextDoc = previousDocs.next();
                            Iterator<Revision> changes = nextDoc.getAllChanges().iterator();
                            if (changes.hasNext()) {
                                nextRevision = changes.next();
                                break;
                            } else {
                                // empty document, try next
                                nextDoc = null;
                            }
                        }
                    }
                };
            }
        };
    }",0,[0]
32969,bugs-dot-jar_WICKET-3333_ddf7e8a2,"protected CharSequence getOnClickScript(final CharSequence url)
	{
		return null;
	}","protected CharSequence getOnClickScript(final CharSequence url)
	{
		return null;
	}",0,[0]
12680,bugs-dot-jar_FLINK-1985_495a5c3c,"private void setSlotSharing() {

		Map<Integer, SlotSharingGroup> slotSharingGroups = new HashMap<Integer, SlotSharingGroup>();

		for (Entry<Integer, AbstractJobVertex> entry : jobVertices.entrySet()) {

			int slotSharingID = streamGraph.getStreamNode(entry.getKey()).getSlotSharingID();

			if (slotSharingID != -1) {
				SlotSharingGroup group = slotSharingGroups.get(slotSharingID);
				if (group == null) {
					group = new SlotSharingGroup();
					slotSharingGroups.put(slotSharingID, group);
				}
				entry.getValue().setSlotSharingGroup(group);
			}
		}

		for (StreamLoop loop : streamGraph.getStreamLoops()) {
			CoLocationGroup ccg = new CoLocationGroup();
			AbstractJobVertex tail = jobVertices.get(loop.getTail().getID());
			AbstractJobVertex head = jobVertices.get(loop.getHead().getID());

			ccg.addVertex(head);
			ccg.addVertex(tail);
		}
	}","private void setSlotSharing() {

		Map<Integer, SlotSharingGroup> slotSharingGroups = new HashMap<Integer, SlotSharingGroup>();

		for (Entry<Integer, AbstractJobVertex> entry : jobVertices.entrySet()) {

			int slotSharingID = streamGraph.getStreamNode(entry.getKey()).getSlotSharingID();

			if (slotSharingID != -1) {
				SlotSharingGroup group = slotSharingGroups.get(slotSharingID);
				if (group == null) {
					group = new SlotSharingGroup();
					slotSharingGroups.put(slotSharingID, group);
				}
				entry.getValue().setSlotSharingGroup(group);
			}
		}

		for (StreamLoop loop : streamGraph.getStreamLoops()) {
			CoLocationGroup ccg = new CoLocationGroup();
			AbstractJobVertex tail = jobVertices.get(loop.getTail().getID());
			AbstractJobVertex head = jobVertices.get(loop.getHead().getID());

			ccg.addVertex(head);
			ccg.addVertex(tail);
		}
	}",0,[0]
1708,bugs-dot-jar_MATH-1005_91d280b7,"public static void checkRectangular(final long[][] in)
        throws NullArgumentException, DimensionMismatchException {
        MathUtils.checkNotNull(in);
        for (int i = 1; i < in.length; i++) {
            if (in[i].length != in[0].length) {
                throw new DimensionMismatchException(
                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
                        in[i].length, in[0].length);
            }
        }
    }","public static void checkRectangular(final long[][] in)
        throws NullArgumentException, DimensionMismatchException {
        MathUtils.checkNotNull(in);
        for (int i = 1; i < in.length; i++) {
            if (in[i].length != in[0].length) {
                throw new DimensionMismatchException(
                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,
                        in[i].length, in[0].length);
            }
        }
    }",0,[0]
2305,bugs-dot-jar_MNG-4918_691a03a7,"public MavenProject getExecutionProject()
    {
        return ( executionProject == null ? this : executionProject );
    }","public MavenProject getExecutionProject()
    {
        return ( executionProject == null ? this : executionProject );
    }",0,[0]
39120,bugs-dot-jar_CAMEL-3709_4c37e773,"public Endpoint getEndpoint() {
        return endpoint;
    }","public Endpoint getEndpoint() {
        return endpoint;
    }",0,[0]
5260,bugs-dot-jar_OAK-499_61381ea2,"private String readName() throws ParseException {
        if (currentTokenType == END) {
            throw getSyntaxError(""a token"");
        }
        String s;
        if (currentTokenType == VALUE) {
            s = currentValue.getValue(Type.STRING);
        } else {
            s = currentToken;
        }
        read();
        return s;
    }","private String readName() throws ParseException {
        if (currentTokenType == END) {
            throw getSyntaxError(""a token"");
        }
        String s;
        if (currentTokenType == VALUE) {
            s = currentValue.getValue(Type.STRING);
        } else {
            s = currentToken;
        }
        read();
        return s;
    }",0,[0]
5523,bugs-dot-jar_CAMEL-8624_597883fa,"private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body,
                                                    List<MethodInfo> possibles, List<MethodInfo> possiblesWithException,
                                                    List<MethodInfo> possibleWithCustomAnnotation)
        throws AmbiguousMethodCallException {

        Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);
        if (exception != null && possiblesWithException.size() == 1) {
            LOG.trace(""Exchange has exception set so we prefer method that also has exception as parameter"");
            // prefer the method that accepts exception in case we have an exception also
            return possiblesWithException.get(0);
        } else if (possibles.size() == 1) {
            return possibles.get(0);
        } else if (possibles.isEmpty()) {
            LOG.trace(""No possible methods so now trying to convert body to parameter types"");

            // let's try converting
            Object newBody = null;
            MethodInfo matched = null;
            int matchCounter = 0;
            for (MethodInfo methodInfo : operationList) {
                if (methodInfo.getBodyParameterType().isInstance(body)) {
                    return methodInfo;
                }

                // we should only try to convert, as we are looking for best match
                Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);
                if (value != null) {
                    if (LOG.isTraceEnabled()) {
                        LOG.trace(""Converted body from: {} to: {}"",
                                body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());
                    }
                    matchCounter++;
                    newBody = value;
                    matched = methodInfo;
                }
            }
            if (matchCounter > 1) {
                throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));
            }
            if (matched != null) {
                LOG.trace(""Setting converted body: {}"", body);
                Message in = exchange.getIn();
                in.setBody(newBody);
                return matched;
            }
        } else {
            // if we only have a single method with custom annotations, let's use that one
            if (possibleWithCustomAnnotation.size() == 1) {
                MethodInfo answer = possibleWithCustomAnnotation.get(0);
                LOG.trace(""There are only one method with annotations so we choose it: {}"", answer);
                return answer;
            }
            // try to choose among multiple methods with annotations
            MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);
            if (chosen != null) {
                return chosen;
            }
            // just make sure the methods aren't all actually the same
            chosen = getSingleCovariantMethod(possibles);
            if (chosen != null) {
                return chosen;
            }
            throw new AmbiguousMethodCallException(exchange, possibles);
        }

        // cannot find a good method to use
        return null;
    }","private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<MethodInfo> operationList, Object body,
                                                    List<MethodInfo> possibles, List<MethodInfo> possiblesWithException,
                                                    List<MethodInfo> possibleWithCustomAnnotation)
        throws AmbiguousMethodCallException {

        Exception exception = ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, Exception.class);
        if (exception != null && possiblesWithException.size() == 1) {
            LOG.trace(""Exchange has exception set so we prefer method that also has exception as parameter"");
            // prefer the method that accepts exception in case we have an exception also
            return possiblesWithException.get(0);
        } else if (possibles.size() == 1) {
            return possibles.get(0);
        } else if (possibles.isEmpty()) {
            LOG.trace(""No possible methods so now trying to convert body to parameter types"");

            // let's try converting
            Object newBody = null;
            MethodInfo matched = null;
            int matchCounter = 0;
            for (MethodInfo methodInfo : operationList) {
                if (methodInfo.getBodyParameterType() != null) {
                    if (methodInfo.getBodyParameterType().isInstance(body)) {
                        return methodInfo;
                    }

                    // we should only try to convert, as we are looking for best match
                    Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);
                    if (value != null) {
                        if (LOG.isTraceEnabled()) {
                            LOG.trace(""Converted body from: {} to: {}"",
                                    body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());
                        }
                        matchCounter++;
                        newBody = value;
                        matched = methodInfo;
                    }
                }
            }
            if (matchCounter > 1) {
                throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));
            }
            if (matched != null) {
                LOG.trace(""Setting converted body: {}"", body);
                Message in = exchange.getIn();
                in.setBody(newBody);
                return matched;
            }
        } else {
            // if we only have a single method with custom annotations, let's use that one
            if (possibleWithCustomAnnotation.size() == 1) {
                MethodInfo answer = possibleWithCustomAnnotation.get(0);
                LOG.trace(""There are only one method with annotations so we choose it: {}"", answer);
                return answer;
            }
            // try to choose among multiple methods with annotations
            MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);
            if (chosen != null) {
                return chosen;
            }
            // just make sure the methods aren't all actually the same
            chosen = getSingleCovariantMethod(possibles);
            if (chosen != null) {
                return chosen;
            }
            throw new AmbiguousMethodCallException(exchange, possibles);
        }

        // cannot find a good method to use
        return null;
    }",1,"[20, 21, 22, 24, 25, 26, 27, 28, 29, 31, 32, 33]"
23166,bugs-dot-jar_WICKET-3764_48454f4d,"public void onConfigure(Component component)
	{
	}","public void onConfigure(Component component)
	{
	}",0,[0]
17360,bugs-dot-jar_CAMEL-7018_3244c1e5,"public Consumer createConsumer(Processor processor) throws Exception {
        if (getComponent() != null) {
            // all consumers must match having the same multipleConsumers options
            String key = getComponent().getQueueKey(getEndpointUri());
            QueueReference ref = getComponent().getQueueReference(key);
            if (ref != null && ref.getMultipleConsumers() != isMultipleConsumers()) {
                // there is already a multiple consumers, so make sure they matches
                throw new IllegalArgumentException(""Cannot use existing queue "" + key + "" as the existing queue multiple consumers ""
                        + ref.getMultipleConsumers() + "" does not match given multiple consumers "" + multipleConsumers);
            }
        }

        Consumer answer = new SedaConsumer(this, processor);
        configureConsumer(answer);
        return answer;
    }","public Consumer createConsumer(Processor processor) throws Exception {
        if (getComponent() != null) {
            // all consumers must match having the same multipleConsumers options
            String key = getComponent().getQueueKey(getEndpointUri());
            QueueReference ref = getComponent().getQueueReference(key);
            if (ref != null && ref.getMultipleConsumers() != isMultipleConsumers()) {
                // there is already a multiple consumers, so make sure they matches
                throw new IllegalArgumentException(""Cannot use existing queue "" + key + "" as the existing queue multiple consumers ""
                        + ref.getMultipleConsumers() + "" does not match given multiple consumers "" + multipleConsumers);
            }
        }

        Consumer answer = new SedaConsumer(this, processor);
        configureConsumer(answer);
        return answer;
    }",0,[0]
31295,bugs-dot-jar_CAMEL-8125_36e7b668,"public static Object mandatoryLookup(CamelContext context, String name) {
        Object answer = lookup(context, name);
        if (answer == null) {
            throw new NoSuchBeanException(name);
        }
        return answer;
    }","public static Object mandatoryLookup(CamelContext context, String name) {
        Object answer = lookup(context, name);
        if (answer == null) {
            throw new NoSuchBeanException(name);
        }
        return answer;
    }",0,[0]
2157,bugs-dot-jar_WICKET-2961_3d8c9d75,"protected final void setFlag(final short flag, final boolean set)
	{
		setFlag((int)flag, set);
	}","protected final void setFlag(final short flag, final boolean set)
	{
		setFlag((int)flag, set);
	}",0,[0]
7540,bugs-dot-jar_WICKET-2624_ef880545,"private final static Method findMethod(Class<?> clz, String expression)
	{
		if (expression.endsWith(""()""))
		{
			expression = expression.substring(0, expression.length() - 2);
		}
		Method method = null;
		try
		{
			method = clz.getMethod(expression, (Class[])null);
		}
		catch (Exception e)
		{
			log.debug(""Cannot find method "" + clz + ""."" + expression);
		}
		return method;
	}","private final static Method findMethod(Class<?> clz, String expression)
	{
		if (expression.endsWith(""()""))
		{
			expression = expression.substring(0, expression.length() - 2);
		}
		Method method = null;
		try
		{
			method = clz.getMethod(expression, (Class[])null);
		}
		catch (Exception e)
		{
			log.debug(""Cannot find method "" + clz + ""."" + expression);
		}
		return method;
	}",0,[0]
15299,bugs-dot-jar_FLINK-3314_8fc7e7af,"public String getName() {
		return getEnvironment().getTaskInfo().getTaskNameWithSubtasks();
	}","public String getName() {
		return getEnvironment().getTaskInfo().getTaskNameWithSubtasks();
	}",0,[0]
22588,bugs-dot-jar_FLINK-1820_39d526e6,"@Override
	public Short createValue() {
		return Short.MIN_VALUE;
	}","@Override
	public Short createValue() {
		return Short.MIN_VALUE;
	}",0,[0]
6121,bugs-dot-jar_OAK-3028_89317b28,"private void runBackgroundUpdateOperations() {
        if (isDisposed.get()) {
            return;
        }
        try {
            internalRunBackgroundUpdateOperations();
        } catch (RuntimeException e) {
            if (isDisposed.get()) {
                LOG.warn(""Background update operation failed (will be retried with next run): "" + e.toString(), e);
                return;
            }
            throw e;
        }
    }","private void runBackgroundUpdateOperations() {
        if (isDisposed.get()) {
            return;
        }
        try {
            internalRunBackgroundUpdateOperations();
        } catch (RuntimeException e) {
            if (isDisposed.get()) {
                LOG.warn(""Background update operation failed (will be retried with next run): "" + e.toString(), e);
                return;
            }
            throw e;
        }
    }",0,[0]
10218,bugs-dot-jar_OAK-3897_94c6c575,"@Nonnull
    Commit newCommit(@Nullable RevisionVector base,
                     @Nullable DocumentNodeStoreBranch branch) {
        if (base == null) {
            base = getHeadRevision();
        }
        if (base.isBranch()) {
            return newBranchCommit(base, branch);
        } else {
            return newTrunkCommit(base);
        }
    }","@Nonnull
    Commit newCommit(@Nullable RevisionVector base,
                     @Nullable DocumentNodeStoreBranch branch) {
        if (base == null) {
            base = getHeadRevision();
        }
        if (base.isBranch()) {
            return newBranchCommit(base, branch);
        } else {
            return newTrunkCommit(base);
        }
    }",0,[0]
17688,bugs-dot-jar_WICKET-3098_1b7afefc,"public void register()
	{
		// Register this listener interface
		registerRequestListenerInterface(this);
	}","public void register()
	{
		// Register this listener interface
		registerRequestListenerInterface(this);
	}",0,[0]
9612,bugs-dot-jar_WICKET-2281_6e0b40bc,"public void setMethod(final String method)
	{
		this.method = method;
	}","public void setMethod(final String method)
	{
		this.method = method;
	}",0,[0]
33174,bugs-dot-jar_WICKET-2202_24ac1a35,"public final Collection<IFormValidator> getFormValidators()
	{
		final int size = formValidators_size();

		List<IFormValidator> validators = null;

		if (size == 0)
		{
			// form has no validators, use empty collection
			validators = Collections.emptyList();
		}
		else
		{
			// form has validators, copy all into collection
			validators = new ArrayList<IFormValidator>(size);
			for (int i = 0; i < size; i++)
			{
				validators.add(formValidators_get(i));
			}
		}
		return Collections.unmodifiableCollection(validators);
	}","public final Collection<IFormValidator> getFormValidators()
	{
		final int size = formValidators_size();

		List<IFormValidator> validators = null;

		if (size == 0)
		{
			// form has no validators, use empty collection
			validators = Collections.emptyList();
		}
		else
		{
			// form has validators, copy all into collection
			validators = new ArrayList<IFormValidator>(size);
			for (int i = 0; i < size; i++)
			{
				validators.add(formValidators_get(i));
			}
		}
		return Collections.unmodifiableCollection(validators);
	}",0,[0]
15133,bugs-dot-jar_MNG-5075_2eb419ed,"private void deepCopy( MavenProject project )
    {
        // disown the parent

        // copy fields
        setFile( project.getFile() );

        // don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be
        // sure!
        if ( project.getDependencyArtifacts() != null )
        {
            setDependencyArtifacts( Collections.unmodifiableSet( project.getDependencyArtifacts() ) );
        }

        if ( project.getArtifacts() != null )
        {
            setArtifacts( Collections.unmodifiableSet( project.getArtifacts() ) );
        }

        if ( project.getParentFile() != null )
        {
            parentFile = new File( project.getParentFile().getAbsolutePath() );
        }

        if ( project.getPluginArtifacts() != null )
        {
            setPluginArtifacts( Collections.unmodifiableSet( project.getPluginArtifacts() ) );
        }

        if ( project.getReportArtifacts() != null )
        {
            setReportArtifacts( Collections.unmodifiableSet( project.getReportArtifacts() ) );
        }

        if ( project.getExtensionArtifacts() != null )
        {
            setExtensionArtifacts( Collections.unmodifiableSet( project.getExtensionArtifacts() ) );
        }

        setParentArtifact( ( project.getParentArtifact() ) );

        if ( project.getRemoteArtifactRepositories() != null )
        {
            setRemoteArtifactRepositories( Collections.unmodifiableList( project.getRemoteArtifactRepositories() ) );
        }

        if ( project.getPluginArtifactRepositories() != null )
        {
            setPluginArtifactRepositories( ( Collections.unmodifiableList( project.getPluginArtifactRepositories() ) ) );
        }

        if ( project.getActiveProfiles() != null )
        {
            setActiveProfiles( ( Collections.unmodifiableList( project.getActiveProfiles() ) ) );
        }

        if ( project.getAttachedArtifacts() != null )
        {
            // clone properties modifyable by plugins in a forked lifecycle
            setAttachedArtifacts( new ArrayList<Artifact>( project.getAttachedArtifacts() ) );
        }

        if ( project.getCompileSourceRoots() != null )
        {
            // clone source roots
            setCompileSourceRoots( ( new ArrayList<String>( project.getCompileSourceRoots() ) ) );
        }

        if ( project.getTestCompileSourceRoots() != null )
        {
            setTestCompileSourceRoots( ( new ArrayList<String>( project.getTestCompileSourceRoots() ) ) );
        }

        if ( project.getScriptSourceRoots() != null )
        {
            setScriptSourceRoots( ( new ArrayList<String>( project.getScriptSourceRoots() ) ) );
        }

        if ( project.getModel() != null )
        {
            setModel( project.getModel().clone() );
        }

        if ( project.getOriginalModel() != null )
        {
            setOriginalModel( project.getOriginalModel() );
        }

        setExecutionRoot( project.isExecutionRoot() );

        if ( project.getArtifact() != null )
        {
            setArtifact( ArtifactUtils.copyArtifact( project.getArtifact() ) );
        }

        if ( project.getManagedVersionMap() != null )
        {
            setManagedVersionMap( new HashMap<String, Artifact>( project.getManagedVersionMap() ) );
        }

        lifecyclePhases.addAll( project.lifecyclePhases );
    }","private void deepCopy( MavenProject project )
    {
        // disown the parent

        // copy fields
        setFile( project.getFile() );

        // don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be
        // sure!
        if ( project.getDependencyArtifacts() != null )
        {
            setDependencyArtifacts( Collections.unmodifiableSet( project.getDependencyArtifacts() ) );
        }

        if ( project.getArtifacts() != null )
        {
            setArtifacts( Collections.unmodifiableSet( project.getArtifacts() ) );
        }

        if ( project.getParentFile() != null )
        {
            parentFile = new File( project.getParentFile().getAbsolutePath() );
        }

        if ( project.getPluginArtifacts() != null )
        {
            setPluginArtifacts( Collections.unmodifiableSet( project.getPluginArtifacts() ) );
        }

        if ( project.getReportArtifacts() != null )
        {
            setReportArtifacts( Collections.unmodifiableSet( project.getReportArtifacts() ) );
        }

        if ( project.getExtensionArtifacts() != null )
        {
            setExtensionArtifacts( Collections.unmodifiableSet( project.getExtensionArtifacts() ) );
        }

        setParentArtifact( ( project.getParentArtifact() ) );

        if ( project.getRemoteArtifactRepositories() != null )
        {
            setRemoteArtifactRepositories( Collections.unmodifiableList( project.getRemoteArtifactRepositories() ) );
        }

        if ( project.getPluginArtifactRepositories() != null )
        {
            setPluginArtifactRepositories( ( Collections.unmodifiableList( project.getPluginArtifactRepositories() ) ) );
        }

        if ( project.getActiveProfiles() != null )
        {
            setActiveProfiles( ( Collections.unmodifiableList( project.getActiveProfiles() ) ) );
        }

        if ( project.getAttachedArtifacts() != null )
        {
            // clone properties modifyable by plugins in a forked lifecycle
            setAttachedArtifacts( new ArrayList<Artifact>( project.getAttachedArtifacts() ) );
        }

        if ( project.getCompileSourceRoots() != null )
        {
            // clone source roots
            setCompileSourceRoots( ( new ArrayList<String>( project.getCompileSourceRoots() ) ) );
        }

        if ( project.getTestCompileSourceRoots() != null )
        {
            setTestCompileSourceRoots( ( new ArrayList<String>( project.getTestCompileSourceRoots() ) ) );
        }

        if ( project.getScriptSourceRoots() != null )
        {
            setScriptSourceRoots( ( new ArrayList<String>( project.getScriptSourceRoots() ) ) );
        }

        if ( project.getModel() != null )
        {
            setModel( project.getModel().clone() );
        }

        if ( project.getOriginalModel() != null )
        {
            setOriginalModel( project.getOriginalModel() );
        }

        setExecutionRoot( project.isExecutionRoot() );

        if ( project.getArtifact() != null )
        {
            setArtifact( ArtifactUtils.copyArtifact( project.getArtifact() ) );
        }

        if ( project.getManagedVersionMap() != null )
        {
            setManagedVersionMap( new HashMap<String, Artifact>( project.getManagedVersionMap() ) );
        }

        lifecyclePhases.addAll( project.lifecyclePhases );
    }",0,[0]
23287,bugs-dot-jar_FLINK-1496_0a4c7694,"@Override
	public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {
		// This can be improved by just serializing the event once for all
		// remote input channels.
		synchronized (requestLock) {
			for (InputChannel inputChannel : inputChannels.values()) {
				inputChannel.sendTaskEvent(event);
			}
		}
	}","@Override
	public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedException {
		// This can be improved by just serializing the event once for all
		// remote input channels.
		synchronized (requestLock) {
			for (InputChannel inputChannel : inputChannels.values()) {
				inputChannel.sendTaskEvent(event);
			}

			if (numberOfUninitializedChannels > 0) {
				pendingEvents.add(event);
			}
		}
	}",1,[]
15512,bugs-dot-jar_WICKET-3428_ffc0cae9,"@Override
	protected RequestCycle getRequestCycle()
	{
		return this;
	}","@Override
	protected RequestCycle getRequestCycle()
	{
		return this;
	}",0,[0]
25823,bugs-dot-jar_CAMEL-6723_b92d6237,"public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {
        String id = exchange.getExchangeId();

        Exchange copy = exchange.copy();
        // do not share the unit of work
        copy.setUnitOfWork(null);
        // hand over on completion to the copy if we got any
        UnitOfWork uow = exchange.getUnitOfWork();
        if (handover && uow != null) {
            uow.handoverSynchronization(copy);
        }
        // set a correlation id so we can track back the original exchange
        copy.setProperty(Exchange.CORRELATION_ID, id);
        return copy;
    }","public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {
        String id = exchange.getExchangeId();

        Exchange copy = exchange.copy();
        // do not share the unit of work
        copy.setUnitOfWork(null);
        // hand over on completion to the copy if we got any
        UnitOfWork uow = exchange.getUnitOfWork();
        if (handover && uow != null) {
            uow.handoverSynchronization(copy);
        }
        // set a correlation id so we can track back the original exchange
        copy.setProperty(Exchange.CORRELATION_ID, id);
        return copy;
    }",0,[0]
38125,bugs-dot-jar_OAK-3013_eabb4066,"@Override
    public boolean isMeasureOrExplainEnabled() {
        return explain || measure;
    }","@Override
    public boolean isMeasureOrExplainEnabled() {
        return explain || measure;
    }",0,[0]
3026,bugs-dot-jar_FLINK-2754_68912126,"public FixedLengthRecordSorter(TypeSerializer<T> serializer, TypeComparator<T> comparator, 
			List<MemorySegment> memory)
	{
		if (serializer == null || comparator == null || memory == null) {
			throw new NullPointerException();
		}
		
		this.serializer = serializer;
		this.comparator = comparator;
		this.useNormKeyUninverted = !comparator.invertNormalizedKey();
		
		// check the size of the first buffer and record it. all further buffers must have the same size.
		// the size must also be a power of 2
		this.totalNumBuffers = memory.size();
		if (this.totalNumBuffers < MIN_REQUIRED_BUFFERS) {
			throw new IllegalArgumentException(""Normalized-Key sorter requires at least "" + MIN_REQUIRED_BUFFERS + "" memory buffers."");
		}
		this.segmentSize = memory.get(0).size();
		this.recordSize = serializer.getLength();
		this.numKeyBytes = this.comparator.getNormalizeKeyLen();
		
		// check that the serializer and comparator allow our operations
		if (this.recordSize <= 0) {
			throw new IllegalArgumentException(""This sorter works only for fixed-length data types."");
		} else if (this.recordSize > this.segmentSize) {
			throw new IllegalArgumentException(""This sorter works only for record lengths below the memory segment size."");
		} else if (!comparator.supportsSerializationWithKeyNormalization()) {
			throw new IllegalArgumentException(""This sorter requires a comparator that supports serialization with key normalization."");
		}
		
		// compute the entry size and limits
		this.recordsPerSegment = segmentSize / this.recordSize;
		this.lastEntryOffset = (this.recordsPerSegment - 1) * this.recordSize;
		this.swapBuffer = new byte[this.recordSize];
		
		this.freeMemory = new ArrayList<MemorySegment>(memory);
		
		// create the buffer collections
		this.sortBuffer = new ArrayList<MemorySegment>(16);
		this.outView = new SingleSegmentOutputView(this.segmentSize);
		this.inView = new SingleSegmentInputView(this.lastEntryOffset + this.recordSize);
		this.currentSortBufferSegment = nextMemorySegment();
		this.sortBuffer.add(this.currentSortBufferSegment);
		this.outView.set(this.currentSortBufferSegment);
		
		this.recordInstance = this.serializer.createInstance();
	}","public FixedLengthRecordSorter(TypeSerializer<T> serializer, TypeComparator<T> comparator, 
			List<MemorySegment> memory)
	{
		if (serializer == null || comparator == null || memory == null) {
			throw new NullPointerException();
		}
		
		this.serializer = serializer;
		this.comparator = comparator;
		this.useNormKeyUninverted = !comparator.invertNormalizedKey();
		
		// check the size of the first buffer and record it. all further buffers must have the same size.
		// the size must also be a power of 2
		this.totalNumBuffers = memory.size();
		if (this.totalNumBuffers < MIN_REQUIRED_BUFFERS) {
			throw new IllegalArgumentException(""Normalized-Key sorter requires at least "" + MIN_REQUIRED_BUFFERS + "" memory buffers."");
		}
		this.segmentSize = memory.get(0).size();
		this.recordSize = serializer.getLength();
		this.numKeyBytes = this.comparator.getNormalizeKeyLen();
		
		// check that the serializer and comparator allow our operations
		if (this.recordSize <= 0) {
			throw new IllegalArgumentException(""This sorter works only for fixed-length data types."");
		} else if (this.recordSize > this.segmentSize) {
			throw new IllegalArgumentException(""This sorter works only for record lengths below the memory segment size."");
		} else if (!comparator.supportsSerializationWithKeyNormalization()) {
			throw new IllegalArgumentException(""This sorter requires a comparator that supports serialization with key normalization."");
		}
		
		// compute the entry size and limits
		this.recordsPerSegment = segmentSize / this.recordSize;
		this.lastEntryOffset = (this.recordsPerSegment - 1) * this.recordSize;
		this.swapBuffer = new byte[this.recordSize];
		
		this.freeMemory = new ArrayList<MemorySegment>(memory);
		
		// create the buffer collections
		this.sortBuffer = new ArrayList<MemorySegment>(16);
		this.outView = new SingleSegmentOutputView(this.segmentSize);
		this.inView = new SingleSegmentInputView(this.lastEntryOffset + this.recordSize);
		this.currentSortBufferSegment = nextMemorySegment();
		this.sortBuffer.add(this.currentSortBufferSegment);
		this.outView.set(this.currentSortBufferSegment);
		
		this.recordInstance = this.serializer.createInstance();
	}",0,[0]
1904,bugs-dot-jar_FLINK-1145_22c370d9,"private static Type getParameterType(Class<?> baseClass, ArrayList<Type> typeHierarchy, Class<?> clazz, int pos) {
		Type[] interfaceTypes = clazz.getGenericInterfaces();
		
		// search in interfaces for base class
		for (Type t : interfaceTypes) {
			Type parameter = getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);
			if (parameter != null) {
				return parameter;
			}
		}
		
		// search in superclass for base class
		Type t = clazz.getGenericSuperclass();
		Type parameter = getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);
		if (parameter != null) {
			return parameter;
		}
		
		throw new IllegalArgumentException(""The types of the interface "" + baseClass.getName() + "" could not be inferred. "" + 
						""Support for synthetic interfaces, lambdas, and generic types is limited at this point."");
	}","private static Type getParameterType(Class<?> baseClass, ArrayList<Type> typeHierarchy, Class<?> clazz, int pos) {
		Type[] interfaceTypes = clazz.getGenericInterfaces();
		
		// search in interfaces for base class
		for (Type t : interfaceTypes) {
			Type parameter = getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);
			if (parameter != null) {
				return parameter;
			}
		}
		
		// search in superclass for base class
		Type t = clazz.getGenericSuperclass();
		Type parameter = getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);
		if (parameter != null) {
			return parameter;
		}
		
		throw new IllegalArgumentException(""The types of the interface "" + baseClass.getName() + "" could not be inferred. "" + 
						""Support for synthetic interfaces, lambdas, and generic types is limited at this point."");
	}",0,[0]
19302,bugs-dot-jar_LOG4J2-1372_ffedf33f,abstract protected String getPropertNameForContextMap();,abstract protected String getPropertNameForContextMap();,0,[0]
16997,bugs-dot-jar_OAK-766_6fc5ea9d,"@Override
    public Iterable<? extends PropertyState> getProperties() {
        enter();
        return Iterables.filter(nodeBuilder.getProperties(),
                new Predicate<PropertyState>() {
                    @Override
                    public boolean apply(PropertyState propertyState) {
                        return canRead(propertyState);
                    }
                });
    }","@Override
    public Iterable<? extends PropertyState> getProperties() {
        enter();
        return Iterables.filter(nodeBuilder.getProperties(),
                new Predicate<PropertyState>() {
                    @Override
                    public boolean apply(PropertyState propertyState) {
                        return canRead(propertyState);
                    }
                });
    }",0,[0]
873,bugs-dot-jar_WICKET-4572_dfc56674,"private void mergeWindowWithNext(int index)
	{
		if (index < windows.size() - 1)
		{
			PageWindowInternal window = windows.get(index);
			PageWindowInternal next = windows.get(index + 1);
			window.filePartSize += next.filePartSize;

			windows.remove(index + 1);
			idToWindowIndex = null; // reset index
		}
	}","private void mergeWindowWithNext(int index)
	{
		if (index < windows.size() - 1)
		{
			PageWindowInternal window = windows.get(index);
			PageWindowInternal next = windows.get(index + 1);
			window.filePartSize += next.filePartSize;

			windows.remove(index + 1);
			idToWindowIndex = null; // reset index
			windowIndexToPageId = null;
		}
	}",1,[]
13755,bugs-dot-jar_MATH-318_83f18d52,"private void computeShiftIncrement(final int start, final int end, final int deflated) {

        final double cnst1 = 0.563;
        final double cnst2 = 1.010;
        final double cnst3 = 1.05;

        // a negative dMin forces the shift to take that absolute value
        // tType records the type of shift.
        if (dMin <= 0.0) {
            tau = -dMin;
            tType = -1;
            return;
        }

        int nn = 4 * end + pingPong - 1;
        switch (deflated) {

        case 0 : // no realEigenvalues deflated.
            if (dMin == dN || dMin == dN1) {

                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];

                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5]  >  work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4]  >  work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9]  >  work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }

                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;

                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;

                }
            } else if (dMin == dN2) {

                // case 5.
                tType = -5;
                double s = 0.25 * dMin;

                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

                // approximate contribution to norm squared from i < nn-2.
                if (end - start > 3) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }

            } else {

                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau   = g * dMin;
                tType = -6;

            }
            break;

        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
            if (dMin1 == dN1 && dMin2 == dN2) {

                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {

                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;

        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.

            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0){
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] -
                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau   = 0.25 * dMin2;
                tType = -11;
            }
            break;

        default : // case 12, more than two realEigenvalues deflated. no information.
            tau   = 0.0;
            tType = -12;
        }

    }","private void computeShiftIncrement(final int start, final int end, final int deflated) {

        final double cnst1 = 0.563;
        final double cnst2 = 1.010;
        final double cnst3 = 1.05;

        // a negative dMin forces the shift to take that absolute value
        // tType records the type of shift.
        if (dMin <= 0.0) {
            tau = -dMin;
            tType = -1;
            return;
        }

        int nn = 4 * end + pingPong - 1;
        switch (deflated) {

        case 0 : // no realEigenvalues deflated.
            if (dMin == dN || dMin == dN1) {

                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];

                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5]  >  work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4]  >  work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9]  >  work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }

                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;

                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;

                }
            } else if (dMin == dN2) {

                // case 5.
                tType = -5;
                double s = 0.25 * dMin;

                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);

                // approximate contribution to norm squared from i < nn-2.
                if (end - start > 3) {
                    b2 = work[nn - 13] / work[nn - 15];
                    a2 = a2 + b2;
                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }

            } else {

                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau   = g * dMin;
                tType = -6;

            }
            break;

        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
            if (dMin1 == dN1 && dMin2 == dN2) {

                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {

                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;

        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.

            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0){
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] -
                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau   = 0.25 * dMin2;
                tType = -11;
            }
            break;

        default : // case 12, more than two realEigenvalues deflated. no information.
            tau   = 0.0;
            tType = -12;
        }

    }",0,[0]
4753,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapSqrtToSelf() {
        for (int i = 0; i < data.length; i++) {
            data[i] = Math.sqrt(data[i]);
        }
        return this;
    }","public RealVector mapSqrtToSelf() {
        for (int i = 0; i < data.length; i++) {
            data[i] = Math.sqrt(data[i]);
        }
        return this;
    }",0,[0]
8411,bugs-dot-jar_ACCUMULO-366_db4a291f,"boolean initiateMinorCompaction(long flushId) {
    
    MinorCompactionTask mct;
    long t1, t2;
    
    StringBuilder logMessage = null;
    
    try {
      synchronized (this) {
        t1 = System.currentTimeMillis();
        
        if (closing || closed || majorCompactionWaitingToStart || tabletMemory.memoryReservedForMinC() || tabletMemory.getMemTable().getNumEntries() == 0
            || updatingFlushID) {
          
          logMessage = new StringBuilder();
          
          logMessage.append(extent.toString());
          logMessage.append("" closing "" + closing);
          logMessage.append("" closed "" + closed);
          logMessage.append("" majorCompactionWaitingToStart "" + majorCompactionWaitingToStart);
          if (tabletMemory != null)
            logMessage.append("" tabletMemory.memoryReservedForMinC() "" + tabletMemory.memoryReservedForMinC());
          if (tabletMemory != null && tabletMemory.getMemTable() != null)
            logMessage.append("" tabletMemory.getMemTable().getNumEntries() "" + tabletMemory.getMemTable().getNumEntries());
          logMessage.append("" updatingFlushID "" + updatingFlushID);
          
          return false;
        }
        // We're still recovering log entries
        if (datafileManager == null) {
          logMessage = new StringBuilder();
          logMessage.append(extent.toString());
          logMessage.append("" datafileManager "" + datafileManager);
          return false;
        }
        
        mct = prepareForMinC(flushId);
        t2 = System.currentTimeMillis();
      }
    } finally {
      // log outside of sync block
      if (logMessage != null && log.isDebugEnabled())
        log.debug(logMessage);
    }
    
    tabletResources.executeMinorCompaction(mct);
    
    log.debug(String.format(""MinC initiate lock %.2f secs"", (t2 - t1) / 1000.0));
    
    return true;
  }","boolean initiateMinorCompaction(long flushId) {
    
    MinorCompactionTask mct;
    long t1, t2;
    
    StringBuilder logMessage = null;
    
    try {
      synchronized (this) {
        t1 = System.currentTimeMillis();
        
        if (closing || closed || majorCompactionWaitingToStart || tabletMemory.memoryReservedForMinC() || tabletMemory.getMemTable().getNumEntries() == 0
            || updatingFlushID) {
          
          logMessage = new StringBuilder();
          
          logMessage.append(extent.toString());
          logMessage.append("" closing "" + closing);
          logMessage.append("" closed "" + closed);
          logMessage.append("" majorCompactionWaitingToStart "" + majorCompactionWaitingToStart);
          if (tabletMemory != null)
            logMessage.append("" tabletMemory.memoryReservedForMinC() "" + tabletMemory.memoryReservedForMinC());
          if (tabletMemory != null && tabletMemory.getMemTable() != null)
            logMessage.append("" tabletMemory.getMemTable().getNumEntries() "" + tabletMemory.getMemTable().getNumEntries());
          logMessage.append("" updatingFlushID "" + updatingFlushID);
          
          return false;
        }
        // We're still recovering log entries
        if (datafileManager == null) {
          logMessage = new StringBuilder();
          logMessage.append(extent.toString());
          logMessage.append("" datafileManager "" + datafileManager);
          return false;
        }
        
        mct = prepareForMinC(flushId);
        t2 = System.currentTimeMillis();
      }
    } finally {
      // log outside of sync block
      if (logMessage != null && log.isDebugEnabled())
        log.debug(logMessage);
    }
    
    tabletResources.executeMinorCompaction(mct);
    
    log.debug(String.format(""MinC initiate lock %.2f secs"", (t2 - t1) / 1000.0));
    
    return true;
  }",0,[0]
68,bugs-dot-jar_OAK-1822_3e83a4c1,"private static void setSplitDocMaxRev(@Nonnull UpdateOp op,
                                          @Nonnull Revision maxRev) {
        checkNotNull(op).set(SD_MAX_REV_TIME_IN_SECS, getModifiedInSecs(maxRev.getTimestamp()));
    }","private static void setSplitDocMaxRev(@Nonnull UpdateOp op,
                                          @Nonnull Revision maxRev) {
        checkNotNull(op).set(SD_MAX_REV_TIME_IN_SECS, getModifiedInSecs(maxRev.getTimestamp()));
    }",0,[0]
5904,bugs-dot-jar_MATH-855_ac597cc1,"private UnivariatePointValuePair best(UnivariatePointValuePair a,
                                          UnivariatePointValuePair b,
                                          boolean isMinim) {
        if (a == null) {
            return b;
        }
        if (b == null) {
            return a;
        }

        if (isMinim) {
            return a.getValue() < b.getValue() ? a : b;
        } else {
            return a.getValue() > b.getValue() ? a : b;
        }
    }","private UnivariatePointValuePair best(UnivariatePointValuePair a,
                                          UnivariatePointValuePair b,
                                          boolean isMinim) {
        if (a == null) {
            return b;
        }
        if (b == null) {
            return a;
        }

        if (isMinim) {
            return a.getValue() <= b.getValue() ? a : b;
        } else {
            return a.getValue() >= b.getValue() ? a : b;
        }
    }",1,"[11, 13]"
3749,bugs-dot-jar_ACCUMULO-209_76d727f0,"@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = copyMatcher(rowMatcher);
    result.colfMatcher = copyMatcher(colfMatcher);
    result.colqMatcher = copyMatcher(colqMatcher);
    result.valueMatcher = copyMatcher(valueMatcher);
    result.orFields = orFields;
    return result;
  }","@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = copyMatcher(rowMatcher);
    result.colfMatcher = copyMatcher(colfMatcher);
    result.colqMatcher = copyMatcher(colqMatcher);
    result.valueMatcher = copyMatcher(valueMatcher);
    result.orFields = orFields;
    return result;
  }",0,[0]
1325,Bears-160,"@Override
    protected void initializeDataTypes(DataTypeParser dataTypes) {
        dataTypes.register(Types.BIT, ""BIT[(L)]"");
        // MySQL unsigned TINYINTs can be mapped to JDBC TINYINT, but signed values don't map. Therefore, per JDBC spec
        // the best mapping for all TINYINT values is JDBC's SMALLINT, which maps to a short.
        dataTypes.register(Types.SMALLINT, ""TINYINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.SMALLINT, ""SMALLINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.INTEGER, ""MEDIUMINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.INTEGER, ""INT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.INTEGER, ""INTEGER[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.BIGINT, ""BIGINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.REAL, ""REAL[(M[,D])] [UNSIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DOUBLE, ""DOUBLE[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DOUBLE, ""DOUBLE PRECISION[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.FLOAT, ""FLOAT[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DECIMAL, ""DECIMAL[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DECIMAL, ""FIXED[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DECIMAL, ""DEC[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.NUMERIC, ""NUMERIC[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.BOOLEAN, ""BOOLEAN"");
        dataTypes.register(Types.BOOLEAN, ""BOOL"");
        dataTypes.register(Types.DATE, ""DATE"");
        dataTypes.register(Types.TIME, ""TIME[(L)]"");
        dataTypes.register(Types.TIMESTAMP_WITH_TIMEZONE, ""TIMESTAMP[(L)]""); // includes timezone information
        dataTypes.register(Types.TIMESTAMP, ""DATETIME[(L)]"");
        dataTypes.register(Types.INTEGER, ""YEAR[(2|4)]"");
        dataTypes.register(Types.BINARY, ""CHAR[(L)] BINARY"");
        dataTypes.register(Types.VARBINARY, ""VARCHAR(L) BINARY"");
        dataTypes.register(Types.BINARY, ""BINARY[(L)]"");
        dataTypes.register(Types.VARCHAR, ""VARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NVARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NATIONAL VARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NCHAR VARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NATIONAL CHARACTER VARYING(L)"");
        dataTypes.register(Types.NVARCHAR, ""NATIONAL CHAR VARYING(L)"");
        dataTypes.register(Types.CHAR, ""CHAR[(L)]"");
        dataTypes.register(Types.NCHAR, ""NCHAR[(L)]"");
        dataTypes.register(Types.NCHAR, ""NATIONAL CHARACTER(L)"");
        dataTypes.register(Types.VARBINARY, ""VARBINARY(L)"");
        dataTypes.register(Types.BLOB, ""TINYBLOB"");
        dataTypes.register(Types.BLOB, ""BLOB"");
        dataTypes.register(Types.BLOB, ""MEDIUMBLOB"");
        dataTypes.register(Types.BLOB, ""LONGBLOB"");
        dataTypes.register(Types.BLOB, ""TINYTEXT BINARY"");
        dataTypes.register(Types.BLOB, ""TEXT BINARY"");
        dataTypes.register(Types.BLOB, ""MEDIUMTEXT BINARY"");
        dataTypes.register(Types.BLOB, ""LONGTEXT BINARY"");
        dataTypes.register(Types.VARCHAR, ""TINYTEXT"");
        dataTypes.register(Types.VARCHAR, ""TEXT[(L)]"");
        dataTypes.register(Types.VARCHAR, ""MEDIUMTEXT"");
        dataTypes.register(Types.VARCHAR, ""LONGTEXT"");
        dataTypes.register(Types.CHAR, ""ENUM(...)"");
        dataTypes.register(Types.CHAR, ""SET(...)"");
        dataTypes.register(Types.OTHER, ""JSON"");
        dataTypes.register(Types.OTHER, ""POINT"");
    }","@Override
    protected void initializeDataTypes(DataTypeParser dataTypes) {
        dataTypes.register(Types.BIT, ""BIT[(L)]"");
        // MySQL unsigned TINYINTs can be mapped to JDBC TINYINT, but signed values don't map. Therefore, per JDBC spec
        // the best mapping for all TINYINT values is JDBC's SMALLINT, which maps to a short.
        dataTypes.register(Types.SMALLINT, ""TINYINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.SMALLINT, ""SMALLINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.INTEGER, ""MEDIUMINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.INTEGER, ""INT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.INTEGER, ""INTEGER[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.BIGINT, ""BIGINT[(L)] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.REAL, ""REAL[(M[,D])] [UNSIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DOUBLE, ""DOUBLE[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DOUBLE, ""DOUBLE PRECISION[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.FLOAT, ""FLOAT[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DECIMAL, ""DECIMAL[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DECIMAL, ""FIXED[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.DECIMAL, ""DEC[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.NUMERIC, ""NUMERIC[(M[,D])] [UNSIGNED|SIGNED] [ZEROFILL]"");
        dataTypes.register(Types.BOOLEAN, ""BOOLEAN"");
        dataTypes.register(Types.BOOLEAN, ""BOOL"");
        dataTypes.register(Types.DATE, ""DATE"");
        dataTypes.register(Types.TIME, ""TIME[(L)]"");
        dataTypes.register(Types.TIMESTAMP_WITH_TIMEZONE, ""TIMESTAMP[(L)]""); // includes timezone information
        dataTypes.register(Types.TIMESTAMP, ""DATETIME[(L)]"");
        dataTypes.register(Types.INTEGER, ""YEAR[(2|4)]"");
        dataTypes.register(Types.BINARY, ""CHAR[(L)] BINARY"");
        dataTypes.register(Types.VARBINARY, ""VARCHAR(L) BINARY"");
        dataTypes.register(Types.BINARY, ""BINARY[(L)]"");
        dataTypes.register(Types.VARCHAR, ""VARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NVARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NATIONAL VARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NCHAR VARCHAR(L)"");
        dataTypes.register(Types.NVARCHAR, ""NATIONAL CHARACTER VARYING(L)"");
        dataTypes.register(Types.NVARCHAR, ""NATIONAL CHAR VARYING(L)"");
        dataTypes.register(Types.CHAR, ""CHAR[(L)]"");
        dataTypes.register(Types.NCHAR, ""NCHAR[(L)]"");
        dataTypes.register(Types.NCHAR, ""NATIONAL CHARACTER(L)"");
        dataTypes.register(Types.VARBINARY, ""VARBINARY(L)"");
        dataTypes.register(Types.BLOB, ""TINYBLOB"");
        dataTypes.register(Types.BLOB, ""BLOB"");
        dataTypes.register(Types.BLOB, ""MEDIUMBLOB"");
        dataTypes.register(Types.BLOB, ""LONGBLOB"");
        dataTypes.register(Types.BLOB, ""TINYTEXT BINARY"");
        dataTypes.register(Types.BLOB, ""TEXT BINARY"");
        dataTypes.register(Types.BLOB, ""MEDIUMTEXT BINARY"");
        dataTypes.register(Types.BLOB, ""LONGTEXT BINARY"");
        dataTypes.register(Types.VARCHAR, ""TINYTEXT"");
        dataTypes.register(Types.VARCHAR, ""TEXT[(L)]"");
        dataTypes.register(Types.VARCHAR, ""MEDIUMTEXT"");
        dataTypes.register(Types.VARCHAR, ""LONGTEXT"");
        dataTypes.register(Types.CHAR, ""ENUM(...)"");
        dataTypes.register(Types.CHAR, ""SET(...)"");
        dataTypes.register(Types.OTHER, ""JSON"");
        dataTypes.register(Types.OTHER, ""POINT"");
    }",0,[0]
484,bugs-dot-jar_CAMEL-4370_7345fefc,"protected String normalizePathToProtocol(String path) {
        if (ObjectHelper.isEmpty(path)) {
            return path;
        }
        path = path.replace('/', getFileSeparator());
        path = path.replace('\\', getFileSeparator());
        return path;
    }","protected String normalizePathToProtocol(String path) {
        if (ObjectHelper.isEmpty(path)) {
            return path;
        }
        path = path.replace('/', getFileSeparator());
        path = path.replace('\\', getFileSeparator());
        return path;
    }",0,[0]
27132,bugs-dot-jar_MATH-395_962315ba,"public double getAbsoluteAccuracy() {
        return absoluteAccuracy;
    }","public double getAbsoluteAccuracy() {
        return absoluteAccuracy;
    }",0,[0]
1170,Bears-152,"public void setRegister(Boolean register) {
        this.register = register;
    }","public void setRegister(Boolean register) {
        this.register = register;
    }",0,[0]
16648,bugs-dot-jar_WICKET-5689_2ac29d30,"WebResponse createWebResponse(final WebRequest webRequest,
		final HttpServletResponse httpServletResponse)
	{
		WebResponse webResponse = newWebResponse(webRequest, httpServletResponse);

		boolean shouldBufferResponse = getRequestCycleSettings().getBufferResponse();
		return shouldBufferResponse ? new HeaderBufferingWebResponse(webResponse) : webResponse;
	}","WebResponse createWebResponse(final WebRequest webRequest,
		final HttpServletResponse httpServletResponse)
	{
		WebResponse webResponse = newWebResponse(webRequest, httpServletResponse);

		boolean shouldBufferResponse = getRequestCycleSettings().getBufferResponse();
		return shouldBufferResponse ? new HeaderBufferingWebResponse(webResponse) : webResponse;
	}",0,[0]
36258,bugs-dot-jar_CAMEL-9444_baece126,"public RecipientListDefinition<Type> aggregationStrategyMethodAllowNull() {
        setStrategyMethodAllowNull(true);
        return this;
    }","public RecipientListDefinition<Type> aggregationStrategyMethodAllowNull() {
        setStrategyMethodAllowNull(true);
        return this;
    }",0,[0]
18489,bugs-dot-jar_FLINK-2294_fef9f115,"public OutputHandler(StreamTask<OUT, ?> vertex) {

		// Initialize some fields
		this.vertex = vertex;
		this.configuration = new StreamConfig(vertex.getTaskConfiguration());
		this.chainedOperators = new ArrayList<StreamOperator<?>>();
		this.outputMap = new HashMap<StreamEdge, StreamOutput<?>>();
		this.cl = vertex.getUserCodeClassLoader();

		// We read the chained configs, and the order of record writer
		// registrations by outputname
		this.chainedConfigs = configuration.getTransitiveChainedTaskConfigs(cl);
		this.chainedConfigs.put(configuration.getVertexID(), configuration);

		this.outEdgesInOrder = configuration.getOutEdgesInOrder(cl);

		// We iterate through all the out edges from this job vertex and create
		// a stream output
		for (StreamEdge outEdge : outEdgesInOrder) {
			StreamOutput<?> streamOutput = createStreamOutput(
					outEdge,
					outEdge.getTargetId(),
					chainedConfigs.get(outEdge.getSourceId()),
					outEdgesInOrder.indexOf(outEdge));
			outputMap.put(outEdge, streamOutput);
		}

		// We create the outer output that will be passed to the first task
		// in the chain
		this.outerOutput = createChainedCollector(configuration);
		
		// Add the head operator to the end of the list
		this.chainedOperators.add(vertex.streamOperator);
	}","public OutputHandler(StreamTask<OUT, ?> vertex) {

		// Initialize some fields
		this.vertex = vertex;
		this.configuration = new StreamConfig(vertex.getTaskConfiguration());
		this.chainedOperators = new ArrayList<StreamOperator<?>>();
		this.outputMap = new HashMap<StreamEdge, StreamOutput<?>>();
		this.cl = vertex.getUserCodeClassLoader();

		// We read the chained configs, and the order of record writer
		// registrations by outputname
		this.chainedConfigs = configuration.getTransitiveChainedTaskConfigs(cl);
		this.chainedConfigs.put(configuration.getVertexID(), configuration);

		this.outEdgesInOrder = configuration.getOutEdgesInOrder(cl);

		// We iterate through all the out edges from this job vertex and create
		// a stream output
		for (StreamEdge outEdge : outEdgesInOrder) {
			StreamOutput<?> streamOutput = createStreamOutput(
					outEdge,
					outEdge.getTargetId(),
					chainedConfigs.get(outEdge.getSourceId()),
					outEdgesInOrder.indexOf(outEdge));
			outputMap.put(outEdge, streamOutput);
		}

		// We create the outer output that will be passed to the first task
		// in the chain
		this.outerOutput = createChainedCollector(configuration);
		
		// Add the head operator to the end of the list
		this.chainedOperators.add(vertex.streamOperator);
	}",0,[0]
13160,bugs-dot-jar_OAK-2434_8159fc21,"@Override
    public String getPlanDescription(IndexPlan plan, NodeState root) {
        Filter filter = plan.getFilter();
        IndexNode index = tracker.acquireIndexNode(pr(plan).indexPath);
        checkState(index != null, ""The Lucene index is not available"");
        try {
            FullTextExpression ft = filter.getFullTextConstraint();
            StringBuilder sb = new StringBuilder(""lucene:"");
            String path = pr(plan).indexPath;
            sb.append(getIndexName(plan))
                    .append(""("")
                    .append(path)
                    .append("") "");
            sb.append(getQuery(plan, null));
            if(plan.getSortOrder() != null && !plan.getSortOrder().isEmpty()){
                sb.append("" ordering:"").append(plan.getSortOrder());
            }
            if (ft != null) {
                sb.append("" ft:("").append(ft).append("")"");
            }
            return sb.toString();
        } finally {
            index.release();
        }
    }","@Override
    public String getPlanDescription(IndexPlan plan, NodeState root) {
        Filter filter = plan.getFilter();
        IndexNode index = tracker.acquireIndexNode(pr(plan).indexPath);
        checkState(index != null, ""The Lucene index is not available"");
        try {
            FullTextExpression ft = filter.getFullTextConstraint();
            StringBuilder sb = new StringBuilder(""lucene:"");
            String path = pr(plan).indexPath;
            sb.append(getIndexName(plan))
                    .append(""("")
                    .append(path)
                    .append("") "");
            sb.append(getQuery(plan, null));
            if(plan.getSortOrder() != null && !plan.getSortOrder().isEmpty()){
                sb.append("" ordering:"").append(plan.getSortOrder());
            }
            if (ft != null) {
                sb.append("" ft:("").append(ft).append("")"");
            }
            return sb.toString();
        } finally {
            index.release();
        }
    }",0,[0]
30272,bugs-dot-jar_OAK-1208_cb3ac20d,"private static void addNonFullTextConstraints(List<Query> qs,
            Filter filter, IndexReader reader) {
        if (!filter.matchesAllTypes()) {
            addNodeTypeConstraints(qs, filter);
        }

        String path = filter.getPath();
        switch (filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (""/"".equals(path)) {
                break;
            }
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case DIRECT_CHILDREN:
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (PathUtils.denotesRoot(path)) {
                // there's no parent of the root node
                // we add a path that can not possibly occur because there
                // is no way to say ""match no documents"" in Lucene
                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(PathUtils.getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
        }

        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
            String name = pr.propertyName;
            if (name.contains(""/"")) {
                // lucene cannot handle child-level property restrictions
                continue;
            }
            if (""rep:excerpt"".equals(name)) {
                continue;
            }
            // TODO OAK-985
            if (JcrConstants.JCR_PRIMARYTYPE.equals(name)) {
                continue;
            }

            String first = null;
            String last = null;
            boolean isLike = pr.isLike;

            // TODO what to do with escaped tokens?
            if (pr.first != null) {
                first = pr.first.getValue(Type.STRING);
                first = first.replace(""\\"", """");
            }
            if (pr.last != null) {
                last = pr.last.getValue(Type.STRING);
                last = last.replace(""\\"", """");
            }

            if (isLike) {
                first = first.replace('%', WildcardQuery.WILDCARD_STRING);
                first = first.replace('_', WildcardQuery.WILDCARD_CHAR);

                int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
                int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
                int len = first.length();

                if (indexOfWS == len || indexOfWC == len) {
                    // remove trailing ""*"" for prefixquery
                    first = first.substring(0, first.length() - 1);
                    if (JCR_PATH.equals(name)) {
                        qs.add(new PrefixQuery(newPathTerm(first)));
                    } else {
                        qs.add(new PrefixQuery(new Term(name, first)));
                    }
                } else {
                    if (JCR_PATH.equals(name)) {
                        qs.add(new WildcardQuery(newPathTerm(first)));
                    } else {
                        qs.add(new WildcardQuery(new Term(name, first)));
                    }
                }
                continue;
            }

            if (first != null && first.equals(last) && pr.firstIncluding
                    && pr.lastIncluding) {
                if (JCR_PATH.equals(name)) {
                    qs.add(new TermQuery(newPathTerm(first)));
                } else {
                    if (""*"".equals(name)) {
                        addReferenceConstraint(first, qs, reader);
                    } else {
                        qs.add(new TermQuery(new Term(name, first)));
                    }
                }
                continue;
            }

            qs.add(TermRangeQuery.newStringRange(name, first, last,
                    pr.firstIncluding, pr.lastIncluding));
        }
    }","private static void addNonFullTextConstraints(List<Query> qs,
            Filter filter, IndexReader reader) {
        if (!filter.matchesAllTypes()) {
            addNodeTypeConstraints(qs, filter);
        }

        String path = filter.getPath();
        switch (filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (""/"".equals(path)) {
                break;
            }
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case DIRECT_CHILDREN:
            if (!path.endsWith(""/"")) {
                path += ""/"";
            }
            qs.add(new PrefixQuery(newPathTerm(path)));
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (PathUtils.denotesRoot(path)) {
                // there's no parent of the root node
                // we add a path that can not possibly occur because there
                // is no way to say ""match no documents"" in Lucene
                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(PathUtils.getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
        }

        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {

            if (pr.first == null && pr.last == null) {
                // ignore property existence checks, Lucene can't to 'property
                // is not null' queries (OAK-1208)
                continue;
            }

            String name = pr.propertyName;
            if (name.contains(""/"")) {
                // lucene cannot handle child-level property restrictions
                continue;
            }
            if (""rep:excerpt"".equals(name)) {
                continue;
            }
            // TODO OAK-985
            if (JcrConstants.JCR_PRIMARYTYPE.equals(name)) {
                continue;
            }

            String first = null;
            String last = null;
            boolean isLike = pr.isLike;

            // TODO what to do with escaped tokens?
            if (pr.first != null) {
                first = pr.first.getValue(Type.STRING);
                first = first.replace(""\\"", """");
            }
            if (pr.last != null) {
                last = pr.last.getValue(Type.STRING);
                last = last.replace(""\\"", """");
            }

            if (isLike) {
                first = first.replace('%', WildcardQuery.WILDCARD_STRING);
                first = first.replace('_', WildcardQuery.WILDCARD_CHAR);

                int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
                int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
                int len = first.length();

                if (indexOfWS == len || indexOfWC == len) {
                    // remove trailing ""*"" for prefixquery
                    first = first.substring(0, first.length() - 1);
                    if (JCR_PATH.equals(name)) {
                        qs.add(new PrefixQuery(newPathTerm(first)));
                    } else {
                        qs.add(new PrefixQuery(new Term(name, first)));
                    }
                } else {
                    if (JCR_PATH.equals(name)) {
                        qs.add(new WildcardQuery(newPathTerm(first)));
                    } else {
                        qs.add(new WildcardQuery(new Term(name, first)));
                    }
                }
                continue;
            }

            if (first != null && first.equals(last) && pr.firstIncluding
                    && pr.lastIncluding) {
                if (JCR_PATH.equals(name)) {
                    qs.add(new TermQuery(newPathTerm(first)));
                } else {
                    if (""*"".equals(name)) {
                        addReferenceConstraint(first, qs, reader);
                    } else {
                        qs.add(new TermQuery(new Term(name, first)));
                    }
                }
                continue;
            }

            qs.add(TermRangeQuery.newStringRange(name, first, last,
                    pr.firstIncluding, pr.lastIncluding));
        }
    }",1,[]
8269,bugs-dot-jar_MATH-934_724795b5,"public Complex(double real, double imaginary) {
        this.real = real;
        this.imaginary = imaginary;

        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
        isInfinite = !isNaN &&
            (Double.isInfinite(real) || Double.isInfinite(imaginary));
    }","public Complex(double real, double imaginary) {
        this.real = real;
        this.imaginary = imaginary;

        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
        isInfinite = !isNaN &&
            (Double.isInfinite(real) || Double.isInfinite(imaginary));
    }",0,[0]
2077,bugs-dot-jar_WICKET-2961_3d8c9d75,"public void prepareForRender(boolean setRenderingFlag)
	{
		beforeRender();

		if (setRenderingFlag)
		{
			// only process feedback panel when we are about to be rendered.
			// setRenderingFlag is false in case prepareForRender is called only to build component
			// hierarchy (i.e. in BookmarkableListenerInterfaceRequestTarget).
			// prepareForRender(true) is always called before the actual rendering is done so
			// that's where feedback panels gather the messages

			List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);
			if (feedbacks != null)
			{
				for (int i = 0; i < feedbacks.size(); i++)
				{
					feedbacks.get(i).internalBeforeRender();
				}
			}
			getRequestCycle().setMetaData(FEEDBACK_LIST, null);
		}

		markRendering(setRenderingFlag);

		// check authorization
		// first the component itself
		// (after attach as otherwise list views etc wont work)
		setRenderAllowed();
	}","public void prepareForRender(boolean setRenderingFlag)
	{
		beforeRender();

		if (setRenderingFlag)
		{
			// only process feedback panel when we are about to be rendered.
			// setRenderingFlag is false in case prepareForRender is called only to build component
			// hierarchy (i.e. in BookmarkableListenerInterfaceRequestTarget).
			// prepareForRender(true) is always called before the actual rendering is done so
			// that's where feedback panels gather the messages

			List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);
			if (feedbacks != null)
			{
				for (int i = 0; i < feedbacks.size(); i++)
				{
					feedbacks.get(i).internalBeforeRender();
				}
			}
			getRequestCycle().setMetaData(FEEDBACK_LIST, null);
		}

		markRendering(setRenderingFlag);

		// check authorization
		// first the component itself
		// (after attach as otherwise list views etc wont work)
		setRenderAllowed();
	}",0,[0]
7733,bugs-dot-jar_OAK-1104_7ae92779,"private RecordId[] getBuckets(Segment segment) {
        RecordId[] buckets = new RecordId[BUCKETS_PER_LEVEL];
        int bitmap = segment.readInt(getOffset(4));
        int ids = 0;
        for (int i = 0; i < BUCKETS_PER_LEVEL; i++) {
            if ((bitmap & (1 << i)) != 0) {
                buckets[i] = segment.readRecordId(getOffset(8, ids++));
            } else {
                buckets[i] = null;
            }
        }
        return buckets;
    }","private RecordId[] getBuckets(Segment segment) {
        RecordId[] buckets = new RecordId[BUCKETS_PER_LEVEL];
        int bitmap = segment.readInt(getOffset(4));
        int ids = 0;
        for (int i = 0; i < BUCKETS_PER_LEVEL; i++) {
            if ((bitmap & (1 << i)) != 0) {
                buckets[i] = segment.readRecordId(getOffset(8, ids++));
            } else {
                buckets[i] = null;
            }
        }
        return buckets;
    }",0,[0]
2601,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void createLocalUser(ByteBuffer login, String user, ByteBuffer password) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      getConnector(login).securityOperations().createLocalUser(user, new PasswordToken(password));
    } catch (Exception e) {
      handleException(e);
    }
  }","@Override
  public void createLocalUser(ByteBuffer login, String user, ByteBuffer password) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      getConnector(login).securityOperations().createLocalUser(user, new PasswordToken(password));
    } catch (Exception e) {
      handleException(e);
    }
  }",0,[0]
26913,bugs-dot-jar_WICKET-5724_b92591f6,"public final void putInternal(String key, CharSequence value)
	{
		xmlTag.put(key, value);
		setModified(true);
	}","public final void putInternal(String key, CharSequence value)
	{
		xmlTag.put(key, value);
		setModified(true);
	}",0,[0]
35528,bugs-dot-jar_OAK-3930_b939aa6e,"@Override
    public void ignorableWhitespace(char[] ch, int start, int length)
            throws SAXException {
        if (currentPropValue != null) {
            // property value

            // data reported by the ignorableWhitespace event within
            // sv:value tags is considered part of the value
            try {
                currentPropValue.append(ch, start, length);
            } catch (IOException ioe) {
                throw new SAXException(""error while processing property value"",
                        ioe);
            }
        }
    }","@Override
    public void ignorableWhitespace(char[] ch, int start, int length)
            throws SAXException {
        if (currentPropValue != null) {
            // property value

            // data reported by the ignorableWhitespace event within
            // sv:value tags is considered part of the value
            try {
                currentPropValue.append(ch, start, length);
            } catch (IOException ioe) {
                throw new SAXException(""error while processing property value"",
                        ioe);
            }
        }
    }",0,[0]
37374,bugs-dot-jar_LOG4J2-492_a759d8ae,"private static void registerContexts(final List<LoggerContext> contexts, final MBeanServer mbs,
            final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException,
            NotCompliantMBeanException {

        for (final LoggerContext ctx : contexts) {
            // first unregister the context and all nested loggers & appenders
            unregisterContext(ctx.getName());
            
            final LoggerContextAdmin mbean = new LoggerContextAdmin(ctx, executor);
            register(mbs, mbean, mbean.getObjectName());
            
            if (ctx instanceof AsyncLoggerContext) {
                RingBufferAdmin rbmbean = AsyncLogger.createRingBufferAdmin(ctx.getName());
                register(mbs, rbmbean, rbmbean.getObjectName());
            }
        }
    }","private static void registerContexts(final List<LoggerContext> contexts, final MBeanServer mbs,
            final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException,
            NotCompliantMBeanException {

        for (final LoggerContext ctx : contexts) {
            // first unregister the context and all nested loggers & appenders
            unregisterContext(ctx.getName());
            
            final LoggerContextAdmin mbean = new LoggerContextAdmin(ctx, executor);
            register(mbs, mbean, mbean.getObjectName());
            
            if (ctx instanceof AsyncLoggerContext) {
                RingBufferAdmin rbmbean = AsyncLogger.createRingBufferAdmin(ctx.getName());
                register(mbs, rbmbean, rbmbean.getObjectName());
            }
        }
    }",0,[0]
6319,bugs-dot-jar_WICKET-2261_089303f4,"public final WebApplication getApplication()
	{
		return application;
	}","public final WebApplication getApplication()
	{
		return application;
	}",0,[0]
2890,bugs-dot-jar_WICKET-3455_f30bd1cb,"public MarkupType getMarkupType()
	{
		try
		{
			return getPage().getMarkupType();
		}
		catch (Exception ex)
		{
			throw new WicketRuntimeException(
				""Unable to determine the markup type which e.g. is used for the extension of the markup file. ""
					+ ""Probably the component is not yet added to the Page. ""
					+ ""You may defer markup access to a later point in time or subclass getMarkupType(). ""
					+ ""Please see IModel, onMarkupAttached() or onInitialize()"", ex);
		}
	}","public MarkupType getMarkupType()
	{
		try
		{
			return getPage().getMarkupType();
		}
		catch (Exception ex)
		{
			throw new WicketRuntimeException(
				""Unable to determine the markup type which e.g. is used for the extension of the markup file. ""
					+ ""Probably the component is not yet added to the Page. ""
					+ ""You may defer markup access to a later point in time or subclass getMarkupType(). ""
					+ ""Please see IModel, onMarkupAttached() or onInitialize()"", ex);
		}
	}",0,[0]
19188,bugs-dot-jar_WICKET-4119_bb7a6995,"public URL getResource(String name) throws MalformedURLException
	{
		if (webappRoot == null)
		{
			return null;
		}

		if (name.startsWith(""/""))
		{
			name = name.substring(1);
		}

		File f = new File(webappRoot, name);
		if (!f.exists())
		{
			return null;
		}
		else
		{
			return f.toURI().toURL();
		}
	}","public URL getResource(String name) throws MalformedURLException
	{
		if (webappRoot == null)
		{
			return null;
		}

		if (name.startsWith(""/""))
		{
			name = name.substring(1);
		}

		File f = new File(webappRoot, name);
		if (!f.exists())
		{
			return null;
		}
		else
		{
			return f.toURI().toURL();
		}
	}",0,[0]
20439,bugs-dot-jar_WICKET-128_7e1000dd,"public final IPageFactory getPageFactory()
	{
		return getApplication().getSessionSettings().getPageFactory();
	}","public final IPageFactory getPageFactory()
	{
		return getApplication().getSessionSettings().getPageFactory();
	}",0,[0]
32696,bugs-dot-jar_CAMEL-3617_02626724,"public void error(TransformerException exception) throws TransformerException {
        throw exception;
    }","public void error(TransformerException exception) throws TransformerException {
        throw exception;
    }",0,[0]
14421,bugs-dot-jar_CAMEL-8954_7b1253db,"@Override
    public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {
        // noop
    }","@Override
    public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {
        // noop
    }",0,[0]
12911,bugs-dot-jar_LOG4J2-293_25cb587a,"public static void removeConfigurationFactory(final ConfigurationFactory factory) {
        if (configFactory == factory) {
            configFactory = new Factory();
        }
    }","public static void removeConfigurationFactory(final ConfigurationFactory factory) {
        if (configFactory == factory) {
            configFactory = new Factory();
        }
    }",0,[0]
34949,bugs-dot-jar_CAMEL-5570_a57830ed,"public String getOnRedeliveryRef() {
        return onRedeliveryRef;
    }","public String getOnRedeliveryRef() {
        return onRedeliveryRef;
    }",0,[0]
24833,bugs-dot-jar_CAMEL-5187_8cadc344,"public Integer getConnectorPort() {
        return connectorPort;
    }","public Integer getConnectorPort() {
        return connectorPort;
    }",0,[0]
26942,bugs-dot-jar_WICKET-5724_b92591f6,"public Object getUserData(final String key)
	{
		if (userData == null)
		{
			return null;
		}

		return userData.get(key);
	}","public Object getUserData(final String key)
	{
		if (userData == null)
		{
			return null;
		}

		return userData.get(key);
	}",0,[0]
180,bugs-dot-jar_WICKET-2368_fae1601b,"public final void endComponentRender(Component component)
	{
		if (component instanceof MarkupContainer)
		{
			checkRendering((MarkupContainer)component);
		}
		else
		{
			renderedComponents = null;
		}
	}","public final void endComponentRender(Component component)
	{
		if (component instanceof MarkupContainer)
		{
			checkRendering((MarkupContainer)component);
		}
		else
		{
			renderedComponents = null;
		}
	}",0,[0]
8032,bugs-dot-jar_OAK-2147_a1556c30,"private static void printWalkedLanes(final String msg, final String[] walked) {
        String m = (msg == null) ? """" : msg;
        if (walked == null) {
            LOG.debug(m + "" walked: null"");
        } else {
            for (int i = 0; i < walked.length; i++) {
                LOG.debug(""{}walked[{}]: {}"", new Object[] { m, i, walked[i] });
            }
        }
    }","private static void printWalkedLanes(final String msg, final String[] walked) {
        String m = (msg == null) ? """" : msg;
        if (walked == null) {
            LOG.debug(m + "" walked: null"");
        } else {
            for (int i = 0; i < walked.length; i++) {
                LOG.debug(""{}walked[{}]: {}"", new Object[] { m, i, walked[i] });
            }
        }
    }",0,[0]
34561,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"public static DFSLoggerInputStreams readHeaderAndReturnStream(VolumeManager fs, Path path, AccumuloConfiguration conf) throws IOException {
    FSDataInputStream input = fs.open(path);
    DataInputStream decryptingInput = null;

    byte[] magic = DfsLogger.LOG_FILE_HEADER_V3.getBytes();
    byte[] magicBuffer = new byte[magic.length];
    input.readFully(magicBuffer);
    if (Arrays.equals(magicBuffer, magic)) {
      // additional parameters it needs from the underlying stream.
      String cryptoModuleClassname = input.readUTF();
      CryptoModule cryptoModule = CryptoModuleFactory.getCryptoModule(cryptoModuleClassname);

      // Create the parameters and set the input stream into those parameters
      CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf);
      params.setEncryptedInputStream(input);

      // Create the plaintext input stream from the encrypted one
      params = cryptoModule.getDecryptingInputStream(params);

      if (params.getPlaintextInputStream() instanceof DataInputStream) {
        decryptingInput = (DataInputStream) params.getPlaintextInputStream();
      } else {
        decryptingInput = new DataInputStream(params.getPlaintextInputStream());
      }
    } else {
      input.seek(0);
      byte[] magicV2 = DfsLogger.LOG_FILE_HEADER_V2.getBytes();
      byte[] magicBufferV2 = new byte[magicV2.length];
      input.readFully(magicBufferV2);

      if (Arrays.equals(magicBufferV2, magicV2)) {
        // Log files from 1.5 dump their options in raw to the logger files. Since we don't know the class
        // that needs to read those files, we can make a couple of basic assumptions. Either it's going to be
        // the NullCryptoModule (no crypto) or the DefaultCryptoModule.

        // If it's null, we won't have any parameters whatsoever. First, let's attempt to read
        // parameters
        Map<String,String> opts = new HashMap<String,String>();
        int count = input.readInt();
        for (int i = 0; i < count; i++) {
          String key = input.readUTF();
          String value = input.readUTF();
          opts.put(key, value);
        }

        if (opts.size() == 0) {
          // NullCryptoModule, we're done
          decryptingInput = input;
        } else {

          // The DefaultCryptoModule will want to read the parameters from the underlying file, so we will put the file back to that spot.
          org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory
              .getCryptoModule(DefaultCryptoModule.class.getName());

          CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf);

          input.seek(0);
          input.readFully(magicBufferV2);
          params.setEncryptedInputStream(input);

          params = cryptoModule.getDecryptingInputStream(params);
          if (params.getPlaintextInputStream() instanceof DataInputStream) {
            decryptingInput = (DataInputStream) params.getPlaintextInputStream();
          } else {
            decryptingInput = new DataInputStream(params.getPlaintextInputStream());
          }
        }

      } else {

        input.seek(0);
        decryptingInput = input;
      }

    }
    return new DFSLoggerInputStreams(input, decryptingInput);
  }","public static DFSLoggerInputStreams readHeaderAndReturnStream(VolumeManager fs, Path path, AccumuloConfiguration conf) throws IOException {
    FSDataInputStream input = fs.open(path);
    DataInputStream decryptingInput = null;

    byte[] magic = DfsLogger.LOG_FILE_HEADER_V3.getBytes();
    byte[] magicBuffer = new byte[magic.length];
    input.readFully(magicBuffer);
    if (Arrays.equals(magicBuffer, magic)) {
      // additional parameters it needs from the underlying stream.
      String cryptoModuleClassname = input.readUTF();
      CryptoModule cryptoModule = CryptoModuleFactory.getCryptoModule(cryptoModuleClassname);

      // Create the parameters and set the input stream into those parameters
      CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf);
      params.setEncryptedInputStream(input);

      // Create the plaintext input stream from the encrypted one
      params = cryptoModule.getDecryptingInputStream(params);

      if (params.getPlaintextInputStream() instanceof DataInputStream) {
        decryptingInput = (DataInputStream) params.getPlaintextInputStream();
      } else {
        decryptingInput = new DataInputStream(params.getPlaintextInputStream());
      }
    } else {
      input.seek(0);
      byte[] magicV2 = DfsLogger.LOG_FILE_HEADER_V2.getBytes();
      byte[] magicBufferV2 = new byte[magicV2.length];
      input.readFully(magicBufferV2);

      if (Arrays.equals(magicBufferV2, magicV2)) {
        // Log files from 1.5 dump their options in raw to the logger files. Since we don't know the class
        // that needs to read those files, we can make a couple of basic assumptions. Either it's going to be
        // the NullCryptoModule (no crypto) or the DefaultCryptoModule.

        // If it's null, we won't have any parameters whatsoever. First, let's attempt to read
        // parameters
        Map<String,String> opts = new HashMap<String,String>();
        int count = input.readInt();
        for (int i = 0; i < count; i++) {
          String key = input.readUTF();
          String value = input.readUTF();
          opts.put(key, value);
        }

        if (opts.size() == 0) {
          // NullCryptoModule, we're done
          decryptingInput = input;
        } else {

          // The DefaultCryptoModule will want to read the parameters from the underlying file, so we will put the file back to that spot.
          org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory
              .getCryptoModule(DefaultCryptoModule.class.getName());

          CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf);

          input.seek(0);
          input.readFully(magicBufferV2);
          params.setEncryptedInputStream(input);

          params = cryptoModule.getDecryptingInputStream(params);
          if (params.getPlaintextInputStream() instanceof DataInputStream) {
            decryptingInput = (DataInputStream) params.getPlaintextInputStream();
          } else {
            decryptingInput = new DataInputStream(params.getPlaintextInputStream());
          }
        }

      } else {

        input.seek(0);
        decryptingInput = input;
      }

    }
    return new DFSLoggerInputStreams(input, decryptingInput);
  }",0,[0]
32450,bugs-dot-jar_CAMEL-3878_b9094cb5,"protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange,
                                                final RedeliveryData data, final AsyncCallback callback) {
        boolean sync = true;

        Exception caught = exchange.getException();

        // we did not success with the redelivery so now we let the failure processor handle it
        // clear exception as we let the failure processor handle it
        exchange.setException(null);

        boolean handled = false;
        // regard both handled or continued as being handled
        if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {
            // its handled then remove traces of redelivery attempted
            exchange.getIn().removeHeader(Exchange.REDELIVERED);
            exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
            exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);
            handled = true;
        } else {
            // must decrement the redelivery counter as we didn't process the redelivery but is
            // handling by the failure handler. So we must -1 to not let the counter be out-of-sync
            decrementRedeliveryCounter(exchange);
        }

        // is the a failure processor to process the Exchange
        if (processor != null) {

            // prepare original IN body if it should be moved instead of current body
            if (data.useOriginalInMessage) {
                log.trace(""Using the original IN message instead of current"");
                Message original = exchange.getUnitOfWork().getOriginalInMessage();
                exchange.setIn(original);
                if (exchange.hasOut()) {
                    log.trace(""Removing the out message to avoid some uncertain behavior"");
                    exchange.setOut(null);
                }
            }
            
            // reset cached streams so they can be read again
            MessageHelper.resetStreamCache(exchange.getIn());

            log.trace(""Failure processor {} is processing Exchange: {}"", processor, exchange);

            // store the last to endpoint as the failure endpoint
            exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));

            // the failure processor could also be asynchronous
            AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);
            sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    log.trace(""Failure processor done: {} processing Exchange: {}"", processor, exchange);
                    try {
                        prepareExchangeAfterFailure(exchange, data);
                        // fire event as we had a failure processor to handle it, which there is a event for
                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;
                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);
                    } finally {
                        // if the fault was handled asynchronously, this should be reflected in the callback as well
                        data.sync &= sync;
                        callback.done(data.sync);
                    }
                }
            });
        } else {
            try {
                // no processor but we need to prepare after failure as well
                prepareExchangeAfterFailure(exchange, data);
            } finally {
                // callback we are done
                callback.done(data.sync);
            }
        }

        // create log message
        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId();
        msg = msg + "". Exhausted after delivery attempt: "" + data.redeliveryCounter + "" caught: "" + caught;
        if (processor != null) {
            msg = msg + "". Processed by failure processor: "" + processor;
        }

        // log that we failed delivery as we are exhausted
        logFailedDelivery(false, handled, false, exchange, msg, data, null);

        return sync;
    }","protected boolean deliverToFailureProcessor(final Processor processor, final Exchange exchange,
                                                final RedeliveryData data, final AsyncCallback callback) {
        boolean sync = true;

        Exception caught = exchange.getException();

        // we did not success with the redelivery so now we let the failure processor handle it
        // clear exception as we let the failure processor handle it
        exchange.setException(null);

        boolean handled = false;
        // regard both handled or continued as being handled
        if (shouldHandled(exchange, data) || shouldContinue(exchange, data)) {
            // its handled then remove traces of redelivery attempted
            exchange.getIn().removeHeader(Exchange.REDELIVERED);
            exchange.getIn().removeHeader(Exchange.REDELIVERY_COUNTER);
            exchange.getIn().removeHeader(Exchange.REDELIVERY_MAX_COUNTER);
            handled = true;
        } else {
            // must decrement the redelivery counter as we didn't process the redelivery but is
            // handling by the failure handler. So we must -1 to not let the counter be out-of-sync
            decrementRedeliveryCounter(exchange);
        }

        // is the a failure processor to process the Exchange
        if (processor != null) {

            // prepare original IN body if it should be moved instead of current body
            if (data.useOriginalInMessage) {
                log.trace(""Using the original IN message instead of current"");
                Message original = exchange.getUnitOfWork().getOriginalInMessage();
                exchange.setIn(original);
                if (exchange.hasOut()) {
                    log.trace(""Removing the out message to avoid some uncertain behavior"");
                    exchange.setOut(null);
                }
            }
            
            // reset cached streams so they can be read again
            MessageHelper.resetStreamCache(exchange.getIn());

            log.trace(""Failure processor {} is processing Exchange: {}"", processor, exchange);

            // store the last to endpoint as the failure endpoint
            exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));

            // the failure processor could also be asynchronous
            AsyncProcessor afp = AsyncProcessorTypeConverter.convert(processor);
            sync = AsyncProcessorHelper.process(afp, exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    log.trace(""Failure processor done: {} processing Exchange: {}"", processor, exchange);
                    try {
                        prepareExchangeAfterFailure(exchange, data);
                        // fire event as we had a failure processor to handle it, which there is a event for
                        boolean deadLetterChannel = processor == data.deadLetterProcessor && data.deadLetterProcessor != null;
                        EventHelper.notifyExchangeFailureHandled(exchange.getContext(), exchange, processor, deadLetterChannel);
                    } finally {
                        // if the fault was handled asynchronously, this should be reflected in the callback as well
                        data.sync &= sync;
                        callback.done(data.sync);
                    }
                }
            });
        } else {
            try {
                // no processor but we need to prepare after failure as well
                prepareExchangeAfterFailure(exchange, data);
            } finally {
                // callback we are done
                callback.done(data.sync);
            }
        }

        // create log message
        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId();
        msg = msg + "". Exhausted after delivery attempt: "" + data.redeliveryCounter + "" caught: "" + caught;
        if (processor != null) {
            msg = msg + "". Processed by failure processor: "" + processor;
        }

        // log that we failed delivery as we are exhausted
        logFailedDelivery(false, handled, false, exchange, msg, data, null);

        return sync;
    }",0,[0]
129,Bears-6,"protected void _renameUsing(Map<String, POJOPropertyBuilder> propMap,
            PropertyNamingStrategy naming)
    {
        POJOPropertyBuilder[] props = propMap.values().toArray(new POJOPropertyBuilder[propMap.size()]);
        propMap.clear();
        for (POJOPropertyBuilder prop : props) {
            PropertyName fullName = prop.getFullName();
            String rename = null;
            // As per [databind#428] need to skip renaming if property has
            // explicitly defined name, unless feature  is enabled
            if (!prop.isExplicitlyNamed() || _config.isEnabled(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING)) {
                if (_forSerialization) {
                    if (prop.hasGetter()) {
                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
                    } else if (prop.hasField()) {
                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
                    }
                } else {
                    if (prop.hasSetter()) {
                        rename = naming.nameForSetterMethod(_config, prop.getSetter(), fullName.getSimpleName());
                    } else if (prop.hasConstructorParameter()) {
                        rename = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), fullName.getSimpleName());
                    } else if (prop.hasField()) {
                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
                    } else if (prop.hasGetter()) {
                        /* Plus, when getter-as-setter is used, need to convert that too..
                         * (should we verify that's enabled? For now, assume it's ok always)
                         */
                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
                    }
                }
            }
            final String simpleName;
            if (rename != null && !fullName.hasSimpleName(rename)) {
                prop = prop.withSimpleName(rename);
                simpleName = rename;
            } else {
                simpleName = fullName.getSimpleName();
            }
            /* As per [JACKSON-687], need to consider case where there may already be
             * something in there...
             */
            POJOPropertyBuilder old = propMap.get(simpleName);
            if (old == null) {
                propMap.put(simpleName, prop);
            } else {
                old.addAll(prop);
            }
            // replace the creatorProperty too, if there is one
            _updateCreatorProperty(prop, _creatorProperties);
        }
    }","protected void _renameUsing(Map<String, POJOPropertyBuilder> propMap,
            PropertyNamingStrategy naming)
    {
        POJOPropertyBuilder[] props = propMap.values().toArray(new POJOPropertyBuilder[propMap.size()]);
        propMap.clear();
        for (POJOPropertyBuilder prop : props) {
            PropertyName fullName = prop.getFullName();
            String rename = null;
            // As per [databind#428] need to skip renaming if property has
            // explicitly defined name, unless feature  is enabled
            if (!prop.isExplicitlyNamed() || _config.isEnabled(MapperFeature.ALLOW_EXPLICIT_PROPERTY_RENAMING)) {
                if (_forSerialization) {
                    if (prop.hasGetter()) {
                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
                    } else if (prop.hasField()) {
                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
                    }
                } else {
                    if (prop.hasSetter()) {
                        rename = naming.nameForSetterMethod(_config, prop.getSetter(), fullName.getSimpleName());
                    } else if (prop.hasConstructorParameter()) {
                        rename = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), fullName.getSimpleName());
                    } else if (prop.hasField()) {
                        rename = naming.nameForField(_config, prop.getField(), fullName.getSimpleName());
                    } else if (prop.hasGetter()) {
                        /* Plus, when getter-as-setter is used, need to convert that too..
                         * (should we verify that's enabled? For now, assume it's ok always)
                         */
                        rename = naming.nameForGetterMethod(_config, prop.getGetter(), fullName.getSimpleName());
                    }
                }
            }
            final String simpleName;
            if (rename != null && !fullName.hasSimpleName(rename)) {
                prop = prop.withSimpleName(rename);
                simpleName = rename;
            } else {
                simpleName = fullName.getSimpleName();
            }
            /* As per [JACKSON-687], need to consider case where there may already be
             * something in there...
             */
            POJOPropertyBuilder old = propMap.get(simpleName);
            if (old == null) {
                propMap.put(simpleName, prop);
            } else {
                old.addAll(prop);
            }
            // replace the creatorProperty too, if there is one
            _updateCreatorProperty(prop, _creatorProperties);
        }
    }",0,[0]
14932,bugs-dot-jar_CAMEL-5683_0c3c7d1b,"public int size() {
        int size = consumers.size();
        LOG.trace(""size = {}"", size);
        return size;
    }","public int size() {
        int size = consumers.size();
        LOG.trace(""size = {}"", size);
        return size;
    }",0,[0]
7082,bugs-dot-jar_LOG4J2-763_97203de8,"@Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final StringFormattedMessage that = (StringFormattedMessage) o;

        if (messagePattern != null ? !messagePattern.equals(that.messagePattern) : that.messagePattern != null) {
            return false;
        }

        return Arrays.equals(stringArgs, that.stringArgs);
    }","@Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final StringFormattedMessage that = (StringFormattedMessage) o;

        if (messagePattern != null ? !messagePattern.equals(that.messagePattern) : that.messagePattern != null) {
            return false;
        }

        return Arrays.equals(stringArgs, that.stringArgs);
    }",0,[0]
7005,bugs-dot-jar_LOG4J2-763_97203de8,"public LocalizedMessage(final ResourceBundle bundle, final String key, final Object[] arguments) {
        this(bundle, (Locale) null, key, arguments);
    }","public LocalizedMessage(final ResourceBundle bundle, final String key, final Object[] arguments) {
        this(bundle, (Locale) null, key, arguments);
    }",0,[0]
26714,bugs-dot-jar_WICKET-3989_6a8fc1cc,"private final IMarkupFragment findStartTag(final IMarkupFragment markup)
	{
		MarkupStream stream = new MarkupStream(markup);

		while (stream.skipUntil(ComponentTag.class))
		{
			ComponentTag tag = stream.getTag();
			if (tag.isOpen() || tag.isOpenClose())
			{
				if (tag instanceof WicketTag)
				{
					WicketTag wtag = (WicketTag)tag;
					if (tagName.equalsIgnoreCase(wtag.getName()))
					{
						return stream.getMarkupFragment();
					}
				}

				stream.skipToMatchingCloseTag(tag);
			}

			stream.next();
		}

		return null;
	}","private final IMarkupFragment findStartTag(final IMarkupFragment markup)
	{
		MarkupStream stream = new MarkupStream(markup);

		while (stream.skipUntil(ComponentTag.class))
		{
			ComponentTag tag = stream.getTag();
			if (tag.isOpen() || tag.isOpenClose())
			{
				if (tag instanceof WicketTag)
				{
					WicketTag wtag = (WicketTag)tag;
					if (tagName.equalsIgnoreCase(wtag.getName()))
					{
						return stream.getMarkupFragment();
					}
				}

				stream.skipToMatchingCloseTag(tag);
			}

			stream.next();
		}

		return null;
	}",0,[0]
4590,bugs-dot-jar_WICKET-4839_8b294488,"public final <C> IConverter<C> get(Class<C> c)
	{
		@SuppressWarnings(""unchecked"")
		final IConverter<C> converter;

		// Date based converters work with thread unsafe DateFormats and
		// a new instance should be created for each usage
		if (Date.class.equals(c))
		{
			converter = (IConverter<C>) new DateConverter();
		}
		else if  (java.sql.Date.class.equals(c))
		{
			converter = (IConverter<C>) new SqlDateConverter();
		}
		else if (java.sql.Time.class.equals(c))
		{
			converter = (IConverter<C>) new SqlTimeConverter();
		}
		else if (java.sql.Timestamp.class.equals(c))
		{
			converter = (IConverter<C>) new SqlTimestampConverter();
		}
		else if (Calendar.class.equals(c))
		{
			converter = (IConverter<C>) new CalendarConverter();
		}
		else
		{
			converter = (IConverter<C>)classToConverter.get(c.getName());
		}
		return converter;
	}","public final <C> IConverter<C> get(Class<C> c)
	{
		@SuppressWarnings(""unchecked"")
		IConverter<C> converter = (IConverter<C>)classToConverter.get(c.getName());

		if (converter == null)
		{
			// Date based converters work with thread unsafe DateFormats and
			// a new instance should be created for each usage
			if (Date.class.equals(c))
			{
				converter = (IConverter<C>) new DateConverter();
			}
			else if  (java.sql.Date.class.equals(c))
			{
				converter = (IConverter<C>) new SqlDateConverter();
			}
			else if (java.sql.Time.class.equals(c))
			{
				converter = (IConverter<C>) new SqlTimeConverter();
			}
			else if (java.sql.Timestamp.class.equals(c))
			{
				converter = (IConverter<C>) new SqlTimestampConverter();
			}
			else if (Calendar.class.equals(c))
			{
				converter = (IConverter<C>) new CalendarConverter();
			}
		}
		return converter;
	}",1,"[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]"
31841,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"public List<ColumnUpdate> getUpdates() {
    serialize();

    SimpleReader in = new SimpleReader(data);

    if (updates == null) {
      if (entries == 1) {
        updates = Collections.singletonList(deserializeColumnUpdate(in));
      } else {
        ColumnUpdate[] tmpUpdates = new ColumnUpdate[entries];

        for (int i = 0; i < entries; i++)
          tmpUpdates[i] = deserializeColumnUpdate(in);

        updates = Arrays.asList(tmpUpdates);
      }
    }

    return updates;
  }","public List<ColumnUpdate> getUpdates() {
    serialize();

    SimpleReader in = new SimpleReader(data);

    if (updates == null) {
      if (entries == 1) {
        updates = Collections.singletonList(deserializeColumnUpdate(in));
      } else {
        ColumnUpdate[] tmpUpdates = new ColumnUpdate[entries];

        for (int i = 0; i < entries; i++)
          tmpUpdates[i] = deserializeColumnUpdate(in);

        updates = Arrays.asList(tmpUpdates);
      }
    }

    return updates;
  }",0,[0]
834,bugs-dot-jar_WICKET-4824_ad849602,"public final HttpsConfig getConfig()
	{
		return config;
	}","public final HttpsConfig getConfig()
	{
		return config;
	}",0,[0]
132,Bears-6,"protected void reportProblem(String msg) {
        throw new IllegalArgumentException(""Problem with definition of ""+_classDef+"": ""+msg);
    }","protected void reportProblem(String msg) {
        throw new IllegalArgumentException(""Problem with definition of ""+_classDef+"": ""+msg);
    }",0,[0]
15398,bugs-dot-jar_LOG4J2-147_17296089,"@Override
    public Result filter(final LogEvent event) {
        return super.filter(event.getContextMap()) ? onMatch : onMismatch;
    }","@Override
    public Result filter(final LogEvent event) {
        return super.filter(event.getContextMap()) ? onMatch : onMismatch;
    }",0,[0]
9288,bugs-dot-jar_WICKET-4185_5fd03973,"public void detach(IRequestCycle requestCycle)
	{
		if (logData == null)
		{
			logData = new ListenerInterfaceLogData(pageComponentProvider, listenerInterface,
				behaviorId);
		}
		pageComponentProvider.detach();
	}","public void detach(IRequestCycle requestCycle)
	{
		if (logData == null)
		{
			logData = new ListenerInterfaceLogData(pageComponentProvider, listenerInterface,
				behaviorId);
		}
		pageComponentProvider.detach();
	}",0,[0]
6884,bugs-dot-jar_OAK-2062_5c4589bd,"@Override
    public FilterImpl createFilter(boolean preparing) {
        FilterImpl f = new FilterImpl(this, query.getStatement(), query.getSettings());
        f.setPreparing(preparing);
        if (joinCondition != null) {
            joinCondition.restrict(f);
        }
        // rep:excerpt handling: create a (fake) restriction
        // ""rep:excerpt is not null"" to let the index know that
        // we will need the excerpt
        for (ColumnImpl c : query.getColumns()) {
            if (c.getSelector().equals(this)) {
                if (c.getColumnName().equals(""rep:excerpt"")) {
                    f.restrictProperty(""rep:excerpt"", Operator.NOT_EQUAL, null);
                }
            }
        }
        
        // all conditions can be pushed to the selectors -
        // except in some cases to ""outer joined"" selectors,
        // but the exceptions are handled in the condition
        // itself.
        // An example where it *is* a problem:
        //  ""select * from a left outer join b on a.x = b.y
        // where b.y is null"" - in this case the selector b
        // must not use an index condition on ""y is null""
        // ("".. is null"" must be written as ""not .. is not null"").
        if (queryConstraint != null) {
            queryConstraint.restrict(f);
            FullTextExpression ft = queryConstraint.getFullTextConstraint(this);
            f.setFullTextConstraint(ft);
        }
        for (ConstraintImpl constraint : selectorConstraints) {
            constraint.restrict(f);
        }

        return f;
    }","@Override
    public FilterImpl createFilter(boolean preparing) {
        FilterImpl f = new FilterImpl(this, query.getStatement(), query.getSettings());
        f.setPreparing(preparing);
        if (joinCondition != null) {
            joinCondition.restrict(f);
        }
        // rep:excerpt handling: create a (fake) restriction
        // ""rep:excerpt is not null"" to let the index know that
        // we will need the excerpt
        for (ColumnImpl c : query.getColumns()) {
            if (c.getSelector().equals(this)) {
                if (c.getColumnName().equals(""rep:excerpt"")) {
                    f.restrictProperty(""rep:excerpt"", Operator.NOT_EQUAL, null);
                }
            }
        }
        
        // all conditions can be pushed to the selectors -
        // except in some cases to ""outer joined"" selectors,
        // but the exceptions are handled in the condition
        // itself.
        // An example where it *is* a problem:
        //  ""select * from a left outer join b on a.x = b.y
        // where b.y is null"" - in this case the selector b
        // must not use an index condition on ""y is null""
        // ("".. is null"" must be written as ""not .. is not null"").
        if (queryConstraint != null) {
            queryConstraint.restrict(f);
            FullTextExpression ft = queryConstraint.getFullTextConstraint(this);
            f.setFullTextConstraint(ft);
        }
        for (ConstraintImpl constraint : selectorConstraints) {
            constraint.restrict(f);
        }

        return f;
    }",0,[0]
18829,bugs-dot-jar_MATH-935_48dde378,"public void remainder(final double[] lhs, final int lhsOffset,
                          final double[] rhs, final int rhsOffset,
                          final double[] result, final int resultOffset) {

        // compute k such that lhs % rhs = lhs - k rhs
        final double rem = lhs[lhsOffset] % rhs[rhsOffset];
        final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);

        // set up value
        result[resultOffset] = rem;

        // set up partial derivatives
        for (int i = 1; i < getSize(); ++i) {
            result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];
        }

    }","public void remainder(final double[] lhs, final int lhsOffset,
                          final double[] rhs, final int rhsOffset,
                          final double[] result, final int resultOffset) {

        // compute k such that lhs % rhs = lhs - k rhs
        final double rem = lhs[lhsOffset] % rhs[rhsOffset];
        final double k   = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);

        // set up value
        result[resultOffset] = rem;

        // set up partial derivatives
        for (int i = 1; i < getSize(); ++i) {
            result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];
        }

    }",0,[0]
40382,bugs-dot-jar_WICKET-442_246d53c5,"public final Object getModelObject()
	{
		final IModel model = getModel();
		if (model != null)
		{
			// Get model value for this component.
			return model.getObject();
		}
		else
		{
			return null;
		}
	}","public final Object getModelObject()
	{
		final IModel model = getModel();
		if (model != null)
		{
			// Get model value for this component.
			return model.getObject();
		}
		else
		{
			return null;
		}
	}",0,[0]
20800,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Converter
    public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {
        if (exchange != null) {
            // use a file input stream if its a java.io.File
            if (file.getFile() instanceof java.io.File) {
                return IOHelper.buffered(new FileInputStream((File) file.getFile()));
            }
            // otherwise ensure the body is loaded as we want the input stream of the body
            file.getBinding().loadContent(exchange, file);
            return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());
        } else {
            // should revert to fallback converter if we don't have an exchange
            return null;
        }
    }","@Converter
    public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {
        if (exchange != null) {
            if (file.getFile() instanceof java.io.File) {
                // prefer to use a file input stream if its a java.io.File (must use type converter to take care of encoding)
                File f = (File) file.getFile();
                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, f);
                if (is != null) {
                    return is;
                }
            }
            // otherwise ensure the body is loaded as we want the input stream of the body
            file.getBinding().loadContent(exchange, file);
            return exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, file.getBody());
        } else {
            // should revert to fallback converter if we don't have an exchange
            return null;
        }
    }",1,"[1, 3, 5]"
1721,Bears-197,"public URIBuilder setPath(final String path) {
        this.path = path;
        this.encodedSchemeSpecificPart = null;
        this.encodedPath = null;
        return this;
    }","public URIBuilder setPath(final String path) {
        this.path = path;
        this.encodedSchemeSpecificPart = null;
        this.encodedPath = null;
        return this;
    }",0,[0]
2858,bugs-dot-jar_OAK-1364_05c89637,"public void setAverageMemory(int averageMemory) {
        if (averageMemory <= 0) {
            throw new IllegalArgumentException(""Average memory must be larger than 0"");
        }
        this.averageMemory = averageMemory;
        if (segments != null) {
            for (Segment<K, V> s : segments) {
                s.setAverageMemory(averageMemory);
            }
        }
    }","public void setAverageMemory(int averageMemory) {
        if (averageMemory <= 0) {
            throw new IllegalArgumentException(""Average memory must be larger than 0"");
        }
        this.averageMemory = averageMemory;
        if (segments != null) {
            for (Segment<K, V> s : segments) {
                s.setAverageMemory(averageMemory);
            }
        }
    }",0,[0]
18004,bugs-dot-jar_ACCUMULO-1348_ef0f6ddc,"public Class<? extends Formatter> getFormatter(String tableName) {
    Class<? extends Formatter> formatter = FormatterCommand.getCurrentFormatter(tableName, this);
    
    if (null == formatter) {
      logError(""Could not load the specified formatter. Using the DefaultFormatter"");
      return this.defaultFormatterClass;
    } else {
      return formatter;
    }
  }","public Class<? extends Formatter> getFormatter(String tableName) {
    Class<? extends Formatter> formatter = FormatterCommand.getCurrentFormatter(tableName, this);
    
    if (null == formatter) {
      logError(""Could not load the specified formatter. Using the DefaultFormatter"");
      return this.defaultFormatterClass;
    } else {
      return formatter;
    }
  }",0,[0]
38207,bugs-dot-jar_CAMEL-3314_4badd9c5,"@SuppressWarnings(""unchecked"")
    public Type routingSlip(String header) {
        RoutingSlipDefinition answer = new RoutingSlipDefinition(header);
        addOutput(answer);
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    public Type routingSlip(String header) {
        RoutingSlipDefinition answer = new RoutingSlipDefinition(header);
        addOutput(answer);
        return (Type) this;
    }",0,[0]
31278,bugs-dot-jar_CAMEL-8125_36e7b668,"@SuppressWarnings({""unchecked"", ""rawtypes""})
    private static <T> void doFindType(List<ProcessorDefinition<?>> outputs, Class<T> type, List<T> found) {
        if (outputs == null || outputs.isEmpty()) {
            return;
        }

        for (ProcessorDefinition out : outputs) {

            // send is much common
            if (out instanceof SendDefinition) {
                SendDefinition send = (SendDefinition) out;
                List<ProcessorDefinition<?>> children = send.getOutputs();
                doFindType(children, type, found);
            }

            // special for choice
            if (out instanceof ChoiceDefinition) {
                ChoiceDefinition choice = (ChoiceDefinition) out;
                for (WhenDefinition when : choice.getWhenClauses()) {
                    if (type.isInstance(when)) {
                        found.add((T)when);   
                    }
                    List<ProcessorDefinition<?>> children = when.getOutputs();
                    doFindType(children, type, found);
                }

                // otherwise is optional
                if (choice.getOtherwise() != null) {
                    List<ProcessorDefinition<?>> children = choice.getOtherwise().getOutputs();
                    doFindType(children, type, found);
                }

                // do not check children as we already did that
                continue;
            }

            // special for try ... catch ... finally
            if (out instanceof TryDefinition) {
                TryDefinition doTry = (TryDefinition) out;
                List<ProcessorDefinition<?>> doTryOut = doTry.getOutputsWithoutCatches();
                doFindType(doTryOut, type, found);

                List<CatchDefinition> doTryCatch = doTry.getCatchClauses();
                for (CatchDefinition doCatch : doTryCatch) {
                    doFindType(doCatch.getOutputs(), type, found);
                }

                if (doTry.getFinallyClause() != null) {
                    doFindType(doTry.getFinallyClause().getOutputs(), type, found);
                }

                // do not check children as we already did that
                continue;
            }

            // special for some types which has special outputs
            if (out instanceof OutputDefinition) {
                OutputDefinition outDef = (OutputDefinition) out;
                List<ProcessorDefinition<?>> outDefOut = outDef.getOutputs();
                doFindType(outDefOut, type, found);

                // do not check children as we already did that
                continue;
            }

            if (type.isInstance(out)) {
                found.add((T)out);
            }

            // try children as well
            List<ProcessorDefinition<?>> children = out.getOutputs();
            doFindType(children, type, found);
        }
    }","@SuppressWarnings({""unchecked"", ""rawtypes""})
    private static <T> void doFindType(List<ProcessorDefinition<?>> outputs, Class<T> type, List<T> found) {
        if (outputs == null || outputs.isEmpty()) {
            return;
        }

        for (ProcessorDefinition out : outputs) {

            // send is much common
            if (out instanceof SendDefinition) {
                SendDefinition send = (SendDefinition) out;
                List<ProcessorDefinition<?>> children = send.getOutputs();
                doFindType(children, type, found);
            }

            // special for choice
            if (out instanceof ChoiceDefinition) {
                ChoiceDefinition choice = (ChoiceDefinition) out;
                for (WhenDefinition when : choice.getWhenClauses()) {
                    if (type.isInstance(when)) {
                        found.add((T)when);   
                    }
                    List<ProcessorDefinition<?>> children = when.getOutputs();
                    doFindType(children, type, found);
                }

                // otherwise is optional
                if (choice.getOtherwise() != null) {
                    List<ProcessorDefinition<?>> children = choice.getOtherwise().getOutputs();
                    doFindType(children, type, found);
                }

                // do not check children as we already did that
                continue;
            }

            // special for try ... catch ... finally
            if (out instanceof TryDefinition) {
                TryDefinition doTry = (TryDefinition) out;
                List<ProcessorDefinition<?>> doTryOut = doTry.getOutputsWithoutCatches();
                doFindType(doTryOut, type, found);

                List<CatchDefinition> doTryCatch = doTry.getCatchClauses();
                for (CatchDefinition doCatch : doTryCatch) {
                    doFindType(doCatch.getOutputs(), type, found);
                }

                if (doTry.getFinallyClause() != null) {
                    doFindType(doTry.getFinallyClause().getOutputs(), type, found);
                }

                // do not check children as we already did that
                continue;
            }

            // special for some types which has special outputs
            if (out instanceof OutputDefinition) {
                OutputDefinition outDef = (OutputDefinition) out;
                List<ProcessorDefinition<?>> outDefOut = outDef.getOutputs();
                doFindType(outDefOut, type, found);

                // do not check children as we already did that
                continue;
            }

            if (type.isInstance(out)) {
                found.add((T)out);
            }

            // try children as well
            List<ProcessorDefinition<?>> children = out.getOutputs();
            doFindType(children, type, found);
        }
    }",0,[0]
12675,bugs-dot-jar_FLINK-1985_495a5c3c,"private String createChainedName(Integer vertexID, List<StreamEdge> chainedOutputs) {
		String operatorName = streamGraph.getStreamNode(vertexID).getOperatorName();
		if (chainedOutputs.size() > 1) {
			List<String> outputChainedNames = new ArrayList<String>();
			for (StreamEdge chainable : chainedOutputs) {
				outputChainedNames.add(chainedNames.get(chainable.getTargetID()));
			}
			String returnOperatorName = operatorName + "" -> (""
					+ StringUtils.join(outputChainedNames, "", "") + "")"";
			return returnOperatorName;
		} else if (chainedOutputs.size() == 1) {
			String returnOperatorName = operatorName + "" -> ""
					+ chainedNames.get(chainedOutputs.get(0).getTargetID());
			return returnOperatorName;
		} else {
			return operatorName;
		}

	}","private String createChainedName(Integer vertexID, List<StreamEdge> chainedOutputs) {
		String operatorName = streamGraph.getStreamNode(vertexID).getOperatorName();
		if (chainedOutputs.size() > 1) {
			List<String> outputChainedNames = new ArrayList<String>();
			for (StreamEdge chainable : chainedOutputs) {
				outputChainedNames.add(chainedNames.get(chainable.getTargetID()));
			}
			String returnOperatorName = operatorName + "" -> (""
					+ StringUtils.join(outputChainedNames, "", "") + "")"";
			return returnOperatorName;
		} else if (chainedOutputs.size() == 1) {
			String returnOperatorName = operatorName + "" -> ""
					+ chainedNames.get(chainedOutputs.get(0).getTargetID());
			return returnOperatorName;
		} else {
			return operatorName;
		}

	}",0,[0]
20272,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Override
  public AccumuloConfiguration getConfiguration() {
    if (conf == null)
      conf = AccumuloConfiguration.getDefaultConfiguration();
    return conf;
  }","@Override
  public AccumuloConfiguration getConfiguration() {
    if (conf == null)
      conf = AccumuloConfiguration.getDefaultConfiguration();
    return conf;
  }",0,[0]
2891,bugs-dot-jar_WICKET-3455_f30bd1cb,"public void internalAdd(final Component child)
	{
		if (log.isDebugEnabled())
		{
			log.debug(""internalAdd "" + child.getId() + "" to "" + this);
		}

		// Add to map
		addedComponent(child);
		put(child);
	}","public void internalAdd(final Component child)
	{
		if (log.isDebugEnabled())
		{
			log.debug(""internalAdd "" + child.getId() + "" to "" + this);
		}

		// Add to map
		addedComponent(child);
		put(child);
	}",0,[0]
7491,bugs-dot-jar_WICKET-4030_5f69685d,"public boolean isClosed()
	{
		return closed;
	}","public boolean isClosed()
	{
		return closed;
	}",0,[0]
923,bugs-dot-jar_OAK-1178_84fb6b29,"private StringBuilder getPath(StringBuilder parentPath) {
        return parent == null ? parentPath : parent.getPath(parentPath).append('/').append(name);
    }","private StringBuilder getPath(StringBuilder parentPath) {
        return parent == null ? parentPath : parent.getPath(parentPath).append('/').append(name);
    }",0,[0]
31765,bugs-dot-jar_FLINK-1167_259f10c0,"public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {
		// check whether the next partial solution is itself the join with
		// the partial solution (so we can potentially do direct updates)
		if (solutionSetDelta instanceof TwoInputNode) {
			TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;
			if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode ||
				solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode)
			{
				this.solutionDeltaImmediatelyAfterSolutionJoin = true;
			}
		}
		
		// there needs to be at least one node in the workset path, so
		// if the next workset is equal to the workset, we need to inject a no-op node
		if (nextWorkset == worksetNode) {
			NoOpNode noop = new NoOpNode();
			noop.setDegreeOfParallelism(getDegreeOfParallelism());

			PactConnection noOpConn = new PactConnection(nextWorkset, noop);
			noop.setIncomingConnection(noOpConn);
			nextWorkset.addOutgoingConnection(noOpConn);
			
			nextWorkset = noop;
		}
		
		// attach an extra node to the solution set delta for the cases where we need to repartition
		UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(""Solution-Set Delta"", getSolutionSetKeyFields(),
				new SolutionSetDeltaOperator(getSolutionSetKeyFields()));
		solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());

		PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);
		solutionSetDeltaUpdateAux.setIncomingConnection(conn);
		solutionSetDelta.addOutgoingConnection(conn);
		
		this.solutionSetDelta = solutionSetDeltaUpdateAux;
		this.nextWorkset = nextWorkset;
		
		this.singleRoot = new SingleRootJoiner();
		this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);
		this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);
		this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);
		
		solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);
		nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);
	}","public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode nextWorkset) {
		// check whether the next partial solution is itself the join with
		// the partial solution (so we can potentially do direct updates)
		if (solutionSetDelta instanceof TwoInputNode) {
			TwoInputNode solutionDeltaTwoInput = (TwoInputNode) solutionSetDelta;
			if (solutionDeltaTwoInput.getFirstPredecessorNode() == this.solutionSetNode ||
				solutionDeltaTwoInput.getSecondPredecessorNode() == this.solutionSetNode)
			{
				this.solutionDeltaImmediatelyAfterSolutionJoin = true;
			}
		}
		
		// there needs to be at least one node in the workset path, so
		// if the next workset is equal to the workset, we need to inject a no-op node
		if (nextWorkset == worksetNode || nextWorkset instanceof BinaryUnionNode) {
			NoOpNode noop = new NoOpNode();
			noop.setDegreeOfParallelism(getDegreeOfParallelism());

			PactConnection noOpConn = new PactConnection(nextWorkset, noop);
			noop.setIncomingConnection(noOpConn);
			nextWorkset.addOutgoingConnection(noOpConn);
			
			nextWorkset = noop;
		}
		
		// attach an extra node to the solution set delta for the cases where we need to repartition
		UnaryOperatorNode solutionSetDeltaUpdateAux = new UnaryOperatorNode(""Solution-Set Delta"", getSolutionSetKeyFields(),
				new SolutionSetDeltaOperator(getSolutionSetKeyFields()));
		solutionSetDeltaUpdateAux.setDegreeOfParallelism(getDegreeOfParallelism());

		PactConnection conn = new PactConnection(solutionSetDelta, solutionSetDeltaUpdateAux);
		solutionSetDeltaUpdateAux.setIncomingConnection(conn);
		solutionSetDelta.addOutgoingConnection(conn);
		
		this.solutionSetDelta = solutionSetDeltaUpdateAux;
		this.nextWorkset = nextWorkset;
		
		this.singleRoot = new SingleRootJoiner();
		this.solutionSetDeltaRootConnection = new PactConnection(solutionSetDeltaUpdateAux, this.singleRoot);
		this.nextWorksetRootConnection = new PactConnection(nextWorkset, this.singleRoot);
		this.singleRoot.setInputs(this.solutionSetDeltaRootConnection, this.nextWorksetRootConnection);
		
		solutionSetDeltaUpdateAux.addOutgoingConnection(this.solutionSetDeltaRootConnection);
		nextWorkset.addOutgoingConnection(this.nextWorksetRootConnection);
	}",1,[14]
10773,bugs-dot-jar_OAK-1035_b2ca8baa,"@Override
    public Iterable<String> query(final Filter filter, final String indexName, 
            final NodeState indexMeta, final Iterable<String> values) {
        final NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);
        return new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
                PathIterator it = new PathIterator(filter, indexName);
                if (values == null) {
                    it.setPathContainsValue(true);
                    it.enqueue(index.getChildNodeEntries().iterator());
                } else {
                    for (String p : values) {
                        NodeState property = index.getChildNode(p);
                        if (property.exists()) {
                            // we have an entry for this value, so use it
                            it.enqueue(Iterators.singletonIterator(
                                    new MemoryChildNodeEntry("""", property)));
                        }
                    }
                }
                return it;
            }
        };
    }","@Override
    public Iterable<String> query(final Filter filter, final String indexName, 
            final NodeState indexMeta, final Iterable<String> values) {
        final NodeState index = indexMeta.getChildNode(INDEX_CONTENT_NODE_NAME);
        return new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
                PathIterator it = new PathIterator(filter, indexName);
                if (values == null) {
                    it.setPathContainsValue(true);
                    it.enqueue(index.getChildNodeEntries().iterator());
                } else {
                    for (String p : values) {
                        NodeState property = index.getChildNode(p);
                        if (property.exists()) {
                            // we have an entry for this value, so use it
                            it.enqueue(Iterators.singletonIterator(
                                    new MemoryChildNodeEntry("""", property)));
                        }
                    }
                }
                return it;
            }
        };
    }",0,[0]
1318,bugs-dot-jar_WICKET-5546_f1af9e03,"final void componentStateChanging(final Component component)
	{
		if (!component.isAuto())
		{
			dirty();
		}
	}","final void componentStateChanging(final Component component)
	{
		if (!component.isAuto())
		{
			dirty();
		}
	}",0,[0]
32225,bugs-dot-jar_MNG-5003_a7d9b689,"private void populatePluginFields( Object mojo, MojoDescriptor mojoDescriptor, ClassRealm pluginRealm,
                                       PlexusConfiguration configuration, ExpressionEvaluator expressionEvaluator )
        throws PluginConfigurationException
    {
        ComponentConfigurator configurator = null;

        String configuratorId = mojoDescriptor.getComponentConfigurator();

        if ( StringUtils.isEmpty( configuratorId ) )
        {
            configuratorId = ""basic"";
        }

        try
        {
            // TODO: could the configuration be passed to lookup and the configurator known to plexus via the descriptor
            // so that this method could entirely be handled by a plexus lookup?
            configurator = container.lookup( ComponentConfigurator.class, configuratorId );

            ConfigurationListener listener = new DebugConfigurationListener( logger );

            ValidatingConfigurationListener validator =
                new ValidatingConfigurationListener( mojo, mojoDescriptor, listener );

            logger.debug( ""Configuring mojo '"" + mojoDescriptor.getId() + ""' with "" + configuratorId
                + "" configurator -->"" );

            configurator.configureComponent( mojo, configuration, expressionEvaluator, pluginRealm, validator );

            logger.debug( ""-- end configuration --"" );

            Collection<Parameter> missingParameters = validator.getMissingParameters();
            if ( !missingParameters.isEmpty() )
            {
                if ( ""basic"".equals( configuratorId ) )
                {
                    throw new PluginParameterException( mojoDescriptor, new ArrayList<Parameter>( missingParameters ) );
                }
                else
                {
                    /*
                     * NOTE: Other configurators like the map-oriented one don't call into the listener, so do it the
                     * hard way.
                     */
                    validateParameters( mojoDescriptor, configuration, expressionEvaluator );
                }
            }
        }
        catch ( ComponentConfigurationException e )
        {
            String message = ""Unable to parse configuration of mojo "" + mojoDescriptor.getId();
            if ( e.getFailedConfiguration() != null )
            {
                message += "" for parameter "" + e.getFailedConfiguration().getName();
            }
            message += "": "" + e.getMessage();

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), message, e );
        }
        catch ( ComponentLookupException e )
        {
            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(),
                                                    ""Unable to retrieve component configurator "" + configuratorId
                                                        + "" for configuration of mojo "" + mojoDescriptor.getId(), e );
        }
        catch ( NoClassDefFoundError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( ""A required class was missing during configuration of mojo "" + mojoDescriptor.getId() + "": ""
                + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );
        }
        catch ( LinkageError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( ""An API incompatibility was encountered during configuration of mojo "" + mojoDescriptor.getId()
                + "": "" + e.getClass().getName() + "": "" + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );
        }
        finally
        {
            if ( configurator != null )
            {
                try
                {
                    container.release( configurator );
                }
                catch ( ComponentLifecycleException e )
                {
                    logger.debug( ""Failed to release mojo configurator - ignoring."" );
                }
            }
        }
    }","private void populatePluginFields( Object mojo, MojoDescriptor mojoDescriptor, ClassRealm pluginRealm,
                                       PlexusConfiguration configuration, ExpressionEvaluator expressionEvaluator )
        throws PluginConfigurationException
    {
        ComponentConfigurator configurator = null;

        String configuratorId = mojoDescriptor.getComponentConfigurator();

        if ( StringUtils.isEmpty( configuratorId ) )
        {
            configuratorId = ""basic"";
        }

        try
        {
            // TODO: could the configuration be passed to lookup and the configurator known to plexus via the descriptor
            // so that this method could entirely be handled by a plexus lookup?
            configurator = container.lookup( ComponentConfigurator.class, configuratorId );

            ConfigurationListener listener = new DebugConfigurationListener( logger );

            ValidatingConfigurationListener validator =
                new ValidatingConfigurationListener( mojo, mojoDescriptor, listener );

            logger.debug( ""Configuring mojo '"" + mojoDescriptor.getId() + ""' with "" + configuratorId
                + "" configurator -->"" );

            configurator.configureComponent( mojo, configuration, expressionEvaluator, pluginRealm, validator );

            logger.debug( ""-- end configuration --"" );

            Collection<Parameter> missingParameters = validator.getMissingParameters();
            if ( !missingParameters.isEmpty() )
            {
                if ( ""basic"".equals( configuratorId ) )
                {
                    throw new PluginParameterException( mojoDescriptor, new ArrayList<Parameter>( missingParameters ) );
                }
                else
                {
                    /*
                     * NOTE: Other configurators like the map-oriented one don't call into the listener, so do it the
                     * hard way.
                     */
                    validateParameters( mojoDescriptor, configuration, expressionEvaluator );
                }
            }
        }
        catch ( ComponentConfigurationException e )
        {
            String message = ""Unable to parse configuration of mojo "" + mojoDescriptor.getId();
            if ( e.getFailedConfiguration() != null )
            {
                message += "" for parameter "" + e.getFailedConfiguration().getName();
            }
            message += "": "" + e.getMessage();

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), message, e );
        }
        catch ( ComponentLookupException e )
        {
            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(),
                                                    ""Unable to retrieve component configurator "" + configuratorId
                                                        + "" for configuration of mojo "" + mojoDescriptor.getId(), e );
        }
        catch ( NoClassDefFoundError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( ""A required class was missing during configuration of mojo "" + mojoDescriptor.getId() + "": ""
                + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );
        }
        catch ( LinkageError e )
        {
            ByteArrayOutputStream os = new ByteArrayOutputStream( 1024 );
            PrintStream ps = new PrintStream( os );
            ps.println( ""An API incompatibility was encountered during configuration of mojo "" + mojoDescriptor.getId()
                + "": "" + e.getClass().getName() + "": "" + e.getMessage() );
            pluginRealm.display( ps );

            throw new PluginConfigurationException( mojoDescriptor.getPluginDescriptor(), os.toString(), e );
        }
        finally
        {
            if ( configurator != null )
            {
                try
                {
                    container.release( configurator );
                }
                catch ( ComponentLifecycleException e )
                {
                    logger.debug( ""Failed to release mojo configurator - ignoring."" );
                }
            }
        }
    }",0,[0]
19697,bugs-dot-jar_WICKET-4259_1f128536,"protected String defaultNullLabel()
	{
		return ""..."";
	}","protected String defaultNullLabel()
	{
		return ""..."";
	}",0,[0]
13889,bugs-dot-jar_WICKET-4014_e60bac5f,"public MountedMapper(String mountPath,
		ClassProvider<? extends IRequestablePage> pageClassProvider)
	{
		this(mountPath, pageClassProvider, new PageParametersEncoder());
	}","public MountedMapper(String mountPath,
		ClassProvider<? extends IRequestablePage> pageClassProvider)
	{
		this(mountPath, pageClassProvider, new PageParametersEncoder());
	}",0,[0]
4232,bugs-dot-jar_CAMEL-4682_1e54865c,"public synchronized void addRouteDefinitions(Collection<RouteDefinition> routeDefinitions) throws Exception {
        for (RouteDefinition routeDefinition : routeDefinitions) {
            removeRouteDefinition(routeDefinition);
        }
        this.routeDefinitions.addAll(routeDefinitions);
        if (shouldStartRoutes()) {
            startRouteDefinitions(routeDefinitions);
        }
    }","public synchronized void addRouteDefinitions(Collection<RouteDefinition> routeDefinitions) throws Exception {
        for (RouteDefinition routeDefinition : routeDefinitions) {
            removeRouteDefinition(routeDefinition);
        }
        this.routeDefinitions.addAll(routeDefinitions);
        if (shouldStartRoutes()) {
            startRouteDefinitions(routeDefinitions);
        }
    }",0,[0]
40872,bugs-dot-jar_CAMEL-7622_faa20255,"public static AdviceWithTask afterById(final RouteDefinition route, final String id, final ProcessorDefinition<?> after,
                                           boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchById(id);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doAfter(route, matchBy, after, it);
    }","public static AdviceWithTask afterById(final RouteDefinition route, final String id, final ProcessorDefinition<?> after,
                                           boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchById(id);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doAfter(route, matchBy, after, it);
    }",0,[0]
35893,bugs-dot-jar_MNG-4565_c6529932,"public FileProfileActivator setPathTranslator( PathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
        return this;
    }","public FileProfileActivator setPathTranslator( PathTranslator pathTranslator )
    {
        this.pathTranslator = pathTranslator;
        return this;
    }",0,[0]
27480,bugs-dot-jar_WICKET-4072_7d5b8645,"public String toAbsoluteString()
	{
		return toAbsoluteString(getCharset());
	}","public String toAbsoluteString()
	{
		return toAbsoluteString(getCharset());
	}",0,[0]
6351,bugs-dot-jar_ACCUMULO-3015_f848178e,"public static float getProgress(ByteSequence start, ByteSequence end, ByteSequence position) {
    int maxDepth = Math.min(Math.max(end.length(), start.length()), position.length());
    BigInteger startBI = new BigInteger(extractBytes(start, maxDepth));
    BigInteger endBI = new BigInteger(extractBytes(end, maxDepth));
    BigInteger positionBI = new BigInteger(extractBytes(position, maxDepth));
    return (float) (positionBI.subtract(startBI).doubleValue() / endBI.subtract(startBI).doubleValue());
  }","public static float getProgress(ByteSequence start, ByteSequence end, ByteSequence position) {
    int maxDepth = Math.min(Math.max(end.length(), start.length()), position.length());
    BigInteger startBI = new BigInteger(extractBytes(start, maxDepth));
    BigInteger endBI = new BigInteger(extractBytes(end, maxDepth));
    BigInteger positionBI = new BigInteger(extractBytes(position, maxDepth));
    return (float) (positionBI.subtract(startBI).doubleValue() / endBI.subtract(startBI).doubleValue());
  }",0,[0]
37150,bugs-dot-jar_CAMEL-7239_ae419224,"public void setFailOnNullHeader(boolean failOnNullHeader) {
        this.failOnNullHeader = failOnNullHeader;
    }","public void setFailOnNullHeader(boolean failOnNullHeader) {
        this.failOnNullHeader = failOnNullHeader;
    }",0,[0]
6488,bugs-dot-jar_CAMEL-7568_b3377b16,"public String getTraceLabel() {
        return ""onCompletion"";
    }","public String getTraceLabel() {
        return ""onCompletion"";
    }",0,[0]
22725,bugs-dot-jar_MATH-778_5b9302d5,"protected void shiftLeft() {
        for (int i = mant.length - 1; i > 0; i--) {
            mant[i] = mant[i-1];
        }
        mant[0] = 0;
        exp--;
    }","protected void shiftLeft() {
        for (int i = mant.length - 1; i > 0; i--) {
            mant[i] = mant[i-1];
        }
        mant[0] = 0;
        exp--;
    }",0,[0]
19181,bugs-dot-jar_WICKET-4119_bb7a6995,"public Enumeration<String> getInitParameterNames()
	{
		return Collections.enumeration(initParameters.keySet());
	}","public Enumeration<String> getInitParameterNames()
	{
		return Collections.enumeration(initParameters.keySet());
	}",0,[0]
17465,bugs-dot-jar_CAMEL-6604_4209fabb,"@Override
    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
        // here we iterate the recipient lists and create the exchange pair for each of those
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();

        // at first we must lookup the endpoint and acquire the producer which can send to the endpoint
        int index = 0;
        while (iter.hasNext()) {
            Object recipient = iter.next();
            Endpoint endpoint;
            Producer producer;
            try {
                endpoint = resolveEndpoint(exchange, recipient);
                producer = producerCache.acquireProducer(endpoint);
            } catch (Exception e) {
                if (isIgnoreInvalidEndpoints()) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Endpoint uri is invalid: "" + recipient + "". This exception will be ignored."", e);
                    }
                    continue;
                } else {
                    // failure so break out
                    throw e;
                }
            }

            // then create the exchange pair
            result.add(createProcessorExchangePair(index++, endpoint, producer, exchange));
        }

        return result;
    }","@Override
    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
        // here we iterate the recipient lists and create the exchange pair for each of those
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>();

        // at first we must lookup the endpoint and acquire the producer which can send to the endpoint
        int index = 0;
        while (iter.hasNext()) {
            Object recipient = iter.next();
            Endpoint endpoint;
            Producer producer;
            try {
                endpoint = resolveEndpoint(exchange, recipient);
                producer = producerCache.acquireProducer(endpoint);
            } catch (Exception e) {
                if (isIgnoreInvalidEndpoints()) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Endpoint uri is invalid: "" + recipient + "". This exception will be ignored."", e);
                    }
                    continue;
                } else {
                    // failure so break out
                    throw e;
                }
            }

            // then create the exchange pair
            result.add(createProcessorExchangePair(index++, endpoint, producer, exchange));
        }

        return result;
    }",0,[0]
16111,bugs-dot-jar_WICKET-4816_66bfc885,"public static String beforeLast(final String s, final char c)
	{
		if (s == null)
		{
			return null;
		}
		final int index = s.lastIndexOf(c);

		if (index == -1)
		{
			return """";
		}

		return s.substring(0, index);
	}","public static String beforeLast(final String s, final char c)
	{
		if (s == null)
		{
			return null;
		}
		final int index = s.lastIndexOf(c);

		if (index == -1)
		{
			return """";
		}

		return s.substring(0, index);
	}",0,[0]
34463,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"static boolean isUUID(String name) {
    if (name == null || name.length() != 36) {
      return false;
    }
    try {
      UUID.fromString(name);
      return true;
    } catch (IllegalArgumentException ex) {
      return false;
    }
  }","static boolean isUUID(String name) {
    if (name == null || name.length() != 36) {
      return false;
    }
    try {
      UUID.fromString(name);
      return true;
    } catch (IllegalArgumentException ex) {
      return false;
    }
  }",0,[0]
39221,bugs-dot-jar_OAK-4353_b0014b7d,"static Map<Integer, Map<Character, File>> collectFiles(File directory) {
        Map<Integer, Map<Character, File>> dataFiles = newHashMap();
        Map<Integer, File> bulkFiles = newHashMap();

        for (File file : directory.listFiles()) {
            Matcher matcher = FILE_NAME_PATTERN.matcher(file.getName());
            if (matcher.matches()) {
                Integer index = Integer.parseInt(matcher.group(2));
                if (""data"".equals(matcher.group(1))) {
                    Map<Character, File> files = dataFiles.get(index);
                    if (files == null) {
                        files = newHashMap();
                        dataFiles.put(index, files);
                    }
                    Character generation = 'a';
                    if (matcher.group(4) != null) {
                        generation = matcher.group(4).charAt(0);
                    }
                    checkState(files.put(generation, file) == null);
                } else {
                    checkState(bulkFiles.put(index, file) == null);
                }
            }
        }

        if (!bulkFiles.isEmpty()) {
            log.info(""Upgrading TarMK file names in {}"", directory);

            if (!dataFiles.isEmpty()) {
                // first put all the data segments at the end of the list
                Integer[] indices =
                        dataFiles.keySet().toArray(new Integer[dataFiles.size()]);
                Arrays.sort(indices);
                int position = Math.max(
                        indices[indices.length - 1] + 1,
                        bulkFiles.size());
                for (Integer index : indices) {
                    Map<Character, File> files = dataFiles.remove(index);
                    Integer newIndex = position++;
                    for (Character generation : newHashSet(files.keySet())) {
                        File file = files.get(generation);
                        File newFile = new File(
                                directory,
                                format(FILE_NAME_FORMAT, newIndex, generation));
                        log.info(""Renaming {} to {}"", file, newFile);
                        file.renameTo(newFile);
                        files.put(generation, newFile);
                    }
                    dataFiles.put(newIndex, files);
                }
            }

            // then add all the bulk segments at the beginning of the list
            Integer[] indices =
                    bulkFiles.keySet().toArray(new Integer[bulkFiles.size()]);
            Arrays.sort(indices);
            int position = 0;
            for (Integer index : indices) {
                File file = bulkFiles.remove(index);
                Integer newIndex = position++;
                File newFile = new File(
                        directory, format(FILE_NAME_FORMAT, newIndex, ""a""));
                log.info(""Renaming {} to {}"", file, newFile);
                file.renameTo(newFile);
                dataFiles.put(newIndex, singletonMap('a', newFile));
            }
        }

        return dataFiles;
    }","static Map<Integer, Map<Character, File>> collectFiles(File directory) {
        Map<Integer, Map<Character, File>> dataFiles = newHashMap();
        Map<Integer, File> bulkFiles = newHashMap();

        for (File file : directory.listFiles()) {
            Matcher matcher = FILE_NAME_PATTERN.matcher(file.getName());
            if (matcher.matches()) {
                Integer index = Integer.parseInt(matcher.group(2));
                if (""data"".equals(matcher.group(1))) {
                    Map<Character, File> files = dataFiles.get(index);
                    if (files == null) {
                        files = newHashMap();
                        dataFiles.put(index, files);
                    }
                    Character generation = 'a';
                    if (matcher.group(4) != null) {
                        generation = matcher.group(4).charAt(0);
                    }
                    checkState(files.put(generation, file) == null);
                } else {
                    checkState(bulkFiles.put(index, file) == null);
                }
            }
        }

        if (!bulkFiles.isEmpty()) {
            log.info(""Upgrading TarMK file names in {}"", directory);

            if (!dataFiles.isEmpty()) {
                // first put all the data segments at the end of the list
                Integer[] indices =
                        dataFiles.keySet().toArray(new Integer[dataFiles.size()]);
                Arrays.sort(indices);
                int position = Math.max(
                        indices[indices.length - 1] + 1,
                        bulkFiles.size());
                for (Integer index : indices) {
                    Map<Character, File> files = dataFiles.remove(index);
                    Integer newIndex = position++;
                    for (Character generation : newHashSet(files.keySet())) {
                        File file = files.get(generation);
                        File newFile = new File(
                                directory,
                                format(FILE_NAME_FORMAT, newIndex, generation));
                        log.info(""Renaming {} to {}"", file, newFile);
                        file.renameTo(newFile);
                        files.put(generation, newFile);
                    }
                    dataFiles.put(newIndex, files);
                }
            }

            // then add all the bulk segments at the beginning of the list
            Integer[] indices =
                    bulkFiles.keySet().toArray(new Integer[bulkFiles.size()]);
            Arrays.sort(indices);
            int position = 0;
            for (Integer index : indices) {
                File file = bulkFiles.remove(index);
                Integer newIndex = position++;
                File newFile = new File(
                        directory, format(FILE_NAME_FORMAT, newIndex, ""a""));
                log.info(""Renaming {} to {}"", file, newFile);
                file.renameTo(newFile);
                dataFiles.put(newIndex, singletonMap('a', newFile));
            }
        }

        return dataFiles;
    }",0,[0]
10340,bugs-dot-jar_OAK-3897_94c6c575,"@Override
    public boolean propertyDeleted(PropertyState before) {
        getUpdateOp().removeMapEntry(before.getName(), revision);
        return true;
    }","@Override
    public boolean propertyDeleted(PropertyState before) {
        getUpdateOp().removeMapEntry(before.getName(), revision);
        return true;
    }",0,[0]
15006,bugs-dot-jar_MNG-5075_2eb419ed,"public List<String> getSystemClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }","public List<String> getSystemClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }",0,[0]
31000,bugs-dot-jar_CAMEL-8125_36e7b668,"public CamelPostProcessorHelper() {
    }","public CamelPostProcessorHelper() {
    }",0,[0]
20466,bugs-dot-jar_WICKET-128_7e1000dd,"protected final Object getAttribute(final String name)
	{
		RequestCycle cycle = RequestCycle.get();
		if (cycle != null)
		{
			return getSessionStore().getAttribute(cycle.getRequest(), name);
		}
		return null;
	}","protected final Object getAttribute(final String name)
	{
		RequestCycle cycle = RequestCycle.get();
		if (cycle != null)
		{
			return getSessionStore().getAttribute(cycle.getRequest(), name);
		}
		return null;
	}",0,[0]
9653,bugs-dot-jar_CAMEL-5707_3f70d612,"public NotifyBuilder whenDoneNotSatisfied(final MockEndpoint mock) {
        return doWhenNotSatisfied(mock, false);
    }","public NotifyBuilder whenDoneNotSatisfied(final MockEndpoint mock) {
        return doWhenNotSatisfied(mock, false);
    }",0,[0]
31412,bugs-dot-jar_CAMEL-4513_9e05f77f,"public BeanExpression(String beanName, String method) {
        this.beanName = beanName;
        this.method = method;
    }","public BeanExpression(String beanName, String method) {
        this.beanName = beanName;
        this.method = method;
    }",0,[0]
443,bugs-dot-jar_WICKET-4927_8c827e33,"@Override
	public void addHeader(String name, String value)
	{
		checkHeader();
		bufferedResponse.addHeader(name, value);
	}","@Override
	public void addHeader(String name, String value)
	{
		getMetaResponse().addHeader(name, value);
	}",1,"[3, 4]"
28937,bugs-dot-jar_CAMEL-3276_205420e2,"public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {
        Exchange copy = exchange.copy();
        // do not share the unit of work
        copy.setUnitOfWork(null);
        // hand over on completion to the copy if we got any
        UnitOfWork uow = exchange.getUnitOfWork();
        if (handover && uow != null) {
            uow.handoverSynchronization(copy);
        }
        // set a correlation id so we can track back the original exchange
        copy.setProperty(Exchange.CORRELATION_ID, exchange.getExchangeId());
        return copy;
    }","public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {
        Exchange copy = exchange.copy();
        // do not share the unit of work
        copy.setUnitOfWork(null);
        // hand over on completion to the copy if we got any
        UnitOfWork uow = exchange.getUnitOfWork();
        if (handover && uow != null) {
            uow.handoverSynchronization(copy);
        }
        // set a correlation id so we can track back the original exchange
        copy.setProperty(Exchange.CORRELATION_ID, exchange.getExchangeId());
        return copy;
    }",0,[0]
1463,Bears-166,"public Phase getPhase() {
        return phase;
    }","public Phase getPhase() {
        return phase;
    }",0,[0]
942,bugs-dot-jar_WICKET-2033_420ac965,"protected void onCheckEvent(final String event)
	{
	}","protected void onCheckEvent(final String event)
	{
	}",0,[0]
5914,bugs-dot-jar_OAK-3110_d10362c0,"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {
        Directory local = createLocalDirForIndexWriter(definition);
        return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));
    }","public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {
        Directory local = createLocalDirForIndexWriter(definition);
        return new CopyOnWriteDirectory(remote, local, reindexMode,
                getIndexPathForLogging(definition), getSharedWorkingSet(definition));
    }",1,[2]
12902,bugs-dot-jar_WICKET-4717_6a1b2f61,"public R getMinimum()
	{
		return minimum;
	}","public R getMinimum()
	{
		return minimum;
	}",0,[0]
1495,Bears-169,"protected void downloadSegmentAndReplace(LLCRealtimeSegmentZKMetadata metadata) {
    _realtimeTableDataManager.downloadAndReplaceSegment(_segmentNameStr, metadata, _indexLoadingConfig);
  }","protected void downloadSegmentAndReplace(LLCRealtimeSegmentZKMetadata metadata) {
    _realtimeTableDataManager.downloadAndReplaceSegment(_segmentNameStr, metadata, _indexLoadingConfig);
  }",0,[0]
8466,bugs-dot-jar_ACCUMULO-366_db4a291f,"public TabletServer() {
    super();
    SimpleTimer.getInstance().schedule(new TimerTask() {
      @Override
      public void run() {
        synchronized (onlineTablets) {
          long now = System.currentTimeMillis();
          for (Tablet tablet : onlineTablets.values())
            try {
              tablet.updateRates(now);
            } catch (Exception ex) {
              log.error(ex, ex);
            }
        }
      }
    }, 5000, 5000);
  }","public TabletServer() {
    super();
    SimpleTimer.getInstance().schedule(new TimerTask() {
      @Override
      public void run() {
        synchronized (onlineTablets) {
          long now = System.currentTimeMillis();
          for (Tablet tablet : onlineTablets.values())
            try {
              tablet.updateRates(now);
            } catch (Exception ex) {
              log.error(ex, ex);
            }
        }
      }
    }, 5000, 5000);
  }",0,[0]
8019,bugs-dot-jar_WICKET-4338_9decad35,"public Url encodePageParameters(final PageParameters pageParameters)
	{
		Url url = new Url();

		for (int i = 0; i < pageParameters.getIndexedCount(); ++i)
		{
			url.getSegments().add(pageParameters.get(i).toString());
		}

		for (PageParameters.NamedPair pair : pageParameters.getAllNamed())
		{
			QueryParameter param = new QueryParameter(pair.getKey(), pair.getValue());
			url.getQueryParameters().add(param);
		}

		return url;
	}","public Url encodePageParameters(final PageParameters pageParameters)
	{
		Url url = new Url();

		for (int i = 0; i < pageParameters.getIndexedCount(); ++i)
		{
			url.getSegments().add(pageParameters.get(i).toString());
		}

		for (PageParameters.NamedPair pair : pageParameters.getAllNamed())
		{
			QueryParameter param = new QueryParameter(pair.getKey(), pair.getValue());
			url.getQueryParameters().add(param);
		}

		return url;
	}",0,[0]
1110,Bears-149,"public ConditionRouter(URL url) {
        this.url = url;
        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
        this.force = url.getParameter(Constants.FORCE_KEY, false);
        try {
            String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
            if (rule == null || rule.trim().length() == 0) {
                throw new IllegalArgumentException(""Illegal route rule!"");
            }
            rule = rule.replace(""consumer."", """").replace(""provider."", """");
            int i = rule.indexOf(""=>"");
            String whenRule = i < 0 ? null : rule.substring(0, i).trim();
            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || ""true"".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);
            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || ""false"".equals(thenRule) ? null : parseRule(thenRule);
            // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.
            this.whenCondition = when;
            this.thenCondition = then;
        } catch (ParseException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }","public ConditionRouter(URL url) {
        this.url = url;
        this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);
        this.force = url.getParameter(Constants.FORCE_KEY, false);
        try {
            String rule = url.getParameterAndDecoded(Constants.RULE_KEY);
            if (rule == null || rule.trim().length() == 0) {
                throw new IllegalArgumentException(""Illegal route rule!"");
            }
            rule = rule.replace(""consumer."", """").replace(""provider."", """");
            int i = rule.indexOf(""=>"");
            String whenRule = i < 0 ? null : rule.substring(0, i).trim();
            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || ""true"".equals(whenRule) ? new HashMap<String, MatchPair>() : parseRule(whenRule);
            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || ""false"".equals(thenRule) ? null : parseRule(thenRule);
            // NOTE: It should be determined on the business level whether the `When condition` can be empty or not.
            this.whenCondition = when;
            this.thenCondition = then;
        } catch (ParseException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }",0,[0]
26391,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    public boolean isModified() {
        return sessionDelegate.safePerform(new PropertyOperation<Boolean>(dlg, ""isModified"") {
            @Nonnull
            @Override
            public Boolean perform() {
                return property.getStatus() == Status.MODIFIED;
            }
        });
    }","@Override
    public boolean isModified() {
        return sessionDelegate.safePerform(new PropertyOperation<Boolean>(dlg, ""isModified"") {
            @Nonnull
            @Override
            public Boolean perform() {
                return property.getStatus() == Status.MODIFIED;
            }
        });
    }",0,[0]
2579,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public Set<String> listTables(ByteBuffer login) throws TException {
    try {
      return getConnector(login).tableOperations().list();
    } catch (Exception e) {
      throw new TException(e);
    }
  }","@Override
  public Set<String> listTables(ByteBuffer login) throws TException {
    try {
      return getConnector(login).tableOperations().list();
    } catch (Exception e) {
      throw new TException(e);
    }
  }",0,[0]
21869,bugs-dot-jar_MNG-2174_778f044e,"public Object mixPluginAndReturnConfigAsDom(Plugin plugin, Model model) throws IOException, XmlPullParserException
   {
       List<ModelProperty> mps = mixPluginAndReturnConfigAsProperties(plugin, model);
       return  !mps.isEmpty() ? Xpp3DomBuilder.build(
               new StringReader(ModelMarshaller.unmarshalModelPropertiesToXml(mps, ProjectUri.Build.Plugins.Plugin.xUri) ) ) : null;
   }","public Object mixPluginAndReturnConfigAsDom(Plugin plugin, Model model) throws IOException, XmlPullParserException
   {
       List<ModelProperty> mps = mixPluginAndReturnConfigAsProperties(plugin, model);
       return  !mps.isEmpty() ? Xpp3DomBuilder.build(
               new StringReader(ModelMarshaller.unmarshalModelPropertiesToXml(mps, ProjectUri.Build.Plugins.Plugin.xUri) ) ) : null;
   }",0,[0]
379,bugs-dot-jar_FLINK-2874_17e7b423,"public static <IN1, IN2, OUT> TypeInformation<OUT> getFlatJoinReturnTypes(FlatJoinFunction<IN1, IN2, OUT> joinInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type)
	{
		return getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);
	}","public static <IN1, IN2, OUT> TypeInformation<OUT> getFlatJoinReturnTypes(FlatJoinFunction<IN1, IN2, OUT> joinInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type)
	{
		return getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);
	}",0,[0]
13429,bugs-dot-jar_MATH-434_133cbc2d,"protected RealMatrix createTableau(final boolean maximize) {

        // create a matrix of the correct size
        int width = numDecisionVariables + numSlackVariables +
        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
        int height = constraints.size() + getNumObjectiveFunctions();
        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);

        // initialize the objective function rows
        if (getNumObjectiveFunctions() == 2) {
            matrix.setEntry(0, 0, -1);
        }
        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
        RealVector objectiveCoefficients =
            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
        copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);
        matrix.setEntry(zIndex, width - 1,
            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());

        if (!restrictToNonNegative) {
            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
                getInvertedCoeffiecientSum(objectiveCoefficients));
        }

        // initialize the constraint rows
        int slackVar = 0;
        int artificialVar = 0;
        for (int i = 0; i < constraints.size(); i++) {
            LinearConstraint constraint = constraints.get(i);
            int row = getNumObjectiveFunctions() + i;

            // decision variable coefficients
            copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);

            // x-
            if (!restrictToNonNegative) {
                matrix.setEntry(row, getSlackVariableOffset() - 1,
                    getInvertedCoeffiecientSum(constraint.getCoefficients()));
            }

            // RHS
            matrix.setEntry(row, width - 1, constraint.getValue());

            // slack variables
            if (constraint.getRelationship() == Relationship.LEQ) {
                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
            } else if (constraint.getRelationship() == Relationship.GEQ) {
                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
            }

            // artificial variables
            if ((constraint.getRelationship() == Relationship.EQ) ||
                    (constraint.getRelationship() == Relationship.GEQ)) {
                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
            }
        }

        return matrix;
    }","protected RealMatrix createTableau(final boolean maximize) {

        // create a matrix of the correct size
        int width = numDecisionVariables + numSlackVariables +
        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
        int height = constraints.size() + getNumObjectiveFunctions();
        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);

        // initialize the objective function rows
        if (getNumObjectiveFunctions() == 2) {
            matrix.setEntry(0, 0, -1);
        }
        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
        RealVector objectiveCoefficients =
            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
        copyArray(objectiveCoefficients.getData(), matrix.getDataRef()[zIndex]);
        matrix.setEntry(zIndex, width - 1,
            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());

        if (!restrictToNonNegative) {
            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
                getInvertedCoefficientSum(objectiveCoefficients));
        }

        // initialize the constraint rows
        int slackVar = 0;
        int artificialVar = 0;
        for (int i = 0; i < constraints.size(); i++) {
            LinearConstraint constraint = constraints.get(i);
            int row = getNumObjectiveFunctions() + i;

            // decision variable coefficients
            copyArray(constraint.getCoefficients().getData(), matrix.getDataRef()[row]);

            // x-
            if (!restrictToNonNegative) {
                matrix.setEntry(row, getSlackVariableOffset() - 1,
                    getInvertedCoefficientSum(constraint.getCoefficients()));
            }

            // RHS
            matrix.setEntry(row, width - 1, constraint.getValue());

            // slack variables
            if (constraint.getRelationship() == Relationship.LEQ) {
                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
            } else if (constraint.getRelationship() == Relationship.GEQ) {
                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
            }

            // artificial variables
            if ((constraint.getRelationship() == Relationship.EQ) ||
                    (constraint.getRelationship() == Relationship.GEQ)) {
                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
            }
        }

        return matrix;
    }",1,"[22, 38]"
18815,bugs-dot-jar_MATH-935_48dde378,"public int getPartialDerivativeIndex(final int ... orders)
            throws DimensionMismatchException, NumberIsTooLargeException {

        // safety check
        if (orders.length != getFreeParameters()) {
            throw new DimensionMismatchException(orders.length, getFreeParameters());
        }

        return getPartialDerivativeIndex(parameters, order, sizes, orders);

    }","public int getPartialDerivativeIndex(final int ... orders)
            throws DimensionMismatchException, NumberIsTooLargeException {

        // safety check
        if (orders.length != getFreeParameters()) {
            throw new DimensionMismatchException(orders.length, getFreeParameters());
        }

        return getPartialDerivativeIndex(parameters, order, sizes, orders);

    }",0,[0]
28922,bugs-dot-jar_WICKET-5853_b80f6640,"@Override
	public Short convertToObject(final String value, final Locale locale)
	{
		final Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);

		if (number == null)
		{
			return null;
		}

		return number.shortValue();
	}","@Override
	public Short convertToObject(final String value, final Locale locale)
	{
		final BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);

		if (number == null)
		{
			return null;
		}

		return number.shortValue();
	}",1,[3]
26073,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"private boolean matches(Matcher matcher, byte data[], int offset, int len) {
    if (matcher != null) {
      try {
        matcher.reset(new String(data, offset, len, encoding));
        return matcher.matches();
      } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
      }
    }
    return !orFields;
  }","private boolean matches(Matcher matcher, byte data[], int offset, int len) {
    if (matcher != null) {
      try {
        matcher.reset(new String(data, offset, len, encoding));
        return matcher.matches();
      } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
      }
    }
    return !orFields;
  }",0,[0]
40214,bugs-dot-jar_ACCUMULO-4029_5ca779a0,"@Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o != null && o.getClass().equals(this.getClass())) {
      return equalMutation((Mutation) o);
    }
    return false;
  }","@Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o != null && o.getClass().equals(this.getClass())) {
      return equalMutation((Mutation) o);
    }
    return false;
  }",0,[0]
1103,bugs-dot-jar_WICKET-5546_f1af9e03,"private void detachFeedback()
	{
		FeedbackMessages feedback = getMetaData(FEEDBACK_KEY);
		if (feedback != null)
		{
			feedback.clear(getApplication().getApplicationSettings()
				.getFeedbackMessageCleanupFilter());

			if (feedback.isEmpty())
			{
				setMetaData(FEEDBACK_KEY, null);
			}
			else
			{
				feedback.detach();
			}
		}
	}","private void detachFeedback()
	{
		FeedbackMessages feedback = getMetaData(FEEDBACK_KEY);
		if (feedback != null)
		{
			feedback.clear(getApplication().getApplicationSettings()
				.getFeedbackMessageCleanupFilter());

			if (feedback.isEmpty())
			{
				setMetaData(FEEDBACK_KEY, null);
			}
			else
			{
				feedback.detach();
			}
		}
	}",0,[0]
19457,bugs-dot-jar_OAK-3442_17032c50,"private static String getIndexName(IndexPlan plan){
        return PathUtils.getName(getPlanResult(plan).indexPath);
    }","private static String getIndexName(IndexPlan plan){
        return PathUtils.getName(getPlanResult(plan).indexPath);
    }",0,[0]
8303,bugs-dot-jar_MATH-934_724795b5,"public Complex tanh() {
        if (isNaN || Double.isInfinite(imaginary)) {
            return NaN;
        }
        if (real > 20.0) {
            return createComplex(1.0, 0.0);
        }
        if (real < -20.0) {
            return createComplex(-1.0, 0.0);
        }
        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);

        return createComplex(FastMath.sinh(real2) / d,
                             FastMath.sin(imaginary2) / d);
    }","public Complex tanh() {
        if (isNaN || Double.isInfinite(imaginary)) {
            return NaN;
        }
        if (real > 20.0) {
            return createComplex(1.0, 0.0);
        }
        if (real < -20.0) {
            return createComplex(-1.0, 0.0);
        }
        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);

        return createComplex(FastMath.sinh(real2) / d,
                             FastMath.sin(imaginary2) / d);
    }",0,[0]
33703,bugs-dot-jar_WICKET-5981_eb125865,"private int children_size()
	{
		if (children == null)
		{
			return 0;
		}
		if (children instanceof Component)
		{
			return 1;
		}
		if (children instanceof List)
		{
			return ((List<?>)children).size();
		}
		return ((Map<?, ?>)children).size();
	}","private int children_size()
	{
		if (children == null)
		{
			return 0;
		}
		if (children instanceof Component)
		{
			return 1;
		}
		if (children instanceof List)
		{
			return ((List<?>)children).size();
		}
		return ((Map<?, ?>)children).size();
	}",0,[0]
11046,bugs-dot-jar_LOG4J2-478_11763dee,"public static void appendEscapingCDATA(final StringBuilder buf, final String str) {
        if (str != null) {
            int end = str.indexOf(CDATA_END);
            if (end < 0) {
                buf.append(str);
            } else {
                int start = 0;
                while (end > -1) {
                    buf.append(str.substring(start, end));
                    buf.append(CDATA_EMBEDED_END);
                    start = end + CDATA_END_LEN;
                    if (start < str.length()) {
                        end = str.indexOf(CDATA_END, start);
                    } else {
                        return;
                    }
                }
                buf.append(str.substring(start));
            }
        }
    }","public static void appendEscapingCDATA(final StringBuilder buf, final String str) {
        if (str != null) {
            int end = str.indexOf(CDATA_END);
            if (end < 0) {
                buf.append(str);
            } else {
                int start = 0;
                while (end > -1) {
                    buf.append(str.substring(start, end));
                    buf.append(CDATA_EMBEDED_END);
                    start = end + CDATA_END_LEN;
                    if (start < str.length()) {
                        end = str.indexOf(CDATA_END, start);
                    } else {
                        return;
                    }
                }
                buf.append(str.substring(start));
            }
        }
    }",0,[0]
10198,bugs-dot-jar_OAK-3897_94c6c575,"public String diff(String fromRevisionId,
                       String toRevisionId,
                       String path,
                       int depth) throws DocumentStoreException {
        if (depth != 0) {
            throw new DocumentStoreException(""Only depth 0 is supported, depth is "" + depth);
        }
        if (path == null || path.equals("""")) {
            path = ""/"";
        }
        RevisionVector fromRev = RevisionVector.fromString(fromRevisionId);
        RevisionVector toRev = RevisionVector.fromString(toRevisionId);
        final DocumentNodeState before = nodeStore.getNode(path, fromRev);
        final DocumentNodeState after = nodeStore.getNode(path, toRev);
        if (before == null || after == null) {
            // TODO implement correct behavior if the node doesn't/didn't exist
            String msg = String.format(""Diff is only supported if the node exists in both cases. "" +
                            ""Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s"",
                    path, fromRev, before != null, toRev, after != null);
            throw new DocumentStoreException(msg);
        }

        JsopDiff diff = new JsopDiff(path, depth);
        after.compareAgainstBaseState(before, diff);
        return diff.toString();
    }","public String diff(String fromRevisionId,
                       String toRevisionId,
                       String path,
                       int depth) throws DocumentStoreException {
        if (depth != 0) {
            throw new DocumentStoreException(""Only depth 0 is supported, depth is "" + depth);
        }
        if (path == null || path.equals("""")) {
            path = ""/"";
        }
        RevisionVector fromRev = RevisionVector.fromString(fromRevisionId);
        RevisionVector toRev = RevisionVector.fromString(toRevisionId);
        final DocumentNodeState before = nodeStore.getNode(path, fromRev);
        final DocumentNodeState after = nodeStore.getNode(path, toRev);
        if (before == null || after == null) {
            // TODO implement correct behavior if the node doesn't/didn't exist
            String msg = String.format(""Diff is only supported if the node exists in both cases. "" +
                            ""Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s"",
                    path, fromRev, before != null, toRev, after != null);
            throw new DocumentStoreException(msg);
        }

        JsopDiff diff = new JsopDiff(path, depth);
        after.compareAgainstBaseState(before, diff);
        return diff.toString();
    }",0,[0]
40143,bugs-dot-jar_CAMEL-9217_e7ac45b6,"public <T> T getAndRemoveParameter(Map<String, Object> parameters, String key, Class<T> type) {
        return getAndRemoveParameter(parameters, key, type, null);
    }","public <T> T getAndRemoveParameter(Map<String, Object> parameters, String key, Class<T> type) {
        return getAndRemoveParameter(parameters, key, type, null);
    }",0,[0]
17515,bugs-dot-jar_CAMEL-3433_e76d23b0,"@SuppressWarnings(""unchecked"")
    public static Expression convertToExpression(final Expression expression, final Class type) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return expression.evaluate(exchange, type);
            }

            @Override
            public String toString() {
                return """" + expression + "".convertTo("" + type.getCanonicalName() + "".class)"";
            }
        };
    }","@SuppressWarnings(""unchecked"")
    public static Expression convertToExpression(final Expression expression, final Class type) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                if (type != null) {
                    return expression.evaluate(exchange, type);
                } else {
                    return expression;
                }
            }

            @Override
            public String toString() {
                return """" + expression;
            }
        };
    }",1,"[4, 9]"
32855,bugs-dot-jar_MNG-4648_83389c34,"private boolean validateStringNotEmpty( String fieldName, ModelProblemCollector problems, Severity severity,
                                            String string, String sourceHint )
    {
        if ( !validateNotNull( fieldName, problems, severity, string, sourceHint ) )
        {
            return false;
        }

        if ( string.length() > 0 )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, sourceHint, ""is missing."" );

        return false;
    }","private boolean validateStringNotEmpty( String fieldName, ModelProblemCollector problems, Severity severity,
                                            String string, String sourceHint )
    {
        if ( !validateNotNull( fieldName, problems, severity, string, sourceHint ) )
        {
            return false;
        }

        if ( string.length() > 0 )
        {
            return true;
        }

        addViolation( problems, severity, fieldName, sourceHint, ""is missing."" );

        return false;
    }",0,[0]
9191,bugs-dot-jar_MATH-377_c640932d,"protected void updateResidualsAndCost()
        throws FunctionEvaluationException {

        if (++objectiveEvaluations > maxEvaluations) {
            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),
                                                  point);
        }
        objective = function.value(point);
        if (objective.length != rows) {
            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,
                                                  objective.length, rows);
        }
        cost = 0;
        int index = 0;
        for (int i = 0; i < rows; i++) {
            final double residual = targetValues[i] - objective[i];
            residuals[i] = residual;
            cost += residualsWeights[i] * residual * residual;
            index += cols;
        }
        cost = Math.sqrt(cost);

    }","protected void updateResidualsAndCost()
        throws FunctionEvaluationException {

        if (++objectiveEvaluations > maxEvaluations) {
            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),
                                                  point);
        }
        objective = function.value(point);
        if (objective.length != rows) {
            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,
                                                  objective.length, rows);
        }
        cost = 0;
        int index = 0;
        for (int i = 0; i < rows; i++) {
            final double residual = targetValues[i] - objective[i];
            residuals[i] = residual;
            cost += residualsWeights[i] * residual * residual;
            index += cols;
        }
        cost = Math.sqrt(cost);

    }",0,[0]
16150,bugs-dot-jar_OAK-1250_0c3b3306,"private void refreshHead() {
        RecordId id = journal.getHead();
        if (!id.equals(head.getRecordId())) {
            head = new SegmentNodeState(
                    store.getWriter().getDummySegment(), id);
            changeDispatcher.contentChanged(head.getChildNode(ROOT), null);
        }
    }","private void refreshHead() {
        RecordId id = journal.getHead();
        if (!id.equals(head.getRecordId())) {
            head = new SegmentNodeState(
                    store.getWriter().getDummySegment(), id);
            changeDispatcher.contentChanged(head.getChildNode(ROOT), null);
        }
    }",0,[0]
10694,bugs-dot-jar_MNG-1797_5d99b35c,"private boolean isActive( Profile profile )
        throws ProfileActivationException
    {
        List activators = null;
        container.addContextValue(""SystemProperties"", systemProperties);
        try
        {
            activators = container.lookupList( ProfileActivator.ROLE );

            for ( Iterator activatorIterator = activators.iterator(); activatorIterator.hasNext(); )
            {
                ProfileActivator activator = (ProfileActivator) activatorIterator.next();

                if ( activator.canDetermineActivation( profile ) )
                {
                    return activator.isActive( profile );
                }
            }

            return false;
        }
        catch ( ComponentLookupException e )
        {
            throw new ProfileActivationException( ""Cannot retrieve list of profile activators."", e );
        }
        finally
        {
            container.getContext().put(""SystemProperties"", null);
            if ( activators != null )
            {
                try
                {
                    container.releaseAll( activators );
                }
                catch ( ComponentLifecycleException e )
                {
                    container.getLogger().debug( ""Error releasing profile activators - ignoring."", e );
                }
            }
        }
    }","private boolean isActive( Profile profile )
        throws ProfileActivationException
    {
        List activators = null;
        container.addContextValue(""SystemProperties"", systemProperties);
        try
        {
            activators = container.lookupList( ProfileActivator.ROLE );

            for ( Iterator activatorIterator = activators.iterator(); activatorIterator.hasNext(); )
            {
                ProfileActivator activator = (ProfileActivator) activatorIterator.next();

                if ( activator.canDetermineActivation( profile ) )
                {
                    return activator.isActive( profile );
                }
            }

            return false;
        }
        catch ( ComponentLookupException e )
        {
            throw new ProfileActivationException( ""Cannot retrieve list of profile activators."", e );
        }
        finally
        {
            container.getContext().put(""SystemProperties"", null);
            if ( activators != null )
            {
                try
                {
                    container.releaseAll( activators );
                }
                catch ( ComponentLifecycleException e )
                {
                    container.getLogger().debug( ""Error releasing profile activators - ignoring."", e );
                }
            }
        }
    }",0,[0]
11426,bugs-dot-jar_CAMEL-7344_91228815,"@Override
    protected void doStart() throws Exception {
        // noop
    }","@Override
    protected void doStart() throws Exception {
        // noop
    }",0,[0]
12876,bugs-dot-jar_MNG-2221_cc859f5c,"public static Model cloneModel( Model model )
    {
        // TODO: would be nice for the modello:java code to generate this as a copy constructor
        Model newModel = new Model();
        ModelInheritanceAssembler assembler = new DefaultModelInheritanceAssembler();
        newModel.setModelVersion( model.getModelVersion() );
        newModel.setName( model.getName() );
        newModel.setParent( cloneParent( model.getParent() ) );
        newModel.setVersion( model.getVersion() );
        newModel.setArtifactId( model.getArtifactId() );
        newModel.setProperties( new Properties( model.getProperties() ) );
        newModel.setGroupId( model.getGroupId() );
        newModel.setPackaging( model.getPackaging() );
        newModel.setModules( cloneModules( model.getModules() ) );

        newModel.setProfiles( cloneProfiles( model.getProfiles() ) );

        assembler.copyModel( newModel, model );

        return newModel;
    }","public static Model cloneModel( Model model )
    {
        // TODO: would be nice for the modello:java code to generate this as a copy constructor
        Model newModel = new Model();
        ModelInheritanceAssembler assembler = new DefaultModelInheritanceAssembler();
        newModel.setModelVersion( model.getModelVersion() );
        newModel.setName( model.getName() );
        newModel.setParent( cloneParent( model.getParent() ) );
        newModel.setVersion( model.getVersion() );
        newModel.setArtifactId( model.getArtifactId() );
        newModel.setProperties( new Properties( model.getProperties() ) );
        newModel.setGroupId( model.getGroupId() );
        newModel.setPackaging( model.getPackaging() );
        newModel.setModules( cloneModules( model.getModules() ) );

        newModel.setProfiles( cloneProfiles( model.getProfiles() ) );

        assembler.copyModel( newModel, model );

        return newModel;
    }",0,[0]
1096,bugs-dot-jar_WICKET-5546_f1af9e03,"public final void configure()
	{
		if (!getRequestFlag(RFLAG_CONFIGURED))
		{
			clearEnabledInHierarchyCache();
			clearVisibleInHierarchyCache();
			onConfigure();
			for (Behavior behavior : getBehaviors())
			{
				if (isBehaviorAccepted(behavior))
				{
					behavior.onConfigure(this);
				}
			}

			// check authorization
			setRenderAllowed();

			internalOnAfterConfigure();

			getApplication().getComponentOnConfigureListeners().onConfigure(this);

			setRequestFlag(RFLAG_CONFIGURED, true);
		}
	}","public final void configure()
	{
		if (!getRequestFlag(RFLAG_CONFIGURED))
		{
			clearEnabledInHierarchyCache();
			clearVisibleInHierarchyCache();
			onConfigure();
			for (Behavior behavior : getBehaviors())
			{
				if (isBehaviorAccepted(behavior))
				{
					behavior.onConfigure(this);
				}
			}

			// check authorization
			setRenderAllowed();

			internalOnAfterConfigure();

			getApplication().getComponentOnConfigureListeners().onConfigure(this);

			setRequestFlag(RFLAG_CONFIGURED, true);
		}
	}",0,[0]
27425,bugs-dot-jar_MATH-1297_56434517,"public int getNSteps() {
      return nSteps;
    }","public int getNSteps() {
      return nSteps;
    }",0,[0]
27785,bugs-dot-jar_CAMEL-7055_15e1077d,"@Deprecated
    public int getBufferSize() {
        return getStrategyBufferSize();
    }","@Deprecated
    public int getBufferSize() {
        return getStrategyBufferSize();
    }",0,[0]
7028,bugs-dot-jar_LOG4J2-763_97203de8,"private void writeObject(final ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        getFormattedMessage();
        out.writeUTF(formattedMessage);
        out.writeUTF(key);
        out.writeUTF(baseName);
        out.writeInt(argArray.length);
        stringArgs = new String[argArray.length];
        int i = 0;
        for (final Object obj : argArray) {
            stringArgs[i] = obj.toString();
            ++i;
        }
        out.writeObject(stringArgs);
    }","private void writeObject(final ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        getFormattedMessage();
        out.writeUTF(formattedMessage);
        out.writeUTF(key);
        out.writeUTF(baseName);
        out.writeInt(argArray.length);
        stringArgs = new String[argArray.length];
        int i = 0;
        for (final Object obj : argArray) {
            stringArgs[i] = obj.toString();
            ++i;
        }
        out.writeObject(stringArgs);
    }",0,[0]
1680,bugs-dot-jar_OAK-1297_73cc2442,"@Override @Nonnull
    public Iterable<String> getNames(@Nonnull String name) {
        return head().getCurrentNodeState().getNames(checkNotNull(name));
    }","@Override @Nonnull
    public Iterable<String> getNames(@Nonnull String name) {
        return head().getCurrentNodeState().getNames(checkNotNull(name));
    }",0,[0]
9317,bugs-dot-jar_WICKET-4597_9dab1bb5,"public final double minutes()
	{
		return seconds() / 60.0;
	}","public final double minutes()
	{
		return seconds() / 60.0;
	}",0,[0]
22005,bugs-dot-jar_CAMEL-3789_9319e139,"public void setBeginRenamer(GenericFileRenamer<T> beginRenamer) {
        this.beginRenamer = beginRenamer;
    }","public void setBeginRenamer(GenericFileRenamer<T> beginRenamer) {
        this.beginRenamer = beginRenamer;
    }",0,[0]
7161,bugs-dot-jar_OAK-4387_ca05fd06,"private Statement convertToUnion(String query, Statement statement,
            int startParseIndex) throws ParseException {
        int start = query.indexOf(""("", startParseIndex);
        String begin = query.substring(0, start);
        XPathToSQL2Converter converter = new XPathToSQL2Converter();
        String partList = query.substring(start);
        converter.initialize(partList);
        converter.read();
        int lastParseIndex = converter.parseIndex;
        int lastOrIndex = lastParseIndex;
        converter.read(""("");
        int level = 0;
        ArrayList<String> parts = new ArrayList<String>();
        while (true) {
            int parseIndex = converter.parseIndex;
            if (converter.readIf(""("")) {
                level++;
            } else if (converter.readIf("")"") && level-- <= 0) {
                break;
            } else if (converter.readIf(""|"") && level == 0) {
                String or = partList.substring(lastOrIndex, lastParseIndex);
                parts.add(or);
                lastOrIndex = parseIndex;
            } else if (currentTokenType == END) {
                throw getSyntaxError(""the query may not be empty"");
            } else {
                converter.read();
            }
            lastParseIndex = parseIndex;
        }
        String or = partList.substring(lastOrIndex, lastParseIndex);
        parts.add(or);        
        String end = partList.substring(lastParseIndex + 1);
        Statement result = null;
        for(String p : parts) {
            String q = begin + p + end;
            converter = new XPathToSQL2Converter();
            Statement stat = converter.convertToStatement(q);
            if (result == null) {
                result = stat;
            } else {
                UnionStatement union = new UnionStatement(result, stat);
                union.orderList = stat.orderList;
                result = union;
            }
            // can not use clear, because it is shared
            stat.orderList = new ArrayList<Order>();
        }
        return result;
    }","private Statement convertToUnion(String query, Statement statement,
            int startParseIndex) throws ParseException {
        int start = query.indexOf(""("", startParseIndex);
        String begin = query.substring(0, start);
        XPathToSQL2Converter converter = new XPathToSQL2Converter();
        String partList = query.substring(start);
        converter.initialize(partList);
        converter.read();
        int lastParseIndex = converter.parseIndex;
        int lastOrIndex = lastParseIndex;
        converter.read(""("");
        int level = 0;
        ArrayList<String> parts = new ArrayList<String>();
        while (true) {
            int parseIndex = converter.parseIndex;
            if (converter.readIf(""("")) {
                level++;
            } else if (converter.readIf("")"") && level-- <= 0) {
                break;
            } else if (converter.readIf(""|"") && level == 0) {
                String or = partList.substring(lastOrIndex, lastParseIndex);
                parts.add(or);
                lastOrIndex = parseIndex;
            } else if (currentTokenType == END) {
                throw getSyntaxError(""the query may not be empty"");
            } else {
                converter.read();
            }
            lastParseIndex = parseIndex;
        }
        String or = partList.substring(lastOrIndex, lastParseIndex);
        parts.add(or);        
        String end = partList.substring(lastParseIndex + 1);
        Statement result = null;
        for(String p : parts) {
            String q = begin + p + end;
            converter = new XPathToSQL2Converter();
            Statement stat = converter.convertToStatement(q);
            if (result == null) {
                result = stat;
            } else {
                UnionStatement union = new UnionStatement(result, stat);
                union.orderList = stat.orderList;
                result = union;
            }
            // can not use clear, because it is shared
            stat.orderList = new ArrayList<Order>();
        }
        return result;
    }",0,[0]
39159,bugs-dot-jar_OAK-2238_a28098fd,"private static RepositoryException newRepositoryException(CommitFailedException exception) {
        return exception.asRepositoryException();
    }","private static RepositoryException newRepositoryException(CommitFailedException exception) {
        return exception.asRepositoryException();
    }",0,[0]
17417,bugs-dot-jar_CAMEL-7018_3244c1e5,"private void doDoExtractAttributesAndOperations(Class<?> managedClass, Map<String, ManagedAttributeInfo> attributes, Set<ManagedOperationInfo> operations) {
        LOG.trace(""Extracting attributes and operations from class: {}"", managedClass);

        // introspect the class, and leverage the cache to have better performance
        IntrospectionSupport.ClassInfo cache = IntrospectionSupport.cacheClass(managedClass);

        for (IntrospectionSupport.MethodInfo cacheInfo : cache.methods) {
            // must be from declaring class
            if (cacheInfo.method.getDeclaringClass() != managedClass) {
                continue;
            }

            LOG.trace(""Extracting attributes and operations from method: {}"", cacheInfo.method);
            ManagedAttribute ma = cacheInfo.method.getAnnotation(ManagedAttribute.class);
            if (ma != null) {
                String key;
                String desc = ma.description();
                Method getter = null;
                Method setter = null;
                boolean mask = ma.mask();

                if (cacheInfo.isGetter) {
                    key = cacheInfo.getterOrSetterShorthandName;
                    getter = cacheInfo.method;
                } else if (cacheInfo.isSetter) {
                    key = cacheInfo.getterOrSetterShorthandName;
                    setter = cacheInfo.method;
                } else {
                    throw new IllegalArgumentException(""@ManagedAttribute can only be used on Java bean methods, was: "" + cacheInfo.method + "" on bean: "" + managedClass);
                }

                // they key must be capitalized
                key = ObjectHelper.capitalize(key);

                // lookup first
                ManagedAttributeInfo info = attributes.get(key);
                if (info == null) {
                    info = new ManagedAttributeInfo(key, desc);
                }
                if (getter != null) {
                    info.setGetter(getter);
                }
                if (setter != null) {
                    info.setSetter(setter);
                }
                info.setMask(mask);

                attributes.put(key, info);
            }

            // operations
            ManagedOperation mo = cacheInfo.method.getAnnotation(ManagedOperation.class);
            if (mo != null) {
                String desc = mo.description();
                Method operation = cacheInfo.method;
                boolean mask = mo.mask();
                operations.add(new ManagedOperationInfo(desc, operation, mask));
            }
        }
    }","private void doDoExtractAttributesAndOperations(Class<?> managedClass, Map<String, ManagedAttributeInfo> attributes, Set<ManagedOperationInfo> operations) {
        LOG.trace(""Extracting attributes and operations from class: {}"", managedClass);

        // introspect the class, and leverage the cache to have better performance
        IntrospectionSupport.ClassInfo cache = IntrospectionSupport.cacheClass(managedClass);

        for (IntrospectionSupport.MethodInfo cacheInfo : cache.methods) {
            // must be from declaring class
            if (cacheInfo.method.getDeclaringClass() != managedClass) {
                continue;
            }

            LOG.trace(""Extracting attributes and operations from method: {}"", cacheInfo.method);
            ManagedAttribute ma = cacheInfo.method.getAnnotation(ManagedAttribute.class);
            if (ma != null) {
                String key;
                String desc = ma.description();
                Method getter = null;
                Method setter = null;
                boolean mask = ma.mask();

                if (cacheInfo.isGetter) {
                    key = cacheInfo.getterOrSetterShorthandName;
                    getter = cacheInfo.method;
                } else if (cacheInfo.isSetter) {
                    key = cacheInfo.getterOrSetterShorthandName;
                    setter = cacheInfo.method;
                } else {
                    throw new IllegalArgumentException(""@ManagedAttribute can only be used on Java bean methods, was: "" + cacheInfo.method + "" on bean: "" + managedClass);
                }

                // they key must be capitalized
                key = ObjectHelper.capitalize(key);

                // lookup first
                ManagedAttributeInfo info = attributes.get(key);
                if (info == null) {
                    info = new ManagedAttributeInfo(key, desc);
                }
                if (getter != null) {
                    info.setGetter(getter);
                }
                if (setter != null) {
                    info.setSetter(setter);
                }
                info.setMask(mask);

                attributes.put(key, info);
            }

            // operations
            ManagedOperation mo = cacheInfo.method.getAnnotation(ManagedOperation.class);
            if (mo != null) {
                String desc = mo.description();
                Method operation = cacheInfo.method;
                boolean mask = mo.mask();
                operations.add(new ManagedOperationInfo(desc, operation, mask));
            }
        }
    }",0,[0]
3073,bugs-dot-jar_CAMEL-5261_55c2e2d8,"public void setTimeout(long timeout) {
        this.timeout = timeout;
    }","public void setTimeout(long timeout) {
        this.timeout = timeout;
    }",0,[0]
8467,bugs-dot-jar_ACCUMULO-366_db4a291f,"private synchronized static void logGCInfo() {
    List<GarbageCollectorMXBean> gcmBeans = ManagementFactory.getGarbageCollectorMXBeans();
    Runtime rt = Runtime.getRuntime();
    
    StringBuilder sb = new StringBuilder(""gc"");
    
    boolean sawChange = false;
    
    long maxIncreaseInCollectionTime = 0;
    
    for (GarbageCollectorMXBean gcBean : gcmBeans) {
      Long prevTime = prevGcTime.get(gcBean.getName());
      long pt = 0;
      if (prevTime != null) {
        pt = prevTime;
      }
      
      long time = gcBean.getCollectionTime();
      
      if (time - pt != 0) {
        sawChange = true;
      }
      
      long increaseInCollectionTime = time - pt;
      sb.append(String.format("" %s=%,.2f(+%,.2f) secs"", gcBean.getName(), time / 1000.0, increaseInCollectionTime / 1000.0));
      maxIncreaseInCollectionTime = Math.max(increaseInCollectionTime, maxIncreaseInCollectionTime);
      prevGcTime.put(gcBean.getName(), time);
    }
    
    long mem = rt.freeMemory();
    if (maxIncreaseInCollectionTime == 0) {
      gcTimeIncreasedCount = 0;
    } else {
      gcTimeIncreasedCount++;
      if (gcTimeIncreasedCount > 3 && mem < rt.totalMemory() * 0.05) {
        log.warn(""Running low on memory"");
        gcTimeIncreasedCount = 0;
      }
    }
    
    if (mem > lastMemorySize) {
      sawChange = true;
    }
    
    String sign = ""+"";
    if (mem - lastMemorySize <= 0) {
      sign = """";
    }
    
    sb.append(String.format("" freemem=%,d(%s%,d) totalmem=%,d"", mem, sign, (mem - lastMemorySize), rt.totalMemory()));
    
    if (sawChange) {
      log.debug(sb.toString());
    }
    
    final long keepAliveTimeout = ServerConfiguration.getSystemConfiguration().getTimeInMillis(Property.INSTANCE_ZK_TIMEOUT);
    if (maxIncreaseInCollectionTime > keepAliveTimeout) {
      Halt.halt(""Garbage collection may be interfering with lock keep-alive.  Halting."", -1);
    }
    
    lastMemorySize = mem;
  }","private synchronized static void logGCInfo() {
    List<GarbageCollectorMXBean> gcmBeans = ManagementFactory.getGarbageCollectorMXBeans();
    Runtime rt = Runtime.getRuntime();
    
    StringBuilder sb = new StringBuilder(""gc"");
    
    boolean sawChange = false;
    
    long maxIncreaseInCollectionTime = 0;
    
    for (GarbageCollectorMXBean gcBean : gcmBeans) {
      Long prevTime = prevGcTime.get(gcBean.getName());
      long pt = 0;
      if (prevTime != null) {
        pt = prevTime;
      }
      
      long time = gcBean.getCollectionTime();
      
      if (time - pt != 0) {
        sawChange = true;
      }
      
      long increaseInCollectionTime = time - pt;
      sb.append(String.format("" %s=%,.2f(+%,.2f) secs"", gcBean.getName(), time / 1000.0, increaseInCollectionTime / 1000.0));
      maxIncreaseInCollectionTime = Math.max(increaseInCollectionTime, maxIncreaseInCollectionTime);
      prevGcTime.put(gcBean.getName(), time);
    }
    
    long mem = rt.freeMemory();
    if (maxIncreaseInCollectionTime == 0) {
      gcTimeIncreasedCount = 0;
    } else {
      gcTimeIncreasedCount++;
      if (gcTimeIncreasedCount > 3 && mem < rt.totalMemory() * 0.05) {
        log.warn(""Running low on memory"");
        gcTimeIncreasedCount = 0;
      }
    }
    
    if (mem > lastMemorySize) {
      sawChange = true;
    }
    
    String sign = ""+"";
    if (mem - lastMemorySize <= 0) {
      sign = """";
    }
    
    sb.append(String.format("" freemem=%,d(%s%,d) totalmem=%,d"", mem, sign, (mem - lastMemorySize), rt.totalMemory()));
    
    if (sawChange) {
      log.debug(sb.toString());
    }
    
    final long keepAliveTimeout = ServerConfiguration.getSystemConfiguration().getTimeInMillis(Property.INSTANCE_ZK_TIMEOUT);
    if (maxIncreaseInCollectionTime > keepAliveTimeout) {
      Halt.halt(""Garbage collection may be interfering with lock keep-alive.  Halting."", -1);
    }
    
    lastMemorySize = mem;
  }",0,[0]
1933,bugs-dot-jar_CAMEL-3535_b56d2962,"protected Exchange onAggregation(Exchange oldExchange, Exchange newExchange) {
        return aggregationStrategy.aggregate(oldExchange, newExchange);
    }","protected Exchange onAggregation(Exchange oldExchange, Exchange newExchange) {
        return aggregationStrategy.aggregate(oldExchange, newExchange);
    }",0,[0]
19653,bugs-dot-jar_WICKET-2882_ebe56869,"private MarkupContainer getEnclosureParent()
	{
		MarkupContainer parent = getParent();
		while (parent.isAuto())
		{
			parent = parent.getParent();
		}

		if (parent == null)
		{
			throw new WicketRuntimeException(
				""Unable to find parent component which is not a transparent resolver"");
		}
		return parent;
	}","private MarkupContainer getEnclosureParent()
	{
		MarkupContainer parent = getParent();
		while ((parent != null) && parent.isAuto())
		{
			parent = parent.getParent();
		}

		if (parent == null)
		{
			throw new WicketRuntimeException(
				""Unable to find parent component which is not a transparent resolver"");
		}
		return parent;
	}",1,[3]
8233,bugs-dot-jar_CAMEL-3727_ff2713d1,"public Collection<Processor> getProcessors() {
        return processors;
    }","public Collection<Processor> getProcessors() {
        return processors;
    }",0,[0]
8591,bugs-dot-jar_WICKET-3309_debca73b,"private void rebuildDirty()
	{
		// go through dirty items
		for (TreeItem item : dirtyItems)
		{
			// item children need to be rebuilt
			if (item.getChildren() == null)
			{
				buildItemChildren(item);
			}
		}
	}","private void rebuildDirty()
	{
		// go through dirty items
		for (TreeItem item : dirtyItems)
		{
			// item children need to be rebuilt
			if (item.getChildren() == null)
			{
				buildItemChildren(item);
			}
		}
	}",0,[0]
27830,bugs-dot-jar_CAMEL-8053_cac72b14,"public Endpoint getEndpoint(String uri) {
        ObjectHelper.notEmpty(uri, ""uri"");

        log.trace(""Getting endpoint with uri: {}"", uri);

        // in case path has property placeholders then try to let property component resolve those
        try {
            uri = resolvePropertyPlaceholders(uri);
        } catch (Exception e) {
            throw new ResolveEndpointFailedException(uri, e);
        }

        final String rawUri = uri;

        // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
        uri = normalizeEndpointUri(uri);

        log.trace(""Getting endpoint with raw uri: {}, normalized uri: {}"", rawUri, uri);

        Endpoint answer;
        String scheme = null;
        EndpointKey key = getEndpointKey(uri);
        answer = endpoints.get(key);
        if (answer == null) {
            try {
                // Use the URI prefix to find the component.
                String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                if (splitURI[1] != null) {
                    scheme = splitURI[0];
                    log.trace(""Endpoint uri: {} is from component with name: {}"", uri, scheme);
                    Component component = getComponent(scheme);

                    // Ask the component to resolve the endpoint.
                    if (component != null) {
                        log.trace(""Creating endpoint from uri: {} using component: {}"", uri, component);

                        // Have the component create the endpoint if it can.
                        if (component.useRawUri()) {
                            answer = component.createEndpoint(rawUri);
                        } else {
                            answer = component.createEndpoint(uri);
                        }

                        if (answer != null && log.isDebugEnabled()) {
                            log.debug(""{} converted to endpoint: {} by component: {}"", new Object[]{URISupport.sanitizeUri(uri), answer, component});
                        }
                    }
                }

                if (answer == null) {
                    // no component then try in registry and elsewhere
                    answer = createEndpoint(uri);
                    log.trace(""No component to create endpoint from uri: {} fallback lookup in registry -> {}"", uri, answer);
                }

                if (answer != null) {
                    addService(answer);
                    answer = addEndpointToRegistry(uri, answer);
                }
            } catch (Exception e) {
                throw new ResolveEndpointFailedException(uri, e);
            }
        }

        // unknown scheme
        if (answer == null && scheme != null) {
            throw new ResolveEndpointFailedException(uri, ""No component found with scheme: "" + scheme);
        }

        return answer;
    }","public Endpoint getEndpoint(String uri) {
        ObjectHelper.notEmpty(uri, ""uri"");

        log.trace(""Getting endpoint with uri: {}"", uri);

        // in case path has property placeholders then try to let property component resolve those
        try {
            uri = resolvePropertyPlaceholders(uri);
        } catch (Exception e) {
            throw new ResolveEndpointFailedException(uri, e);
        }

        final String rawUri = uri;

        // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
        uri = normalizeEndpointUri(uri);

        log.trace(""Getting endpoint with raw uri: {}, normalized uri: {}"", rawUri, uri);

        Endpoint answer;
        String scheme = null;
        EndpointKey key = getEndpointKey(uri);
        answer = endpoints.get(key);
        if (answer == null) {
            try {
                // Use the URI prefix to find the component.
                String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                if (splitURI[1] != null) {
                    scheme = splitURI[0];
                    log.trace(""Endpoint uri: {} is from component with name: {}"", uri, scheme);
                    Component component = getComponent(scheme);

                    // Ask the component to resolve the endpoint.
                    if (component != null) {
                        log.trace(""Creating endpoint from uri: {} using component: {}"", uri, component);

                        // Have the component create the endpoint if it can.
                        if (component.useRawUri()) {
                            answer = component.createEndpoint(rawUri);
                        } else {
                            answer = component.createEndpoint(uri);
                        }

                        if (answer != null && log.isDebugEnabled()) {
                            log.debug(""{} converted to endpoint: {} by component: {}"", new Object[]{URISupport.sanitizeUri(uri), answer, component});
                        }
                    }
                }

                if (answer == null) {
                    // no component then try in registry and elsewhere
                    answer = createEndpoint(uri);
                    log.trace(""No component to create endpoint from uri: {} fallback lookup in registry -> {}"", uri, answer);
                }

                if (answer != null) {
                    addService(answer);
                    answer = addEndpointToRegistry(uri, answer);
                }
            } catch (Exception e) {
                throw new ResolveEndpointFailedException(uri, e);
            }
        }

        // unknown scheme
        if (answer == null && scheme != null) {
            throw new ResolveEndpointFailedException(uri, ""No component found with scheme: "" + scheme);
        }

        return answer;
    }",0,[0]
1035,bugs-dot-jar_CAMEL-9238_169b981e,"public void setCharset(String charset) {
        this.charset = charset;
    }","public void setCharset(String charset) {
        this.charset = charset;
    }",0,[0]
9169,bugs-dot-jar_MATH-377_c640932d,"public RealMatrix getUT() throws InvalidMatrixException {

        if (cachedUt == null) {
            cachedUt = getU().transpose();
        }

        // return the cached matrix
        return cachedUt;

    }","public RealMatrix getUT() throws InvalidMatrixException {

        if (cachedUt == null) {
            cachedUt = getU().transpose();
        }

        // return the cached matrix
        return cachedUt;

    }",0,[0]
7320,bugs-dot-jar_WICKET-5251_3d2393c7,"public PackageResourceReference(final String name)
	{
		super(name);
	}","public PackageResourceReference(final String name)
	{
		super(name);
	}",0,[0]
22788,bugs-dot-jar_OAK-847_65aa40dd,"private ConcurrentSkipListMap<String, Map<String, Object>> getMap(Collection collection) {
        switch (collection) {
        case NODES:
            return nodes;
        case CLUSTER_NODES:
            return clusterNodes;
        default:
            throw new IllegalArgumentException(collection.name());
        }
    }","private ConcurrentSkipListMap<String, Map<String, Object>> getMap(Collection collection) {
        switch (collection) {
        case NODES:
            return nodes;
        case CLUSTER_NODES:
            return clusterNodes;
        default:
            throw new IllegalArgumentException(collection.name());
        }
    }",0,[0]
26540,bugs-dot-jar_OAK-3021_494da6de,"private void checkValidPrivileges(Iterable<String> privilegeNames) throws CommitFailedException {
        if (privilegeNames == null || Iterables.isEmpty(privilegeNames)) {
            throw accessViolation(9, ""Missing privileges."");
        }
        for (String privilegeName : privilegeNames) {
            try {
                Privilege privilege = privilegeManager.getPrivilege(privilegeName);
                if (privilege.isAbstract()) {
                    throw accessViolation(11, ""Abstract privilege "" + privilegeName);
                }
            } catch (AccessControlException e) {
                throw accessViolation(10, ""Invalid privilege "" + privilegeName);
            } catch (RepositoryException e) {
                throw new IllegalStateException(""Failed to read privileges"", e);
            }
        }
    }","private void checkValidPrivileges(Iterable<String> privilegeNames) throws CommitFailedException {
        if (privilegeNames == null || Iterables.isEmpty(privilegeNames)) {
            throw accessViolation(9, ""Missing privileges."");
        }
        for (String privilegeName : privilegeNames) {
            try {
                Privilege privilege = privilegeManager.getPrivilege(privilegeName);
                if (privilege.isAbstract()) {
                    throw accessViolation(11, ""Abstract privilege "" + privilegeName);
                }
            } catch (AccessControlException e) {
                throw accessViolation(10, ""Invalid privilege "" + privilegeName);
            } catch (RepositoryException e) {
                throw new IllegalStateException(""Failed to read privileges"", e);
            }
        }
    }",0,[0]
14193,bugs-dot-jar_LOG4J2-392_731c84b5,"@Override
    public void start() {
        LOGGER.debug(""Starting configuration {}"", this);
        this.setStarting();
        pluginManager.collectPlugins();
        final PluginManager levelPlugins = new PluginManager(""Level"");
        levelPlugins.collectPlugins();
        final Map<String, PluginType<?>> plugins = levelPlugins.getPlugins();
        if (plugins != null) {
            for (final PluginType<?> type : plugins.values()) {
                try {
                    // Cause the class to be initialized if it isn't already.
                    Loader.initializeClass(type.getPluginClass().getName(), type.getPluginClass().getClassLoader());
                } catch (final Exception ex) {
                    LOGGER.error(""Unable to initialize {} due to {}: {}"", type.getPluginClass().getName(),
                            ex.getClass().getSimpleName(), ex.getMessage());
                }
            }
        }
        setup();
        setupAdvertisement();
        doConfigure();
        for (final LoggerConfig logger : loggers.values()) {
            logger.start();
        }
        for (final Appender appender : appenders.values()) {
            appender.start();
        }
        root.start(); // LOG4J2-336
        super.start();
        LOGGER.debug(""Started configuration {} OK."", this);
    }","@Override
    public void start() {
        LOGGER.debug(""Starting configuration {}"", this);
        this.setStarting();
        pluginManager.collectPlugins();
        final PluginManager levelPlugins = new PluginManager(""Level"");
        levelPlugins.collectPlugins();
        final Map<String, PluginType<?>> plugins = levelPlugins.getPlugins();
        if (plugins != null) {
            for (final PluginType<?> type : plugins.values()) {
                try {
                    // Cause the class to be initialized if it isn't already.
                    Loader.initializeClass(type.getPluginClass().getName(), type.getPluginClass().getClassLoader());
                } catch (final Exception ex) {
                    LOGGER.error(""Unable to initialize {} due to {}: {}"", type.getPluginClass().getName(),
                            ex.getClass().getSimpleName(), ex.getMessage());
                }
            }
        }
        setup();
        setupAdvertisement();
        doConfigure();
        final Set<LoggerConfig> alreadyStarted = new HashSet<LoggerConfig>();
        for (final LoggerConfig logger : loggers.values()) {
            logger.start();
            alreadyStarted.add(logger);
        }
        for (final Appender appender : appenders.values()) {
            appender.start();
        }
        if (!alreadyStarted.contains(root)) { // LOG4J2-392
            root.start(); // LOG4J2-336
        }
        super.start();
        LOGGER.debug(""Started configuration {} OK."", this);
    }",1,[28]
24033,bugs-dot-jar_OAK-579_7d72e6ed,"public JoinConditionImpl getJoinCondition() {
        return joinCondition;
    }","public JoinConditionImpl getJoinCondition() {
        return joinCondition;
    }",0,[0]
815,bugs-dot-jar_ACCUMULO-412_5594b2e0,"private String prepareBulkImport(FileSystem fs, String dir, String tableId) throws IOException {
    Path bulkDir = createNewBulkDir(fs, tableId);
    
    MetadataTable.addBulkLoadInProgressFlag(""/"" + bulkDir.getParent().getName() + ""/"" + bulkDir.getName());
    
    Path dirPath = new Path(dir);
    FileStatus[] mapFiles = fs.listStatus(dirPath);
    
    UniqueNameAllocator namer = UniqueNameAllocator.getInstance();
    
    for (FileStatus fileStatus : mapFiles) {
      String sa[] = fileStatus.getPath().getName().split(""\\."");
      String extension = """";
      if (sa.length > 1) {
        extension = sa[sa.length - 1];
        
        if (!FileOperations.getValidExtensions().contains(extension)) {
          log.warn(fileStatus.getPath() + "" does not have a valid extension, ignoring"");
          continue;
        }
      } else {
        // assume it is a map file
        extension = Constants.MAPFILE_EXTENSION;
      }
      
      if (extension.equals(Constants.MAPFILE_EXTENSION)) {
        if (!fileStatus.isDir()) {
          log.warn(fileStatus.getPath() + "" is not a map file, ignoring"");
          continue;
        }
        
        if (fileStatus.getPath().getName().equals(""_logs"")) {
          log.info(fileStatus.getPath() + "" is probably a log directory from a map/reduce task, skipping"");
          continue;
        }
        try {
          FileStatus dataStatus = fs.getFileStatus(new Path(fileStatus.getPath(), MapFile.DATA_FILE_NAME));
          if (dataStatus.isDir()) {
            log.warn(fileStatus.getPath() + "" is not a map file, ignoring"");
            continue;
          }
        } catch (FileNotFoundException fnfe) {
          log.warn(fileStatus.getPath() + "" is not a map file, ignoring"");
          continue;
        }
      }
      
      String newName = ""I"" + namer.getNextName() + ""."" + extension;
      Path newPath = new Path(bulkDir, newName);
      try {
        fs.rename(fileStatus.getPath(), newPath);
        log.debug(""Moved "" + fileStatus.getPath() + "" to "" + newPath);
      } catch (IOException E1) {
        log.error(""Could not move: "" + fileStatus.getPath().toString() + "" "" + E1.getMessage());
      }
    }
    return bulkDir.toString();
  }","private String prepareBulkImport(FileSystem fs, String dir, String tableId) throws IOException {
    Path bulkDir = createNewBulkDir(fs, tableId);
    
    MetadataTable.addBulkLoadInProgressFlag(""/"" + bulkDir.getParent().getName() + ""/"" + bulkDir.getName());
    
    Path dirPath = new Path(dir);
    FileStatus[] mapFiles = fs.listStatus(dirPath);
    
    UniqueNameAllocator namer = UniqueNameAllocator.getInstance();
    
    for (FileStatus fileStatus : mapFiles) {
      String sa[] = fileStatus.getPath().getName().split(""\\."");
      String extension = """";
      if (sa.length > 1) {
        extension = sa[sa.length - 1];
        
        if (!FileOperations.getValidExtensions().contains(extension)) {
          log.warn(fileStatus.getPath() + "" does not have a valid extension, ignoring"");
          continue;
        }
      } else {
        // assume it is a map file
        extension = Constants.MAPFILE_EXTENSION;
      }
      
      if (extension.equals(Constants.MAPFILE_EXTENSION)) {
        if (!fileStatus.isDir()) {
          log.warn(fileStatus.getPath() + "" is not a map file, ignoring"");
          continue;
        }
        
        if (fileStatus.getPath().getName().equals(""_logs"")) {
          log.info(fileStatus.getPath() + "" is probably a log directory from a map/reduce task, skipping"");
          continue;
        }
        try {
          FileStatus dataStatus = fs.getFileStatus(new Path(fileStatus.getPath(), MapFile.DATA_FILE_NAME));
          if (dataStatus.isDir()) {
            log.warn(fileStatus.getPath() + "" is not a map file, ignoring"");
            continue;
          }
        } catch (FileNotFoundException fnfe) {
          log.warn(fileStatus.getPath() + "" is not a map file, ignoring"");
          continue;
        }
      }
      
      String newName = ""I"" + namer.getNextName() + ""."" + extension;
      Path newPath = new Path(bulkDir, newName);
      try {
        fs.rename(fileStatus.getPath(), newPath);
        log.debug(""Moved "" + fileStatus.getPath() + "" to "" + newPath);
      } catch (IOException E1) {
        log.error(""Could not move: "" + fileStatus.getPath().toString() + "" "" + E1.getMessage());
      }
    }
    return bulkDir.toString();
  }",0,[0]
39322,bugs-dot-jar_OAK-429_c02ecef8,"@Override
    public boolean isArray() {
        return isArray;
    }","@Override
    public boolean isArray() {
        return isArray;
    }",0,[0]
6325,bugs-dot-jar_WICKET-2261_089303f4,"public WebRequest getWicketRequest()
	{
		return wicketRequest;
	}","public WebRequest getWicketRequest()
	{
		return wicketRequest;
	}",0,[0]
7345,bugs-dot-jar_MATH-657_97b440fc,"public Complex(double real) {
        this(real, 0.0);
    }","public Complex(double real) {
        this(real, 0.0);
    }",0,[0]
23535,bugs-dot-jar_LOG4J2-127_029e79da,"public void fatal(Object message, Throwable t) {
        if (isEnabled(Level.FATAL, null, message, t)) {
            log(null, FQCN, Level.FATAL, new ObjectMessage(message), t);
        }
    }","public void fatal(Object message, Throwable t) {
        if (isEnabled(Level.FATAL, null, message, t)) {
            log(null, FQCN, Level.FATAL, new ObjectMessage(message), t);
        }
    }",0,[0]
6015,bugs-dot-jar_OAK-1348_bc7b7e8c,"@Nonnull
    @Override
    public List<ACE> getEntries() {
        return entries;
    }","@Nonnull
    @Override
    public List<ACE> getEntries() {
        return entries;
    }",0,[0]
1332,bugs-dot-jar_MATH-1252_09fe956a,"public ResizableDoubleArray(int initialCapacity, double expansionFactor, double contractionCriterion)
        throws MathIllegalArgumentException {
        this(initialCapacity, expansionFactor, contractionCriterion, DEFAULT_EXPANSION_MODE, null);
    }","public ResizableDoubleArray(int initialCapacity, double expansionFactor, double contractionCriterion)
        throws MathIllegalArgumentException {
        this(initialCapacity, expansionFactor, contractionCriterion, DEFAULT_EXPANSION_MODE, null);
    }",0,[0]
39178,bugs-dot-jar_OAK-4353_b0014b7d,"public static int align(int address, int boundary) {
        return (address + boundary - 1) & ~(boundary - 1);
    }","public static int align(int address, int boundary) {
        return (address + boundary - 1) & ~(boundary - 1);
    }",0,[0]
15449,bugs-dot-jar_MATH-555_328513f3,"public static short indicator(final short x) {
        return (x >= ZS) ? PS : NS;
    }","public static short indicator(final short x) {
        return (x >= ZS) ? PS : NS;
    }",0,[0]
33193,bugs-dot-jar_WICKET-2202_24ac1a35,"@Override
	public final Component setVersioned(final boolean isVersioned)
	{
		super.setVersioned(isVersioned);

		// Search for FormComponents like TextField etc.
		visitFormComponents(new FormComponent.AbstractVisitor()
		{
			@Override
			public void onFormComponent(final FormComponent<?> formComponent)
			{
				formComponent.setVersioned(isVersioned);
			}
		});
		return this;
	}","@Override
	public final Component setVersioned(final boolean isVersioned)
	{
		super.setVersioned(isVersioned);

		// Search for FormComponents like TextField etc.
		visitFormComponents(new FormComponent.AbstractVisitor()
		{
			@Override
			public void onFormComponent(final FormComponent<?> formComponent)
			{
				formComponent.setVersioned(isVersioned);
			}
		});
		return this;
	}",0,[0]
17194,bugs-dot-jar_WICKET-294_5c592d85,"public IRequestTargetUrlCodingStrategy[] listMounts()
	{
		return (IRequestTargetUrlCodingStrategy[])mountsOnPath.strategies().toArray(
				new IRequestTargetUrlCodingStrategy[mountsOnPath.size()]);
	}","public IRequestTargetUrlCodingStrategy[] listMounts()
	{
		return (IRequestTargetUrlCodingStrategy[])mountsOnPath.strategies().toArray(
				new IRequestTargetUrlCodingStrategy[mountsOnPath.size()]);
	}",0,[0]
21161,bugs-dot-jar_WICKET-5442_a382917f,"public int getHour()
	{
		return getHour(localtime);
	}","public int getHour()
	{
		return getHour(localtime);
	}",0,[0]
2361,bugs-dot-jar_WICKET-5165_0d4d1df7,"protected BufferedWebResponse getAndRemoveBufferedResponse(Url url)
	{
		return WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);
	}","protected BufferedWebResponse getAndRemoveBufferedResponse(Url url)
	{
		return WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);
	}",0,[0]
251,bugs-dot-jar_OAK-2250_08b25cb0,"public boolean hasDeclaredNodeTypes(){
        return !declaringNodeTypes.isEmpty();
    }","public boolean hasDeclaredNodeTypes(){
        return !declaringNodeTypes.isEmpty();
    }",0,[0]
25976,bugs-dot-jar_MATH-1117_f4c926ea,"public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax,
                       final double tolerance) {
        super(boxBoundary(xMin, xMax, yMin, yMax, tolerance), tolerance);
    }","public PolygonsSet(final double xMin, final double xMax,
                       final double yMin, final double yMax,
                       final double tolerance) {
        super(boxBoundary(xMin, xMax, yMin, yMax, tolerance), tolerance);
    }",0,[0]
18200,bugs-dot-jar_MATH-554_fbbb96eb,"public static double distanceInf(Vector3D v1, Vector3D v2) {
    final double dx = FastMath.abs(v2.x - v1.x);
    final double dy = FastMath.abs(v2.y - v1.y);
    final double dz = FastMath.abs(v2.z - v1.z);
    return FastMath.max(FastMath.max(dx, dy), dz);
  }","public static double distanceInf(Vector3D v1, Vector3D v2) {
    final double dx = FastMath.abs(v2.x - v1.x);
    final double dy = FastMath.abs(v2.y - v1.y);
    final double dz = FastMath.abs(v2.z - v1.z);
    return FastMath.max(FastMath.max(dx, dy), dz);
  }",0,[0]
1893,Bears-225,"private DeclaredCommandMethod(Method method) {
        this(method, new ExecutionSpecificParameters(method));
    }","private DeclaredCommandMethod(Method method) {
        this(method, new ExecutionSpecificParameters(method));
    }",0,[0]
103,Bears-6,"public AnnotationIntrospector getAnnotationIntrospector() {
        return _annotationIntrospector;
    }","public AnnotationIntrospector getAnnotationIntrospector() {
        return _annotationIntrospector;
    }",0,[0]
27876,bugs-dot-jar_CAMEL-8053_cac72b14,"public String getComponentParameterJsonSchema(String componentName) throws IOException {
        String packageName = sanitizeComponentName(componentName);
        String path = CamelContextHelper.COMPONENT_DOCUMENTATION_PREFIX + packageName + ""/"" + componentName + "".json"";
        ClassResolver resolver = getClassResolver();
        InputStream inputStream = resolver.loadResourceAsStream(path);
        log.debug(""Loading component JSON Schema for: {} using class resolver: {} -> {}"", new Object[]{componentName, resolver, inputStream});
        if (inputStream != null) {
            try {
                return IOHelper.loadText(inputStream);
            } finally {
                IOHelper.close(inputStream);
            }
        }
        return null;
    }","public String getComponentParameterJsonSchema(String componentName) throws IOException {
        String packageName = sanitizeComponentName(componentName);
        String path = CamelContextHelper.COMPONENT_DOCUMENTATION_PREFIX + packageName + ""/"" + componentName + "".json"";
        ClassResolver resolver = getClassResolver();
        InputStream inputStream = resolver.loadResourceAsStream(path);
        log.debug(""Loading component JSON Schema for: {} using class resolver: {} -> {}"", new Object[]{componentName, resolver, inputStream});
        if (inputStream != null) {
            try {
                return IOHelper.loadText(inputStream);
            } finally {
                IOHelper.close(inputStream);
            }
        }
        return null;
    }",0,[0]
8401,bugs-dot-jar_ACCUMULO-366_db4a291f,"private void handleTabletClosedDuringScan(ArrayList<KVEntry> results, LookupResult lookupResult, boolean exceededMemoryUsage, Range range, int entriesAdded) {
    if (exceededMemoryUsage)
      throw new IllegalStateException(""tablet should not exceed memory usage or close, not both"");
    
    if (entriesAdded > 0)
      addUnfinishedRange(lookupResult, range, results.get(results.size() - 1).key, false);
    else
      lookupResult.unfinishedRanges.add(range);
    
    lookupResult.closed = true;
  }","private void handleTabletClosedDuringScan(ArrayList<KVEntry> results, LookupResult lookupResult, boolean exceededMemoryUsage, Range range, int entriesAdded) {
    if (exceededMemoryUsage)
      throw new IllegalStateException(""tablet should not exceed memory usage or close, not both"");
    
    if (entriesAdded > 0)
      addUnfinishedRange(lookupResult, range, results.get(results.size() - 1).key, false);
    else
      lookupResult.unfinishedRanges.add(range);
    
    lookupResult.closed = true;
  }",0,[0]
8602,bugs-dot-jar_WICKET-5112_ed780cc7,"@Override
	public void validate(IValidatable<String> validatable)
	{
		String url = validatable.getValue();
		if (!isValid(url))
		{
			validatable.error(decorate(new ValidationError(this), validatable));
		}
	}","@Override
	public void validate(IValidatable<String> validatable)
	{
		String url = validatable.getValue();
		if (!isValid(url))
		{
			validatable.error(decorate(new ValidationError(this), validatable));
		}
	}",0,[0]
26349,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    @Nonnull
    public String getCorrespondingNodePath(final String workspaceName) throws RepositoryException {
        return toJcrPath(perform(new ItemOperation<String>(dlg, ""getCorrespondingNodePath"") {
            @Nonnull
            @Override
            public String perform() throws RepositoryException {
                checkValidWorkspace(workspaceName);
                if (workspaceName.equals(sessionDelegate.getWorkspaceName())) {
                    return item.getPath();
                } else {
                    throw new UnsupportedRepositoryOperationException(""OAK-118: Node.getCorrespondingNodePath"");
                }
            }
        }));
    }","@Override
    @Nonnull
    public String getCorrespondingNodePath(final String workspaceName) throws RepositoryException {
        return toJcrPath(perform(new ItemOperation<String>(dlg, ""getCorrespondingNodePath"") {
            @Nonnull
            @Override
            public String perform() throws RepositoryException {
                checkValidWorkspace(workspaceName);
                if (workspaceName.equals(sessionDelegate.getWorkspaceName())) {
                    return item.getPath();
                } else {
                    throw new UnsupportedRepositoryOperationException(""OAK-118: Node.getCorrespondingNodePath"");
                }
            }
        }));
    }",0,[0]
26136,bugs-dot-jar_OAK-543_3ce758b7,"public ChildNodeEntriesMap getCNEMap(final Id id) throws NotFoundException,
            Exception {
        verifyInitialized();

        ChildNodeEntriesMap map = (ChildNodeEntriesMap) cache.get(id,
                new Callable<ChildNodeEntriesMap>() {
                    @Override
                    public ChildNodeEntriesMap call() throws Exception {
                        return pm.readCNEMap(id);
                    }
                });
        return map;
    }","public ChildNodeEntriesMap getCNEMap(final Id id) throws NotFoundException,
            Exception {
        verifyInitialized();

        ChildNodeEntriesMap map = (ChildNodeEntriesMap) cache.get(id,
                new Callable<ChildNodeEntriesMap>() {
                    @Override
                    public ChildNodeEntriesMap call() throws Exception {
                        return pm.readCNEMap(id);
                    }
                });
        return map;
    }",0,[0]
9723,bugs-dot-jar_OAK-614_6feacf6b,"@Override
    public PropertyState getProperty(String name) {
        return read().getProperty(name);
    }","@Override
    public PropertyState getProperty(String name) {
        return read().getProperty(name);
    }",0,[0]
1286,Bears-156,"@Override
    public boolean isDeleteCascaded(ManagedType<?> ownerType, String attributeName) {
        AbstractEntityPersister entityPersister = (AbstractEntityPersister) entityPersisters.get(ownerType.getJavaType().getName());
        EntityMetamodel entityMetamodel = entityPersister.getEntityMetamodel();
        Integer index = entityMetamodel.getPropertyIndexOrNull(attributeName);
        if (index != null) {
            return entityMetamodel.getCascadeStyles()[index].doCascade(CascadingAction.DELETE);
        }

        return false;
    }","@Override
    public boolean isDeleteCascaded(ManagedType<?> ownerType, String attributeName) {
        AbstractEntityPersister entityPersister = (AbstractEntityPersister) entityPersisters.get(ownerType.getJavaType().getName());
        EntityMetamodel entityMetamodel = entityPersister.getEntityMetamodel();
        Integer index = entityMetamodel.getPropertyIndexOrNull(attributeName);
        if (index != null) {
            return entityMetamodel.getCascadeStyles()[index].doCascade(CascadingAction.DELETE);
        }

        return false;
    }",0,[0]
17167,bugs-dot-jar_MATH-293_59a0da9c,"protected Integer getBasicRow(final int col) {
        Integer row = null;
        for (int i = 0; i < getHeight(); i++) {
            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                row = i;
            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                return null;
            }
        }
        return row;
    }","protected Integer getBasicRow(final int col) {
        Integer row = null;
        for (int i = 0; i < getHeight(); i++) {
            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                row = i;
            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                return null;
            }
        }
        return row;
    }",0,[0]
2837,bugs-dot-jar_OAK-1364_05c89637,"public V peek(K key) {
        Entry<K, V> e = find(key);
        return e == null ? null : e.value;
    }","public V peek(K key) {
        int hash = getHash(key);
        Entry<K, V> e = getSegment(hash).find(key, hash);
        return e == null ? null : e.value;
    }",1,[1]
32117,bugs-dot-jar_MATH-724_9c8bb934,"public int nextPascal(int r, double p) {
        return nextInversionDeviate(new PascalDistribution(r, p));
    }","public int nextPascal(int r, double p) {
        return nextInversionDeviate(new PascalDistribution(r, p));
    }",0,[0]
4542,bugs-dot-jar_OAK-2420_24cb1908,"@Nonnull
    @Override
    public String checkpoint(long lifetime, @Nonnull Map<String, String> properties) {
        return checkpoints.create(lifetime, properties).toString();
    }","@Nonnull
    @Override
    public String checkpoint(long lifetime, @Nonnull Map<String, String> properties) {
        return checkpoints.create(lifetime, properties).toString();
    }",0,[0]
802,Bears-103,"public AquilaProtocolDecoder(AquilaProtocol protocol) {
        super(protocol);
    }","public AquilaProtocolDecoder(AquilaProtocol protocol) {
        super(protocol);
    }",0,[0]
4824,bugs-dot-jar_MATH-326_ce185345,"public OpenMapRealVector append(OpenMapRealVector v) {
        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());
        Iterator iter = v.entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            res.setEntry(iter.key() + virtualSize, iter.value());
        }
        return res;
    }","public OpenMapRealVector append(OpenMapRealVector v) {
        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());
        Iterator iter = v.entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            res.setEntry(iter.key() + virtualSize, iter.value());
        }
        return res;
    }",0,[0]
36372,bugs-dot-jar_CAMEL-9444_baece126,"protected void doStop() throws Exception {
        ServiceHelper.stopServices(producerCache, aggregationStrategy);
    }","protected void doStop() throws Exception {
        ServiceHelper.stopServices(producerCache, aggregationStrategy);
    }",0,[0]
205,bugs-dot-jar_WICKET-2368_fae1601b,"public final void setNumericId(final int id)
	{
		numericId = id;
	}","public final void setNumericId(final int id)
	{
		numericId = id;
	}",0,[0]
1007,Bears-130,"@Override
    protected Object decode(
            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {

        ChannelBuffer buf = (ChannelBuffer) msg;

        // Find type
        int index = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');
        index = buf.indexOf(index + 1, buf.writerIndex(), (byte) ',');

        String type = buf.toString(index + 1, 3, StandardCharsets.US_ASCII);
        switch (type) {
            case ""D03"":
                if (channel != null) {
                    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);
                    String imei = Context.getIdentityManager().getById(deviceSession.getDeviceId()).getUniqueId();
                    channel.write(""@@O46,"" + imei + "",D00,camera_picture.jpg,0*00\r\n"");
                }
                return null;
            case ""CCC"":
                return decodeBinaryMessage(channel, remoteAddress, buf);
            default:
                return decodeRegularMessage(channel, remoteAddress, buf);
        }
    }","@Override
    protected Object decode(
            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {

        ChannelBuffer buf = (ChannelBuffer) msg;

        // Find type
        int index = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');
        index = buf.indexOf(index + 1, buf.writerIndex(), (byte) ',');

        String type = buf.toString(index + 1, 3, StandardCharsets.US_ASCII);
        switch (type) {
            case ""D03"":
                if (channel != null) {
                    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);
                    String imei = Context.getIdentityManager().getById(deviceSession.getDeviceId()).getUniqueId();
                    channel.write(""@@O46,"" + imei + "",D00,camera_picture.jpg,0*00\r\n"");
                }
                return null;
            case ""CCC"":
                return decodeBinaryMessage(channel, remoteAddress, buf);
            default:
                return decodeRegularMessage(channel, remoteAddress, buf);
        }
    }",0,[0]
26218,bugs-dot-jar_OAK-2603_77d2d3b0,"VersionGarbageCollector(DocumentNodeStore nodeStore,
                            VersionGCSupport gcSupport) {
        this.nodeStore = nodeStore;
        this.versionStore = gcSupport;
    }","VersionGarbageCollector(DocumentNodeStore nodeStore,
                            VersionGCSupport gcSupport) {
        this.nodeStore = nodeStore;
        this.versionStore = gcSupport;
    }",0,[0]
12912,bugs-dot-jar_LOG4J2-293_25cb587a,protected abstract String[] getSupportedTypes();,protected abstract String[] getSupportedTypes();,0,[0]
229,Bears-8,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property)
        throws JsonMappingException
    {
        JsonSerializer<?> ser = null;
        JsonSerializer<?> keySer = null;
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();
        Object suppressableValue = _suppressableValue;

        // First: if we have a property, may have property-annotation overrides
        if ((propertyAcc != null) && (intr != null)) {
            Object serDef = intr.findKeySerializer(propertyAcc);
            if (serDef != null) {
                keySer = provider.serializerInstance(propertyAcc, serDef);
            }
            serDef = intr.findContentSerializer(propertyAcc);
            if (serDef != null) {
                ser = provider.serializerInstance(propertyAcc, serDef);
            }
        }

        JsonInclude.Value inclV = findIncludeOverrides(provider, property, Map.class);
        JsonInclude.Include incl = inclV.getContentInclusion();
        if ((incl != null) && (incl != JsonInclude.Include.USE_DEFAULTS)) {
            suppressableValue = incl;
        }
        if (ser == null) {
            ser = _valueSerializer;
        }
        // [databind#124]: May have a content converter
        ser = findConvertingContentSerializer(provider, property, ser);
        if (ser == null) {
            // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,
            //   we can consider it a static case as well.
            // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho
            if (_valueTypeIsStatic && !_valueType.isJavaLangObject()) {
                ser = provider.findValueSerializer(_valueType, property);
            }
        } else {
            ser = provider.handleSecondaryContextualization(ser, property);
        }
        if (keySer == null) {
            keySer = _keySerializer;
        }
        if (keySer == null) {
            keySer = provider.findKeySerializer(_keyType, property);
        } else {
            keySer = provider.handleSecondaryContextualization(keySer, property);
        }
        Set<String> ignored = _ignoredEntries;
        boolean sortKeys = false;
        if ((intr != null) && (propertyAcc != null)) {
            JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(propertyAcc);
            if (ignorals != null){
                Set<String> newIgnored = ignorals.findIgnoredForSerialization();
                if ((newIgnored != null) && !newIgnored.isEmpty()) {
                    ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);
                    for (String str : newIgnored) {
                        ignored.add(str);
                    }
                }
            }
            Boolean b = intr.findSerializationSortAlphabetically(propertyAcc);
            sortKeys = (b != null) && b.booleanValue();
        }
        JsonFormat.Value format = findFormatOverrides(provider, property, Map.class);
        if (format != null) {
            Boolean B = format.getFeature(JsonFormat.Feature.WRITE_SORTED_MAP_ENTRIES);
            if (B != null) {
                sortKeys = B.booleanValue();
            }
        }
        MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);
        if (suppressableValue != _suppressableValue) {
            mser = mser.withContentInclusion(suppressableValue);
        }

        // [databind#307]: allow filtering
        if (property != null) {
            AnnotatedMember m = property.getMember();
            if (m != null) {
                Object filterId = intr.findFilterId(m);
                if (filterId != null) {
                    mser = mser.withFilterId(filterId);
                }
            }
        }
        return mser;
    }","@Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property)
        throws JsonMappingException
    {
        JsonSerializer<?> ser = null;
        JsonSerializer<?> keySer = null;
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();
        Object suppressableValue = _suppressableValue;

        // First: if we have a property, may have property-annotation overrides
        if ((propertyAcc != null) && (intr != null)) {
            Object serDef = intr.findKeySerializer(propertyAcc);
            if (serDef != null) {
                keySer = provider.serializerInstance(propertyAcc, serDef);
            }
            serDef = intr.findContentSerializer(propertyAcc);
            if (serDef != null) {
                ser = provider.serializerInstance(propertyAcc, serDef);
            }
        }

        JsonInclude.Value inclV = findIncludeOverrides(provider, property, Map.class);
        JsonInclude.Include incl = inclV.getContentInclusion();
        if ((incl != null) && (incl != JsonInclude.Include.USE_DEFAULTS)) {
            suppressableValue = incl;
        }
        if (ser == null) {
            ser = _valueSerializer;
        }
        // [databind#124]: May have a content converter
        ser = findConvertingContentSerializer(provider, property, ser);
        if (ser == null) {
            // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,
            //   we can consider it a static case as well.
            // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho
            if (_valueTypeIsStatic && !_valueType.isJavaLangObject()) {
                ser = provider.findValueSerializer(_valueType, property);
            }
        } else {
            ser = provider.handleSecondaryContextualization(ser, property);
        }
        if (keySer == null) {
            keySer = _keySerializer;
        }
        if (keySer == null) {
            keySer = provider.findKeySerializer(_keyType, property);
        } else {
            keySer = provider.handleSecondaryContextualization(keySer, property);
        }
        Set<String> ignored = _ignoredEntries;
        boolean sortKeys = false;
        if ((intr != null) && (propertyAcc != null)) {
            JsonIgnoreProperties.Value ignorals = intr.findPropertyIgnorals(propertyAcc);
            if (ignorals != null){
                Set<String> newIgnored = ignorals.findIgnoredForSerialization();
                if ((newIgnored != null) && !newIgnored.isEmpty()) {
                    ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);
                    for (String str : newIgnored) {
                        ignored.add(str);
                    }
                }
            }
            Boolean b = intr.findSerializationSortAlphabetically(propertyAcc);
            sortKeys = (b != null) && b.booleanValue();
        }
        JsonFormat.Value format = findFormatOverrides(provider, property, Map.class);
        if (format != null) {
            Boolean B = format.getFeature(JsonFormat.Feature.WRITE_SORTED_MAP_ENTRIES);
            if (B != null) {
                sortKeys = B.booleanValue();
            }
        }
        MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);
        if (suppressableValue != _suppressableValue) {
            mser = mser.withContentInclusion(suppressableValue);
        }

        // [databind#307]: allow filtering
        if (property != null) {
            AnnotatedMember m = property.getMember();
            if (m != null) {
                Object filterId = intr.findFilterId(m);
                if (filterId != null) {
                    mser = mser.withFilterId(filterId);
                }
            }
        }
        return mser;
    }",0,[0]
4226,bugs-dot-jar_CAMEL-4682_1e54865c,"public Route getRoute(String id) {
        for (Route route : getRoutes()) {
            if (route.getId().equals(id)) {
                return route;
            }
        }
        return null;
    }","public Route getRoute(String id) {
        for (Route route : getRoutes()) {
            if (route.getId().equals(id)) {
                return route;
            }
        }
        return null;
    }",0,[0]
22749,bugs-dot-jar_MATH-778_5b9302d5,"public Dfp power10K(final int e) {
        Dfp d = newInstance(getOne());
        d.exp = e + 1;
        return d;
    }","public Dfp power10K(final int e) {
        Dfp d = newInstance(getOne());
        d.exp = e + 1;
        return d;
    }",0,[0]
4575,bugs-dot-jar_OAK-2420_24cb1908,"private void moveOrCopyNode(boolean move,
                                DocumentNodeState source,
                                String targetPath,
                                Commit commit) {
        // TODO Optimize - Move logic would not work well with very move of very large subtrees
        // At minimum we can optimize by traversing breadth wise and collect node id
        // and fetch them via '$in' queries

        // TODO Transient Node - Current logic does not account for operations which are part
        // of this commit i.e. transient nodes. If its required it would need to be looked
        // into

        DocumentNodeState newNode = new DocumentNodeState(this, targetPath, commit.getRevision());
        source.copyTo(newNode);

        commit.addNode(newNode);
        if (move) {
            markAsDeleted(source, commit, false);
        }
        for (DocumentNodeState child : getChildNodes(source, null, Integer.MAX_VALUE)) {
            String childName = PathUtils.getName(child.getPath());
            String destChildPath = concat(targetPath, childName);
            moveOrCopyNode(move, child, destChildPath, commit);
        }
    }","private void moveOrCopyNode(boolean move,
                                DocumentNodeState source,
                                String targetPath,
                                Commit commit) {
        // TODO Optimize - Move logic would not work well with very move of very large subtrees
        // At minimum we can optimize by traversing breadth wise and collect node id
        // and fetch them via '$in' queries

        // TODO Transient Node - Current logic does not account for operations which are part
        // of this commit i.e. transient nodes. If its required it would need to be looked
        // into

        DocumentNodeState newNode = new DocumentNodeState(this, targetPath, commit.getRevision());
        source.copyTo(newNode);

        commit.addNode(newNode);
        if (move) {
            markAsDeleted(source, commit, false);
        }
        for (DocumentNodeState child : getChildNodes(source, null, Integer.MAX_VALUE)) {
            String childName = PathUtils.getName(child.getPath());
            String destChildPath = concat(targetPath, childName);
            moveOrCopyNode(move, child, destChildPath, commit);
        }
    }",0,[0]
7751,bugs-dot-jar_ACCUMULO-843_65390f8c,"public Collection<Text> getSplits() {
    return splits;
  }","public Collection<Text> getSplits() {
    return splits;
  }",0,[0]
19266,bugs-dot-jar_MATH-1165_596ccd59,"public List<CentroidCluster<T>> getClusters() {
        return clusters;
    }","public List<CentroidCluster<T>> getClusters() {
        return clusters;
    }",0,[0]
8845,bugs-dot-jar_CAMEL-7275_44cad623,"@Override
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors, errorHandlers, aggregationStrategy);
    }","@Override
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors, errorHandlers, aggregationStrategy);
    }",0,[0]
359,Bears-15,"@Override
    @Deprecated
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)
    {
        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.contentAs());
    }","@Override
    @Deprecated
    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)
    {
        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.contentAs());
    }",0,[0]
1357,Bears-160,"protected void parseReferenceOption(Marker start) {
        if (tokens.canConsume(""RESTRICT"")) {} else if (tokens.canConsume(""CASCADE"")) {} else if (tokens.canConsume(""SET"", ""NULL"")) {} else {
            tokens.canConsume(""NO"", ""ACTION"");
        }
    }","protected void parseReferenceOption(Marker start) {
        if (tokens.canConsume(""RESTRICT"")) {} else if (tokens.canConsume(""CASCADE"")) {} else if (tokens.canConsume(""SET"", ""NULL"")) {} else {
            tokens.canConsume(""NO"", ""ACTION"");
        }
    }",0,[0]
12402,bugs-dot-jar_MATH-1088_63d88c74,"@Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < dimension; i++) {
            sb.append(""["").append(getCount(i)).append(""]"");
        }
        return sb.toString();
    }","@Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < dimension; i++) {
            sb.append(""["").append(getCount(i)).append(""]"");
        }
        return sb.toString();
    }",0,[0]
40601,bugs-dot-jar_WICKET-442_246d53c5,"private final void processEventsAndRespond()
	{
		// let the processor handle/ issue any events
		processor.processEvents(this);

		// set current stage manually this time
		currentStep = RESPOND;

		// generate a response
		processor.respond(this);
	}","private final void processEventsAndRespond()
	{
		// let the processor handle/ issue any events
		processor.processEvents(this);

		// set current stage manually this time
		currentStep = RESPOND;

		// generate a response
		processor.respond(this);
	}",0,[0]
24019,bugs-dot-jar_OAK-579_7d72e6ed,"public void bindSelector(SourceImpl source) {
        descendantSelector = source.getExistingSelector(descendantSelectorName);
        ancestorSelector = source.getExistingSelector(ancestorSelectorName);
    }","public void bindSelector(SourceImpl source) {
        descendantSelector = source.getExistingSelector(descendantSelectorName);
        ancestorSelector = source.getExistingSelector(ancestorSelectorName);
    }",0,[0]
4656,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapCosh() {
        return copy().mapCoshToSelf();
    }","public RealVector mapCosh() {
        return copy().mapCoshToSelf();
    }",0,[0]
6317,bugs-dot-jar_WICKET-2261_089303f4,"public boolean initializeHttpSessionAsTemporary()
	{
		return false;
	}","public boolean initializeHttpSessionAsTemporary()
	{
		return false;
	}",0,[0]
1479,bugs-dot-jar_OAK-185_7fe28a0e,"@Override
    public void unlock() throws RepositoryException {
        String lockOwner = sessionDelegate.getOakPathOrThrow(JCR_LOCK_OWNER);
        String lockIsDeep = sessionDelegate.getOakPathOrThrow(JCR_LOCK_IS_DEEP);
        try {
            Root root = sessionDelegate.getContentSession().getCurrentRoot();
            Tree tree = root.getTree(dlg.getPath());
            if (tree == null) {
                throw new ItemNotFoundException();
            }
            tree.removeProperty(lockOwner);
            tree.removeProperty(lockIsDeep);
            root.commit(DefaultConflictHandler.OURS);
        } catch (CommitFailedException e) {
            throw new RepositoryException(""Unable to unlock "" + this, e);
        }

        getSession().refresh(true);
    }","@Override
    public void unlock() throws RepositoryException {
        String lockOwner = sessionDelegate.getOakPathOrThrow(JCR_LOCK_OWNER);
        String lockIsDeep = sessionDelegate.getOakPathOrThrow(JCR_LOCK_IS_DEEP);
        try {
            Root root = sessionDelegate.getContentSession().getCurrentRoot();
            Tree tree = root.getTree(dlg.getPath());
            if (tree == null) {
                throw new ItemNotFoundException();
            }
            tree.removeProperty(lockOwner);
            tree.removeProperty(lockIsDeep);
            root.commit(DefaultConflictHandler.OURS);
        } catch (CommitFailedException e) {
            throw new RepositoryException(""Unable to unlock "" + this, e);
        }

        getSession().refresh(true);
    }",0,[0]
32888,bugs-dot-jar_OAK-4036_f4324736,"private void registerObserver(BundleContext bundleContext, Map<String, ?> config) {
        boolean enableAsyncIndexOpen = PropertiesUtil.toBoolean(config.get(PROP_ASYNC_INDEX_OPEN), true);
        Observer observer = indexProvider;
        if (enableAsyncIndexOpen) {
            backgroundObserver = new BackgroundObserver(indexProvider, getExecutorService(), 5);
            observer = backgroundObserver;
            oakRegs.add(registerMBean(whiteboard,
                    BackgroundObserverMBean.class,
                    backgroundObserver.getMBean(),
                    BackgroundObserverMBean.TYPE,
                    ""LuceneIndexConfigObserver queue stats""));
            log.info(""Registering the LuceneIndexProvider as a BackgroundObserver"");
        }
        regs.add(bundleContext.registerService(Observer.class.getName(), observer, null));
    }","private void registerObserver(BundleContext bundleContext, Map<String, ?> config) {
        boolean enableAsyncIndexOpen = PropertiesUtil.toBoolean(config.get(PROP_ASYNC_INDEX_OPEN), true);
        Observer observer = indexProvider;
        if (enableAsyncIndexOpen) {
            backgroundObserver = new BackgroundObserver(indexProvider, getExecutorService(), 5);
            observer = backgroundObserver;
            oakRegs.add(registerMBean(whiteboard,
                    BackgroundObserverMBean.class,
                    backgroundObserver.getMBean(),
                    BackgroundObserverMBean.TYPE,
                    ""LuceneIndexConfigObserver queue stats""));
            log.info(""Registering the LuceneIndexProvider as a BackgroundObserver"");
        }
        regs.add(bundleContext.registerService(Observer.class.getName(), observer, null));
    }",0,[0]
23530,bugs-dot-jar_LOG4J2-127_029e79da,"public void fatal(Marker marker, String message) {
        if (isEnabled(Level.FATAL, marker, message)) {
            log(marker, FQCN, Level.FATAL, new SimpleMessage(message), null);
        }
    }","public void fatal(Marker marker, String message) {
        if (isEnabled(Level.FATAL, marker, message)) {
            log(marker, FQCN, Level.FATAL, new SimpleMessage(message), null);
        }
    }",0,[0]
14900,bugs-dot-jar_OAK-3318_e12e2052,"private NodeState getTikaConfigNode() {
        return definition.getChildNode(TIKA).getChildNode(TIKA_CONFIG);
    }","private NodeState getTikaConfigNode() {
        return definition.getChildNode(TIKA).getChildNode(TIKA_CONFIG);
    }",0,[0]
15465,bugs-dot-jar_MATH-555_328513f3,"public static int sign(final int x) {
        return (x == 0) ? 0 : (x > 0) ? 1 : -1;
    }","public static int sign(final int x) {
        return (x == 0) ? 0 : (x > 0) ? 1 : -1;
    }",0,[0]
10059,bugs-dot-jar_MATH-1127_ba62c59d,"public static boolean equals(double x, double y) {
        return equals(x, y, 1);
    }","public static boolean equals(double x, double y) {
        return equals(x, y, 1);
    }",0,[0]
17335,bugs-dot-jar_FLINK-1951_adb321d6,"public JobGraph compileJobGraph(OptimizedPlan program) {
		this.vertices = new HashMap<PlanNode, AbstractJobVertex>();
		this.chainedTasks = new HashMap<PlanNode, TaskInChain>();
		this.chainedTasksInSequence = new ArrayList<TaskInChain>();
		this.auxVertices = new ArrayList<AbstractJobVertex>();
		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>();
		this.iterationStack = new ArrayList<IterationPlanNode>();
		
		this.sharingGroup = new SlotSharingGroup();
		
		// this starts the traversal that generates the job graph
		program.accept(this);
		
		// sanity check that we are not somehow in an iteration at the end
		if (this.currentIteration != null) {
			throw new CompilerException(""The graph translation ended prematurely, leaving an unclosed iteration."");
		}
		
		// finalize the iterations
		for (IterationDescriptor iteration : this.iterations.values()) {
			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {
				finalizeBulkIteration(iteration);
			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {
				finalizeWorksetIteration(iteration);
			} else {
				throw new CompilerException();
			}
		}
		
		// now that the traversal is done, we have the chained tasks write their configs into their
		// parents' configurations
		for (TaskInChain tic : this.chainedTasksInSequence) {
			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration());
			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName());
		}
		
		// create the job graph object
		JobGraph graph = new JobGraph(program.getJobName());
		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries());
		graph.setAllowQueuedScheduling(false);
		
		// add vertices to the graph
		for (AbstractJobVertex vertex : this.vertices.values()) {
			graph.addVertex(vertex);
		}
		
		for (AbstractJobVertex vertex : this.auxVertices) {
			graph.addVertex(vertex);
			vertex.setSlotSharingGroup(sharingGroup);
		}
		
		// add registered cache file into job configuration
		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {
			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration());
		}

		try {
			InstantiationUtil.writeObjectToConfig(
					program.getOriginalPactPlan().getExecutionConfig(),
					graph.getJobConfiguration(),
					ExecutionConfig.CONFIG_KEY);
		} catch (IOException e) {
			throw new RuntimeException(""Config object could not be written to Job Configuration: "" + e);
		}

		// release all references again
		this.vertices = null;
		this.chainedTasks = null;
		this.chainedTasksInSequence = null;
		this.auxVertices = null;
		this.iterations = null;
		this.iterationStack = null;
		
		// return job graph
		return graph;
	}","public JobGraph compileJobGraph(OptimizedPlan program) {
		this.vertices = new HashMap<PlanNode, AbstractJobVertex>();
		this.chainedTasks = new HashMap<PlanNode, TaskInChain>();
		this.chainedTasksInSequence = new ArrayList<TaskInChain>();
		this.auxVertices = new ArrayList<AbstractJobVertex>();
		this.iterations = new HashMap<IterationPlanNode, IterationDescriptor>();
		this.iterationStack = new ArrayList<IterationPlanNode>();
		
		this.sharingGroup = new SlotSharingGroup();
		
		// this starts the traversal that generates the job graph
		program.accept(this);
		
		// sanity check that we are not somehow in an iteration at the end
		if (this.currentIteration != null) {
			throw new CompilerException(""The graph translation ended prematurely, leaving an unclosed iteration."");
		}
		
		// finalize the iterations
		for (IterationDescriptor iteration : this.iterations.values()) {
			if (iteration.getIterationNode() instanceof BulkIterationPlanNode) {
				finalizeBulkIteration(iteration);
			} else if (iteration.getIterationNode() instanceof WorksetIterationPlanNode) {
				finalizeWorksetIteration(iteration);
			} else {
				throw new CompilerException();
			}
		}
		
		// now that the traversal is done, we have the chained tasks write their configs into their
		// parents' configurations
		for (TaskInChain tic : this.chainedTasksInSequence) {
			TaskConfig t = new TaskConfig(tic.getContainingVertex().getConfiguration());
			t.addChainedTask(tic.getChainedTask(), tic.getTaskConfig(), tic.getTaskName());
		}
		
		// create the job graph object
		JobGraph graph = new JobGraph(program.getJobName());
		graph.setNumberOfExecutionRetries(program.getOriginalPactPlan().getNumberOfExecutionRetries());
		graph.setAllowQueuedScheduling(false);
		
		// add vertices to the graph
		for (AbstractJobVertex vertex : this.vertices.values()) {
			graph.addVertex(vertex);
		}
		
		for (AbstractJobVertex vertex : this.auxVertices) {
			graph.addVertex(vertex);
			vertex.setSlotSharingGroup(sharingGroup);
		}
		
		// add registered cache file into job configuration
		for (Entry<String, DistributedCacheEntry> e : program.getOriginalPactPlan().getCachedFiles()) {
			DistributedCache.writeFileInfoToConfig(e.getKey(), e.getValue(), graph.getJobConfiguration());
		}

		try {
			InstantiationUtil.writeObjectToConfig(
					program.getOriginalPactPlan().getExecutionConfig(),
					graph.getJobConfiguration(),
					ExecutionConfig.CONFIG_KEY);
		} catch (IOException e) {
			throw new RuntimeException(""Config object could not be written to Job Configuration: "" + e);
		}

		// release all references again
		this.vertices = null;
		this.chainedTasks = null;
		this.chainedTasksInSequence = null;
		this.auxVertices = null;
		this.iterations = null;
		this.iterationStack = null;
		
		// return job graph
		return graph;
	}",0,[0]
14285,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public KeyValueAndPeek nextEntry(String scanner) throws TException {
    
    ScanResult scanResult = nextK(scanner, 1);
    if (scanResult.results.size() > 0) {
      return new KeyValueAndPeek(scanResult.results.get(0), scanResult.isMore());
    } else {
      throw new NoMoreEntriesException();
    }
    
  }","@Override
  public KeyValueAndPeek nextEntry(String scanner) throws TException {
    
    ScanResult scanResult = nextK(scanner, 1);
    if (scanResult.results.size() > 0) {
      return new KeyValueAndPeek(scanResult.results.get(0), scanResult.isMore());
    } else {
      throw new NoMoreEntriesException();
    }
    
  }",0,[0]
23605,bugs-dot-jar_OAK-4423_08f0b280,"@Override @Nonnull
    public NodeState reset(@Nonnull NodeBuilder builder) {
        checkArgument(builder instanceof SegmentNodeBuilder);

        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;

        NodeState root = getRoot();
        snb.reset(root);

        return root;
    }","@Override @Nonnull
    public NodeState reset(@Nonnull NodeBuilder builder) {
        checkArgument(builder instanceof SegmentNodeBuilder);

        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;

        NodeState root = getRoot();
        snb.reset(root);

        return root;
    }",0,[0]
39484,bugs-dot-jar_MATH-305_ef9b639a,"public static double[] normalizeArray(double[] values, double normalizedSum)
       throws ArithmeticException, IllegalArgumentException {
         if (Double.isInfinite(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     ""Cannot normalize to an infinite value"");
         }
         if (Double.isNaN(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     ""Cannot normalize to NaN"");
         }
         double sum = 0d;
         final int len = values.length;
         double[] out = new double[len];
         for (int i = 0; i < len; i++) {
             if (Double.isInfinite(values[i])) {
                 throw MathRuntimeException.createArithmeticException(
                         ""Array contains an infinite element, {0} at index {1}"", values[i], i);
             }
             if (!Double.isNaN(values[i])) {
                 sum += values[i];
             }
         }
         if (sum == 0) {
             throw MathRuntimeException.createArithmeticException(
                     ""Array sums to zero"");
         }
         for (int i = 0; i < len; i++) {
             if (Double.isNaN(values[i])) {
                 out[i] = Double.NaN;
             } else {
                 out[i] = values[i] * normalizedSum / sum;
             }
         }
         return out;
     }","public static double[] normalizeArray(double[] values, double normalizedSum)
       throws ArithmeticException, IllegalArgumentException {
         if (Double.isInfinite(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     ""Cannot normalize to an infinite value"");
         }
         if (Double.isNaN(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     ""Cannot normalize to NaN"");
         }
         double sum = 0d;
         final int len = values.length;
         double[] out = new double[len];
         for (int i = 0; i < len; i++) {
             if (Double.isInfinite(values[i])) {
                 throw MathRuntimeException.createArithmeticException(
                         ""Array contains an infinite element, {0} at index {1}"", values[i], i);
             }
             if (!Double.isNaN(values[i])) {
                 sum += values[i];
             }
         }
         if (sum == 0) {
             throw MathRuntimeException.createArithmeticException(
                     ""Array sums to zero"");
         }
         for (int i = 0; i < len; i++) {
             if (Double.isNaN(values[i])) {
                 out[i] = Double.NaN;
             } else {
                 out[i] = values[i] * normalizedSum / sum;
             }
         }
         return out;
     }",0,[0]
16616,bugs-dot-jar_FLINK-1848_7164b2b6,"@Override
	public void initialize(final URI name) throws IOException {	}","@Override
	public void initialize(final URI name) throws IOException {	}",0,[0]
1810,Bears-211,public CBORFactory() { this(null); },public CBORFactory() { this(null); },0,[0]
7089,bugs-dot-jar_LOG4J2-763_97203de8,"public StructuredDataMessage(final String id, final String msg, final String type,
                                 final Map<String, String> data) {
        super(data);
        this.id = new StructuredDataId(id, null, null);
        this.message = msg;
        this.type = type;
    }","public StructuredDataMessage(final String id, final String msg, final String type,
                                 final Map<String, String> data) {
        super(data);
        this.id = new StructuredDataId(id, null, null);
        this.message = msg;
        this.type = type;
    }",0,[0]
5864,bugs-dot-jar_MATH-859_66dece12,"public UniformRealDistribution(RandomGenerator rng,
                                   double lower,
                                   double upper,
                                   double inverseCumAccuracy)
        throws NumberIsTooLargeException {
        super(rng);
        if (lower >= upper) {
            throw new NumberIsTooLargeException(
                            LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
                            lower, upper, false);
        }

        this.lower = lower;
        this.upper = upper;
        solverAbsoluteAccuracy = inverseCumAccuracy;
    }","public UniformRealDistribution(RandomGenerator rng,
                                   double lower,
                                   double upper,
                                   double inverseCumAccuracy)
        throws NumberIsTooLargeException {
        super(rng);
        if (lower >= upper) {
            throw new NumberIsTooLargeException(
                            LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,
                            lower, upper, false);
        }

        this.lower = lower;
        this.upper = upper;
        solverAbsoluteAccuracy = inverseCumAccuracy;
    }",0,[0]
8712,bugs-dot-jar_WICKET-5883_cd3b9234,"public void process(IFormSubmitter submittingComponent)
	{
		if (!isEnabledInHierarchy() || !isVisibleInHierarchy())
		{
			// since process() can be called outside of the default form workflow, an additional
			// check is needed

			// FIXME throw listener exception
			return;
		}

		// run validation
		validate();

		// If a validation error occurred
		if (hasError())
		{
			// mark all children as invalid
			markFormComponentsInvalid();

			// let subclass handle error
			callOnError(submittingComponent);
		}
		else
		{
			// mark all children as valid
			markFormComponentsValid();

			// before updating, call the interception method for clients
			beforeUpdateFormComponentModels();

			// Update model using form data
			updateFormComponentModels();

			// validate model objects after input values have been bound
			internalOnValidateModelObjects();
			if (hasError())
			{
				callOnError(submittingComponent);
				return;
			}

			// Form has no error
			delegateSubmit(submittingComponent);
		}
	}","public void process(IFormSubmitter submittingComponent)
	{
		if (!isEnabledInHierarchy() || !isVisibleInHierarchy())
		{
			// since process() can be called outside of the default form workflow, an additional
			// check is needed

			// FIXME throw listener exception
			return;
		}

		// run validation
		validate();

		// If a validation error occurred
		if (hasError())
		{
			// mark all children as invalid
			markFormComponentsInvalid();

			// let subclass handle error
			callOnError(submittingComponent);
		}
		else
		{
			// mark all children as valid
			markFormComponentsValid();

			// before updating, call the interception method for clients
			beforeUpdateFormComponentModels();

			// Update model using form data
			updateFormComponentModels();

			// validate model objects after input values have been bound
			internalOnValidateModelObjects();
			if (hasError())
			{
				callOnError(submittingComponent);
				return;
			}

			// Form has no error
			delegateSubmit(submittingComponent);
		}
	}",0,[0]
26497,bugs-dot-jar_WICKET-3510_292a2582,"protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel)
	{
		return DateTextField.forShortStyle(id, dateFieldModel);
	}","protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel)
	{
		return DateTextField.forShortStyle(id, dateFieldModel, false);
	}",1,[2]
2872,bugs-dot-jar_OAK-1364_05c89637,"public static Builder newBuilder() {
        return new Builder();
    }","public static Builder newBuilder() {
        return new Builder();
    }",0,[0]
13772,bugs-dot-jar_CAMEL-6936_4954d573,"protected abstract boolean pollDirectory(String fileName, List<GenericFile<T>> fileList, int depth);","protected abstract boolean pollDirectory(String fileName, List<GenericFile<T>> fileList, int depth);",0,[0]
10745,bugs-dot-jar_CAMEL-7478_69b00a31,"public <T> T evaluate(Exchange exchange, Class<T> type) {
        Object result = evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(type, exchange, result);
    }","public <T> T evaluate(Exchange exchange, Class<T> type) {
        Object result = evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(type, exchange, result);
    }",0,[0]
667,Bears-20,"protected FromStringDeserializer(Class<?> vc) {
        super(vc);
    }","protected FromStringDeserializer(Class<?> vc) {
        super(vc);
    }",0,[0]
25708,bugs-dot-jar_OAK-748_503451c1,"@Override
    public void remove(NodeBuilder index, String key, Iterable<String> values) {
        if (!index.hasChildNode(key)) {
            return;
        }
        NodeBuilder child = index.child(key);
        Map<String, NodeBuilder> parents = new TreeMap<String, NodeBuilder>(Collections.reverseOrder());

        for (String rm : values) {
            if (PathUtils.denotesRoot(rm)) {
                child.removeProperty(""match"");
            } else {
                String parentPath = PathUtils.getParentPath(rm);
                String name = PathUtils.getName(rm);
                NodeBuilder indexEntry = parents.get(parentPath);
                if (indexEntry == null) {
                    indexEntry = child;
                    String segmentPath = """";
                    Iterator<String> segments = PathUtils.elements(parentPath)
                            .iterator();
                    while (segments.hasNext()) {
                        String segment = segments.next();
                        segmentPath = PathUtils.concat(segmentPath, segment);
                        indexEntry = indexEntry.child(segment);
                        parents.put(segmentPath, indexEntry);
                    }
                }
                if (indexEntry.hasChildNode(name)) {
                    NodeBuilder childEntry = indexEntry.child(name);
                    childEntry.removeProperty(""match"");
                    if (childEntry.getChildNodeCount() == 0) {
                        indexEntry.removeNode(name);
                    }
                }
            }
        }
        // prune the index: remove all children that have no children
        // and no ""match"" property progressing bottom up
        Iterator<String> it = parents.keySet().iterator();
        while (it.hasNext()) {
            String path = it.next();
            NodeBuilder parent = parents.get(path);
            pruneNode(parent);
        }

        // finally prune the index node
        pruneNode(child);
        if (child.getChildNodeCount() == 0
                && child.getProperty(""match"") == null) {
            index.removeNode(key);
        }
    }","@Override
    public void remove(NodeBuilder index, String key, Iterable<String> values) {
        if (!index.hasChildNode(key)) {
            return;
        }
        NodeBuilder child = index.child(key);
        Map<String, NodeBuilder> parents = new TreeMap<String, NodeBuilder>(Collections.reverseOrder());

        for (String rm : values) {
            if (PathUtils.denotesRoot(rm)) {
                child.removeProperty(""match"");
            } else {
                String parentPath = PathUtils.getParentPath(rm);
                String name = PathUtils.getName(rm);
                NodeBuilder indexEntry = parents.get(parentPath);
                if (indexEntry == null) {
                    indexEntry = child;
                    String segmentPath = """";
                    Iterator<String> segments = PathUtils.elements(parentPath)
                            .iterator();
                    while (segments.hasNext()) {
                        String segment = segments.next();
                        segmentPath = PathUtils.concat(segmentPath, segment);
                        indexEntry = indexEntry.child(segment);
                        parents.put(segmentPath, indexEntry);
                    }
                }
                if (indexEntry.hasChildNode(name)) {
                    NodeBuilder childEntry = indexEntry.child(name);
                    childEntry.removeProperty(""match"");
                    if (childEntry.getChildNodeCount() == 0) {
                        indexEntry.removeNode(name);
                    }
                }
            }
        }
        // prune the index: remove all children that have no children
        // and no ""match"" property progressing bottom up
        Iterator<String> it = parents.keySet().iterator();
        while (it.hasNext()) {
            String path = it.next();
            NodeBuilder parent = parents.get(path);
            pruneNode(parent);
        }

        // finally prune the index node
        pruneNode(child);
        if (child.getChildNodeCount() == 0
                && child.getProperty(""match"") == null) {
            index.removeNode(key);
        }
    }",0,[0]
9511,bugs-dot-jar_OAK-1697_1552be04,"private static long getExpirationTime(NodeUtil tokenNode, long defaultValue) {
        return tokenNode.getLong(TOKEN_ATTRIBUTE_EXPIRY, defaultValue);
    }","private static long getExpirationTime(NodeUtil tokenNode, long defaultValue) {
        return tokenNode.getLong(TOKEN_ATTRIBUTE_EXPIRY, defaultValue);
    }",0,[0]
4727,bugs-dot-jar_MATH-326_ce185345,"public RealVector add(double[] v)
        throws IllegalArgumentException {
        checkVectorDimensions(v.length);
        double[] out = data.clone();
        for (int i = 0; i < data.length; i++) {
            out[i] += v[i];
        }
        return new ArrayRealVector(out, false);
    }","public RealVector add(double[] v)
        throws IllegalArgumentException {
        checkVectorDimensions(v.length);
        double[] out = data.clone();
        for (int i = 0; i < data.length; i++) {
            out[i] += v[i];
        }
        return new ArrayRealVector(out, false);
    }",0,[0]
40394,bugs-dot-jar_WICKET-442_246d53c5,"public long getSizeInBytes()
	{
		final MarkupContainer originalParent = this.parent;
		this.parent = null;
		long size = -1;
		try
		{
			size = Objects.sizeof(this);
		}
		catch (Exception e)
		{
			log.error(""Exception getting size for component "" + this, e);
		}
		this.parent = originalParent;
		return size;
	}","public long getSizeInBytes()
	{
		final MarkupContainer originalParent = this.parent;
		this.parent = null;
		long size = -1;
		try
		{
			size = Objects.sizeof(this);
		}
		catch (Exception e)
		{
			log.error(""Exception getting size for component "" + this, e);
		}
		this.parent = originalParent;
		return size;
	}",0,[0]
3105,bugs-dot-jar_OAK-1216_e403e003,"public final synchronized SessionImpl getSession() {
        if (session == null) {
            session = createSession();
        }
        return session;
    }","public final synchronized SessionImpl getSession() {
        if (session == null) {
            session = createSession();
        }
        return session;
    }",0,[0]
19222,bugs-dot-jar_WICKET-4119_bb7a6995,"@Override
	public int hashCode()
	{
		final int prime = 31;
		int result = 1;
		result = prime * result + ((absolutePath == null) ? 0 : absolutePath.hashCode());
		result = prime * result + ((locale == null) ? 0 : locale.hashCode());
		result = prime * result + ((path == null) ? 0 : path.hashCode());
		result = prime * result + ((scopeName == null) ? 0 : scopeName.hashCode());
		result = prime * result + ((style == null) ? 0 : style.hashCode());
		result = prime * result + ((variation == null) ? 0 : variation.hashCode());
		return result;
	}","@Override
	public int hashCode()
	{
		final int prime = 31;
		int result = 1;
		result = prime * result + ((absolutePath == null) ? 0 : absolutePath.hashCode());
		result = prime * result + ((locale == null) ? 0 : locale.hashCode());
		result = prime * result + ((path == null) ? 0 : path.hashCode());
		result = prime * result + ((scopeName == null) ? 0 : scopeName.hashCode());
		result = prime * result + ((style == null) ? 0 : style.hashCode());
		result = prime * result + ((variation == null) ? 0 : variation.hashCode());
		return result;
	}",0,[0]
36467,bugs-dot-jar_MATH-705_645d642b,"@Override
  protected StepInterpolator doCopy() {
    return new HighamHall54StepInterpolator(this);
  }","@Override
  protected StepInterpolator doCopy() {
    return new HighamHall54StepInterpolator(this);
  }",0,[0]
23523,bugs-dot-jar_LOG4J2-127_029e79da,"public boolean isErrorEnabled() {
        return isEnabled(Level.ERROR, null, (Object) null, null);
    }","public boolean isErrorEnabled() {
        return isEnabled(Level.ERROR, null, (Object) null, null);
    }",0,[0]
1728,Bears-197,"public URIBuilder addParameter(final String param, final String value) {
        if (this.queryParams == null) {
            this.queryParams = new ArrayList<BasicNameValuePair>();
        }
        this.queryParams.add(new BasicNameValuePair(param, value));
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        this.query = null;
        return this;
    }","public URIBuilder addParameter(final String param, final String value) {
        if (this.queryParams == null) {
            this.queryParams = new ArrayList<BasicNameValuePair>();
        }
        this.queryParams.add(new BasicNameValuePair(param, value));
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        this.query = null;
        return this;
    }",0,[0]
7236,bugs-dot-jar_WICKET-5881_8c83c5c5,"@Override
	public void updateModel()
	{
		setModelObject(getConvertedInput());
	}","@Override
	public void updateModel()
	{
		setModelObject(getConvertedInput());
	}",0,[0]
411,Bears-15,"protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore)
    {
        super(src._handledType);

        // Bit clumsy, but has to do:
        HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore);
        final BeanPropertyWriter[] propsIn = src._props;
        final BeanPropertyWriter[] fpropsIn = src._filteredProps;
        final int len = propsIn.length;

        ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len);
        ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len);

        for (int i = 0; i < len; ++i) {
            BeanPropertyWriter bpw = propsIn[i];
            // should be ignored?
            if (ignoredSet.contains(bpw.getName())) {
                continue;
            }
            propsOut.add(bpw);
            if (fpropsIn != null) {
                fpropsOut.add(fpropsIn[i]);
            }
        }
        _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]);
        _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]);
        
        _typeId = src._typeId;
        _anyGetterWriter = src._anyGetterWriter;
        _objectIdWriter = src._objectIdWriter;
        _propertyFilterId = src._propertyFilterId;
        _serializationShape = src._serializationShape;
    }","protected BeanSerializerBase(BeanSerializerBase src, String[] toIgnore)
    {
        super(src._handledType);

        // Bit clumsy, but has to do:
        HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(toIgnore);
        final BeanPropertyWriter[] propsIn = src._props;
        final BeanPropertyWriter[] fpropsIn = src._filteredProps;
        final int len = propsIn.length;

        ArrayList<BeanPropertyWriter> propsOut = new ArrayList<BeanPropertyWriter>(len);
        ArrayList<BeanPropertyWriter> fpropsOut = (fpropsIn == null) ? null : new ArrayList<BeanPropertyWriter>(len);

        for (int i = 0; i < len; ++i) {
            BeanPropertyWriter bpw = propsIn[i];
            // should be ignored?
            if (ignoredSet.contains(bpw.getName())) {
                continue;
            }
            propsOut.add(bpw);
            if (fpropsIn != null) {
                fpropsOut.add(fpropsIn[i]);
            }
        }
        _props = propsOut.toArray(new BeanPropertyWriter[propsOut.size()]);
        _filteredProps = (fpropsOut == null) ? null : fpropsOut.toArray(new BeanPropertyWriter[fpropsOut.size()]);
        
        _typeId = src._typeId;
        _anyGetterWriter = src._anyGetterWriter;
        _objectIdWriter = src._objectIdWriter;
        _propertyFilterId = src._propertyFilterId;
        _serializationShape = src._serializationShape;
    }",0,[0]
17837,bugs-dot-jar_OAK-1075_79467350,"private boolean evaluate(PropertyValue p1, PropertyValue p2) {
        switch (operator) {
        case EQUAL:
            return PropertyValues.match(p1, p2);
        case NOT_EQUAL:
            return !PropertyValues.match(p1, p2);
        case GREATER_OR_EQUAL:
            return p1.compareTo(p2) >= 0;
        case GREATER_THAN:
            return p1.compareTo(p2) > 0;
        case LESS_OR_EQUAL:
            return p1.compareTo(p2) <= 0;
        case LESS_THAN:
            return p1.compareTo(p2) < 0;
        case LIKE:
            return evaluateLike(p1, p2);
        }
        throw new IllegalArgumentException(""Unknown operator: "" + operator);
    }","private boolean evaluate(PropertyValue p1, PropertyValue p2) {
        switch (operator) {
        case EQUAL:
            return PropertyValues.match(p1, p2);
        case NOT_EQUAL:
            return PropertyValues.notMatch(p1, p2);
        case GREATER_OR_EQUAL:
            return p1.compareTo(p2) >= 0;
        case GREATER_THAN:
            return p1.compareTo(p2) > 0;
        case LESS_OR_EQUAL:
            return p1.compareTo(p2) <= 0;
        case LESS_THAN:
            return p1.compareTo(p2) < 0;
        case LIKE:
            return evaluateLike(p1, p2);
        }
        throw new IllegalArgumentException(""Unknown operator: "" + operator);
    }",1,[5]
868,Bears-118,"public void setFilterDistance(int filterDistance) {
        this.filterDistance = filterDistance;
    }","public void setFilterDistance(int filterDistance) {
        this.filterDistance = filterDistance;
    }",0,[0]
39224,bugs-dot-jar_OAK-4353_b0014b7d,"private int count() {
        fileStoreLock.readLock().lock();
        try {
            int count = 0;
            if (writer != null) {
                count += writer.count();
            }
            for (TarReader reader : readers) {
                count += reader.count();
            }
            return count;
        } finally {
            fileStoreLock.readLock().unlock();
        }
    }","private int count() {
        fileStoreLock.readLock().lock();
        try {
            int count = 0;
            if (writer != null) {
                count += writer.count();
            }
            for (TarReader reader : readers) {
                count += reader.count();
            }
            return count;
        } finally {
            fileStoreLock.readLock().unlock();
        }
    }",0,[0]
3318,bugs-dot-jar_LOG4J2-492_61ccbb95,"private static void registerContextSelector(final ContextSelector selector, final MBeanServer mbs,
            final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException,
            NotCompliantMBeanException {

        final ContextSelectorAdmin mbean = new ContextSelectorAdmin(selector);
        register(mbs, mbean, mbean.getObjectName());
    }","private static void registerContextSelector(final ContextSelector selector, final MBeanServer mbs,
            final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException,
            NotCompliantMBeanException {

        final ContextSelectorAdmin mbean = new ContextSelectorAdmin(selector);
        register(mbs, mbean, mbean.getObjectName());
    }",0,[0]
2431,bugs-dot-jar_CAMEL-8137_53b4e90c,"protected MethodInfo createMethodInfo(Class<?> clazz, Method method) {
        Class<?>[] parameterTypes = method.getParameterTypes();
        List<Annotation>[] parametersAnnotations = collectParameterAnnotations(clazz, method);

        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();
        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();

        boolean hasCustomAnnotation = false;
        boolean hasHandlerAnnotation = ObjectHelper.hasAnnotation(method.getAnnotations(), Handler.class);

        int size = parameterTypes.length;
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Creating MethodInfo for class: {} method: {} having {} parameters"", new Object[]{clazz, method, size});
        }

        for (int i = 0; i < size; i++) {
            Class<?> parameterType = parameterTypes[i];
            Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new Annotation[parametersAnnotations[i].size()]);
            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);
            hasCustomAnnotation |= expression != null;

            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations, expression);
            LOG.trace(""Parameter #{}: {}"", i, parameterInfo);
            parameters.add(parameterInfo);
            if (expression == null) {
                boolean bodyAnnotation = ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);
                LOG.trace(""Parameter #{} has @Body annotation"", i);
                hasCustomAnnotation |= bodyAnnotation;
                if (bodyParameters.isEmpty()) {
                    // okay we have not yet set the body parameter and we have found
                    // the candidate now to use as body parameter
                    if (Exchange.class.isAssignableFrom(parameterType)) {
                        // use exchange
                        expression = ExpressionBuilder.exchangeExpression();
                    } else {
                        // assume it's the body and it must be mandatory convertible to the parameter type
                        // but we allow null bodies in case the message really contains a null body
                        expression = ExpressionBuilder.mandatoryBodyExpression(parameterType, true);
                    }
                    LOG.trace(""Parameter #{} is the body parameter using expression {}"", i, expression);
                    parameterInfo.setExpression(expression);
                    bodyParameters.add(parameterInfo);
                } else {
                    // will ignore the expression for parameter evaluation
                }
            }
            LOG.trace(""Parameter #{} has parameter info: "", i, parameterInfo);
        }

        // now let's add the method to the repository
        return new MethodInfo(camelContext, clazz, method, parameters, bodyParameters, hasCustomAnnotation, hasHandlerAnnotation);
    }","protected MethodInfo createMethodInfo(Class<?> clazz, Method method) {
        Class<?>[] parameterTypes = method.getParameterTypes();
        List<Annotation>[] parametersAnnotations = collectParameterAnnotations(clazz, method);

        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();
        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();

        boolean hasCustomAnnotation = false;
        boolean hasHandlerAnnotation = ObjectHelper.hasAnnotation(method.getAnnotations(), Handler.class);

        int size = parameterTypes.length;
        if (LOG.isTraceEnabled()) {
            LOG.trace(""Creating MethodInfo for class: {} method: {} having {} parameters"", new Object[]{clazz, method, size});
        }

        for (int i = 0; i < size; i++) {
            Class<?> parameterType = parameterTypes[i];
            Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new Annotation[parametersAnnotations[i].size()]);
            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);
            hasCustomAnnotation |= expression != null;

            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations, expression);
            LOG.trace(""Parameter #{}: {}"", i, parameterInfo);
            parameters.add(parameterInfo);
            if (expression == null) {
                boolean bodyAnnotation = ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);
                LOG.trace(""Parameter #{} has @Body annotation"", i);
                hasCustomAnnotation |= bodyAnnotation;
                if (bodyParameters.isEmpty()) {
                    // okay we have not yet set the body parameter and we have found
                    // the candidate now to use as body parameter
                    if (Exchange.class.isAssignableFrom(parameterType)) {
                        // use exchange
                        expression = ExpressionBuilder.exchangeExpression();
                    } else {
                        // assume it's the body and it must be mandatory convertible to the parameter type
                        // but we allow null bodies in case the message really contains a null body
                        expression = ExpressionBuilder.mandatoryBodyExpression(parameterType, true);
                    }
                    LOG.trace(""Parameter #{} is the body parameter using expression {}"", i, expression);
                    parameterInfo.setExpression(expression);
                    bodyParameters.add(parameterInfo);
                } else {
                    // will ignore the expression for parameter evaluation
                }
            }
            LOG.trace(""Parameter #{} has parameter info: "", i, parameterInfo);
        }

        // now let's add the method to the repository
        return new MethodInfo(camelContext, clazz, method, parameters, bodyParameters, hasCustomAnnotation, hasHandlerAnnotation);
    }",0,[0]
585,bugs-dot-jar_WICKET-5570_57d8f051,"public AbstractAjaxTimerBehavior(final Duration updateInterval)
	{
		setUpdateInterval(updateInterval);
	}","public AbstractAjaxTimerBehavior(final Duration updateInterval)
	{
		setUpdateInterval(updateInterval);
	}",0,[0]
3201,bugs-dot-jar_WICKET-3767_84c3baac,"public final String getRawInput()
	{
		return NO_RAW_INPUT.equals(rawInput) ? null : rawInput;
	}","public final String getRawInput()
	{
		return NO_RAW_INPUT.equals(rawInput) ? null : rawInput;
	}",0,[0]
26283,bugs-dot-jar_OAK-644_55a4f738,"private static Collection<PrivilegeDefinition> getBuiltInDefinitions() {
        Map<String, PrivilegeDefinition> definitions = new LinkedHashMap<String, PrivilegeDefinition>();
        for (String privilegeName : NON_AGGR_PRIVILEGES) {
            PrivilegeDefinition def = new PrivilegeDefinitionImpl(privilegeName, false);
            definitions.put(privilegeName, def);
        }
        for (String privilegeName : AGGREGATE_PRIVILEGES.keySet()) {
            PrivilegeDefinition def = new PrivilegeDefinitionImpl(privilegeName, false, AGGREGATE_PRIVILEGES.get(privilegeName));
            definitions.put(privilegeName, def);
        }
        PrivilegeDefinition all = new PrivilegeDefinitionImpl(JCR_ALL, false, definitions.keySet());
        definitions.put(JCR_ALL, all);
        return definitions.values();
    }","private static Collection<PrivilegeDefinition> getBuiltInDefinitions() {
        Map<String, PrivilegeDefinition> definitions = new LinkedHashMap<String, PrivilegeDefinition>();
        for (String privilegeName : NON_AGGR_PRIVILEGES) {
            PrivilegeDefinition def = new PrivilegeDefinitionImpl(privilegeName, false);
            definitions.put(privilegeName, def);
        }
        for (String privilegeName : AGGREGATE_PRIVILEGES.keySet()) {
            PrivilegeDefinition def = new PrivilegeDefinitionImpl(privilegeName, false, AGGREGATE_PRIVILEGES.get(privilegeName));
            definitions.put(privilegeName, def);
        }
        PrivilegeDefinition all = new PrivilegeDefinitionImpl(JCR_ALL, false, definitions.keySet());
        definitions.put(JCR_ALL, all);
        return definitions.values();
    }",0,[0]
37045,bugs-dot-jar_OAK-1883_9c2421ed,"public void releaseRecoveryLock(int clusterId){
        UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);
        update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);
        store.createOrUpdate(Collection.CLUSTER_NODES, update);
    }","public void releaseRecoveryLock(int clusterId){
        UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);
        update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);
        update.set(ClusterNodeInfo.STATE, null);
        store.createOrUpdate(Collection.CLUSTER_NODES, update);
    }",1,[]
134,bugs-dot-jar_OAK-1822_3e83a4c1,"CachedNodeDocument getCachedNodeDoc(String id) {
        if (nodesCache instanceof OffHeapCache) {
            return ((OffHeapCache) nodesCache).getCachedDocument(id);
        }

        return nodesCache.getIfPresent(new StringValue(id));
    }","CachedNodeDocument getCachedNodeDoc(String id) {
        if (nodesCache instanceof OffHeapCache) {
            return ((OffHeapCache) nodesCache).getCachedDocument(id);
        }

        return nodesCache.getIfPresent(new StringValue(id));
    }",0,[0]
38231,bugs-dot-jar_CAMEL-3314_4badd9c5,"public ThrottleDefinition throttle(long maximumRequestCount) {
        ThrottleDefinition answer = new ThrottleDefinition(maximumRequestCount);
        addOutput(answer);
        return answer;
    }","public ThrottleDefinition throttle(long maximumRequestCount) {
        ThrottleDefinition answer = new ThrottleDefinition(maximumRequestCount);
        addOutput(answer);
        return answer;
    }",0,[0]
13759,bugs-dot-jar_MATH-318_83f18d52,"private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,
                                                       final double lambda) {
        final int nM1 = d.length - 1;
        double si = -lambda;
        int sixI = 0;
        for (int i = 0; i < nM1; ++i) {
            final double di   = d[i];
            final double li   = l[i];
            final double diP1 = di + si;
            final double liP1 = li * di / diP1;
            work[sixI]        = si;
            work[sixI + 1]    = diP1;
            work[sixI + 2]    = liP1;
            si = li * liP1 * si - lambda;
            sixI += 6;
        }
        work[6 * nM1 + 1] = d[nM1] + si;
        work[6 * nM1]     = si;
    }","private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,
                                                       final double lambda) {
        final int nM1 = d.length - 1;
        double si = -lambda;
        int sixI = 0;
        for (int i = 0; i < nM1; ++i) {
            final double di   = d[i];
            final double li   = l[i];
            final double diP1 = di + si;
            final double liP1 = li * di / diP1;
            work[sixI]        = si;
            work[sixI + 1]    = diP1;
            work[sixI + 2]    = liP1;
            si = li * liP1 * si - lambda;
            sixI += 6;
        }
        work[6 * nM1 + 1] = d[nM1] + si;
        work[6 * nM1]     = si;
    }",0,[0]
33649,bugs-dot-jar_WICKET-3845_afc7034d,"public String[] getHeaderValues(String name)
	{
		final List<Object> objects = headers.get(new HeaderKey(name));

		if (objects == null)
		{
			return NO_VALUES;
		}

		final String[] values = new String[objects.size()];

		for (int i = 0; i < values.length; i++)
		{
			values[i] = valueToString(objects.get(i));
		}
		return values;
	}","public String[] getHeaderValues(String name)
	{
		final List<Object> objects = headers.get(new HeaderKey(name));

		if (objects == null)
		{
			return NO_VALUES;
		}

		final String[] values = new String[objects.size()];

		for (int i = 0; i < values.length; i++)
		{
			values[i] = valueToString(objects.get(i));
		}
		return values;
	}",0,[0]
38224,bugs-dot-jar_CAMEL-3314_4badd9c5,"public ExpressionClause<AggregateDefinition> aggregate() {
        AggregateDefinition answer = new AggregateDefinition();
        addOutput(answer);
        return answer.createAndSetExpression();
    }","public ExpressionClause<AggregateDefinition> aggregate() {
        AggregateDefinition answer = new AggregateDefinition();
        addOutput(answer);
        return answer.createAndSetExpression();
    }",0,[0]
10077,bugs-dot-jar_WICKET-4292_9cb617ae,"@Override
	public boolean containsHeader(final String name)
	{
		return headers.containsKey(name);
	}","@Override
	public boolean containsHeader(final String name)
	{
		return headers.containsKey(name);
	}",0,[0]
38507,bugs-dot-jar_CAMEL-9124_9da2c05a,"public RedeliveryPolicyDefinition maximumRedeliveryDelay(String maximumRedeliveryDelay) {
        setMaximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }","public RedeliveryPolicyDefinition maximumRedeliveryDelay(String maximumRedeliveryDelay) {
        setMaximumRedeliveryDelay(maximumRedeliveryDelay);
        return this;
    }",0,[0]
12453,bugs-dot-jar_OAK-1225_3535afe2,"@Override
    @Nonnull
    public AccessControlManager getAccessControlManager() throws RepositoryException {
        return sessionContext.getAccessControlManager();
    }","@Override
    @Nonnull
    public AccessControlManager getAccessControlManager() throws RepositoryException {
        return sessionContext.getAccessControlManager();
    }",0,[0]
1015,bugs-dot-jar_ACCUMULO-3408_81d25bc2,"public static String commas(long i, long warnMin, long warnMax, long errMin, long errMax) {
    if (i < errMin || i > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(i));
    if (i < warnMin || i > warnMax)
      return String.format(""<span class='warning'>%s</span>"", bigNumberForQuantity(i));
    return bigNumberForQuantity(i);
  }","public static String commas(long i, long warnMin, long warnMax, long errMin, long errMax) {
    if (i < errMin || i > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(i));
    if (i < warnMin || i > warnMax)
      return String.format(""<span class='warning'>%s</span>"", bigNumberForQuantity(i));
    return bigNumberForQuantity(i);
  }",0,[0]
2316,bugs-dot-jar_MNG-4918_691a03a7,"public Map<String, Artifact> getManagedVersionMap()
    {
        if ( managedVersionMap != null )
        {
            return managedVersionMap;
        }

        Map<String, Artifact> map = null;
        if ( repositorySystem != null )
        {

            List<Dependency> deps;
            DependencyManagement dependencyManagement = getDependencyManagement();
            if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) )
            {
                map = new HashMap<String, Artifact>();
                for ( Iterator<Dependency> i = dependencyManagement.getDependencies().iterator(); i.hasNext(); )
                {
                    Dependency d = i.next();

                    Artifact artifact = repositorySystem.createDependencyArtifact( d );

                    if ( artifact == null )
                    {
                        map = Collections.emptyMap();
                    }

                    map.put( d.getManagementKey(), artifact );
                }
            }
            else
            {
                map = Collections.emptyMap();
            }
        }
        managedVersionMap = map;
        return managedVersionMap;
    }","public Map<String, Artifact> getManagedVersionMap()
    {
        if ( managedVersionMap != null )
        {
            return managedVersionMap;
        }

        Map<String, Artifact> map = null;
        if ( repositorySystem != null )
        {

            List<Dependency> deps;
            DependencyManagement dependencyManagement = getDependencyManagement();
            if ( ( dependencyManagement != null ) && ( ( deps = dependencyManagement.getDependencies() ) != null ) && ( deps.size() > 0 ) )
            {
                map = new HashMap<String, Artifact>();
                for ( Iterator<Dependency> i = dependencyManagement.getDependencies().iterator(); i.hasNext(); )
                {
                    Dependency d = i.next();

                    Artifact artifact = repositorySystem.createDependencyArtifact( d );

                    if ( artifact == null )
                    {
                        map = Collections.emptyMap();
                    }

                    map.put( d.getManagementKey(), artifact );
                }
            }
            else
            {
                map = Collections.emptyMap();
            }
        }
        managedVersionMap = map;
        return managedVersionMap;
    }",0,[0]
21143,bugs-dot-jar_WICKET-5442_a382917f,"public static Time now()
	{
		return millis(System.currentTimeMillis());
	}","public static Time now()
	{
		return millis(System.currentTimeMillis());
	}",0,[0]
731,bugs-dot-jar_LOG4J2-385_7c2ce5cf,"private PatternParser createPatternParser() {

        return new PatternParser(null, KEY, null);
    }","private PatternParser createPatternParser() {

        return new PatternParser(null, KEY, null);
    }",0,[0]
35571,bugs-dot-jar_OAK-621_00b4b8a0,"@Override
    public TreeLocation getLocation() {
        root.checkLive();
        return new NodeLocation(this);
    }","@Override
    public TreeLocation getLocation() {
        root.checkLive();
        return new NodeLocation(this);
    }",0,[0]
11251,bugs-dot-jar_CAMEL-7130_cc192f87,"public Templates getTemplate() {
        return template;
    }","public Templates getTemplate() {
        return template;
    }",0,[0]
9513,bugs-dot-jar_OAK-1697_1552be04,"@Nonnull
    private static String generateKey(int size) {
        SecureRandom random = new SecureRandom();
        byte key[] = new byte[size];
        random.nextBytes(key);

        StringBuilder res = new StringBuilder(key.length * 2);
        for (byte b : key) {
            res.append(Text.hexTable[(b >> 4) & 15]);
            res.append(Text.hexTable[b & 15]);
        }
        return res.toString();
    }","@Nonnull
    private static String generateKey(int size) {
        SecureRandom random = new SecureRandom();
        byte key[] = new byte[size];
        random.nextBytes(key);

        StringBuilder res = new StringBuilder(key.length * 2);
        for (byte b : key) {
            res.append(Text.hexTable[(b >> 4) & 15]);
            res.append(Text.hexTable[b & 15]);
        }
        return res.toString();
    }",0,[0]
13790,bugs-dot-jar_LOG4J2-619_3b4b370e,"@Override
    public Configuration reconfigure() {
        if (configFile != null) {
            try {
                final ConfigurationFactory.ConfigurationSource source =
                    new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);
                final XmlConfiguration config = new XmlConfiguration(source);
                if (config.rootElement == null) {
                    return null;
                }
            } catch (final FileNotFoundException ex) {
                LOGGER.error(""Cannot locate file "" + configFile, ex);
            }
        }
        return null;
    }","@Override
    public Configuration reconfigure() {
        if (configFile != null) {
            try {
                final ConfigurationFactory.ConfigurationSource source =
                    new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);
                final XmlConfiguration config = new XmlConfiguration(source);
                return (config.rootElement == null) ? null : config;
            } catch (final FileNotFoundException ex) {
                LOGGER.error(""Cannot locate file "" + configFile, ex);
            }
        }
        return null;
    }",1,"[7, 8, 9]"
8069,bugs-dot-jar_OAK-1655_c91bfa54,"@Override
    public void setBlockSize(int x) {

    }","@Override
    public void setBlockSize(int x) {

    }",0,[0]
8550,bugs-dot-jar_WICKET-3309_debca73b,"public final void invalidateAll()
	{
		updated();
		dirtyAll = true;
	}","public final void invalidateAll()
	{
		updated();
		dirtyAll = true;
	}",0,[0]
40509,bugs-dot-jar_WICKET-442_246d53c5,"public void beforeCallComponent(final Component component,
			final RequestListenerInterface listener)
	{
	}","public void beforeCallComponent(final Component component,
			final RequestListenerInterface listener)
	{
	}",0,[0]
29301,bugs-dot-jar_CAMEL-7586_1f92fa42,"public int removeEndpoints(String pattern) throws Exception {
        // endpoints is always removed from JMX if removed from context
        Collection<Endpoint> removed = context.removeEndpoints(pattern);
        return removed.size();
    }","public int removeEndpoints(String pattern) throws Exception {
        // endpoints is always removed from JMX if removed from context
        Collection<Endpoint> removed = context.removeEndpoints(pattern);
        return removed.size();
    }",0,[0]
40486,bugs-dot-jar_WICKET-442_246d53c5,"protected final void replaceComponentTagBody(final MarkupStream markupStream,
			final ComponentTag tag, final CharSequence body)
	{
		// The tag might have been changed from open-close to open. Hence
		// we'll need what was in the markup itself
		ComponentTag markupOpenTag = null;

		// If tag has a body
		if (tag.isOpen())
		{
			// Get what tag was in the markup; not what the user it might
			// have changed it to.
			markupStream.setCurrentIndex(markupStream.getCurrentIndex() - 1);
			markupOpenTag = markupStream.getTag();
			markupStream.next();

			// If it was an open tag in the markup as well, than ...
			if (markupOpenTag.isOpen())
			{
				// skip any raw markup in the body
				markupStream.skipRawMarkup();
			}
		}

		if (body != null)
		{
			// Write the new body
			getResponse().write(body);
		}

		// If we had an open tag (and not an openclose tag) and we found a
		// close tag, we're good
		if (tag.isOpen())
		{
			// If it was an open tag in the markup, than there must be
			// a close tag as well.
			if ((markupOpenTag != null) && markupOpenTag.isOpen() && !markupStream.atCloseTag())
			{
				// There must be a component in this discarded body
				markupStream.throwMarkupException(""Expected close tag for '"" + markupOpenTag
						+ ""' Possible attempt to embed component(s) '"" + markupStream.get()
						+ ""' in the body of this component which discards its body"");
			}
		}
	}","protected final void replaceComponentTagBody(final MarkupStream markupStream,
			final ComponentTag tag, final CharSequence body)
	{
		// The tag might have been changed from open-close to open. Hence
		// we'll need what was in the markup itself
		ComponentTag markupOpenTag = null;

		// If tag has a body
		if (tag.isOpen())
		{
			// Get what tag was in the markup; not what the user it might
			// have changed it to.
			markupStream.setCurrentIndex(markupStream.getCurrentIndex() - 1);
			markupOpenTag = markupStream.getTag();
			markupStream.next();

			// If it was an open tag in the markup as well, than ...
			if (markupOpenTag.isOpen())
			{
				// skip any raw markup in the body
				markupStream.skipRawMarkup();
			}
		}

		if (body != null)
		{
			// Write the new body
			getResponse().write(body);
		}

		// If we had an open tag (and not an openclose tag) and we found a
		// close tag, we're good
		if (tag.isOpen())
		{
			// If it was an open tag in the markup, than there must be
			// a close tag as well.
			if ((markupOpenTag != null) && markupOpenTag.isOpen() && !markupStream.atCloseTag())
			{
				// There must be a component in this discarded body
				markupStream.throwMarkupException(""Expected close tag for '"" + markupOpenTag
						+ ""' Possible attempt to embed component(s) '"" + markupStream.get()
						+ ""' in the body of this component which discards its body"");
			}
		}
	}",0,[0]
2101,bugs-dot-jar_WICKET-2961_3d8c9d75,"void setModelImpl(IModel<?> model)
	{
		if (getFlag(FLAG_MODEL_SET))
		{
			if (model != null)
			{
				data_set(0, model);
			}
			else
			{
				data_remove(0);
				setFlag(FLAG_MODEL_SET, false);
			}
		}
		else
		{
			if (model != null)
			{
				data_insert(0, model);
				setFlag(FLAG_MODEL_SET, true);
			}
		}
	}","void setModelImpl(IModel<?> model)
	{
		if (getFlag(FLAG_MODEL_SET))
		{
			if (model != null)
			{
				data_set(0, model);
			}
			else
			{
				data_remove(0);
				setFlag(FLAG_MODEL_SET, false);
			}
		}
		else
		{
			if (model != null)
			{
				data_insert(0, model);
				setFlag(FLAG_MODEL_SET, true);
			}
		}
	}",0,[0]
15620,bugs-dot-jar_WICKET-4494_35843c19,"public static boolean requiresCloseTag(final String name)
	{
		return doesNotRequireCloseTag.get(name.toLowerCase()) == null;
	}","public static boolean requiresCloseTag(final String name)
	{
		return doesNotRequireCloseTag.get(name.toLowerCase()) == null;
	}",0,[0]
13138,bugs-dot-jar_OAK-2434_8159fc21,"@Override
    public Cursor query(final IndexPlan plan, NodeState rootState) {
        final Filter filter = plan.getFilter();
        FullTextExpression ft = filter.getFullTextConstraint();
        Set<String> relPaths = getRelativePaths(ft);
        if (relPaths.size() > 1) {
            return new MultiLuceneIndex(filter, rootState, relPaths).query();
        }

        final String parent = relPaths.size() == 0 ? """" : relPaths.iterator().next();
        // we only restrict non-full-text conditions if there is
        // no relative property in the full-text constraint
        final boolean nonFullTextConstraints = parent.isEmpty();
        final int parentDepth = getDepth(parent);
        QueryEngineSettings settings = filter.getQueryEngineSettings();
        Iterator<LuceneResultRow> itr = new AbstractIterator<LuceneResultRow>() {
            private final Deque<LuceneResultRow> queue = Queues.newArrayDeque();
            private final Set<String> seenPaths = Sets.newHashSet();
            private ScoreDoc lastDoc;
            private int nextBatchSize = LUCENE_QUERY_BATCH_SIZE;

            @Override
            protected LuceneResultRow computeNext() {
                while (!queue.isEmpty() || loadDocs()) {
                    return queue.remove();
                }
                return endOfData();
            }

            private LuceneResultRow convertToRow(ScoreDoc doc, IndexSearcher searcher) throws IOException {
                IndexReader reader = searcher.getIndexReader();
                PathStoredFieldVisitor visitor = new PathStoredFieldVisitor();
                reader.document(doc.doc, visitor);
                String path = visitor.getPath();
                if (path != null) {
                    if ("""".equals(path)) {
                        path = ""/"";
                    }
                    if (!parent.isEmpty()) {
                        // TODO OAK-828 this breaks node aggregation
                        // get the base path
                        // ensure the path ends with the given
                        // relative path
                        // if (!path.endsWith(""/"" + parent)) {
                        // continue;
                        // }
                        path = getAncestorPath(path, parentDepth);
                        // avoid duplicate entries
                        if (seenPaths.contains(path)) {
                            return null;
                        }
                        seenPaths.add(path);
                    }

                    return new LuceneResultRow(path, doc.score);
                }
                return null;
            }

            /**
             * Loads the lucene documents in batches
             * @return true if any document is loaded
             */
            private boolean loadDocs() {
                ScoreDoc lastDocToRecord = null;

                IndexNode indexNode = tracker.acquireIndexNode((String) plan.getAttribute(ATTR_INDEX_PATH));
                checkState(indexNode != null);
                try {
                    IndexSearcher searcher = indexNode.getSearcher();
                    Query query = getQuery(filter, searcher.getIndexReader(),
                            nonFullTextConstraints, indexNode.getDefinition());
                    TopDocs docs;
                    long time = System.currentTimeMillis();
                    if (lastDoc != null) {
                        LOG.debug(""loading the next {} entries for query {}"", nextBatchSize, query);
                        docs = searcher.searchAfter(lastDoc, query, nextBatchSize);
                    } else {
                        LOG.debug(""loading the first {} entries for query {}"", nextBatchSize, query);
                        docs = searcher.search(query, nextBatchSize);
                    }
                    time = System.currentTimeMillis() - time;
                    LOG.debug(""... took {} ms"", time);
                    nextBatchSize = (int) Math.min(nextBatchSize * 2L, 100000);

                    for (ScoreDoc doc : docs.scoreDocs) {
                        LuceneResultRow row = convertToRow(doc, searcher);
                        if(row != null) {
                            queue.add(row);
                        }
                        lastDocToRecord = doc;
                    }
                } catch (IOException e) {
                    LOG.warn(""query via {} failed."", LuceneIndex.this, e);
                } finally {
                    indexNode.release();
                }

                if (lastDocToRecord != null) {
                    this.lastDoc = lastDocToRecord;
                }

                return !queue.isEmpty();
            }
        };
        return new LucenePathCursor(itr, settings);
    }","@Override
    public Cursor query(final IndexPlan plan, NodeState rootState) {
        final Filter filter = plan.getFilter();
        FullTextExpression ft = filter.getFullTextConstraint();
        Set<String> relPaths = getRelativePaths(ft);
        if (relPaths.size() > 1) {
            return new MultiLuceneIndex(filter, rootState, relPaths).query();
        }

        final String parent = relPaths.size() == 0 ? """" : relPaths.iterator().next();
        // we only restrict non-full-text conditions if there is
        // no relative property in the full-text constraint
        final boolean nonFullTextConstraints = parent.isEmpty();
        final int parentDepth = getDepth(parent);
        QueryEngineSettings settings = filter.getQueryEngineSettings();
        Iterator<LuceneResultRow> itr = new AbstractIterator<LuceneResultRow>() {
            private final Deque<LuceneResultRow> queue = Queues.newArrayDeque();
            private final Set<String> seenPaths = Sets.newHashSet();
            private ScoreDoc lastDoc;
            private int nextBatchSize = LUCENE_QUERY_BATCH_SIZE;

            @Override
            protected LuceneResultRow computeNext() {
                while (!queue.isEmpty() || loadDocs()) {
                    return queue.remove();
                }
                return endOfData();
            }

            private LuceneResultRow convertToRow(ScoreDoc doc, IndexSearcher searcher) throws IOException {
                IndexReader reader = searcher.getIndexReader();
                PathStoredFieldVisitor visitor = new PathStoredFieldVisitor();
                reader.document(doc.doc, visitor);
                String path = visitor.getPath();
                if (path != null) {
                    if ("""".equals(path)) {
                        path = ""/"";
                    }
                    if (!parent.isEmpty()) {
                        // TODO OAK-828 this breaks node aggregation
                        // get the base path
                        // ensure the path ends with the given
                        // relative path
                        // if (!path.endsWith(""/"" + parent)) {
                        // continue;
                        // }
                        path = getAncestorPath(path, parentDepth);
                        // avoid duplicate entries
                        if (seenPaths.contains(path)) {
                            return null;
                        }
                        seenPaths.add(path);
                    }

                    return new LuceneResultRow(path, doc.score);
                }
                return null;
            }

            /**
             * Loads the lucene documents in batches
             * @return true if any document is loaded
             */
            private boolean loadDocs() {
                ScoreDoc lastDocToRecord = null;

                IndexNode indexNode = tracker.acquireIndexNode((String) plan.getAttribute(ATTR_INDEX_PATH));
                checkState(indexNode != null);
                try {
                    IndexSearcher searcher = indexNode.getSearcher();
                    Query query = getQuery(filter, searcher.getIndexReader(),
                            nonFullTextConstraints, indexNode.getDefinition());
                    TopDocs docs;
                    long time = System.currentTimeMillis();
                    if (lastDoc != null) {
                        LOG.debug(""loading the next {} entries for query {}"", nextBatchSize, query);
                        docs = searcher.searchAfter(lastDoc, query, nextBatchSize);
                    } else {
                        LOG.debug(""loading the first {} entries for query {}"", nextBatchSize, query);
                        docs = searcher.search(query, nextBatchSize);
                    }
                    time = System.currentTimeMillis() - time;
                    LOG.debug(""... took {} ms"", time);
                    nextBatchSize = (int) Math.min(nextBatchSize * 2L, 100000);

                    for (ScoreDoc doc : docs.scoreDocs) {
                        LuceneResultRow row = convertToRow(doc, searcher);
                        if(row != null) {
                            queue.add(row);
                        }
                        lastDocToRecord = doc;
                    }
                } catch (IOException e) {
                    LOG.warn(""query via {} failed."", LuceneIndex.this, e);
                } finally {
                    indexNode.release();
                }

                if (lastDocToRecord != null) {
                    this.lastDoc = lastDocToRecord;
                }

                return !queue.isEmpty();
            }
        };
        return new LucenePathCursor(itr, settings);
    }",0,[0]
692,bugs-dot-jar_MATH-320_b2f3f6db,"public RealMatrix getU()
        throws InvalidMatrixException {

        if (cachedU == null) {

            final int p = singularValues.length;
            if (m >= n) {
                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                final double[][] eData = e.getData();
                final double[][] wData = new double[m][p];
                double[] ei1 = eData[0];
                for (int i = 0; i < p - 1; ++i) {
                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                    final double mi = mainBidiagonal[i];
                    final double si = secondaryBidiagonal[i];
                    final double[] ei0 = ei1;
                    final double[] wi  = wData[i];
                    ei1 = eData[i + 1];
                    for (int j = 0; j < p; ++j) {
                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                    }
                }
                // last row
                final double lastMain = mainBidiagonal[p - 1];
                final double[] wr1  = wData[p - 1];
                for (int j = 0; j < p; ++j) {
                    wr1[j] = ei1[j] * lastMain / singularValues[j];
                }
                for (int i = p; i < m; ++i) {
                    wData[i] = new double[p];
                }
                cachedU =
                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
            } else {
                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                cachedU = transformer.getU().multiply(e);
            }

        }

        // return the cached matrix
        return cachedU;

    }","public RealMatrix getU()
        throws InvalidMatrixException {

        if (cachedU == null) {

            final int p = singularValues.length;
            if (m >= n) {
                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                final double[][] eData = e.getData();
                final double[][] wData = new double[m][p];
                double[] ei1 = eData[0];
                for (int i = 0; i < p; ++i) {
                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                    final double mi = mainBidiagonal[i];
                    final double[] ei0 = ei1;
                    final double[] wi  = wData[i];
                    if (i < n - 1) {
                        ei1 = eData[i + 1];
                        final double si = secondaryBidiagonal[i];
                        for (int j = 0; j < p; ++j) {
                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                        }
                    } else {
                        for (int j = 0; j < p; ++j) {
                            wi[j] = mi * ei0[j] / singularValues[j];
                        }
                    }
                }

                for (int i = p; i < m; ++i) {
                    wData[i] = new double[p];
                }
                cachedU =
                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
            } else {
                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                cachedU = transformer.getU().multiply(e);
            }

        }

        // return the cached matrix
        return cachedU;

    }",1,"[9, 13, 16, 19, 20, 21, 24, 25, 26, 27, 28, 29]"
2330,bugs-dot-jar_MNG-4918_691a03a7,"@Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( 128 );
        sb.append( ""MavenProject: "" );
        sb.append( getGroupId() );
        sb.append( "":"" );
        sb.append( getArtifactId() );
        sb.append( "":"" );
        sb.append( getVersion() );
        sb.append( "" @ "" );

        try
        {
            sb.append( getFile().getPath() );
        }
        catch ( NullPointerException e )
        {
            //don't log it.
        }

        return sb.toString();
    }","@Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder( 128 );
        sb.append( ""MavenProject: "" );
        sb.append( getGroupId() );
        sb.append( "":"" );
        sb.append( getArtifactId() );
        sb.append( "":"" );
        sb.append( getVersion() );
        sb.append( "" @ "" );

        try
        {
            sb.append( getFile().getPath() );
        }
        catch ( NullPointerException e )
        {
            //don't log it.
        }

        return sb.toString();
    }",0,[0]
20784,bugs-dot-jar_CAMEL-5215_033eb6fe,"public boolean existsFile(String name) throws GenericFileOperationFailedException {
        File file = new File(name);
        return file.exists();
    }","public boolean existsFile(String name) throws GenericFileOperationFailedException {
        File file = new File(name);
        return file.exists();
    }",0,[0]
24044,bugs-dot-jar_OAK-579_7d72e6ed,"public SameNodeJoinConditionImpl(String selector1Name, String selector2Name,
            String selector2Path) {
        this.selector1Name = selector1Name;
        this.selector2Name = selector2Name;
        this.selector2Path = selector2Path;
    }","public SameNodeJoinConditionImpl(String selector1Name, String selector2Name,
            String selector2Path) {
        this.selector1Name = selector1Name;
        this.selector2Name = selector2Name;
        this.selector2Path = selector2Path;
    }",0,[0]
17025,bugs-dot-jar_OAK-766_6fc5ea9d,"private void applyPendingMoves() {
        if (parent != null) {
            parent.applyPendingMoves();
        }

        pendingMoves = pendingMoves.apply(this);
    }","private void applyPendingMoves() {
        if (parent != null) {
            parent.applyPendingMoves();
        }

        pendingMoves = pendingMoves.apply(this);
    }",0,[0]
35559,bugs-dot-jar_OAK-621_00b4b8a0,"private boolean isDisconnected() {
        if (isRoot()) {
            return false;
        }
        if (parent.nodeBuilder == null) {
            return false;
        }
        if (!parent.nodeBuilder.isConnected()) {
            return true;
        }
        return !getNodeBuilder().isConnected();
    }","private boolean isDisconnected() {
        if (isRoot()) {
            return false;
        }
        if (parent.nodeBuilder == null) {
            return false;
        }
        if (!parent.nodeBuilder.isConnected()) {
            return true;
        }
        return !nodeBuilder.isConnected();
    }",1,[10]
15388,bugs-dot-jar_MNG-1895_806eaeb0,"public boolean isActive()
    {
        return active;
    }","public boolean isActive()
    {
        return active;
    }",0,[0]
140,bugs-dot-jar_OAK-1822_3e83a4c1,"@Nonnull
    private static DBObject createUpdate(UpdateOp updateOp) {
        BasicDBObject setUpdates = new BasicDBObject();
        BasicDBObject incUpdates = new BasicDBObject();
        BasicDBObject unsetUpdates = new BasicDBObject();

        // always increment modCount
        updateOp.increment(Document.MOD_COUNT, 1);

        // other updates
        for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {
            Key k = entry.getKey();
            if (k.getName().equals(Document.ID)) {
                // avoid exception ""Mod on _id not allowed""
                continue;
            }
            Operation op = entry.getValue();
            switch (op.type) {
                case SET: {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
                case INCREMENT: {
                    incUpdates.append(k.toString(), op.value);
                    break;
                }
                case SET_MAP_ENTRY: {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
                case REMOVE_MAP_ENTRY: {
                    unsetUpdates.append(k.toString(), ""1"");
                    break;
                }
            }
        }

        BasicDBObject update = new BasicDBObject();
        if (!setUpdates.isEmpty()) {
            update.append(""$set"", setUpdates);
        }
        if (!incUpdates.isEmpty()) {
            update.append(""$inc"", incUpdates);
        }
        if (!unsetUpdates.isEmpty()) {
            update.append(""$unset"", unsetUpdates);
        }

        return update;
    }","@Nonnull
    private static DBObject createUpdate(UpdateOp updateOp) {
        BasicDBObject setUpdates = new BasicDBObject();
        BasicDBObject maxUpdates = new BasicDBObject();
        BasicDBObject incUpdates = new BasicDBObject();
        BasicDBObject unsetUpdates = new BasicDBObject();

        // always increment modCount
        updateOp.increment(Document.MOD_COUNT, 1);

        // other updates
        for (Entry<Key, Operation> entry : updateOp.getChanges().entrySet()) {
            Key k = entry.getKey();
            if (k.getName().equals(Document.ID)) {
                // avoid exception ""Mod on _id not allowed""
                continue;
            }
            Operation op = entry.getValue();
            switch (op.type) {
                case SET:
                case SET_MAP_ENTRY: {
                    setUpdates.append(k.toString(), op.value);
                    break;
                }
                case MAX: {
                    maxUpdates.append(k.toString(), op.value);
                    break;
                }
                case INCREMENT: {
                    incUpdates.append(k.toString(), op.value);
                    break;
                }
                case REMOVE_MAP_ENTRY: {
                    unsetUpdates.append(k.toString(), ""1"");
                    break;
                }
            }
        }

        BasicDBObject update = new BasicDBObject();
        if (!setUpdates.isEmpty()) {
            update.append(""$set"", setUpdates);
        }
        if (!maxUpdates.isEmpty()) {
            update.append(""$max"", maxUpdates);
        }
        if (!incUpdates.isEmpty()) {
            update.append(""$inc"", incUpdates);
        }
        if (!unsetUpdates.isEmpty()) {
            update.append(""$unset"", unsetUpdates);
        }

        return update;
    }",1,"[18, 22, 23, 26, 27]"
1988,Bears-241,"private boolean contentIsSame(String decodedOriginalContent, String newContent) {
        return newContent != null && newContent.equals(decodedOriginalContent);
    }","private boolean contentIsSame(String decodedOriginalContent, String newContent) {
        return newContent != null && newContent.equals(decodedOriginalContent);
    }",0,[0]
1621,bugs-dot-jar_WICKET-5345_3fc7234e,"private boolean isLastSegmentEmpty()
	{
		return isLastSegmentEmpty(segments);
	}","private boolean isLastSegmentEmpty()
	{
		return isLastSegmentEmpty(segments);
	}",0,[0]
37410,bugs-dot-jar_CAMEL-4482_e38494f1,"protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors, errorHandlers);
        errorHandlers.clear();
    }","protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors, errorHandlers);
        errorHandlers.clear();
    }",0,[0]
24117,bugs-dot-jar_FLINK-3513_d90672fd,"private Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes() {
		// The hash function used to generate the hash
		final HashFunction hashFunction = Hashing.murmur3_128(0);
		final Map<Integer, byte[]> hashes = new HashMap<>();

		Set<Integer> visited = new HashSet<>();
		Queue<StreamNode> remaining = new ArrayDeque<>();

		// We need to make the source order deterministic. The source IDs are
		// not returned in the same order, which means that submitting the same
		// program twice might result in different traversal, which breaks the
		// deterministic hash assignment.
		List<Integer> sources = new ArrayList<>();
		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {
			sources.add(sourceNodeId);
		}
		Collections.sort(sources);

		//
		// Traverse the graph in a breadth-first manner. Keep in mind that
		// the graph is not a tree and multiple paths to nodes can exist.
		//

		// Start with source nodes
		for (Integer sourceNodeId : sources) {
			remaining.add(streamGraph.getStreamNode(sourceNodeId));
			visited.add(sourceNodeId);
		}

		StreamNode currentNode;
		while ((currentNode = remaining.poll()) != null) {
			// Generate the hash code. Because multiple path exist to each
			// node, we might not have all required inputs available to
			// generate the hash code.
			if (generateNodeHash(currentNode, hashFunction, hashes)) {
				// Add the child nodes
				for (StreamEdge outEdge : currentNode.getOutEdges()) {
					StreamNode child = outEdge.getTargetVertex();

					if (!visited.contains(child.getId())) {
						remaining.add(child);
						visited.add(child.getId());
					}
				}
			}
			else {
				// We will revisit this later.
				visited.remove(currentNode.getId());
			}
		}

		return hashes;
	}","private Map<Integer, byte[]> traverseStreamGraphAndGenerateHashes() {
		// The hash function used to generate the hash
		final HashFunction hashFunction = Hashing.murmur3_128(0);
		final Map<Integer, byte[]> hashes = new HashMap<>();

		Set<Integer> visited = new HashSet<>();
		Queue<StreamNode> remaining = new ArrayDeque<>();

		// We need to make the source order deterministic. The source IDs are
		// not returned in the same order, which means that submitting the same
		// program twice might result in different traversal, which breaks the
		// deterministic hash assignment.
		List<Integer> sources = new ArrayList<>();
		for (Integer sourceNodeId : streamGraph.getSourceIDs()) {
			sources.add(sourceNodeId);
		}
		Collections.sort(sources);

		//
		// Traverse the graph in a breadth-first manner. Keep in mind that
		// the graph is not a tree and multiple paths to nodes can exist.
		//

		// Start with source nodes
		for (Integer sourceNodeId : sources) {
			remaining.add(streamGraph.getStreamNode(sourceNodeId));
			visited.add(sourceNodeId);
		}

		StreamNode currentNode;
		while ((currentNode = remaining.poll()) != null) {
			// Generate the hash code. Because multiple path exist to each
			// node, we might not have all required inputs available to
			// generate the hash code.
			if (generateNodeHash(currentNode, hashFunction, hashes)) {
				// Add the child nodes
				for (StreamEdge outEdge : currentNode.getOutEdges()) {
					StreamNode child = outEdge.getTargetVertex();

					if (!visited.contains(child.getId())) {
						remaining.add(child);
						visited.add(child.getId());
					}
				}
			}
			else {
				// We will revisit this later.
				visited.remove(currentNode.getId());
			}
		}

		return hashes;
	}",0,[0]
4917,bugs-dot-jar_OAK-1467_dde7de85,"public void applyToCache(Revision before, boolean isBranchCommit) {
        HashMap<String, ArrayList<String>> nodesWithChangedChildren = new HashMap<String, ArrayList<String>>();
        for (String p : modifiedNodes) {
            if (PathUtils.denotesRoot(p)) {
                continue;
            }
            String parent = PathUtils.getParentPath(p);
            ArrayList<String> list = nodesWithChangedChildren.get(parent);
            if (list == null) {
                list = new ArrayList<String>();
                nodesWithChangedChildren.put(parent, list);
            }
            list.add(p);
        }
        List<String> added = new ArrayList<String>();
        List<String> removed = new ArrayList<String>();
        List<String> changed = new ArrayList<String>();
        for (String path : modifiedNodes) {
            added.clear();
            removed.clear();
            changed.clear();
            ArrayList<String> changes = nodesWithChangedChildren.get(path);
            if (changes != null) {
                for (String s : changes) {
                    if (addedNodes.contains(s)) {
                        added.add(s);
                    } else if (removedNodes.contains(s)) {
                        removed.add(s);
                    } else {
                        changed.add(s);
                    }
                }
            }
            UpdateOp op = operations.get(path);
            boolean isNew = op != null && op.isNew();
            boolean pendingLastRev = op == null
                    || !NodeDocument.hasLastRev(op, revision.getClusterId());
            boolean isDelete = op != null && op.isDelete();
            nodeStore.applyChanges(revision, before, path, isNew, isDelete,
                    pendingLastRev, isBranchCommit, added, removed, changed);
        }
    }","public void applyToCache(Revision before, boolean isBranchCommit) {
        HashMap<String, ArrayList<String>> nodesWithChangedChildren = new HashMap<String, ArrayList<String>>();
        for (String p : modifiedNodes) {
            if (PathUtils.denotesRoot(p)) {
                continue;
            }
            String parent = PathUtils.getParentPath(p);
            ArrayList<String> list = nodesWithChangedChildren.get(parent);
            if (list == null) {
                list = new ArrayList<String>();
                nodesWithChangedChildren.put(parent, list);
            }
            list.add(p);
        }
        List<String> added = new ArrayList<String>();
        List<String> removed = new ArrayList<String>();
        List<String> changed = new ArrayList<String>();
        for (String path : modifiedNodes) {
            added.clear();
            removed.clear();
            changed.clear();
            ArrayList<String> changes = nodesWithChangedChildren.get(path);
            if (changes != null) {
                for (String s : changes) {
                    if (addedNodes.contains(s)) {
                        added.add(s);
                    } else if (removedNodes.contains(s)) {
                        removed.add(s);
                    } else {
                        changed.add(s);
                    }
                }
            }
            UpdateOp op = operations.get(path);
            boolean isNew = op != null && op.isNew();
            boolean pendingLastRev = op == null
                    || !NodeDocument.hasLastRev(op, revision.getClusterId());
            boolean isDelete = op != null && op.isDelete();
            nodeStore.applyChanges(revision, before, path, isNew, isDelete,
                    pendingLastRev, isBranchCommit, added, removed, changed);
        }
    }",0,[0]
18863,bugs-dot-jar_OAK-1749_591e4d4a,"private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder,
            String name) {
        String now = now();
        builder.getChildNode(INDEX_DEFINITIONS_NAME)
                .setProperty(name + ""-status"", STATUS_DONE)
                .setProperty(name + ""-done"", now, Type.DATE)
                .removeProperty(name + ""-start"");
        return builder;
    }","private static NodeBuilder postAsyncRunNodeStatus(NodeBuilder builder,
            String name) {
        String now = now();
        builder.getChildNode(INDEX_DEFINITIONS_NAME)
                .setProperty(name + ""-status"", STATUS_DONE)
                .setProperty(name + ""-done"", now, Type.DATE)
                .removeProperty(name + ""-start"");
        return builder;
    }",0,[0]
2514,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static Expression regexTokenizeExpression(final Expression expression,
                                                     final String regexTokenizer) {
        final Pattern pattern = Pattern.compile(regexTokenizer);
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                Object value = expression.evaluate(exchange, Object.class);
                Scanner scanner = ObjectHelper.getScanner(exchange, value);
                scanner.useDelimiter(regexTokenizer);
                return scanner;
            }

            @Override
            public String toString() {
                return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }","public static Expression regexTokenizeExpression(final Expression expression,
                                                     final String regexTokenizer) {
        final Pattern pattern = Pattern.compile(regexTokenizer);
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                Object value = expression.evaluate(exchange, Object.class);
                Scanner scanner = ObjectHelper.getScanner(exchange, value);
                scanner.useDelimiter(regexTokenizer);
                return scanner;
            }

            @Override
            public String toString() {
                return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }",0,[0]
13852,bugs-dot-jar_CAMEL-4011_cbffff59,"@Converter
    public static String toString(Integer value) {
        return value.toString();
    }","@Converter
    public static String toString(Integer value) {
        return value.toString();
    }",0,[0]
9823,bugs-dot-jar_OAK-3634_90ad50da,"long getLockAcquisitionCount() {
        return nodeLocks.getLockAcquisitionCount();
    }","long getLockAcquisitionCount() {
        return nodeLocks.getLockAcquisitionCount();
    }",0,[0]
169,Bears-6,"@Override
    public boolean isTypeId() {
        Boolean b = fromMemberAnnotations(new WithMember<Boolean>() {
            @Override
            public Boolean withMember(AnnotatedMember member) {
                return _annotationIntrospector.isTypeId(member);
            }
        });
        return (b != null) && b.booleanValue();
    }","@Override
    public boolean isTypeId() {
        Boolean b = fromMemberAnnotations(new WithMember<Boolean>() {
            @Override
            public Boolean withMember(AnnotatedMember member) {
                return _annotationIntrospector.isTypeId(member);
            }
        });
        return (b != null) && b.booleanValue();
    }",0,[0]
35597,bugs-dot-jar_WICKET-5486_a79ed51e,"protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl,
		Url targetUrl)
	{
		// WICKET-5484 never render and write for Ajax requests
		if (isAjax(cycle))
		{
			return false;
		}

		return neverRedirect(getRedirectPolicy())
			|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl
				.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),
				isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())
			|| shouldPreserveClientUrl(cycle);
	}","protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl,
		Url targetUrl)
	{
		// WICKET-5484 never render and write for Ajax requests
		if (isAjax(cycle))
		{
			return false;
		}

		return neverRedirect(getRedirectPolicy())
			|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl
				.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),
				isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())
			|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));
	}",1,[13]
39840,bugs-dot-jar_WICKET-4686_89184b79,"protected IRequestHandler processHybrid(PageInfo pageInfo,
		Class<? extends IRequestablePage> pageClass, PageParameters pageParameters,
		Integer renderCount)
	{
		PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,
			renderCount);
		provider.setPageSource(getContext());
		if (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry())
		{
			throw new PageExpiredException(String.format(""Bookmarkable page id '%d' has expired."",
				pageInfo.getPageId()));
		}
		else
		{
			return new RenderPageRequestHandler(provider);
		}
	}","protected IRequestHandler processHybrid(PageInfo pageInfo,
		Class<? extends IRequestablePage> pageClass, PageParameters pageParameters,
		Integer renderCount)
	{
		PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,
			renderCount);
		provider.setPageSource(getContext());
		if (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry())
		{
			throw new PageExpiredException(String.format(""Bookmarkable page id '%d' has expired."",
				pageInfo.getPageId()));
		}
		else
		{
			return new RenderPageRequestHandler(provider);
		}
	}",0,[0]
8663,bugs-dot-jar_OAK-2246_dcadb0e1,"public ImporterImpl(String absPath,
                        SessionContext sessionContext,
                        Root root,
                        int uuidBehavior,
                        boolean isWorkspaceImport) throws RepositoryException {
        String oakPath = sessionContext.getOakPath(absPath);
        if (oakPath == null) {
            throw new RepositoryException(""Invalid name or path: "" + absPath);
        }
        if (!PathUtils.isAbsolute(oakPath)) {
            throw new RepositoryException(""Not an absolute path: "" + absPath);
        }

        SessionDelegate sd = sessionContext.getSessionDelegate();
        if (isWorkspaceImport && sd.hasPendingChanges()) {
            throw new RepositoryException(""Pending changes on session. Cannot run workspace import."");
        }

        this.uuidBehavior = uuidBehavior;
        userID = sd.getAuthInfo().getUserID();

        importTargetTree = root.getTree(oakPath);
        if (!importTargetTree.exists()) {
            throw new PathNotFoundException(absPath);
        }

        WorkspaceImpl wsp = sessionContext.getWorkspace();
        VersionManager vMgr = wsp.getVersionManager();
        if (!vMgr.isCheckedOut(absPath)) {
            throw new VersionException(""Target node is checked in."");
        }
        if (importTargetTree.getStatus() != Tree.Status.NEW && wsp.getLockManager().isLocked(absPath)) {
            throw new LockException(""Target node is locked."");
        }
        effectiveNodeTypeProvider = wsp.getNodeTypeManager();
        definitionProvider = wsp.getNodeTypeManager();
        ntTypesRoot = root.getTree(NODE_TYPES_PATH);

        accessManager = sessionContext.getAccessManager();

        currentStateIdManager = new IdentifierManager(root);
        baseStateIdManager = new IdentifierManager(sd.getContentSession().getLatestRoot());

        refTracker = new ReferenceChangeTracker();

        parents = new Stack<Tree>();
        parents.push(importTargetTree);

        pItemImporters.clear();
        for (ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {
            // FIXME this passes the session scoped name path mapper also for workspace imports
            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {
                pItemImporters.add(importer);
            }
        }
    }","public ImporterImpl(String absPath,
                        SessionContext sessionContext,
                        Root root,
                        int uuidBehavior,
                        boolean isWorkspaceImport) throws RepositoryException {
        String oakPath = sessionContext.getOakPath(absPath);
        if (oakPath == null) {
            throw new RepositoryException(""Invalid name or path: "" + absPath);
        }
        if (!PathUtils.isAbsolute(oakPath)) {
            throw new RepositoryException(""Not an absolute path: "" + absPath);
        }

        SessionDelegate sd = sessionContext.getSessionDelegate();
        if (isWorkspaceImport && sd.hasPendingChanges()) {
            throw new RepositoryException(""Pending changes on session. Cannot run workspace import."");
        }

        this.uuidBehavior = uuidBehavior;
        userID = sd.getAuthInfo().getUserID();

        importTargetTree = root.getTree(oakPath);
        if (!importTargetTree.exists()) {
            throw new PathNotFoundException(absPath);
        }

        WorkspaceImpl wsp = sessionContext.getWorkspace();
        VersionManager vMgr = wsp.getVersionManager();
        if (!vMgr.isCheckedOut(absPath)) {
            throw new VersionException(""Target node is checked in."");
        }
        if (importTargetTree.getStatus() != Tree.Status.NEW && wsp.getLockManager().isLocked(absPath)) {
            throw new LockException(""Target node is locked."");
        }
        effectiveNodeTypeProvider = wsp.getNodeTypeManager();
        definitionProvider = wsp.getNodeTypeManager();
        ntTypesRoot = root.getTree(NODE_TYPES_PATH);

        accessManager = sessionContext.getAccessManager();

        idLookup = new IdResolver(root, sd.getContentSession());

        refTracker = new ReferenceChangeTracker();

        parents = new Stack<Tree>();
        parents.push(importTargetTree);

        pItemImporters.clear();
        for (ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {
            // FIXME this passes the session scoped name path mapper also for workspace imports
            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {
                pItemImporters.add(importer);
            }
        }
    }",1,"[40, 41]"
148,Bears-6,"@Override
    public boolean isExplicitlyIncluded() {
        return _anyExplicits(_fields)
                || _anyExplicits(_getters)
                || _anyExplicits(_setters)
                // 16-Jan-2016, tatu: Creator names are special, in that name should exist too;
                //   reason for this is [databind#1317]. Let's hope this works well, may need
                //   to tweak further if this lowers visibility
//                || _anyExplicits(_ctorParameters)
                || _anyExplicitNames(_ctorParameters)
                ;
    }","@Override
    public boolean isExplicitlyIncluded() {
        return _anyExplicits(_fields)
                || _anyExplicits(_getters)
                || _anyExplicits(_setters)
                // 16-Jan-2016, tatu: Creator names are special, in that name should exist too;
                //   reason for this is [databind#1317]. Let's hope this works well, may need
                //   to tweak further if this lowers visibility
//                || _anyExplicits(_ctorParameters)
                || _anyExplicitNames(_ctorParameters)
                ;
    }",0,[0]
20889,bugs-dot-jar_WICKET-5734_71674df5,"public AbstractBookmarkableMapper()
	{
		this(""notUsed"", new PageParametersEncoder());
	}","public AbstractBookmarkableMapper()
	{
		this(""notUsed"", new PageParametersEncoder());
	}",0,[0]
4743,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapSinhToSelf() {
        for (int i = 0; i < data.length; i++) {
            data[i] = Math.sinh(data[i]);
        }
        return this;
    }","public RealVector mapSinhToSelf() {
        for (int i = 0; i < data.length; i++) {
            data[i] = Math.sinh(data[i]);
        }
        return this;
    }",0,[0]
14184,bugs-dot-jar_WICKET-2900_0e70ce39,"@Override
	public int hashCode()
	{
		int hashcode = beanTypeName.hashCode();
		if (getBeanName() != null)
		{
			hashcode = hashcode + (127 * beanName.hashCode());
		}
		return hashcode;
	}","@Override
	public int hashCode()
	{
		int hashcode = beanTypeName.hashCode();
		if (getBeanName() != null)
		{
			hashcode = hashcode + (127 * beanName.hashCode());
		}
		return hashcode;
	}",0,[0]
8054,bugs-dot-jar_OAK-1655_c91bfa54,"@Override
    public DataRecord getRecord(DataIdentifier identifier) throws DataStoreException {
        if(isInMemoryRecord(identifier)){
            return getDataRecord(identifier.toString());
        }
        return delegate.getRecord(identifier);
    }","@Override
    public DataRecord getRecord(DataIdentifier identifier) throws DataStoreException {
        if(isInMemoryRecord(identifier)){
            return getDataRecord(identifier.toString());
        }
        return delegate.getRecord(identifier);
    }",0,[0]
9724,bugs-dot-jar_OAK-614_6feacf6b,"@Override @Nonnull
    public NodeBuilder removeProperty(String name) {
        write();

        if (writeState.base.getProperty(name) != null) {
            writeState.properties.put(name, null);
        } else {
            writeState.properties.remove(name);
        }

        updated();
        return this;
    }","@Override @Nonnull
    public NodeBuilder removeProperty(String name) {
        write();

        if (writeState.base.getProperty(name) != null) {
            writeState.properties.put(name, null);
        } else {
            writeState.properties.remove(name);
        }

        updated();
        return this;
    }",0,[0]
8520,bugs-dot-jar_FLINK-2442_30761572,"public abstract <E> void validateCustomPartitioner(Partitioner<E> partitioner, TypeInformation<E> typeInfo);","public abstract <E> void validateCustomPartitioner(Partitioner<E> partitioner, TypeInformation<E> typeInfo);",0,[0]
1866,Bears-211,"public SmileFactory enable(SmileGenerator.Feature f) {
        _smileGeneratorFeatures |= f.getMask();
        return this;
    }","public SmileFactory enable(SmileGenerator.Feature f) {
        _smileGeneratorFeatures |= f.getMask();
        return this;
    }",0,[0]
17432,bugs-dot-jar_MATH-1045_a4ffd393,"public double getRealEigenvalue(final int i) {
        return realEigenvalues[i];
    }","public double getRealEigenvalue(final int i) {
        return realEigenvalues[i];
    }",0,[0]
1640,Bears-194,"private void addMethodParamsToTaintedVariables(Node node) {
		this.functionParameterTypes = new HashMap<String, Class<?>>();
		this.functionParameterTainted = new HashSet<String>();
		ASTFormalParameters formalParameters = null;
		if (node == null) {
			return;
		}
			
		if (node.getClass() == ASTMethodDeclaration.class) {
			ASTMethodDeclarator declarator = node.getFirstChildOfType(ASTMethodDeclarator.class);
			formalParameters = declarator.getFirstChildOfType(ASTFormalParameters.class);
		} else if (node.getClass() == ASTConstructorDeclaration.class) {
			formalParameters = node.getFirstChildOfType(ASTFormalParameters.class);
		}
		if (formalParameters == null) {
			return;
		}
		List<ASTFormalParameter> parameters = formalParameters.findChildrenOfType(ASTFormalParameter.class);
		for (ASTFormalParameter parameter : parameters) {
			ASTType type = parameter.getTypeNode();
			ASTVariableDeclaratorId name1 = parameter.getFirstChildOfType(ASTVariableDeclaratorId.class);
			String name = name1.getImage();
			if (name != null && type != null) {
				this.functionParameterTypes.put(name, type.getType());
			}
			if (name != null && isUnsafeType(type)) {
				this.functionParameterTainted.add(name);
			}
		}
	}","private void addMethodParamsToTaintedVariables(Node node) {
		this.functionParameterTypes = new HashMap<String, Class<?>>();
		this.functionParameterTainted = new HashSet<String>();
		ASTFormalParameters formalParameters = null;
		if (node == null) {
			return;
		}
			
		if (node.getClass() == ASTMethodDeclaration.class) {
			ASTMethodDeclarator declarator = node.getFirstChildOfType(ASTMethodDeclarator.class);
			formalParameters = declarator.getFirstChildOfType(ASTFormalParameters.class);
		} else if (node.getClass() == ASTConstructorDeclaration.class) {
			formalParameters = node.getFirstChildOfType(ASTFormalParameters.class);
		}
		if (formalParameters == null) {
			return;
		}
		List<ASTFormalParameter> parameters = formalParameters.findChildrenOfType(ASTFormalParameter.class);
		for (ASTFormalParameter parameter : parameters) {
			ASTType type = parameter.getTypeNode();
			ASTVariableDeclaratorId name1 = parameter.getFirstChildOfType(ASTVariableDeclaratorId.class);
			String name = name1.getImage();
			if (name != null && type != null) {
				this.functionParameterTypes.put(name, type.getType());
			}
			if (name != null && isUnsafeType(type)) {
				this.functionParameterTainted.add(name);
			}
		}
	}",0,[0]
8554,bugs-dot-jar_WICKET-3309_debca73b,"public final void nodeSelected(Object node)
	{
		if (isNodeVisible(node))
		{
			invalidateNode(node, isForceRebuildOnSelectionChange());
		}
	}","public final void nodeSelected(Object node)
	{
		if (isNodeVisible(node))
		{
			invalidateNode(node, isForceRebuildOnSelectionChange());
		}
	}",0,[0]
8496,bugs-dot-jar_ACCUMULO-366_db4a291f,"@Override
  public int getMajorCompactions() {
    if (this.isEnabled()) {
      int result = 0;
      for (Tablet tablet : Collections.unmodifiableCollection(onlineTablets.values())) {
        if (tablet.majorCompactionRunning())
          result++;
      }
      return result;
    }
    return 0;
  }","@Override
  public int getMajorCompactions() {
    if (this.isEnabled()) {
      int result = 0;
      for (Tablet tablet : Collections.unmodifiableCollection(onlineTablets.values())) {
        if (tablet.majorCompactionRunning())
          result++;
      }
      return result;
    }
    return 0;
  }",0,[0]
29275,bugs-dot-jar_CAMEL-7586_1f92fa42,"public boolean isShutdownNowOnTimeout() {
        return context.getShutdownStrategy().isShutdownNowOnTimeout();
    }","public boolean isShutdownNowOnTimeout() {
        return context.getShutdownStrategy().isShutdownNowOnTimeout();
    }",0,[0]
30957,bugs-dot-jar_LOG4J2-410_8f0c4871,"@Override
    public boolean isInfoEnabled(final Marker marker) {
        return logger.isInfoEnabled((org.apache.logging.log4j.Marker) marker);
    }","@Override
    public boolean isInfoEnabled(final Marker marker) {
        return logger.isInfoEnabled((org.apache.logging.log4j.Marker) marker);
    }",0,[0]
17128,bugs-dot-jar_MATH-949_f83bbc1d,"private static int[] inverse(final int[] indices) {
        final int[] inverse = new int[indices.length];
        for (int i = 0; i < indices.length; i++) {
            inverse[indices[i]] = i;
        }
        return inverse;
    }","private static int[] inverse(final int[] indices) {
        final int[] inverse = new int[indices.length];
        for (int i = 0; i < indices.length; i++) {
            inverse[indices[i]] = i;
        }
        return inverse;
    }",0,[0]
4122,bugs-dot-jar_OAK-3082_29e5b734,"private void setPrincipalBasedAcl(PrincipalACL principalAcl) throws RepositoryException {
        AccessControlPolicy[] plcs = getPolicies(principalAcl.principal);
        PrincipalACL existing = (plcs.length == 0) ? null : (PrincipalACL) plcs[0];

        List<ACE> toAdd = Lists.newArrayList(principalAcl.getEntries());
        List<ACE> toRemove = Collections.emptyList();
        if (existing != null) {
            toAdd.removeAll(existing.getEntries());
            toRemove = existing.getEntries();
            toRemove.removeAll(principalAcl.getEntries());
        }

        // add new entries
        for (ACE ace : toAdd) {
            String path = getNodePath(ace);
            Tree tree = getTree(path, Permissions.MODIFY_ACCESS_CONTROL, true);

            ACL acl = (ACL) createACL(path, tree, false);
            if (acl == null) {
                acl = new NodeACL(path);
            }

            Map<String, Value> restrictions = new HashMap<String, Value>();
            for (String name : ace.getRestrictionNames()) {
                if (!REP_NODE_PATH.equals(name)) {
                    restrictions.put(name, ace.getRestriction(name));
                }
            }
            acl.addEntry(ace.getPrincipal(), ace.getPrivileges(), ace.isAllow(), restrictions);
            setNodeBasedAcl(path, tree, acl);
        }

        // remove entries that are not longer present in the acl to write
        for (ACE ace : toRemove) {
            String path = getNodePath(ace);
            Tree tree = getTree(path, Permissions.MODIFY_ACCESS_CONTROL, true);

            ACL acl = (ACL) createACL(path, tree, false);
            if (acl != null) {
                acl.removeAccessControlEntry(ace);
                setNodeBasedAcl(path, tree, acl);
            } else {
                log.debug(""Missing ACL at {}; cannot remove entry {}"", path, ace);
            }
        }
    }","private void setPrincipalBasedAcl(PrincipalACL principalAcl) throws RepositoryException {
        AccessControlPolicy[] plcs = getPolicies(principalAcl.principal);
        PrincipalACL existing = (plcs.length == 0) ? null : (PrincipalACL) plcs[0];

        List<ACE> toAdd = Lists.newArrayList(principalAcl.getEntries());
        List<ACE> toRemove = Collections.emptyList();
        if (existing != null) {
            toAdd.removeAll(existing.getEntries());
            toRemove = existing.getEntries();
            toRemove.removeAll(principalAcl.getEntries());
        }

        // add new entries
        for (ACE ace : toAdd) {
            String path = getNodePath(ace);
            Tree tree = getTree(path, Permissions.MODIFY_ACCESS_CONTROL, true);

            ACL acl = (ACL) createACL(path, tree, false);
            if (acl == null) {
                acl = new NodeACL(path);
            }

            Map<String, Value> restrictions = new HashMap<String, Value>();
            for (String name : ace.getRestrictionNames()) {
                if (!REP_NODE_PATH.equals(name)) {
                    restrictions.put(name, ace.getRestriction(name));
                }
            }
            acl.addEntry(ace.getPrincipal(), ace.getPrivileges(), ace.isAllow(), restrictions);
            setNodeBasedAcl(path, tree, acl);
        }

        // remove entries that are not longer present in the acl to write
        for (ACE ace : toRemove) {
            String path = getNodePath(ace);
            Tree tree = getTree(path, Permissions.MODIFY_ACCESS_CONTROL, true);

            ACL acl = (ACL) createACL(path, tree, false);
            if (acl != null) {
                acl.removeAccessControlEntry(ace);
                setNodeBasedAcl(path, tree, acl);
            } else {
                log.debug(""Missing ACL at {}; cannot remove entry {}"", path, ace);
            }
        }
    }",0,[0]
983,bugs-dot-jar_LOG4J2-1067_4786a739,"public String getCauseStackTraceAsString() {
        return this.getCauseStackTraceAsString(null);
    }","public String getCauseStackTraceAsString() {
        return this.getCauseStackTraceAsString(null);
    }",0,[0]
15643,bugs-dot-jar_MATH-329_6dd3724b,"public void addValue(Comparable<?> v){
        Comparable<?> obj = v;
        if (v instanceof Integer) {
           obj = Long.valueOf(((Integer) v).longValue());
        }
        try {
            Long count = freqTable.get(obj);
            if (count == null) {
                freqTable.put(obj, Long.valueOf(1));
            } else {
                freqTable.put(obj, Long.valueOf(count.longValue() + 1));
            }
        } catch (ClassCastException ex) {
            //TreeMap will throw ClassCastException if v is not comparable
            throw MathRuntimeException.createIllegalArgumentException(
                  ""instance of class {0} not comparable to existing values"",
                  v.getClass().getName());
        }
    }","public void addValue(Comparable<?> v){
        Comparable<?> obj = v;
        if (v instanceof Integer) {
           obj = Long.valueOf(((Integer) v).longValue());
        }
        try {
            Long count = freqTable.get(obj);
            if (count == null) {
                freqTable.put(obj, Long.valueOf(1));
            } else {
                freqTable.put(obj, Long.valueOf(count.longValue() + 1));
            }
        } catch (ClassCastException ex) {
            //TreeMap will throw ClassCastException if v is not comparable
            throw MathRuntimeException.createIllegalArgumentException(
                  ""instance of class {0} not comparable to existing values"",
                  v.getClass().getName());
        }
    }",0,[0]
28061,bugs-dot-jar_CAMEL-7304_fa165d6b,"@Override
    public boolean isAbstract() {
        return true;
    }","@Override
    public boolean isAbstract() {
        return true;
    }",0,[0]
35425,bugs-dot-jar_WICKET-4505_a4caaa57,"private boolean parseTagText(final XmlTag tag, final String tagText) throws ParseException
	{
		// Get the length of the tagtext
		final int tagTextLength = tagText.length();

		// If we match tagname pattern
		final TagNameParser tagnameParser = new TagNameParser(tagText);
		if (tagnameParser.matcher().lookingAt())
		{
			// Extract the tag from the pattern matcher
			tag.name = tagnameParser.getName();
			tag.namespace = tagnameParser.getNamespace();

			// Are we at the end? Then there are no attributes, so we just
			// return the tag
			int pos = tagnameParser.matcher().end(0);
			if (pos == tagTextLength)
			{
				return true;
			}

			// Extract attributes
			final VariableAssignmentParser attributeParser = new VariableAssignmentParser(tagText);
			while (attributeParser.matcher().find(pos))
			{
				// Get key and value using attribute pattern
				String value = attributeParser.getValue();

				// In case like <html xmlns:wicket> will the value be null
				if (value == null)
				{
					value = """";
				}

				// Set new position to end of attribute
				pos = attributeParser.matcher().end(0);

				// Chop off double quotes or single quotes
				if (value.startsWith(""\"""") || value.startsWith(""\'""))
				{
					value = value.substring(1, value.length() - 1);
				}

				// Trim trailing whitespace
				value = value.trim();

				// Get key
				final String key = attributeParser.getKey();

				// Put the attribute in the attributes hash
				if (null != tag.getAttributes().put(key, value))
				{
					throw new ParseException(""Same attribute found twice: "" + key +
						getLineAndColumnText(), input.getPosition());
				}

				// The input has to match exactly (no left over junk after
				// attributes)
				if (pos == tagTextLength)
				{
					return true;
				}
			}

			return true;
		}

		return false;
	}","private boolean parseTagText(final XmlTag tag, final String tagText) throws ParseException
	{
		// Get the length of the tagtext
		final int tagTextLength = tagText.length();

		// If we match tagname pattern
		final TagNameParser tagnameParser = new TagNameParser(tagText);
		if (tagnameParser.matcher().lookingAt())
		{
			// Extract the tag from the pattern matcher
			tag.name = tagnameParser.getName();
			tag.namespace = tagnameParser.getNamespace();

			// Are we at the end? Then there are no attributes, so we just
			// return the tag
			int pos = tagnameParser.matcher().end(0);
			if (pos == tagTextLength)
			{
				return true;
			}

			// Extract attributes
			final VariableAssignmentParser attributeParser = new VariableAssignmentParser(tagText);
			while (attributeParser.matcher().find(pos))
			{
				// Get key and value using attribute pattern
				String value = attributeParser.getValue();

				// In case like <html xmlns:wicket> will the value be null
				if (value == null)
				{
					value = """";
				}

				// Set new position to end of attribute
				pos = attributeParser.matcher().end(0);

				// Chop off double quotes or single quotes
				if (value.startsWith(""\"""") || value.startsWith(""\'""))
				{
					value = value.substring(1, value.length() - 1);
				}

				// Trim trailing whitespace
				value = value.trim();

				// Unescape
				value = Strings.unescapeMarkup(value).toString();

				// Get key
				final String key = attributeParser.getKey();

				// Put the attribute in the attributes hash
				if (null != tag.getAttributes().put(key, value))
				{
					throw new ParseException(""Same attribute found twice: "" + key +
						getLineAndColumnText(), input.getPosition());
				}

				// The input has to match exactly (no left over junk after
				// attributes)
				if (pos == tagTextLength)
				{
					return true;
				}
			}

			return true;
		}

		return false;
	}",1,[]
25968,bugs-dot-jar_ACCUMULO-3383_97f16db4,"private static File computeTopCacheDir() {
    String procName = ManagementFactory.getRuntimeMXBean().getName();
    return new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + procName + ""-"" + System.getProperty(""user.name"", ""nouser""));
  }","private static File computeTopCacheDir() {
    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, System.getProperty(""java.io.tmpdir""));
    String procName = ManagementFactory.getRuntimeMXBean().getName();
    return new File(cacheDirPath, ""accumulo-vfs-cache-"" + procName + ""-"" + System.getProperty(""user.name"", ""nouser""));
  }",1,[2]
847,bugs-dot-jar_OAK-3333_194999ed,"@Nonnull
    static List<UpdateOp> forDocument(@Nonnull NodeDocument doc,
                                      @Nonnull RevisionContext context,
                                      @Nonnull Revision headRevision,
                                      int numRevsThreshold) {
        if (doc.isSplitDocument()) {
            throw new IllegalArgumentException(
                    ""Not a main document: "" + doc.getId());
        }
        return new SplitOperations(doc, context, headRevision, numRevsThreshold).create();

    }","@Nonnull
    static List<UpdateOp> forDocument(@Nonnull NodeDocument doc,
                                      @Nonnull RevisionContext context,
                                      @Nonnull Revision headRevision,
                                      int numRevsThreshold) {
        if (doc.isSplitDocument()) {
            throw new IllegalArgumentException(
                    ""Not a main document: "" + doc.getId());
        }
        return new SplitOperations(doc, context, headRevision, numRevsThreshold).create();

    }",0,[0]
37977,bugs-dot-jar_OAK-738_8ed779dc,"@Override
    @Nonnull
    public String getCorrespondingNodePath(String workspaceName) throws RepositoryException {
        checkAlive();
        checkValidWorkspace(workspaceName);
        throw new UnsupportedRepositoryOperationException(""TODO: Node.getCorrespondingNodePath"");
    }","@Override
    @Nonnull
    public String getCorrespondingNodePath(String workspaceName) throws RepositoryException {
        checkAlive();
        checkValidWorkspace(workspaceName);
        throw new UnsupportedRepositoryOperationException(""TODO: Node.getCorrespondingNodePath"");
    }",0,[0]
4658,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapDivide(double d) {
        return copy().mapDivideToSelf(d);
    }","public RealVector mapDivide(double d) {
        return copy().mapDivideToSelf(d);
    }",0,[0]
1898,Bears-225,"@Override
    public ResolvableType getReturnType() {
        return returnType;
    }","@Override
    public ResolvableType getReturnType() {
        return returnType;
    }",0,[0]
56,bugs-dot-jar_OAK-1822_3e83a4c1,"public static void removeCollision(@Nonnull UpdateOp op,
                                       @Nonnull Revision revision) {
        checkNotNull(op).removeMapEntry(COLLISIONS, checkNotNull(revision));
    }","public static void removeCollision(@Nonnull UpdateOp op,
                                       @Nonnull Revision revision) {
        checkNotNull(op).removeMapEntry(COLLISIONS, checkNotNull(revision));
    }",0,[0]
10666,bugs-dot-jar_MATH-1065_996c0c16,"public EnumeratedRealDistribution(final double[] singletons, final double[] probabilities)
    throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
           NotFiniteNumberException, NotANumberException {
        this(new Well19937c(), singletons, probabilities);
    }","public EnumeratedRealDistribution(final double[] singletons, final double[] probabilities)
    throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
           NotFiniteNumberException, NotANumberException {
        this(new Well19937c(), singletons, probabilities);
    }",0,[0]
26070,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = new RegExFilter();
    result.setSource(getSource().deepCopy(env));
    result.rowMatcher = copyMatcher(rowMatcher);
    result.colfMatcher = copyMatcher(colfMatcher);
    result.colqMatcher = copyMatcher(colqMatcher);
    result.valueMatcher = copyMatcher(valueMatcher);
    result.orFields = orFields;
    return result;
  }","@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    RegExFilter result = (RegExFilter) super.deepCopy(env);
    result.rowMatcher = copyMatcher(rowMatcher);
    result.colfMatcher = copyMatcher(colfMatcher);
    result.colqMatcher = copyMatcher(colqMatcher);
    result.valueMatcher = copyMatcher(valueMatcher);
    result.orFields = orFields;
    return result;
  }",1,"[2, 3]"
95,Bears-5,"@SuppressWarnings(""resource"")
    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = new TokenBuffer(p, ctxt);
        tokens.writeStartObject();

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        wrapInstantiationProblem(e, ctxt);
                        continue; // never gets here
                    }
                    // [databind#631]: Assign current value, to be accessible by custom serializers
                    p.setCurrentValue(bean);
                    // if so, need to copy all remaining tokens into buffer
                    while (t == JsonToken.FIELD_NAME) {
                        p.nextToken(); // to skip name
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    tokens.writeEndObject();
                    if (bean.getClass() != _beanType.getRawClass()) {
                        // !!! 08-Jul-2011, tatu: Could probably support; but for now
                        //   it's too complicated, so bail out
                        tokens.close();
                        throw ctxt.mappingException(""Can not create polymorphic instances with unwrapped values"");
                    }
                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                continue;
            }
            // Things marked as ignorable should not be passed to any setter
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            tokens.writeFieldName(propName);
            tokens.copyCurrentStructure(p);
            // ""any property""?
            if (_anySetter != null) {
                try {
                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
            }
        }

        // We hit END_OBJECT, so:
        Object bean;
        try {
            bean = creator.build(ctxt, buffer);
        } catch (Exception e) {
            wrapInstantiationProblem(e, ctxt);
            return null; // never gets here
        }
        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
    }","@SuppressWarnings(""resource"")
    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = new TokenBuffer(p, ctxt);
        tokens.writeStartObject();

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        wrapInstantiationProblem(e, ctxt);
                        continue; // never gets here
                    }
                    // [databind#631]: Assign current value, to be accessible by custom serializers
                    p.setCurrentValue(bean);
                    // if so, need to copy all remaining tokens into buffer
                    while (t == JsonToken.FIELD_NAME) {
                        p.nextToken(); // to skip name
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    tokens.writeEndObject();
                    if (bean.getClass() != _beanType.getRawClass()) {
                        // !!! 08-Jul-2011, tatu: Could probably support; but for now
                        //   it's too complicated, so bail out
                        tokens.close();
                        throw ctxt.mappingException(""Can not create polymorphic instances with unwrapped values"");
                    }
                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                continue;
            }
            // Things marked as ignorable should not be passed to any setter
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            tokens.writeFieldName(propName);
            tokens.copyCurrentStructure(p);
            // ""any property""?
            if (_anySetter != null) {
                try {
                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
            }
        }

        // We hit END_OBJECT, so:
        Object bean;
        try {
            bean = creator.build(ctxt, buffer);
        } catch (Exception e) {
            wrapInstantiationProblem(e, ctxt);
            return null; // never gets here
        }
        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
    }",0,[0]
9618,bugs-dot-jar_WICKET-2281_6e0b40bc,"public void setRequestToComponent(final Component component)
	{
		final IPageMap pageMap = component.getPage().getPageMap();
		final String pageMapName = pageMap.isDefault() ? """" : pageMap.getName();
		if (component instanceof BookmarkablePageLink)
		{
			final Class<? extends Page> clazz = ((BookmarkablePageLink<?>)component).getPageClass();
			parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName +
				':' + clazz.getName());
		}
		else
		{
			int version = component.getPage().getCurrentVersionNumber();
			Class<?> clazz = null;
			if (component instanceof IRedirectListener)
			{
				clazz = IRedirectListener.class;
			}
			else if (component instanceof IResourceListener)
			{
				clazz = IResourceListener.class;
			}
			else if (component instanceof IFormSubmitListener)
			{
				clazz = IFormSubmitListener.class;
			}
			else if (component instanceof ILinkListener)
			{
				clazz = ILinkListener.class;
			}
			else if (component instanceof IOnChangeListener)
			{
				clazz = IOnChangeListener.class;
			}
			else
			{
				throw new IllegalArgumentException(
					""The component class doesn't seem to implement any of the known *Listener interfaces: "" +
						component.getClass());
			}

			// manually create the url using default strategy and format
			parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, pageMapName + ':' +
				component.getPath() + ':' + (version == 0 ? """" : """" + version) + ':' +
				Classes.simpleName(clazz) + ""::"");

			// see if we can replace our manual listener url with a properly generated one...

			try
			{
				RequestListenerInterface rli = (RequestListenerInterface)clazz.getField(""INTERFACE"")
					.get(clazz);

				String auto = component.getRequestCycle().urlFor(component, rli).toString();
				int idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);
				if (idx >= 0)
				{
					auto = auto.substring(idx +
						WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.length() + 1);
				}
				else
				{
					// additional check for crypted strategy
					idx = auto.indexOf(""x=6*"");
					if (idx >= 0)
					{
						auto = auto.substring(idx + 4);
					}
				}

				idx = auto.indexOf(""&"");
				if (idx >= 0)
				{
					auto = auto.substring(0, idx);
				}

				parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);

			}
			catch (Exception e)
			{
				// noop
			}


			if (component.isStateless() && component.getPage().isBookmarkable())
			{
				parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME,
					pageMapName + ':' + component.getPage().getClass().getName());
			}
		}
	}","public void setRequestToComponent(final Component component)
	{
		final IPageMap pageMap = component.getPage().getPageMap();
		final String pageMapName = pageMap.isDefault() ? """" : pageMap.getName();
		if (component instanceof BookmarkablePageLink)
		{
			final Class<? extends Page> clazz = ((BookmarkablePageLink<?>)component).getPageClass();
			parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME, pageMapName +
				':' + clazz.getName());
		}
		else
		{
			int version = component.getPage().getCurrentVersionNumber();
			Class<?> clazz = null;
			if (component instanceof IRedirectListener)
			{
				clazz = IRedirectListener.class;
			}
			else if (component instanceof IResourceListener)
			{
				clazz = IResourceListener.class;
			}
			else if (component instanceof IFormSubmitListener)
			{
				clazz = IFormSubmitListener.class;
			}
			else if (component instanceof ILinkListener)
			{
				clazz = ILinkListener.class;
			}
			else if (component instanceof IOnChangeListener)
			{
				clazz = IOnChangeListener.class;
			}
			else
			{
				throw new IllegalArgumentException(
					""The component class doesn't seem to implement any of the known *Listener interfaces: "" +
						component.getClass());
			}

			// manually create the url using default strategy and format
			parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, pageMapName + ':' +
				component.getPath() + ':' + (version == 0 ? """" : """" + version) + ':' +
				Classes.simpleName(clazz) + ""::"");

			// see if we can replace our manual listener url with a properly generated one...

			try
			{
				RequestListenerInterface rli = (RequestListenerInterface)clazz.getField(""INTERFACE"")
					.get(clazz);

				String auto = component.getRequestCycle().urlFor(component, rli).toString();

				// check for crypted strategy
				if (auto.startsWith(""?x=""))
				{
					auto = auto.substring(3);
					parameters.put(""x"", auto);
					parameters.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);
				}
				else
				{
					int idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);
					if (idx >= 0)
					{
						auto = auto.substring(idx +
							WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.length() + 1);
					}
					else
					{
						idx = auto.indexOf(""&"");
						if (idx >= 0)
						{
							auto = auto.substring(0, idx);
						}
					}
					parameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);
				}
			}
			catch (Exception e)
			{
				// noop
			}

			if (component.isStateless() && component.getPage().isBookmarkable())
			{
				parameters.put(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME,
					pageMapName + ':' + component.getPage().getClass().getName());
			}
		}
	}",1,"[54, 55, 57, 58, 62, 63, 66, 70, 71, 72, 73, 74, 76]"
40874,bugs-dot-jar_CAMEL-7622_faa20255,"private static AdviceWithTask doAfter(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition<?> after,
                                          final Iterator<ProcessorDefinition<?>> it) {
        return new AdviceWithTask() {
            public void task() throws Exception {
                boolean match = false;
                while (it.hasNext()) {
                    ProcessorDefinition<?> output = it.next();
                    if (matchBy.match(output)) {
                        List<ProcessorDefinition> outputs = getParentOutputs(output.getParent());
                        if (outputs != null) {
                            int index = outputs.indexOf(output);
                            if (index != -1) {
                                match = true;
                                Object existing = outputs.get(index);
                                outputs.add(index + 1, after);
                                LOG.info(""AdviceWith ("" + matchBy.getId() + "") : ["" + existing + ""] --> after ["" + after + ""]"");
                            }
                        }
                    }
                }

                if (!match) {
                    throw new IllegalArgumentException(""There are no outputs which matches: "" + matchBy.getId() + "" in the route: "" + route);
                }
            }
        };
    }","private static AdviceWithTask doAfter(final RouteDefinition route, final MatchBy matchBy, final ProcessorDefinition<?> after,
                                          final Iterator<ProcessorDefinition<?>> it) {
        return new AdviceWithTask() {
            public void task() throws Exception {
                boolean match = false;
                while (it.hasNext()) {
                    ProcessorDefinition<?> output = it.next();
                    if (matchBy.match(output)) {
                        List<ProcessorDefinition> outputs = getParentOutputs(output.getParent());
                        if (outputs != null) {
                            int index = outputs.indexOf(output);
                            if (index != -1) {
                                match = true;
                                Object existing = outputs.get(index);
                                outputs.add(index + 1, after);
                                LOG.info(""AdviceWith ("" + matchBy.getId() + "") : ["" + existing + ""] --> after ["" + after + ""]"");
                            }
                        }
                    }
                }

                if (!match) {
                    throw new IllegalArgumentException(""There are no outputs which matches: "" + matchBy.getId() + "" in the route: "" + route);
                }
            }
        };
    }",0,[0]
37778,bugs-dot-jar_WICKET-3647_1b57b51c,"protected void renderPlaceholderTag(final ComponentTag tag, final Response response)
	{
		String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + "":"";

		response.write(""<"");
		if (ns != null)
		{
			response.write(ns);
		}
		response.write(tag.getName());
		response.write("" id=\"""");
		response.write(getAjaxRegionMarkupId());
		response.write(""\"" style=\""display:none\""></"");
		if (ns != null)
		{
			response.write(ns);
		}
		response.write(tag.getName());
		response.write("">"");
	}","protected void renderPlaceholderTag(final ComponentTag tag, final Response response)
	{
		String ns = Strings.isEmpty(tag.getNamespace()) ? null : tag.getNamespace() + "":"";

		response.write(""<"");
		if (ns != null)
		{
			response.write(ns);
		}
		response.write(tag.getName());
		response.write("" id=\"""");
		response.write(getAjaxRegionMarkupId());
		response.write(""\"" style=\""display:none\""></"");
		if (ns != null)
		{
			response.write(ns);
		}
		response.write(tag.getName());
		response.write("">"");
	}",0,[0]
24014,bugs-dot-jar_OAK-579_7d72e6ed,"@Override
    public void restrict(FilterImpl f) {
        if (f.getSelector() == parentSelector) {
            String c = childSelector.currentPath();
            if (c != null) {
                f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);
            }
        }
        if (f.getSelector() == childSelector) {
            String p = parentSelector.currentPath();
            if (p != null) {
                f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);
            }
        }
    }","@Override
    public void restrict(FilterImpl f) {
        if (f.getSelector() == parentSelector) {
            String c = childSelector.currentPath();
            if (c == null && f.isPreparing() && childSelector.isPrepared()) {
                // during the prepare phase, if the selector is already
                // prepared, then we would know the value
                c = KNOWN_PATH;
            }
            if (c != null) {
                f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);
            }
        }
        if (f.getSelector() == childSelector) {
            String p = parentSelector.currentPath();
            if (p == null && f.isPreparing() && parentSelector.isPrepared()) {
                // during the prepare phase, if the selector is already
                // prepared, then we would know the value
                p = KNOWN_PATH;
            }
            if (p != null) {
                f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);
            }
        }
    }",1,[]
29334,bugs-dot-jar_LOG4J2-268_8faf7f77,"protected void addContextData(final String prefix, final Map<String, String> fields,
                                  final Map<String, String> context) {
        for (final Map.Entry<String, String> entry : context.entrySet()) {
            if (entry.getKey() != null && entry.getValue() != null) {
                fields.put(prefix + entry.getKey(), entry.getValue());
            }
        }
    }","protected void addContextData(final String prefix, final Map<String, String> fields,
                                  final Map<String, String> context) {
        for (final Map.Entry<String, String> entry : context.entrySet()) {
            if (entry.getKey() != null && entry.getValue() != null) {
                fields.put(prefix + entry.getKey(), entry.getValue());
            }
        }
    }",0,[0]
16503,bugs-dot-jar_OAK-1977_4bfbfcdd,"Cursor execute() {
        QueryEngineSettings settings = filter.getQueryEngineSettings();
        Cursor cursor = Cursors.newPathCursor(
                strategy.query(filter, name, definition, values),
                settings);
        if (depth > 1) {
            cursor = Cursors.newAncestorCursor(cursor, depth - 1, settings);
        }
        return cursor;
    }","Cursor execute() {
        QueryEngineSettings settings = filter.getQueryEngineSettings();
        Cursor cursor = Cursors.newPathCursor(
                strategy.query(filter, name, definition, values),
                settings);
        if (depth > 1) {
            cursor = Cursors.newAncestorCursor(cursor, depth - 1, settings);
        }
        return cursor;
    }",0,[0]
723,Bears-23,"protected Date parseAsRFC1123(String dateStr, ParsePosition pos)
    {
        if (_formatRFC1123 == null) {
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                    _timezone, _locale, _lenient);
        }
        return _formatRFC1123.parse(dateStr, pos);
    }","protected Date parseAsRFC1123(String dateStr, ParsePosition pos)
    {
        if (_formatRFC1123 == null) {
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                    _timezone, _locale, _lenient);
        }
        return _formatRFC1123.parse(dateStr, pos);
    }",0,[0]
133,bugs-dot-jar_OAK-1822_3e83a4c1,"Iterable<? extends Map.Entry<CacheValue, ? extends CachedNodeDocument>> getCacheEntries() {
        if (nodesCache instanceof OffHeapCache) {
            return Iterables.concat(nodesCache.asMap().entrySet(),
                    ((OffHeapCache) nodesCache).offHeapEntriesMap().entrySet());
        }
        return nodesCache.asMap().entrySet();
    }","Iterable<? extends Map.Entry<CacheValue, ? extends CachedNodeDocument>> getCacheEntries() {
        if (nodesCache instanceof OffHeapCache) {
            return Iterables.concat(nodesCache.asMap().entrySet(),
                    ((OffHeapCache) nodesCache).offHeapEntriesMap().entrySet());
        }
        return nodesCache.asMap().entrySet();
    }",0,[0]
18196,bugs-dot-jar_MATH-554_fbbb96eb,"@Override
  public int hashCode() {
      if (isNaN()) {
          return 8;
      }
      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));
  }","@Override
  public int hashCode() {
      if (isNaN()) {
          return 8;
      }
      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));
  }",0,[0]
2082,bugs-dot-jar_WICKET-2961_3d8c9d75,"private boolean removeBehavior(final IBehavior behavior)
	{
		final int start = getFlag(FLAG_MODEL_SET) ? 1 : 0;
		final int len = data_length();
		for (int i = start; i < len; ++i)
		{
			Object o = data_get(i);
			if (o != null && o.equals(behavior))
			{
				// behaviors that produce urls depend on their index in the behaviors list,
				// therefore we cannot blindly shrink the array by removing this behavior's slot.
				// Instead we check if there are any behaviors downstream that will be affected by
				// this, and if there are we set this behavior's slot to null instead of removing it
				// to preserve indexes of behaviors downstream.
				boolean anyListenersAfter = false;
				for (int j = i + 1; j < len; j++)
				{
					if (data_get(j) instanceof IRequestListener)
					{
						anyListenersAfter = true;
						break;
					}
				}

				if (anyListenersAfter)
				{
					data_set(i, null);
				}
				else
				{
					data_remove(i);

					if (o instanceof IRequestListener)
					{
						// this was a listener which mightve caused holes in the array, see if we
						// can clean them up. notice: at this point we already know there are no
						// listeners that can be affected by index change downstream because this is
						// the last one in the array
						for (int j = i - 1; j >= start; j--)
						{
							if (data_get(j) == null)
							{
								data_remove(j);
							}
						}
					}
				}
				behavior.unbind(this);
				return true;
			}
		}
		return false;
	}","private boolean removeBehavior(final IBehavior behavior)
	{
		final int start = getFlag(FLAG_MODEL_SET) ? 1 : 0;
		final int len = data_length();
		for (int i = start; i < len; ++i)
		{
			Object o = data_get(i);
			if (o != null && o.equals(behavior))
			{
				// behaviors that produce urls depend on their index in the behaviors list,
				// therefore we cannot blindly shrink the array by removing this behavior's slot.
				// Instead we check if there are any behaviors downstream that will be affected by
				// this, and if there are we set this behavior's slot to null instead of removing it
				// to preserve indexes of behaviors downstream.
				boolean anyListenersAfter = false;
				for (int j = i + 1; j < len; j++)
				{
					if (data_get(j) instanceof IRequestListener)
					{
						anyListenersAfter = true;
						break;
					}
				}

				if (anyListenersAfter)
				{
					data_set(i, null);
				}
				else
				{
					data_remove(i);

					if (o instanceof IRequestListener)
					{
						// this was a listener which mightve caused holes in the array, see if we
						// can clean them up. notice: at this point we already know there are no
						// listeners that can be affected by index change downstream because this is
						// the last one in the array
						for (int j = i - 1; j >= start; j--)
						{
							if (data_get(j) == null)
							{
								data_remove(j);
							}
						}
					}
				}
				behavior.unbind(this);
				return true;
			}
		}
		return false;
	}",0,[0]
12824,bugs-dot-jar_MATH-1208_ce2badf0,"private double cumBinP(int binIndex) {
        return upperBounds[binIndex];
    }","private double cumBinP(int binIndex) {
        return upperBounds[binIndex];
    }",0,[0]
9298,bugs-dot-jar_WICKET-4597_9dab1bb5,"public static Duration benchmark(final Runnable code)
	{
		// Get time before running code
		final Time start = Time.now();

		// Run code
		code.run();

		// Return the difference
		return Time.now().subtract(start);
	}","public static Duration benchmark(final Runnable code)
	{
		// Get time before running code
		final Time start = Time.now();

		// Run code
		code.run();

		// Return the difference
		return Time.now().subtract(start);
	}",0,[0]
23675,bugs-dot-jar_MATH-744_8a83581e,"public double pow(final double exponent) {
        return FastMath.pow(numerator.doubleValue(),   exponent) /
               FastMath.pow(denominator.doubleValue(), exponent);
    }","public double pow(final double exponent) {
        return FastMath.pow(numerator.doubleValue(),   exponent) /
               FastMath.pow(denominator.doubleValue(), exponent);
    }",0,[0]
34278,bugs-dot-jar_WICKET-4184_a0150366,"public CharSequence subSequence(final int start, final int end)
	{
		return this.substring(start, end);
	}","public CharSequence subSequence(final int start, final int end)
	{
		return this.substring(start, end);
	}",0,[0]
3130,bugs-dot-jar_OAK-1216_e403e003,"@Nonnull
    public AccessManager getAccessManager() throws RepositoryException {
        if (accessManager == null) {
            accessManager = new AccessManager(delegate, getPermissionProvider());
        }
        return accessManager;
    }","@Nonnull
    public AccessManager getAccessManager() throws RepositoryException {
        if (accessManager == null) {
            accessManager = new AccessManager(delegate, getPermissionProvider());
        }
        return accessManager;
    }",0,[0]
29719,bugs-dot-jar_FLINK-2763_af477563,"public long getProbeSideRecordCount() {
		return this.probeSideRecordCounter;
	}","public long getProbeSideRecordCount() {
		return this.probeSideRecordCounter;
	}",0,[0]
35287,bugs-dot-jar_ACCUMULO-1732_941e3cb1,"public static void setMockInstance(Job job, String instanceName) {
    InputConfigurator.setMockInstance(CLASS, job.getConfiguration(), instanceName);
  }","public static void setMockInstance(Job job, String instanceName) {
    InputConfigurator.setMockInstance(CLASS, job.getConfiguration(), instanceName);
  }",0,[0]
8479,bugs-dot-jar_ACCUMULO-366_db4a291f,"private int startTabletClientService() throws UnknownHostException {
    // start listening for client connection last
    TabletClientService.Iface tch = TraceWrap.service(new ThriftClientHandler());
    TabletClientService.Processor processor = new TabletClientService.Processor(tch);
    int port = startServer(Property.TSERV_CLIENTPORT, processor, ""Thrift Client Server"");
    log.info(""port = "" + port);
    return port;
  }","private int startTabletClientService() throws UnknownHostException {
    // start listening for client connection last
    TabletClientService.Iface tch = TraceWrap.service(new ThriftClientHandler());
    TabletClientService.Processor processor = new TabletClientService.Processor(tch);
    int port = startServer(Property.TSERV_CLIENTPORT, processor, ""Thrift Client Server"");
    log.info(""port = "" + port);
    return port;
  }",0,[0]
34255,bugs-dot-jar_WICKET-4184_a0150366,"public int capacity()
	{
		return value.length;
	}","public int capacity()
	{
		return value.length;
	}",0,[0]
36945,bugs-dot-jar_OAK-1933_2e16a983,"@Override
    public void restrictPushDown(SelectorImpl s) {
        constraint1.restrictPushDown(s);
        constraint2.restrictPushDown(s);
    }","@Override
    public void restrictPushDown(SelectorImpl s) {
        constraint1.restrictPushDown(s);
        constraint2.restrictPushDown(s);
    }",0,[0]
12564,bugs-dot-jar_MATH-864_abe53a53,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = fitfun.encode(getStartPoint());
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum = new PointValuePair(getStartPoint(),
                isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------

        generationLoop:
            for (iterations = 1; iterations <= maxIterations; iterations++) {
                // Generate and evaluate lambda offspring
                RealMatrix arz = randn1(dimension, lambda);
                RealMatrix arx = zeros(dimension, lambda);
                double[] fitness = new double[lambda];
                // generate random offspring
                for (int k = 0; k < lambda; k++) {
                    RealMatrix arxk = null;
                    for (int i = 0; i < checkFeasableCount+1; i++) {
                        if (diagonalOnly <= 0) {
                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                        } else {
                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma));
                        }
                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                            break;
                        }
                        // regenerate random arguments for row
                        arz.setColumn(k, randn(dimension));
                    }
                    copyColumn(arxk, 0, arx, k);
                    try {
                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                    } catch (TooManyEvaluationsException e) {
                        break generationLoop;
                    }
                }
                // Sort by fitness and compute weighted mean into xmean
                int[] arindex = sortedIndices(fitness);
                // Calculate new xmean, this is selection and recombination
                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
                xmean = bestArx.multiply(weights);
                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
                RealMatrix zmean = bestArz.multiply(weights);
                boolean hsig = updateEvolutionPaths(zmean, xold);
                if (diagonalOnly <= 0) {
                    updateCovariance(hsig, bestArx, arz, arindex, xold);
                } else {
                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);
                }
                // Adapt step size sigma - Eq. (5)
                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
                double bestFitness = fitness[arindex[0]];
                double worstFitness = fitness[arindex[arindex.length-1]];
                if (bestValue > bestFitness) {
                    bestValue = bestFitness;
                    lastResult = optimum;
                    optimum = new PointValuePair(
                            fitfun.decode(bestArx.getColumn(0)),
                            isMinimize ? bestFitness : -bestFitness);
                    if (getConvergenceChecker() != null && lastResult != null) {
                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                            break generationLoop;
                        }
                    }
                }
                // handle termination criteria
                // Break, if fitness is good enough
                if (stopFitness != 0) { // only if stopFitness is defined
                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                        break generationLoop;
                    }
                }
                double[] sqrtDiagC = sqrt(diagC).getColumn(0);
                double[] pcCol = pc.getColumn(0);
                for (int i = 0; i < dimension; i++) {
                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                        break;
                    }
                    if (i >= dimension-1) {
                        break generationLoop;
                    }
                }
                for (int i = 0; i < dimension; i++) {
                    if (sigma*sqrtDiagC[i] > stopTolUpX) {
                        break generationLoop;
                    }
                }
                double historyBest = min(fitnessHistory);
                double historyWorst = max(fitnessHistory);
                if (iterations > 2 && Math.max(historyWorst, worstFitness) -
                        Math.min(historyBest, bestFitness) < stopTolFun) {
                    break generationLoop;
                }
                if (iterations > fitnessHistory.length &&
                        historyWorst-historyBest < stopTolHistFun) {
                    break generationLoop;
                }
                // condition number of the covariance matrix exceeds 1e14
                if (max(diagD)/min(diagD) > 1e7) {
                    break generationLoop;
                }
                // user defined termination
                if (getConvergenceChecker() != null) {
                    PointValuePair current =
                        new PointValuePair(bestArx.getColumn(0),
                                isMinimize ? bestFitness : -bestFitness);
                    if (lastResult != null &&
                        getConvergenceChecker().converged(iterations, current, lastResult)) {
                        break generationLoop;
                    }
                    lastResult = current;
                }
                // Adjust step size in case of equal function values (flat fitness)
                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                        Math.min(historyBest, bestFitness) == 0) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                // store best in history
                push(fitnessHistory,bestFitness);
                fitfun.setValueRange(worstFitness-bestFitness);
                if (generateStatistics) {
                    statisticsSigmaHistory.add(sigma);
                    statisticsFitnessHistory.add(bestFitness);
                    statisticsMeanHistory.add(xmean.transpose());
                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
                }
            }
        return optimum;
    }","@Override
    protected PointValuePair doOptimize() {
        checkParameters();
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = fitfun.encode(getStartPoint());
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum = new PointValuePair(getStartPoint(),
                isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------

        generationLoop:
            for (iterations = 1; iterations <= maxIterations; iterations++) {
                // Generate and evaluate lambda offspring
                RealMatrix arz = randn1(dimension, lambda);
                RealMatrix arx = zeros(dimension, lambda);
                double[] fitness = new double[lambda];
                // generate random offspring
                for (int k = 0; k < lambda; k++) {
                    RealMatrix arxk = null;
                    for (int i = 0; i < checkFeasableCount+1; i++) {
                        if (diagonalOnly <= 0) {
                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                        } else {
                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma));
                        }
                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                            break;
                        }
                        // regenerate random arguments for row
                        arz.setColumn(k, randn(dimension));
                    }
                    copyColumn(arxk, 0, arx, k);
                    try {
                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                    } catch (TooManyEvaluationsException e) {
                        break generationLoop;
                    }
                }
                // Sort by fitness and compute weighted mean into xmean
                int[] arindex = sortedIndices(fitness);
                // Calculate new xmean, this is selection and recombination
                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
                xmean = bestArx.multiply(weights);
                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
                RealMatrix zmean = bestArz.multiply(weights);
                boolean hsig = updateEvolutionPaths(zmean, xold);
                if (diagonalOnly <= 0) {
                    updateCovariance(hsig, bestArx, arz, arindex, xold);
                } else {
                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);
                }
                // Adapt step size sigma - Eq. (5)
                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
                double bestFitness = fitness[arindex[0]];
                double worstFitness = fitness[arindex[arindex.length-1]];
                if (bestValue > bestFitness) {
                    bestValue = bestFitness;
                    lastResult = optimum;
                    optimum = new PointValuePair(
                            fitfun.repairAndDecode(bestArx.getColumn(0)),
                            isMinimize ? bestFitness : -bestFitness);
                    if (getConvergenceChecker() != null && lastResult != null) {
                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                            break generationLoop;
                        }
                    }
                }
                // handle termination criteria
                // Break, if fitness is good enough
                if (stopFitness != 0) { // only if stopFitness is defined
                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                        break generationLoop;
                    }
                }
                double[] sqrtDiagC = sqrt(diagC).getColumn(0);
                double[] pcCol = pc.getColumn(0);
                for (int i = 0; i < dimension; i++) {
                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                        break;
                    }
                    if (i >= dimension-1) {
                        break generationLoop;
                    }
                }
                for (int i = 0; i < dimension; i++) {
                    if (sigma*sqrtDiagC[i] > stopTolUpX) {
                        break generationLoop;
                    }
                }
                double historyBest = min(fitnessHistory);
                double historyWorst = max(fitnessHistory);
                if (iterations > 2 && Math.max(historyWorst, worstFitness) -
                        Math.min(historyBest, bestFitness) < stopTolFun) {
                    break generationLoop;
                }
                if (iterations > fitnessHistory.length &&
                        historyWorst-historyBest < stopTolHistFun) {
                    break generationLoop;
                }
                // condition number of the covariance matrix exceeds 1e14
                if (max(diagD)/min(diagD) > 1e7) {
                    break generationLoop;
                }
                // user defined termination
                if (getConvergenceChecker() != null) {
                    PointValuePair current =
                        new PointValuePair(bestArx.getColumn(0),
                                isMinimize ? bestFitness : -bestFitness);
                    if (lastResult != null &&
                        getConvergenceChecker().converged(iterations, current, lastResult)) {
                        break generationLoop;
                    }
                    lastResult = current;
                }
                // Adjust step size in case of equal function values (flat fitness)
                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                        Math.min(historyBest, bestFitness) == 0) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                // store best in history
                push(fitnessHistory,bestFitness);
                fitfun.setValueRange(worstFitness-bestFitness);
                if (generateStatistics) {
                    statisticsSigmaHistory.add(sigma);
                    statisticsFitnessHistory.add(bestFitness);
                    statisticsMeanHistory.add(xmean.transpose());
                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
                }
            }
        return optimum;
    }",1,[71]
812,bugs-dot-jar_ACCUMULO-412_5594b2e0,"@Override
  public long isReady(long tid, Master master) throws Exception {
    if (!Utils.getReadLock(tableId, tid).tryLock())
      return 100;
    
    Instance instance = HdfsZooInstance.getInstance();
    Tables.clearCache(instance);
    if (Tables.getTableState(instance, tableId) == TableState.ONLINE) {
      long reserve1, reserve2;
      reserve1 = reserve2 = Utils.reserveHdfsDirectory(sourceDir, tid);
      if (reserve1 == 0)
        reserve2 = Utils.reserveHdfsDirectory(errorDir, tid);
      return reserve2;
    } else {
      throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.OFFLINE, null);
    }
  }","@Override
  public long isReady(long tid, Master master) throws Exception {
    Set<TServerInstance> finished = new HashSet<TServerInstance>();
    Set<TServerInstance> running = master.onlineTabletServers();
    for (TServerInstance server : running) {
      try {
        if (!master.getConnection(server).isActive(tid))
          finished.add(server);
      } catch (TException ex) {
        log.info(""Ignoring error trying to check on tid "" + tid + "" from server "" + server + "": "" + ex);
      }
    }
    if (finished.containsAll(running))
      return 0;
    return 1000;
  }",1,"[2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]"
13131,bugs-dot-jar_OAK-2434_8159fc21,"public LuceneIndex(IndexTracker tracker, NodeAggregator aggregator) {
        this.tracker = tracker;
        this.aggregator = aggregator;
    }","public LuceneIndex(IndexTracker tracker, NodeAggregator aggregator) {
        this.tracker = tracker;
        this.aggregator = aggregator;
    }",0,[0]
3625,bugs-dot-jar_MATH-327_262fe4c0,"public SingularValueDecompositionImpl(final RealMatrix matrix) {
        m = matrix.getRowDimension();
        n = matrix.getColumnDimension();

        cachedU = null;
        cachedS = null;
        cachedV = null;
        cachedVt = null;

        double[][] localcopy = matrix.getData();
        double[][] matATA = new double[n][n];
        //
        // create A^T*A
        //
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                matATA[i][j] = 0.0;
                for (int k = 0; k < m; k++) {
                    matATA[i][j] += localcopy[k][i] * localcopy[k][j];
                }
                matATA[j][i] = matATA[i][j];
            }
        }

        double[][] matAAT = new double[m][m];
        //
        // create A*A^T
        //
        for (int i = 0; i < m; i++) {
            for (int j = i; j < m; j++) {
                matAAT[i][j] = 0.0;
                for (int k = 0; k < n; k++) {
                    matAAT[i][j] += localcopy[i][k] * localcopy[j][k];
                }
                 matAAT[j][i] = matAAT[i][j];
            }
        }
        int p;
        if (m >= n) {
            p = n;
            // compute eigen decomposition of A^T*A
            eigenDecomposition
                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);
            singularValues = eigenDecomposition.getRealEigenvalues();
            cachedV = eigenDecomposition.getV();
            // compute eigen decomposition of A*A^T
            eigenDecomposition
                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);
            cachedU = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
        } else {
            p = m;
            // compute eigen decomposition of A*A^T
            eigenDecomposition
                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);
            singularValues = eigenDecomposition.getRealEigenvalues();
            cachedU = eigenDecomposition.getV();

            // compute eigen decomposition of A^T*A
            eigenDecomposition
                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);
            cachedV = eigenDecomposition.getV().getSubMatrix(0, n - 1 , 0, p - 1);
        }
        for (int i = 0; i < p; i++) {
            singularValues[i] = FastMath.sqrt(FastMath.abs(singularValues[i]));
        }
        // Up to this point, U and V are computed independently of each other.
        // There still a sign indetermination of each column of, say, U.
        // The sign is set such that A.V_i=sigma_i.U_i (i<=p)
        // The right sign corresponds to a positive dot product of A.V_i and U_i
        for (int i = 0; i < p; i++) {
            RealVector tmp = cachedU.getColumnVector(i);
            double product=matrix.operate(cachedV.getColumnVector(i)).dotProduct(tmp);
            if (product < 0) {
                cachedU.setColumnVector(i, tmp.mapMultiply(-1));
            }
        }
    }","public SingularValueDecompositionImpl(final RealMatrix matrix) {

        // Derived from LINPACK code.
        // Initialize.
        double[][] A;
        m = matrix.getRowDimension();
        n = matrix.getColumnDimension();
        if (matrix.getRowDimension() < matrix.getColumnDimension()) {
            transposed = true;
            A = matrix.transpose().getData();
            m = matrix.getColumnDimension();
            n = matrix.getRowDimension();
        } else {
            transposed = false;
            A = matrix.getData();
            m = matrix.getRowDimension();
            n = matrix.getColumnDimension();
        }
        int nu = FastMath.min(m, n);
        singularValues = new double[FastMath.min(m + 1, n)];
        double[][] U = new double[m][nu];
        double[][] V = new double[n][n];
        double[] e = new double[n];
        double[] work = new double[m];
        boolean wantu = true;
        boolean wantv = true;
        // Reduce A to bidiagonal form, storing the diagonal elements
        // in s and the super-diagonal elements in e.
        int nct = FastMath.min(m - 1, n);
        int nrt = FastMath.max(0, FastMath.min(n - 2, m));
        for (int k = 0; k < FastMath.max(nct, nrt); k++) {
            if (k < nct) {
                // Compute the transformation for the k-th column and
                // place the k-th diagonal in s[k].
                // Compute 2-norm of k-th column without under/overflow.
                singularValues[k] = 0;
                for (int i = k; i < m; i++) {
                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);
                }
                if (singularValues[k] != 0.0) {
                    if (A[k][k] < 0.0) {
                        singularValues[k] = -singularValues[k];
                    }
                    for (int i = k; i < m; i++) {
                        A[i][k] /= singularValues[k];
                    }
                    A[k][k] += 1.0;
                }
                singularValues[k] = -singularValues[k];
            }
            for (int j = k + 1; j < n; j++) {
                if ((k < nct) & (singularValues[k] != 0.0)) {
                    // Apply the transformation.
                    double t = 0;
                    for (int i = k; i < m; i++) {
                        t += A[i][k] * A[i][j];
                    }
                    t = -t / A[k][k];
                    for (int i = k; i < m; i++) {
                        A[i][j] += t * A[i][k];
                    }
                }
                // Place the k-th row of A into e for the
                // subsequent calculation of the row transformation.
                e[j] = A[k][j];
            }
            if (wantu & (k < nct)) {
                // Place the transformation in U for subsequent back
                // multiplication.
                for (int i = k; i < m; i++) {
                    U[i][k] = A[i][k];
                }
            }
            if (k < nrt) {
                // Compute the k-th row transformation and place the
                // k-th super-diagonal in e[k].
                // Compute 2-norm without under/overflow.
                e[k] = 0;
                for (int i = k + 1; i < n; i++) {
                    e[k] = FastMath.hypot(e[k], e[i]);
                }
                if (e[k] != 0.0) {
                    if (e[k + 1] < 0.0) {
                        e[k] = -e[k];
                    }
                    for (int i = k + 1; i < n; i++) {
                        e[i] /= e[k];
                    }
                    e[k + 1] += 1.0;
                }
                e[k] = -e[k];
                if ((k + 1 < m) & (e[k] != 0.0)) {
                    // Apply the transformation.
                    for (int i = k + 1; i < m; i++) {
                        work[i] = 0.0;
                    }
                    for (int j = k + 1; j < n; j++) {
                        for (int i = k + 1; i < m; i++) {
                            work[i] += e[j] * A[i][j];
                        }
                    }
                    for (int j = k + 1; j < n; j++) {
                        double t = -e[j] / e[k + 1];
                        for (int i = k + 1; i < m; i++) {
                            A[i][j] += t * work[i];
                        }
                    }
                }
                if (wantv) {
                    // Place the transformation in V for subsequent
                    // back multiplication.
                    for (int i = k + 1; i < n; i++) {
                        V[i][k] = e[i];
                    }
                }
            }
        }
        // Set up the final bidiagonal matrix or order p.
        int p = FastMath.min(n, m + 1);
        if (nct < n) {
            singularValues[nct] = A[nct][nct];
        }
        if (m < p) {
            singularValues[p - 1] = 0.0;
        }
        if (nrt + 1 < p) {
            e[nrt] = A[nrt][p - 1];
        }
        e[p - 1] = 0.0;
        // If required, generate U.
        if (wantu) {
            for (int j = nct; j < nu; j++) {
                for (int i = 0; i < m; i++) {
                    U[i][j] = 0.0;
                }
                U[j][j] = 1.0;
            }
            for (int k = nct - 1; k >= 0; k--) {
                if (singularValues[k] != 0.0) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k; i < m; i++) {
                            t += U[i][k] * U[i][j];
                        }
                        t = -t / U[k][k];
                        for (int i = k; i < m; i++) {
                            U[i][j] += t * U[i][k];
                        }
                    }
                    for (int i = k; i < m; i++) {
                        U[i][k] = -U[i][k];
                    }
                    U[k][k] = 1.0 + U[k][k];
                    for (int i = 0; i < k - 1; i++) {
                        U[i][k] = 0.0;
                    }
                } else {
                    for (int i = 0; i < m; i++) {
                        U[i][k] = 0.0;
                    }
                    U[k][k] = 1.0;
                }
            }
        }
        // If required, generate V.
        if (wantv) {
            for (int k = n - 1; k >= 0; k--) {
                if ((k < nrt) & (e[k] != 0.0)) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k + 1; i < n; i++) {
                            t += V[i][k] * V[i][j];
                        }
                        t = -t / V[k + 1][k];
                        for (int i = k + 1; i < n; i++) {
                            V[i][j] += t * V[i][k];
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    V[i][k] = 0.0;
                }
                V[k][k] = 1.0;
            }
        }
        // Main iteration loop for the singular values.
        int pp = p - 1;
        int iter = 0;
        while (p > 0) {
            int k, kase;
            // Here is where a test for too many iterations would go.
            // This section of the program inspects for
            // negligible elements in the s and e arrays.  On
            // completion the variables kase and k are set as follows.
            // kase = 1     if s(p) and e[k-1] are negligible and k<p
            // kase = 2     if s(k) is negligible and k<p
            // kase = 3     if e[k-1] is negligible, k<p, and
            //              s(k), ..., s(p) are not negligible (qr step).
            // kase = 4     if e(p-1) is negligible (convergence).
            for (k = p - 2; k >= -1; k--) {
                if (k == -1) {
                    break;
                }
                final double threshold =
                        TINY + EPS * (FastMath.abs(singularValues[k]) + FastMath.abs(singularValues[k + 1]));
                if (FastMath.abs(e[k]) <= threshold) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p - 2) {
                kase = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) {
                        break;
                    }
                    double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +
                               (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);
                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {
                        singularValues[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    kase = 3;
                } else if (ks == p - 1) {
                    kase = 1;
                } else {
                    kase = 2;
                    k = ks;
                }
            }
            k++;
            // Perform the task indicated by kase.
            switch (kase) {
                // Deflate negligible s(p).
                case 1: {
                    double f = e[p - 2];
                    e[p - 2] = 0.0;
                    for (int j = p - 2; j >= k; j--) {
                        double t = FastMath.hypot(singularValues[j], f);
                        double cs = singularValues[j] / t;
                        double sn = f / t;
                        singularValues[j] = t;
                        if (j != k) {
                            f = -sn * e[j - 1];
                            e[j - 1] = cs * e[j - 1];
                        }
                        if (wantv) {
                            for (int i = 0; i < n; i++) {
                                t = cs * V[i][j] + sn * V[i][p - 1];
                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                                V[i][j] = t;
                            }
                        }
                    }
                }
                break;
                // Split at negligible s(k).
                case 2: {
                    double f = e[k - 1];
                    e[k - 1] = 0.0;
                    for (int j = k; j < p; j++) {
                        double t = FastMath.hypot(singularValues[j], f);
                        double cs = singularValues[j] / t;
                        double sn = f / t;
                        singularValues[j] = t;
                        f = -sn * e[j];
                        e[j] = cs * e[j];
                        if (wantu) {
                            for (int i = 0; i < m; i++) {
                                t = cs * U[i][j] + sn * U[i][k - 1];
                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                                U[i][j] = t;
                            }
                        }
                    }
                }
                break;
                // Perform one qr step.
                case 3: {
                    // Calculate the shift.
                    double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(
                            FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])), FastMath.abs(e[p - 2])),
                            FastMath.abs(singularValues[k])), FastMath.abs(e[k]));
                    double sp = singularValues[p - 1] / scale;
                    double spm1 = singularValues[p - 2] / scale;
                    double epm1 = e[p - 2] / scale;
                    double sk = singularValues[k] / scale;
                    double ek = e[k] / scale;
                    double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                    double c = (sp * epm1) * (sp * epm1);
                    double shift = 0.0;
                    if ((b != 0.0) | (c != 0.0)) {
                        shift = FastMath.sqrt(b * b + c);
                        if (b < 0.0) {
                            shift = -shift;
                        }
                        shift = c / (b + shift);
                    }
                    double f = (sk + sp) * (sk - sp) + shift;
                    double g = sk * ek;
                    // Chase zeros.
                    for (int j = k; j < p - 1; j++) {
                        double t = FastMath.hypot(f, g);
                        double cs = f / t;
                        double sn = g / t;
                        if (j != k) {
                            e[j - 1] = t;
                        }
                        f = cs * singularValues[j] + sn * e[j];
                        e[j] = cs * e[j] - sn * singularValues[j];
                        g = sn * singularValues[j + 1];
                        singularValues[j + 1] = cs * singularValues[j + 1];
                        if (wantv) {
                            for (int i = 0; i < n; i++) {
                                t = cs * V[i][j] + sn * V[i][j + 1];
                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                                V[i][j] = t;
                            }
                        }
                        t = FastMath.hypot(f, g);
                        cs = f / t;
                        sn = g / t;
                        singularValues[j] = t;
                        f = cs * e[j] + sn * singularValues[j + 1];
                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];
                        g = sn * e[j + 1];
                        e[j + 1] = cs * e[j + 1];
                        if (wantu && (j < m - 1)) {
                            for (int i = 0; i < m; i++) {
                                t = cs * U[i][j] + sn * U[i][j + 1];
                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                                U[i][j] = t;
                            }
                        }
                    }
                    e[p - 2] = f;
                    iter = iter + 1;
                }
                break;
                // Convergence.
                default: {
                    // Make the singular values positive.
                    if (singularValues[k] <= 0.0) {
                        singularValues[k] = singularValues[k] < 0.0 ? -singularValues[k] : 0.0;
                        if (wantv) {
                            for (int i = 0; i <= pp; i++) {
                                V[i][k] = -V[i][k];
                            }
                        }
                    }
                    // Order the singular values.
                    while (k < pp) {
                        if (singularValues[k] >= singularValues[k + 1]) {
                            break;
                        }
                        double t = singularValues[k];
                        singularValues[k] = singularValues[k + 1];
                        singularValues[k + 1] = t;
                        if (wantv && (k < n - 1)) {
                            for (int i = 0; i < n; i++) {
                                t = V[i][k + 1];
                                V[i][k + 1] = V[i][k];
                                V[i][k] = t;
                            }
                        }
                        if (wantu && (k < m - 1)) {
                            for (int i = 0; i < m; i++) {
                                t = U[i][k + 1];
                                U[i][k + 1] = U[i][k];
                                U[i][k] = t;
                            }
                        }
                        k++;
                    }
                    iter = 0;
                    p--;
                }
                break;
            }
        }

        if (!transposed) {
            cachedU = MatrixUtils.createRealMatrix(U);
            cachedV = MatrixUtils.createRealMatrix(V);
        } else {
            cachedU = MatrixUtils.createRealMatrix(V);
            cachedV = MatrixUtils.createRealMatrix(U);

        }
    }",1,"[4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 62, 63, 65, 66, 67, 68, 69, 70, 71, 72, 73]"
3277,bugs-dot-jar_CAMEL-5699_6d63a502,"public void setShowExchangePattern(boolean showExchangePattern) {
        this.showExchangePattern = showExchangePattern;
    }","public void setShowExchangePattern(boolean showExchangePattern) {
        this.showExchangePattern = showExchangePattern;
    }",0,[0]
18960,bugs-dot-jar_OAK-546_428e32c6,"Condition property(String relPath, RelationOp op, Value value) {
        return new Condition.Property(relPath, op, value);
    }","Condition property(String relPath, RelationOp op, Value value) {
        return new Condition.Property(relPath, op, value);
    }",0,[0]
10442,bugs-dot-jar_WICKET-5230_9c8f658a,"protected boolean getUpdateModel()
	{
		return true;
	}","protected boolean getUpdateModel()
	{
		return true;
	}",0,[0]
36269,bugs-dot-jar_CAMEL-9444_baece126,"public RecipientListDefinition<Type> timeout(long timeout) {
        setTimeout(timeout);
        return this;
    }","public RecipientListDefinition<Type> timeout(long timeout) {
        setTimeout(timeout);
        return this;
    }",0,[0]
8360,bugs-dot-jar_ACCUMULO-366_db4a291f,"public Article extract(Reader reader) {
    XMLInputFactory xmlif = XMLInputFactory.newInstance();
    xmlif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.TRUE);
    
    XMLStreamReader xmlr = null;
    
    try {
      xmlr = xmlif.createXMLStreamReader(reader);
    } catch (XMLStreamException e1) {
      throw new RuntimeException(e1);
    }
    
    QName titleName = QName.valueOf(""title"");
    QName textName = QName.valueOf(""text"");
    QName revisionName = QName.valueOf(""revision"");
    QName timestampName = QName.valueOf(""timestamp"");
    QName commentName = QName.valueOf(""comment"");
    QName idName = QName.valueOf(""id"");
    
    Map<QName,StringBuilder> tags = new HashMap<QName,StringBuilder>();
    for (QName tag : new QName[] {titleName, textName, timestampName, commentName, idName}) {
      tags.put(tag, new StringBuilder());
    }
    
    StringBuilder articleText = tags.get(textName);
    StringBuilder titleText = tags.get(titleName);
    StringBuilder timestampText = tags.get(timestampName);
    StringBuilder commentText = tags.get(commentName);
    StringBuilder idText = tags.get(idName);
    
    StringBuilder current = null;
    boolean inRevision = false;
    while (true) {
      try {
        if (!xmlr.hasNext())
          break;
        xmlr.next();
      } catch (XMLStreamException e) {
        throw new RuntimeException(e);
      }
      QName currentName = null;
      if (xmlr.hasName()) {
        currentName = xmlr.getName();
      }
      if (xmlr.isStartElement() && tags.containsKey(currentName)) {
        if (!inRevision || (!currentName.equals(revisionName) && !currentName.equals(idName))) {
          current = tags.get(currentName);
          current.setLength(0);
        }
      } else if (xmlr.isStartElement() && currentName.equals(revisionName)) {
        inRevision = true;
      } else if (xmlr.isEndElement() && currentName.equals(revisionName)) {
        inRevision = false;
      } else if (xmlr.isEndElement() && current != null) {
        if (textName.equals(currentName)) {
          
          String title = titleText.toString();
          String text = articleText.toString();
          String comment = commentText.toString();
          int id = Integer.parseInt(idText.toString());
          long timestamp;
          try {
            timestamp = dateFormat.parse(timestampText.append(""+0000"").toString()).getTime();
            return new Article(id, title, timestamp, comment, text);
          } catch (ParseException e) {
            return null;
          }
        }
        current = null;
      } else if (current != null && xmlr.hasText()) {
        current.append(xmlr.getText());
      }
    }
    return null;
  }","public Article extract(Reader reader) {
    XMLInputFactory xmlif = XMLInputFactory.newInstance();
    xmlif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, Boolean.TRUE);
    
    XMLStreamReader xmlr = null;
    
    try {
      xmlr = xmlif.createXMLStreamReader(reader);
    } catch (XMLStreamException e1) {
      throw new RuntimeException(e1);
    }
    
    QName titleName = QName.valueOf(""title"");
    QName textName = QName.valueOf(""text"");
    QName revisionName = QName.valueOf(""revision"");
    QName timestampName = QName.valueOf(""timestamp"");
    QName commentName = QName.valueOf(""comment"");
    QName idName = QName.valueOf(""id"");
    
    Map<QName,StringBuilder> tags = new HashMap<QName,StringBuilder>();
    for (QName tag : new QName[] {titleName, textName, timestampName, commentName, idName}) {
      tags.put(tag, new StringBuilder());
    }
    
    StringBuilder articleText = tags.get(textName);
    StringBuilder titleText = tags.get(titleName);
    StringBuilder timestampText = tags.get(timestampName);
    StringBuilder commentText = tags.get(commentName);
    StringBuilder idText = tags.get(idName);
    
    StringBuilder current = null;
    boolean inRevision = false;
    while (true) {
      try {
        if (!xmlr.hasNext())
          break;
        xmlr.next();
      } catch (XMLStreamException e) {
        throw new RuntimeException(e);
      }
      QName currentName = null;
      if (xmlr.hasName()) {
        currentName = xmlr.getName();
      }
      if (xmlr.isStartElement() && tags.containsKey(currentName)) {
        if (!inRevision || (!currentName.equals(revisionName) && !currentName.equals(idName))) {
          current = tags.get(currentName);
          current.setLength(0);
        }
      } else if (xmlr.isStartElement() && currentName.equals(revisionName)) {
        inRevision = true;
      } else if (xmlr.isEndElement() && currentName.equals(revisionName)) {
        inRevision = false;
      } else if (xmlr.isEndElement() && current != null) {
        if (textName.equals(currentName)) {
          
          String title = titleText.toString();
          String text = articleText.toString();
          String comment = commentText.toString();
          int id = Integer.parseInt(idText.toString());
          long timestamp;
          try {
            timestamp = dateFormat.parse(timestampText.append(""+0000"").toString()).getTime();
            return new Article(id, title, timestamp, comment, text);
          } catch (ParseException e) {
            return null;
          }
        }
        current = null;
      } else if (current != null && xmlr.hasText()) {
        current.append(xmlr.getText());
      }
    }
    return null;
  }",0,[0]
19918,bugs-dot-jar_FLINK-3052_8dc70f2e,"public int getCostWeight() {
		return this.costWeight;
	}","public int getCostWeight() {
		return this.costWeight;
	}",0,[0]
1397,bugs-dot-jar_OAK-185_7fe28a0e,"public void orderBefore(String source, String target)
            throws ItemNotFoundException, InvalidItemStateException {
        Tree tree = getTree();
        if (tree.getChild(source) == null) {
            throw new ItemNotFoundException(""Not a child: "" + source);
        } else if (target != null && tree.getChild(target) == null) {
            throw new ItemNotFoundException(""Not a child: "" + target);
        } else {
            List<CoreValue> order = new ArrayList<CoreValue>();
            Set<String> added = new HashSet<String>();
            CoreValueFactory factory =
                    sessionDelegate.getContentSession().getCoreValueFactory();

            PropertyState property = tree.getProperty(""childOrder"");
            if (property != null) {
                for (CoreValue value : property.getValues()) {
                    String name = value.getString();
                    if (!name.equals(source) && !added.contains(property)
                            && !name.startsWith("":"")) {
                        if (name.equals(target)) {
                            order.add(factory.createValue(source));
                            added.add(source);
                        }
                        order.add(factory.createValue(name));
                        added.add(name);
                    }
                }
            }

            if (!added.contains(source)) {
                order.add(factory.createValue(source));
            }
            if (target != null && !added.contains(target)) {
                order.add(factory.createValue(source));
            }

            tree.setProperty(""childOrder"", order);
        }
    }","public void orderBefore(String source, String target)
            throws ItemNotFoundException, InvalidItemStateException {
        Tree tree = getTree();
        if (tree.getChild(source) == null) {
            throw new ItemNotFoundException(""Not a child: "" + source);
        } else if (target != null && tree.getChild(target) == null) {
            throw new ItemNotFoundException(""Not a child: "" + target);
        } else {
            List<CoreValue> order = new ArrayList<CoreValue>();
            Set<String> added = new HashSet<String>();
            CoreValueFactory factory =
                    sessionDelegate.getContentSession().getCoreValueFactory();

            PropertyState property = tree.getProperty(""childOrder"");
            if (property != null) {
                for (CoreValue value : property.getValues()) {
                    String name = value.getString();
                    if (!name.equals(source) && !added.contains(property)
                            && !name.startsWith("":"")) {
                        if (name.equals(target)) {
                            order.add(factory.createValue(source));
                            added.add(source);
                        }
                        order.add(factory.createValue(name));
                        added.add(name);
                    }
                }
            }

            if (!added.contains(source)) {
                order.add(factory.createValue(source));
            }
            if (target != null && !added.contains(target)) {
                order.add(factory.createValue(source));
            }

            tree.setProperty(""childOrder"", order);
        }
    }",0,[0]
7154,bugs-dot-jar_OAK-4387_ca05fd06,"private void initialize(String query) throws ParseException {
        if (query == null) {
            query = """";
        }
        statement = query;
        int len = query.length() + 1;
        char[] command = new char[len];
        int[] types = new int[len];
        len--;
        query.getChars(0, len, command, 0);
        command[len] = ' ';
        int startLoop = 0;
        for (int i = 0; i < len; i++) {
            char c = command[i];
            int type = 0;
            switch (c) {
            case '@':
            case '|':
            case '/':
            case '-':
            case '(':
            case ')':
            case '{':
            case '}':
            case '*':
            case ',':
            case ';':
            case '+':
            case '%':
            case '?':
            case '$':
            case '[':
            case ']':
                type = CHAR_SPECIAL_1;
                break;
            case '!':
            case '<':
            case '>':
            case '=':
                type = CHAR_SPECIAL_2;
                break;
            case '.':
                type = CHAR_DECIMAL;
                break;
            case '\'':
                type = CHAR_STRING;
                types[i] = CHAR_STRING;
                startLoop = i;
                while (command[++i] != '\'') {
                    checkRunOver(i, len, startLoop);
                }
                break;
            case '\""':
                type = CHAR_STRING;
                types[i] = CHAR_STRING;
                startLoop = i;
                while (command[++i] != '\""') {
                    checkRunOver(i, len, startLoop);
                }
                break;
            case ':':
            case '_':
                type = CHAR_NAME;
                break;
            default:
                if (c >= 'a' && c <= 'z') {
                    type = CHAR_NAME;
                } else if (c >= 'A' && c <= 'Z') {
                    type = CHAR_NAME;
                } else if (c >= '0' && c <= '9') {
                    type = CHAR_VALUE;
                } else {
                    if (Character.isJavaIdentifierPart(c)) {
                        type = CHAR_NAME;
                    }
                }
            }
            types[i] = (byte) type;
        }
        statementChars = command;
        types[len] = CHAR_END;
        characterTypes = types;
        parseIndex = 0;
    }","private void initialize(String query) throws ParseException {
        if (query == null) {
            query = """";
        }
        statement = query;
        int len = query.length() + 1;
        char[] command = new char[len];
        int[] types = new int[len];
        len--;
        query.getChars(0, len, command, 0);
        command[len] = ' ';
        int startLoop = 0;
        for (int i = 0; i < len; i++) {
            char c = command[i];
            int type = 0;
            switch (c) {
            case '@':
            case '|':
            case '/':
            case '-':
            case '(':
            case ')':
            case '{':
            case '}':
            case '*':
            case ',':
            case ';':
            case '+':
            case '%':
            case '?':
            case '$':
            case '[':
            case ']':
                type = CHAR_SPECIAL_1;
                break;
            case '!':
            case '<':
            case '>':
            case '=':
                type = CHAR_SPECIAL_2;
                break;
            case '.':
                type = CHAR_DECIMAL;
                break;
            case '\'':
                type = CHAR_STRING;
                types[i] = CHAR_STRING;
                startLoop = i;
                while (command[++i] != '\'') {
                    checkRunOver(i, len, startLoop);
                }
                break;
            case '\""':
                type = CHAR_STRING;
                types[i] = CHAR_STRING;
                startLoop = i;
                while (command[++i] != '\""') {
                    checkRunOver(i, len, startLoop);
                }
                break;
            case ':':
            case '_':
                type = CHAR_NAME;
                break;
            default:
                if (c >= 'a' && c <= 'z') {
                    type = CHAR_NAME;
                } else if (c >= 'A' && c <= 'Z') {
                    type = CHAR_NAME;
                } else if (c >= '0' && c <= '9') {
                    type = CHAR_VALUE;
                } else {
                    if (Character.isJavaIdentifierPart(c)) {
                        type = CHAR_NAME;
                    }
                }
            }
            types[i] = (byte) type;
        }
        statementChars = command;
        types[len] = CHAR_END;
        characterTypes = types;
        parseIndex = 0;
    }",0,[0]
9160,bugs-dot-jar_MATH-377_c640932d,"public double[] getImagEigenvalues() throws InvalidMatrixException {
        return imagEigenvalues.clone();
    }","public double[] getImagEigenvalues() throws InvalidMatrixException {
        return imagEigenvalues.clone();
    }",0,[0]
18951,bugs-dot-jar_OAK-546_428e32c6,"@Override
    public Condition gt(String relPath, Value value) {
        return new Condition.Property(relPath, RelationOp.GT, value);
    }","@Override
    public Condition gt(String relPath, Value value) {
        return new Condition.Property(relPath, RelationOp.GT, value);
    }",0,[0]
16473,bugs-dot-jar_OAK-1977_4bfbfcdd,"@Override
    public Cursor query(IndexPlan plan, NodeState root) {
        LOG.debug(""query(IndexPlan, NodeState)"");
        LOG.debug(""query() - plan: {}"", plan);
        LOG.debug(""query() - rootState: {}"", root);

        Filter filter = plan.getFilter();
        List<OrderEntry> sortOrder = plan.getSortOrder();
        Iterable<String> paths = null;
        OrderedContentMirrorStoreStrategy strategy
                = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());
        int depth = 1;
        PropertyRestriction pr = plan.getPropertyRestriction();
        if (pr != null) {
            String propertyName = PathUtils.getName(pr.propertyName);
            depth = PathUtils.getDepth(propertyName);
            paths = strategy.query(plan.getFilter(), propertyName,
                    plan.getDefinition(), pr);
        }
        if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {
            // we could be here if we have a query where the ORDER BY makes us play it.
            for (OrderEntry oe : sortOrder) {
                String propertyName = PathUtils.getName(oe.getPropertyName());
                depth = PathUtils.getDepth(oe.getPropertyName());
                paths = strategy.query(plan.getFilter(), propertyName,
                        plan.getDefinition(), new PropertyRestriction());
            }
        }

        if (paths == null) {
            // if still here then something went wrong.
            throw new IllegalStateException(
                    ""OrderedPropertyIndex index is used even when no index is available for filter ""
                            + filter);
        }
        Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());
        cursor = Cursors.newPrefixCursor(cursor, plan.getPathPrefix());
        if (depth > 1) {
            cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());
        }
        return cursor;
    }","@Override
    public Cursor query(IndexPlan plan, NodeState root) {
        LOG.debug(""query(IndexPlan, NodeState)"");
        LOG.debug(""query() - plan: {}"", plan);
        LOG.debug(""query() - rootState: {}"", root);

        Filter filter = plan.getFilter();
        List<OrderEntry> sortOrder = plan.getSortOrder();
        String pathPrefix = plan.getPathPrefix();
        Iterable<String> paths = null;
        OrderedContentMirrorStoreStrategy strategy
                = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());
        int depth = 1;
        PropertyRestriction pr = plan.getPropertyRestriction();
        if (pr != null) {
            String propertyName = PathUtils.getName(pr.propertyName);
            depth = PathUtils.getDepth(propertyName);
            paths = strategy.query(plan.getFilter(), propertyName,
                    plan.getDefinition(), pr, pathPrefix);
        }
        if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {
            // we could be here if we have a query where the ORDER BY makes us play it.
            for (OrderEntry oe : sortOrder) {
                String propertyName = PathUtils.getName(oe.getPropertyName());
                depth = PathUtils.getDepth(oe.getPropertyName());
                paths = strategy.query(plan.getFilter(), propertyName,
                        plan.getDefinition(), new PropertyRestriction(), pathPrefix);
            }
        }

        if (paths == null) {
            // if still here then something went wrong.
            throw new IllegalStateException(
                    ""OrderedPropertyIndex index is used even when no index is available for filter ""
                            + filter);
        }
        Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());
        if (depth > 1) {
            cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());
        }
        return cursor;
    }",1,"[17, 25, 36]"
10690,bugs-dot-jar_MNG-1797_5d99b35c,"public void explicitlyActivate( List profileIds )
    {
        for ( Iterator it = profileIds.iterator(); it.hasNext(); )
        {
            String profileId = (String) it.next();

            explicitlyActivate( profileId );
        }
    }","public void explicitlyActivate( List profileIds )
    {
        for ( Iterator it = profileIds.iterator(); it.hasNext(); )
        {
            String profileId = (String) it.next();

            explicitlyActivate( profileId );
        }
    }",0,[0]
516,Bears-16,"public boolean hasProperties() {
        return (_properties != null) && (_properties.size() > 0);
    }","public boolean hasProperties() {
        return (_properties != null) && (_properties.size() > 0);
    }",0,[0]
32622,bugs-dot-jar_WICKET-4370_7ca927c1,"public void setServerPort(int port)
	{
		serverPort = port;
	}","public void setServerPort(int port)
	{
		serverPort = port;
	}",0,[0]
15444,bugs-dot-jar_MATH-555_328513f3,"public static byte indicator(final byte x) {
        return (x >= ZB) ? PB : NB;
    }","public static byte indicator(final byte x) {
        return (x >= ZB) ? PB : NB;
    }",0,[0]
8259,bugs-dot-jar_CAMEL-3727_ff2713d1,"public void setExecutorService(ExecutorService executorService) {
        this.executorService = executorService;
    }","public void setExecutorService(ExecutorService executorService) {
        this.executorService = executorService;
    }",0,[0]
32012,bugs-dot-jar_OAK-2330_408a566e,"private boolean indexAggregatedNode(String path, List<Field> fields, Aggregate.NodeIncludeResult result)
            throws CommitFailedException {
        //rule for node being aggregated might be null if such nodes
        //are not indexed on there own. In such cases we rely in current
        //rule for some checks
        IndexDefinition.IndexingRule ruleAggNode = context.getDefinition()
                .getApplicableIndexingRule(getPrimaryTypeName(result.nodeState));
        boolean dirty = false;

        for (PropertyState property : result.nodeState.getProperties()){
            String pname = property.getName();

            if (!isVisible(pname)) {
                continue;
            }

            //Check if type is indexed
            int type = property.getType().tag();
            if (ruleAggNode != null ) {
                if (!ruleAggNode.includePropertyType(type)) {
                    continue;
                }
            } else if (!indexingRule.includePropertyType(type)){
                continue;
            }

            if (Type.BINARY == property.getType()) {
                String aggreagtedNodePath = PathUtils.concat(path, result.nodePath);
                this.context.indexUpdate();
                //Here the fulltext is being created for aggregate root hence nodePath passed
                //should be null
                String nodePath = result.isRelativeNode() ? result.rootIncludePath : null;
                fields.addAll(newBinary(property, result.nodeState, nodePath, aggreagtedNodePath + ""@"" + pname));
                dirty = true;
            } else {
                PropertyDefinition pd = null;
                if (ruleAggNode != null){
                    pd = ruleAggNode.getConfig(pname);
                }

                if (pd != null && !pd.nodeScopeIndex){
                    continue;
                }

                for (String value : property.getValue(Type.STRINGS)) {
                    this.context.indexUpdate();
                    Field field = result.isRelativeNode() ?
                            newFulltextField(result.rootIncludePath, value) : newFulltextField(value) ;
                    if (pd != null) {
                        field.setBoost(pd.boost);
                    }
                    fields.add(field);
                    dirty = true;
                }
            }
        }
        return dirty;
    }","private boolean indexAggregatedNode(String path, List<Field> fields, Aggregate.NodeIncludeResult result)
            throws CommitFailedException {
        //rule for node being aggregated might be null if such nodes
        //are not indexed on there own. In such cases we rely in current
        //rule for some checks
        IndexDefinition.IndexingRule ruleAggNode = context.getDefinition()
                .getApplicableIndexingRule(getPrimaryTypeName(result.nodeState));
        boolean dirty = false;

        for (PropertyState property : result.nodeState.getProperties()){
            String pname = property.getName();

            if (!isVisible(pname)) {
                continue;
            }

            //Check if type is indexed
            int type = property.getType().tag();
            if (ruleAggNode != null ) {
                if (!ruleAggNode.includePropertyType(type)) {
                    continue;
                }
            } else if (!indexingRule.includePropertyType(type)){
                continue;
            }

            if (Type.BINARY == property.getType()) {
                String aggreagtedNodePath = PathUtils.concat(path, result.nodePath);
                this.context.indexUpdate();
                //Here the fulltext is being created for aggregate root hence nodePath passed
                //should be null
                String nodePath = result.isRelativeNode() ? result.rootIncludePath : null;
                fields.addAll(newBinary(property, result.nodeState, nodePath, aggreagtedNodePath + ""@"" + pname));
                dirty = true;
            } else {
                PropertyDefinition pd = null;
                if (ruleAggNode != null){
                    pd = ruleAggNode.getConfig(pname);
                }

                if (pd != null && !pd.nodeScopeIndex){
                    continue;
                }

                for (String value : property.getValue(Type.STRINGS)) {
                    this.context.indexUpdate();
                    Field field = result.isRelativeNode() ?
                            newFulltextField(result.rootIncludePath, value) : newFulltextField(value) ;
                    if (pd != null) {
                        field.setBoost(pd.boost);
                    }
                    fields.add(field);
                    dirty = true;
                }
            }
        }
        return dirty;
    }",0,[0]
21857,bugs-dot-jar_MNG-2174_778f044e,"public boolean equals( Object o )
    {
        return o instanceof PomClassicDomainModel && getId().equals( ( (PomClassicDomainModel) o ).getId() );
    }","public boolean equals( Object o )
    {
        return o instanceof PomClassicDomainModel && getId().equals( ( (PomClassicDomainModel) o ).getId() );
    }",0,[0]
29349,bugs-dot-jar_LOG4J2-268_8faf7f77,"@Override
    public boolean isEndOfBatch() {
        return event.isEndOfBatch();
    }","@Override
    public boolean isEndOfBatch() {
        return event.isEndOfBatch();
    }",0,[0]
4887,bugs-dot-jar_LOG4J2-107_88641f49,"public PatternParser(String converterKey) {
        this(null, converterKey, null);
    }","public PatternParser(String converterKey) {
        this(null, converterKey, null);
    }",0,[0]
12552,bugs-dot-jar_WICKET-5686_8e794fc4,"private String getBeanNameOfClass(final ApplicationContext ctx, final Class<?> clazz,
		final boolean required)
	{
		// get the list of all possible matching beans
		List<String> names = new ArrayList<String>(
			Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));

		// filter out beans that are not candidates for autowiring
		if (ctx instanceof AbstractApplicationContext)
		{
			Iterator<String> it = names.iterator();
			while (it.hasNext())
			{
				final String possibility = it.next();
				BeanDefinition beanDef = getBeanDefinition(
					((AbstractApplicationContext)ctx).getBeanFactory(), possibility);
				if (BeanFactoryUtils.isFactoryDereference(possibility) ||
					possibility.startsWith(""scopedTarget."") ||
					(beanDef != null && !beanDef.isAutowireCandidate()))
				{
					it.remove();
				}
			}
		}

		if (names.isEmpty())
		{
			if (required)
			{
				throw new IllegalStateException(""bean of type ["" + clazz.getName() + ""] not found"");
			}
			return null;
		}
		else if (names.size() > 1)
		{
			if (ctx instanceof AbstractApplicationContext)
			{
				List<String> primaries = new ArrayList<>();
				for (String name : names)
				{
					BeanDefinition beanDef = getBeanDefinition(
						((AbstractApplicationContext)ctx).getBeanFactory(), name);
					if (beanDef instanceof AbstractBeanDefinition)
					{
						if (beanDef.isPrimary())
						{
							primaries.add(name);
						}
					}
				}
				if (primaries.size() == 1)
				{
					return primaries.get(0);
				}
			}
			StringBuilder msg = new StringBuilder();
			msg.append(""More than one bean of type ["");
			msg.append(clazz.getName());
			msg.append(""] found, you have to specify the name of the bean "");
			msg.append(""(@SpringBean(name=\""foo\"")) or (@Named(\""foo\"") if using @javax.inject classes) in order to resolve this conflict. "");
			msg.append(""Matched beans: "");
			msg.append(Strings.join("","", names.toArray(new String[names.size()])));
			throw new IllegalStateException(msg.toString());
		}
		else
		{
			return names.get(0);
		}
	}","private String getBeanNameOfClass(final ApplicationContext ctx, final Class<?> clazz,
		final boolean required)
	{
		// get the list of all possible matching beans
		List<String> names = new ArrayList<String>(
			Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(ctx, clazz)));

		// filter out beans that are not candidates for autowiring
		if (ctx instanceof AbstractApplicationContext)
		{
			Iterator<String> it = names.iterator();
			while (it.hasNext())
			{
				final String possibility = it.next();
				BeanDefinition beanDef = getBeanDefinition(
					((AbstractApplicationContext)ctx).getBeanFactory(), possibility);
				if (BeanFactoryUtils.isFactoryDereference(possibility) ||
					possibility.startsWith(""scopedTarget."") ||
					(beanDef != null && !beanDef.isAutowireCandidate()))
				{
					it.remove();
				}
			}
		}

		if (names.isEmpty())
		{
			if (required)
			{
				throw new IllegalStateException(""bean of type ["" + clazz.getName() + ""] not found"");
			}
			return null;
		}
		else if (names.size() > 1)
		{
			if (ctx instanceof AbstractApplicationContext)
			{
				List<String> primaries = new ArrayList<>();
				for (String name : names)
				{
					BeanDefinition beanDef = getBeanDefinition(
						((AbstractApplicationContext)ctx).getBeanFactory(), name);
					if (beanDef instanceof AbstractBeanDefinition)
					{
						if (beanDef.isPrimary())
						{
							primaries.add(name);
						}
					}
				}
				if (primaries.size() == 1)
				{
					return primaries.get(0);
				}
			}
			StringBuilder msg = new StringBuilder();
			msg.append(""More than one bean of type ["");
			msg.append(clazz.getName());
			msg.append(""] found, you have to specify the name of the bean "");
			msg.append(""(@SpringBean(name=\""foo\"")) or (@Named(\""foo\"") if using @javax.inject classes) in order to resolve this conflict. "");
			msg.append(""Matched beans: "");
			msg.append(Strings.join("","", names.toArray(new String[names.size()])));
			throw new IllegalStateException(msg.toString());
		}
		else
		{
			return names.get(0);
		}
	}",0,[0]
18156,bugs-dot-jar_WICKET-5147_184e51e9,"private void registerLastHandler(RequestCycle cycle, IRequestHandler handler)
	{
		if (handler instanceof IPageRequestHandler)
		{
			cycle.setMetaData(LAST_HANDLER_KEY, (IPageRequestHandler) handler);
		}
	}","private void registerLastHandler(RequestCycle cycle, IRequestHandler handler)
	{
		if (handler instanceof IPageRequestHandler)
		{
			cycle.setMetaData(LAST_HANDLER_KEY, (IPageRequestHandler) handler);
		}
	}",0,[0]
2322,bugs-dot-jar_MNG-4918_691a03a7,"@Deprecated
    public void attachArtifact( String type, String classifier, File file )
    {
    }","@Deprecated
    public void attachArtifact( String type, String classifier, File file )
    {
    }",0,[0]
23951,bugs-dot-jar_OAK-1363_69b68890,"@CheckForNull
    private String getUserId() {
        String uid = null;
        if (credentials != null) {
            if (credentials instanceof SimpleCredentials) {
                uid = ((SimpleCredentials) credentials).getUserID();
            } else if (credentials instanceof GuestCredentials) {
                uid = getAnonymousId();
            } else if (credentials instanceof ImpersonationCredentials) {
                Credentials bc = ((ImpersonationCredentials) credentials).getBaseCredentials();
                if (bc instanceof SimpleCredentials) {
                    uid = ((SimpleCredentials) bc).getUserID();
                }
            } else {
                try {
                    NameCallback callback = new NameCallback(""User-ID: "");
                    callbackHandler.handle(new Callback[]{callback});
                    uid = callback.getName();
                } catch (UnsupportedCallbackException e) {
                    log.warn(""Credentials- or NameCallback must be supported"");
                } catch (IOException e) {
                    log.error(""Name-Callback failed: "" + e.getMessage());
                }
            }
        }

        if (uid == null) {
            uid = getSharedLoginName();
        }
        return uid;
    }","@CheckForNull
    private String getUserId() {
        String uid = null;
        if (credentials != null) {
            if (credentials instanceof SimpleCredentials) {
                uid = ((SimpleCredentials) credentials).getUserID();
            } else if (credentials instanceof GuestCredentials) {
                uid = getAnonymousId();
            } else if (credentials instanceof ImpersonationCredentials) {
                Credentials bc = ((ImpersonationCredentials) credentials).getBaseCredentials();
                if (bc instanceof SimpleCredentials) {
                    uid = ((SimpleCredentials) bc).getUserID();
                }
            } else {
                try {
                    NameCallback callback = new NameCallback(""User-ID: "");
                    callbackHandler.handle(new Callback[]{callback});
                    uid = callback.getName();
                } catch (UnsupportedCallbackException e) {
                    log.warn(""Credentials- or NameCallback must be supported"");
                } catch (IOException e) {
                    log.error(""Name-Callback failed: "" + e.getMessage());
                }
            }
        }

        if (uid == null) {
            uid = getSharedLoginName();
        }
        return uid;
    }",0,[0]
994,Bears-129,"private Object decodeFri(Channel channel, SocketAddress remoteAddress, String sentence) {
        Parser parser = new Parser(PATTERN_FRI, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        LinkedList<Position> positions = new LinkedList<>();

        String vin = parser.next();
        int power = parser.nextInt(0);

        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());
        while (itemParser.find()) {
            Position position = new Position();
            position.setProtocol(getProtocolName());
            position.setDeviceId(deviceSession.getDeviceId());

            position.set(Position.KEY_VIN, vin);

            decodeLocation(position, itemParser);

            positions.add(position);
        }

        Position position = positions.getLast();

        decodeLocation(position, parser);

        // power value only on some devices
        if (power > 10) {
            position.set(Position.KEY_POWER, power);
        }

        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);
        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());

        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);
        position.set(Position.KEY_HOURS, parser.next());
        position.set(Position.PREFIX_ADC + 1, parser.next());
        position.set(Position.PREFIX_ADC + 2, parser.next());
        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());

        decodeStatus(position, parser);

        position.set(Position.KEY_RPM, parser.nextInt());
        position.set(Position.KEY_FUEL_LEVEL, parser.nextInt());

        decodeDeviceTime(position, parser);
        if (ignoreFixTime) {
            positions.clear();
            positions.add(position);
        }

        return positions;
    }","private Object decodeFri(Channel channel, SocketAddress remoteAddress, String sentence) {
        Parser parser = new Parser(PATTERN_FRI, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        LinkedList<Position> positions = new LinkedList<>();

        String vin = parser.next();
        int power = parser.nextInt(0);

        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());
        while (itemParser.find()) {
            Position position = new Position();
            position.setProtocol(getProtocolName());
            position.setDeviceId(deviceSession.getDeviceId());

            position.set(Position.KEY_VIN, vin);

            decodeLocation(position, itemParser);

            positions.add(position);
        }

        Position position = positions.getLast();

        decodeLocation(position, parser);

        // power value only on some devices
        if (power > 10) {
            position.set(Position.KEY_POWER, power);
        }

        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);
        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());

        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);
        position.set(Position.KEY_HOURS, parser.next());
        position.set(Position.PREFIX_ADC + 1, parser.next());
        position.set(Position.PREFIX_ADC + 2, parser.next());
        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());

        decodeStatus(position, parser);

        position.set(Position.KEY_RPM, parser.nextInt());
        position.set(Position.KEY_FUEL_LEVEL, parser.nextInt());

        decodeDeviceTime(position, parser);
        if (ignoreFixTime) {
            positions.clear();
            positions.add(position);
        }

        return positions;
    }",0,[0]
11352,bugs-dot-jar_OAK-395_e6c31270,"@Override
    public void removeShare() throws RepositoryException {
        throw new UnsupportedRepositoryOperationException(""TODO: Node.removeShare"");
    }","@Override
    public void removeShare() throws RepositoryException {
        throw new UnsupportedRepositoryOperationException(""TODO: Node.removeShare"");
    }",0,[0]
1945,bugs-dot-jar_CAMEL-3535_b56d2962,"public void setCompletionInterval(long completionInterval) {
        this.completionInterval = completionInterval;
    }","public void setCompletionInterval(long completionInterval) {
        this.completionInterval = completionInterval;
    }",0,[0]
127,Bears-6,"private void _collectIgnorals(String name)
    {
        if (!_forSerialization) {
            if (_ignoredPropertyNames == null) {
                _ignoredPropertyNames = new HashSet<String>();
            }
            _ignoredPropertyNames.add(name);
        }
    }","private void _collectIgnorals(String name)
    {
        if (!_forSerialization) {
            if (_ignoredPropertyNames == null) {
                _ignoredPropertyNames = new HashSet<String>();
            }
            _ignoredPropertyNames.add(name);
        }
    }",0,[0]
27133,bugs-dot-jar_MATH-395_962315ba,"public void resetAbsoluteAccuracy() {
        absoluteAccuracy = defaultAbsoluteAccuracy;
    }","public void resetAbsoluteAccuracy() {
        absoluteAccuracy = defaultAbsoluteAccuracy;
    }",0,[0]
13192,bugs-dot-jar_FLINK-2074_6bc6dbec,"@Override
	protected boolean currentNotEmpty() {
		return currentReducedMap != null;
	}","@Override
	protected boolean currentNotEmpty() {
		return currentReducedMap != null;
	}",0,[0]
31818,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"public void putDelete(Text columnFamily, Text columnQualifier, ColumnVisibility columnVisibility, long timestamp) {
    put(columnFamily, columnQualifier, columnVisibility.getExpression(), true, timestamp, true, EMPTY_BYTES);
  }","public void putDelete(Text columnFamily, Text columnQualifier, ColumnVisibility columnVisibility, long timestamp) {
    put(columnFamily, columnQualifier, columnVisibility.getExpression(), true, timestamp, true, EMPTY_BYTES);
  }",0,[0]
9369,bugs-dot-jar_CAMEL-5644_15d0fd9b,"private MethodInfo chooseMethodWithCustomAnnotations(Exchange exchange, Collection<MethodInfo> possibles)
        throws AmbiguousMethodCallException {
        // if we have only one method with custom annotations let's choose that
        MethodInfo chosen = null;
        for (MethodInfo possible : possibles) {
            if (possible.hasCustomAnnotation()) {
                if (chosen != null) {
                    chosen = null;
                    break;
                } else {
                    chosen = possible;
                }
            }
        }
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }","private MethodInfo chooseMethodWithCustomAnnotations(Exchange exchange, Collection<MethodInfo> possibles)
        throws AmbiguousMethodCallException {
        // if we have only one method with custom annotations let's choose that
        MethodInfo chosen = null;
        for (MethodInfo possible : possibles) {
            if (possible.hasCustomAnnotation()) {
                if (chosen != null) {
                    chosen = null;
                    break;
                } else {
                    chosen = possible;
                }
            }
        }
        if (chosen != null) {
            return chosen;
        }
        throw new AmbiguousMethodCallException(exchange, possibles);
    }",0,[0]
830,bugs-dot-jar_WICKET-4824_ad849602,"final Url mapHandler(IRequestHandler handler, Request request)
	{
		Url url = delegate.mapHandler(handler);

		Scheme desired = getDesiredSchemeFor(handler);
		Scheme current = getSchemeOf(request);
		if (!desired.isCompatibleWith(current))
		{
			// the generated url does not have the correct scheme, set it (which in turn will cause
			// the url to be rendered in its full representation)
			url.setProtocol(desired.urlName());
			if (url.getPort() != null || !desired.usesStandardPort(config))
			{
				url.setPort(desired.getPort(config));
			}
		}
		return url;
	}","final Url mapHandler(IRequestHandler handler, Request request)
	{
		Url url = delegate.mapHandler(handler);

		Scheme desired = getDesiredSchemeFor(handler);
		Scheme current = getSchemeOf(request);
		if (!desired.isCompatibleWith(current))
		{
			// the generated url does not have the correct scheme, set it (which in turn will cause
			// the url to be rendered in its full representation)
			url.setProtocol(desired.urlName());
			url.setPort(desired.getPort(config));
		}
		return url;
	}",1,"[11, 12, 13, 14]"
25573,bugs-dot-jar_ACCUMULO-2974_5eceb10e,"@Override
  public Path getFullPath(FileType fileType, String path) {
    int colon = path.indexOf(':');
    if (colon > -1) {
      // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL
      if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {
        path = path.substring(path.indexOf('/'));
      } else {
        return new Path(path);
      }
    }

    // normalize the path
    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
    if (path.startsWith(""/""))
      path = path.substring(1);
    fullPath = new Path(fullPath, path);

    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
    return fs.makeQualified(fullPath);
  }","@Override
  public Path getFullPath(FileType fileType, String path) {
    int colon = path.indexOf(':');
    if (colon > -1) {
      // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL
      if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {
        path = path.substring(path.indexOf('/'));
      } else {
        return new Path(path);
      }
    }

    if (path.startsWith(""/""))
      path = path.substring(1);

    // ACCUMULO-2974 To ensure that a proper absolute path is created, the caller needs to include the table ID
    // in the relative path. Fail when this doesn't appear to happen.
    if (FileType.TABLE == fileType) {
      // Trailing slash doesn't create an additional element
      String[] pathComponents = StringUtils.split(path, Path.SEPARATOR_CHAR);

      // Is an rfile
      if (path.endsWith(RFile.EXTENSION)) {
        if (pathComponents.length < 3) {
          throw new IllegalArgumentException(""Fewer components in file path than expected"");
        }
      } else {
        // is a directory
        if (pathComponents.length < 2) {
          throw new IllegalArgumentException(""Fewer components in directory path than expected"");
        }
      }
    }

    // normalize the path
    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
    fullPath = new Path(fullPath, path);

    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
    return fs.makeQualified(fullPath);
  }",1,"[12, 13]"
13437,bugs-dot-jar_MATH-434_133cbc2d,"boolean isOptimal() {
        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {
            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {
                return false;
            }
        }
        return true;
    }","boolean isOptimal() {
        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {
            final double entry = tableau.getEntry(0, i);
            if (MathUtils.compareTo(entry, 0d, epsilon) < 0) {
                return false;
            }
        }
        return true;
    }",1,[2]
1575,Bears-192,"public String getOwner() {
    return owner;
  }","public String getOwner() {
    return owner;
  }",0,[0]
12494,bugs-dot-jar_FLINK-2968_59685903,"@Override
	@SuppressWarnings(""unchecked"")
	public final void processElement(StreamRecord<IN> element) throws Exception {
		if (setProcessingTime) {
			element.replace(element.getValue(), System.currentTimeMillis());
		}

		Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());

		K key = keySelector.getKey(element.getValue());

		Map<W, Context> keyWindows = windows.get(key);
		if (keyWindows == null) {
			keyWindows = new HashMap<>();
			windows.put(key, keyWindows);
		}

		for (W window: elementWindows) {
			Context context = keyWindows.get(window);
			if (context == null) {
				WindowBuffer<IN> windowBuffer = windowBufferFactory.create();
				context = new Context(key, window, windowBuffer);
				keyWindows.put(window, context);
			}

			context.windowBuffer.storeElement(element);
			Trigger.TriggerResult triggerResult = context.onElement(element);
			processTriggerResult(triggerResult, key, window);
		}
	}","@Override
	@SuppressWarnings(""unchecked"")
	public final void processElement(StreamRecord<IN> element) throws Exception {
		if (setProcessingTime) {
			element.replace(element.getValue(), System.currentTimeMillis());
		}

		Collection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());

		K key = keySelector.getKey(element.getValue());

		Map<W, Context> keyWindows = windows.get(key);
		if (keyWindows == null) {
			keyWindows = new HashMap<>();
			windows.put(key, keyWindows);
		}

		for (W window: elementWindows) {
			Context context = keyWindows.get(window);
			if (context == null) {
				WindowBuffer<IN> windowBuffer = windowBufferFactory.create();
				context = new Context(key, window, windowBuffer);
				keyWindows.put(window, context);
			}

			context.windowBuffer.storeElement(element);
			Trigger.TriggerResult triggerResult = context.onElement(element);
			processTriggerResult(triggerResult, key, window);
		}
	}",0,[0]
7532,bugs-dot-jar_WICKET-2624_ef880545,"public final static Field getPropertyField(String expression, Object object)
	{
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
		if (setter == null)
		{
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +
				"" for getting the target classs of: "" + object);
		}
		return setter.getField();
	}","public final static Field getPropertyField(String expression, Object object)
	{
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
		if (setter == null)
		{
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +
				"" for getting the target classs of: "" + object);
		}
		return setter.getField();
	}",0,[0]
30765,bugs-dot-jar_OAK-2695_0598498e,"public static DocumentNodeState fromString(DocumentNodeStore store, String s) {
        JsopTokenizer json = new JsopTokenizer(s);
        String path = null;
        Revision rev = null;
        Revision lastRev = null;
        boolean hasChildren = false;
        DocumentNodeState state = null;
        HashMap<String, String> map = new HashMap<String, String>();
        while (true) {
            String k = json.readString();
            json.read(':');
            if (""path"".equals(k)) {
                path = json.readString();
            } else if (""rev"".equals(k)) {
                rev = Revision.fromString(json.readString());
            } else if (""lastRev"".equals(k)) {
                lastRev = Revision.fromString(json.readString());
            } else if (""hasChildren"".equals(k)) {
                hasChildren = json.read() == JsopReader.TRUE;
            } else if (""prop"".equals(k)) {
                json.read('{');
                while (true) {
                    if (json.matches('}')) {
                        break;
                    }
                    k = json.readString();
                    json.read(':');
                    String v = json.readString();
                    map.put(k, v);
                    json.matches(',');
                }
            }
            if (json.matches(JsopReader.END)) {
                break;
            }
            json.read(',');
        }
        state = new DocumentNodeState(store, path, rev, hasChildren);
        state.setLastRevision(lastRev);
        for (Entry<String, String> e : map.entrySet()) {
            state.setProperty(e.getKey(), e.getValue());
        }
        return state;
    }","public static DocumentNodeState fromString(DocumentNodeStore store, String s) {
        JsopTokenizer json = new JsopTokenizer(s);
        String path = null;
        Revision rev = null;
        Revision lastRev = null;
        boolean hasChildren = false;
        DocumentNodeState state = null;
        HashMap<String, String> map = new HashMap<String, String>();
        while (true) {
            String k = json.readString();
            json.read(':');
            if (""path"".equals(k)) {
                path = json.readString();
            } else if (""rev"".equals(k)) {
                rev = Revision.fromString(json.readString());
            } else if (""lastRev"".equals(k)) {
                lastRev = Revision.fromString(json.readString());
            } else if (""hasChildren"".equals(k)) {
                hasChildren = json.read() == JsopReader.TRUE;
            } else if (""prop"".equals(k)) {
                json.read('{');
                while (true) {
                    if (json.matches('}')) {
                        break;
                    }
                    k = json.readString();
                    json.read(':');
                    String v = json.readString();
                    map.put(k, v);
                    json.matches(',');
                }
            }
            if (json.matches(JsopReader.END)) {
                break;
            }
            json.read(',');
        }
        state = new DocumentNodeState(store, path, rev, hasChildren);
        state.setLastRevision(lastRev);
        for (Entry<String, String> e : map.entrySet()) {
            state.setProperty(e.getKey(), e.getValue());
        }
        return state;
    }",0,[0]
4633,bugs-dot-jar_MATH-326_ce185345,"public double dotProduct(RealVector v) throws IllegalArgumentException {
        checkVectorDimensions(v);
        double d = 0;
        Iterator<Entry> it = sparseIterator();
        Entry e;
        while (it.hasNext() && (e = it.next()) != null) {
            d += e.getValue() * v.getEntry(e.getIndex());
        }
        return d;
    }","public double dotProduct(RealVector v) throws IllegalArgumentException {
        checkVectorDimensions(v);
        double d = 0;
        Iterator<Entry> it = sparseIterator();
        Entry e;
        while (it.hasNext() && (e = it.next()) != null) {
            d += e.getValue() * v.getEntry(e.getIndex());
        }
        return d;
    }",0,[0]
26377,bugs-dot-jar_OAK-3310_4416a9f8,"private Iterator<Property> propertyIterator(Iterator<PropertyDelegate> properties) {
        return sessionDelegate.sync(transform(
                properties,
                new Function<PropertyDelegate, Property>() {
                    @Override
                    public Property apply(PropertyDelegate propertyDelegate) {
                        return new PropertyImpl(propertyDelegate, sessionContext);
                    }
                }));
    }","private Iterator<Property> propertyIterator(Iterator<PropertyDelegate> properties) {
        return sessionDelegate.sync(transform(
                properties,
                new Function<PropertyDelegate, Property>() {
                    @Override
                    public Property apply(PropertyDelegate propertyDelegate) {
                        return new PropertyImpl(propertyDelegate, sessionContext);
                    }
                }));
    }",0,[0]
7358,bugs-dot-jar_MATH-657_97b440fc,"public boolean isInfinite() {
        return isInfinite;
    }","public boolean isInfinite() {
        return isInfinite;
    }",0,[0]
7492,bugs-dot-jar_WICKET-4030_5f69685d,protected abstract Response getRealResponse();,protected abstract Response getRealResponse();,0,[0]
6874,bugs-dot-jar_OAK-2062_5c4589bd,"@Override
    public void unprepare() {
        plan = null;
        selectorConstraints.clear();
        isParent = false;
        joinCondition = null;
        allJoinConditions.clear();
    }","@Override
    public void unprepare() {
        plan = null;
        selectorConstraints.clear();
        isParent = false;
        joinCondition = null;
        allJoinConditions.clear();
    }",0,[0]
29323,bugs-dot-jar_WICKET-3539_a4459ef4,"public ComponentEventSender(Component source, IEventDispatcher dispatcher)
	{
		Args.notNull(source, ""source"");
		Args.notNull(dispatcher, ""dispatcher"");
		this.source = source;
		this.dispatcher = dispatcher;
	}","public ComponentEventSender(Component source, IEventDispatcher dispatcher)
	{
		Args.notNull(source, ""source"");
		Args.notNull(dispatcher, ""dispatcher"");
		this.source = source;
		this.dispatcher = dispatcher;
	}",0,[0]
4298,bugs-dot-jar_CAMEL-4682_1e54865c,"public ServicePool<Endpoint, Producer> getProducerServicePool() {
        return producerServicePool;
    }","public ServicePool<Endpoint, Producer> getProducerServicePool() {
        return producerServicePool;
    }",0,[0]
54,Bears-3,"protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf)
    {
        if (prop == null) {
            return prop;
        }
        String newName = xf.transform(prop.getName());
        prop = prop.withSimpleName(newName);
        JsonDeserializer<?> deser = prop.getValueDeserializer();
        if (deser != null) {
            @SuppressWarnings(""unchecked"")
            JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>)
                deser.unwrappingDeserializer(xf);
            if (newDeser != deser) {
                prop = prop.withValueDeserializer(newDeser);
            }
        }
        return prop;
    }","protected SettableBeanProperty _rename(SettableBeanProperty prop, NameTransformer xf)
    {
        if (prop == null) {
            return prop;
        }
        String newName = xf.transform(prop.getName());
        prop = prop.withSimpleName(newName);
        JsonDeserializer<?> deser = prop.getValueDeserializer();
        if (deser != null) {
            @SuppressWarnings(""unchecked"")
            JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>)
                deser.unwrappingDeserializer(xf);
            if (newDeser != deser) {
                prop = prop.withValueDeserializer(newDeser);
            }
        }
        return prop;
    }",0,[0]
19198,bugs-dot-jar_WICKET-4119_bb7a6995,"public void log(String msg, Throwable cause)
	{
		log.error(msg, cause);
	}","public void log(String msg, Throwable cause)
	{
		log.error(msg, cause);
	}",0,[0]
708,bugs-dot-jar_WICKET-4594_556a2236,"public PageProvider(IRequestablePage page)
	{
		Args.notNull(page, ""page"");

		pageInstance = page;
		pageId = page.getPageId();
		renderCount = page.getRenderCount();
	}","public PageProvider(IRequestablePage page)
	{
		Args.notNull(page, ""page"");

		pageInstance = page;
		pageId = page.getPageId();
		renderCount = page.getRenderCount();
	}",0,[0]
23207,bugs-dot-jar_OAK-1020_83427028,"boolean isProtected(String property) throws InvalidItemStateException {
        Tree tree = getTree();
        Tree typeRoot = sessionDelegate.getRoot().getTree(NODE_TYPES_PATH);
        List<Tree> types = TreeUtil.getEffectiveType(tree, typeRoot);

        boolean protectedResidual = false;
        for (Tree type : types) {
            if (contains(TreeUtil.getNames(type, OAK_PROTECTED_PROPERTIES), property)) {
                return true;
            } else if (!protectedResidual) {
                protectedResidual = TreeUtil.getBoolean(
                        type, OAK_HAS_PROTECTED_RESIDUAL_PROPERTIES);
            }
        }

        // Special case: There are one or more protected *residual*
        // child node definitions. Iterate through them to check whether
        // there's a matching, protected one.
        if (protectedResidual) {
            for (Tree type : types) {
                Tree definitions = type.getChild(OAK_RESIDUAL_PROPERTY_DEFINITIONS);
                for (Tree definition : definitions.getChildren()) {
                    // TODO: check for matching property type?
                    if (TreeUtil.getBoolean(definition, JCR_PROTECTED)) {
                        return true;
                    }
                }
            }
        }

        return false;
    }","boolean isProtected(String property) throws InvalidItemStateException {
        Tree tree = getTree();
        Tree typeRoot = sessionDelegate.getRoot().getTree(NODE_TYPES_PATH);
        List<Tree> types = TreeUtil.getEffectiveType(tree, typeRoot);

        boolean protectedResidual = false;
        for (Tree type : types) {
            if (contains(TreeUtil.getNames(type, OAK_PROTECTED_PROPERTIES), property)) {
                return true;
            } else if (!protectedResidual) {
                protectedResidual = TreeUtil.getBoolean(
                        type, OAK_HAS_PROTECTED_RESIDUAL_PROPERTIES);
            }
        }

        // Special case: There are one or more protected *residual*
        // child node definitions. Iterate through them to check whether
        // there's a matching, protected one.
        if (protectedResidual) {
            for (Tree type : types) {
                Tree definitions = type.getChild(OAK_RESIDUAL_PROPERTY_DEFINITIONS);
                for (Tree definition : definitions.getChildren()) {
                    // TODO: check for matching property type?
                    if (TreeUtil.getBoolean(definition, JCR_PROTECTED)) {
                        return true;
                    }
                }
            }
        }

        return false;
    }",0,[0]
37916,bugs-dot-jar_ACCUMULO-4138_50db442b,"protected Authorizations getAuths(final CommandLine cl, final Shell shellState) throws AccumuloSecurityException, AccumuloException {
    final String user = shellState.getConnector().whoami();
    Authorizations auths = shellState.getConnector().securityOperations().getUserAuthorizations(user);
    if (cl.hasOption(scanOptAuths.getOpt())) {
      auths = ScanCommand.parseAuthorizations(cl.getOptionValue(scanOptAuths.getOpt()));
    }
    return auths;
  }","protected Authorizations getAuths(final CommandLine cl, final Shell shellState) throws AccumuloSecurityException, AccumuloException {
    final String user = shellState.getConnector().whoami();
    Authorizations auths = shellState.getConnector().securityOperations().getUserAuthorizations(user);
    if (cl.hasOption(scanOptAuths.getOpt())) {
      auths = ScanCommand.parseAuthorizations(cl.getOptionValue(scanOptAuths.getOpt()));
    }
    return auths;
  }",0,[0]
24051,bugs-dot-jar_OAK-579_7d72e6ed,"public SelectorImpl(String nodeTypeName, String selectorName) {
        this.nodeTypeName = nodeTypeName;
        this.selectorName = selectorName;
    }","public SelectorImpl(String nodeTypeName, String selectorName) {
        this.nodeTypeName = nodeTypeName;
        this.selectorName = selectorName;
    }",0,[0]
295,Bears-14,"@Override
    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        // We may also have custom overrides:
        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
        if (custom != null) {
            return custom;
        }
        /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
        if (type.isThrowable()) {
            return buildThrowableDeserializer(ctxt, type, beanDesc);
        }
        /* Or, for abstract types, may have alternate means for resolution
         * (defaulting, materialization)
         */
        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
        //    not something we could materialize anything for
        if (type.isAbstract() && !type.isPrimitive()) {
            // Let's make it possible to materialize abstract types.
            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
            if (concreteType != null) {
                /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
                beanDesc = config.introspect(concreteType);
                return buildBeanDeserializer(ctxt, concreteType, beanDesc);
            }
        }

        // Otherwise, may want to check handlers for standard types, from superclass:
        @SuppressWarnings(""unchecked"")
        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
        if (deser != null) {
            return deser;
        }

        // Otherwise: could the class be a Bean class? If not, bail out
        if (!isPotentialBeanType(type.getRawClass())) {
            return null;
        }
        // Use generic bean introspection to build deserializer
        return buildBeanDeserializer(ctxt, type, beanDesc);
    }","@Override
    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        // We may also have custom overrides:
        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
        if (custom != null) {
            return custom;
        }
        /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
        if (type.isThrowable()) {
            return buildThrowableDeserializer(ctxt, type, beanDesc);
        }
        /* Or, for abstract types, may have alternate means for resolution
         * (defaulting, materialization)
         */
        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
        //    not something we could materialize anything for
        if (type.isAbstract() && !type.isPrimitive()) {
            // Let's make it possible to materialize abstract types.
            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
            if (concreteType != null) {
                /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
                beanDesc = config.introspect(concreteType);
                return buildBeanDeserializer(ctxt, concreteType, beanDesc);
            }
        }

        // Otherwise, may want to check handlers for standard types, from superclass:
        @SuppressWarnings(""unchecked"")
        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
        if (deser != null) {
            return deser;
        }

        // Otherwise: could the class be a Bean class? If not, bail out
        if (!isPotentialBeanType(type.getRawClass())) {
            return null;
        }
        // For checks like [databind#1599]
        checkIllegalTypes(ctxt, type, beanDesc);
        // Use generic bean introspection to build deserializer
        return buildBeanDeserializer(ctxt, type, beanDesc);
    }",1,[]
5953,bugs-dot-jar_OAK-3110_d10362c0,"@Override
    public int getMaxCopyInProgressCount() {
        return maxCopyInProgressCount.get();
    }","@Override
    public int getMaxCopyInProgressCount() {
        return maxCopyInProgressCount.get();
    }",0,[0]
17250,bugs-dot-jar_OAK-2389_7c320b1e,"@Override
    public JsopBuilder newline() {
        buff.append('\n');
        return this;
    }","@Override
    public JsopBuilder newline() {
        buff.append('\n');
        return this;
    }",0,[0]
855,Bears-115,"private void decodeTail(Position position, String data) {
        String[] values = data.split("","");
        int index = 0;

        Network network = new Network();

        int cellCount = Integer.parseInt(values[index++]);
        index += 1; // timing advance
        int mcc = Integer.parseInt(values[index++]);
        int mnc = Integer.parseInt(values[index++]);

        for (int i = 0; i < cellCount; i++) {
            network.addCellTower(CellTower.from(mcc, mnc,
                    Integer.parseInt(values[index++]), Integer.parseInt(values[index++]),
                    Integer.parseInt(values[index++])));
        }

        if (index < values.length && !values[index].isEmpty()) {
            int wifiCount = Integer.parseInt(values[index++]);

            for (int i = 0; i < wifiCount; i++) {
                index += 1; // wifi name
                network.addWifiAccessPoint(WifiAccessPoint.from(
                        values[index++], Integer.parseInt(values[index++])));
            }
        }

        if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
            position.setNetwork(network);
        }
    }","private void decodeTail(Position position, String data) {
        String[] values = data.split("","");
        int index = 0;

        Network network = new Network();

        int cellCount = Integer.parseInt(values[index++]);
        index += 1; // timing advance
        int mcc = Integer.parseInt(values[index++]);
        int mnc = Integer.parseInt(values[index++]);

        for (int i = 0; i < cellCount; i++) {
            network.addCellTower(CellTower.from(mcc, mnc,
                    Integer.parseInt(values[index++]), Integer.parseInt(values[index++]),
                    Integer.parseInt(values[index++])));
        }

        if (index < values.length && !values[index].isEmpty()) {
            int wifiCount = Integer.parseInt(values[index++]);

            for (int i = 0; i < wifiCount; i++) {
                index += 1; // wifi name
                network.addWifiAccessPoint(WifiAccessPoint.from(
                        values[index++], Integer.parseInt(values[index++])));
            }
        }

        if (network.getCellTowers() != null || network.getWifiAccessPoints() != null) {
            position.setNetwork(network);
        }
    }",0,[0]
37891,bugs-dot-jar_ACCUMULO-4138_50db442b,"@Override
  public Options getOptions() {
    final Options o = new Options();
    verboseOpt = new Option(""v"", ""verbose"", false, ""verbose output during merge"");
    sizeOpt = new Option(""s"", ""size"", true, ""merge tablets to the given size over the entire table"");
    forceOpt = new Option(""f"", ""force"", false, ""merge small tablets to large tablets, even if it goes over the given size"");
    allOpt = new Option("""", ""all"", false, ""allow an entire table to be merged into one tablet without prompting the user for confirmation"");
    Option startRowOpt = OptUtil.startRowOpt();
    startRowOpt.setDescription(""begin row (NOT inclusive)"");
    o.addOption(startRowOpt);
    o.addOption(OptUtil.endRowOpt());
    o.addOption(OptUtil.tableOpt(""table to be merged""));
    o.addOption(verboseOpt);
    o.addOption(sizeOpt);
    o.addOption(forceOpt);
    o.addOption(allOpt);
    return o;
  }","@Override
  public Options getOptions() {
    final Options o = new Options();
    verboseOpt = new Option(""v"", ""verbose"", false, ""verbose output during merge"");
    sizeOpt = new Option(""s"", ""size"", true, ""merge tablets to the given size over the entire table"");
    forceOpt = new Option(""f"", ""force"", false, ""merge small tablets to large tablets, even if it goes over the given size"");
    allOpt = new Option("""", ""all"", false, ""allow an entire table to be merged into one tablet without prompting the user for confirmation"");
    o.addOption(OptUtil.startRowOpt());
    o.addOption(OptUtil.endRowOpt());
    o.addOption(OptUtil.tableOpt(""table to be merged""));
    o.addOption(verboseOpt);
    o.addOption(sizeOpt);
    o.addOption(forceOpt);
    o.addOption(allOpt);
    return o;
  }",1,"[7, 8, 9]"
7032,bugs-dot-jar_LOG4J2-763_97203de8,"@Override
    public String[] getFormats() {
        final String[] formats = new String[MapFormat.values().length];
        int i = 0;
        for (final MapFormat format : MapFormat.values()) {
            formats[i++] = format.name();
        }
        return formats;
    }","@Override
    public String[] getFormats() {
        final String[] formats = new String[MapFormat.values().length];
        int i = 0;
        for (final MapFormat format : MapFormat.values()) {
            formats[i++] = format.name();
        }
        return formats;
    }",0,[0]
2684,bugs-dot-jar_OAK-1932_913c2f53,"protected boolean wasCompactedTo(Record after) {
        CompactionMap map = segmentId.getTracker().getCompactionMap();
        return map.wasCompactedTo(getRecordId(), after.getRecordId());
    }","protected boolean wasCompactedTo(Record after) {
        CompactionMap map = segmentId.getTracker().getCompactionMap();
        return map.wasCompactedTo(getRecordId(), after.getRecordId());
    }",0,[0]
13867,bugs-dot-jar_OAK-1174_342809f7,"public static boolean parse(String jcrPath, Listener listener) {
        // check for length
        int len = jcrPath == null ? 0 : jcrPath.length();

        // shortcut for root path
        if (len == 1 && jcrPath.charAt(0) == '/') {
            listener.root();
            return true;
        }

        // short cut for empty path
        if (len == 0) {
            return true;
        }

        // check if absolute path
        int pos = 0;
        if (jcrPath.charAt(0) == '/') {
            if (!listener.root()) {
                return false;
            }
            pos++;
        }

        // parse the path
        int state = STATE_PREFIX_START;

        int lastPos = pos;
        String name = null;

        int index = 0;
        boolean wasSlash = false;

        while (pos <= len) {
            char c = pos == len ? EOF : jcrPath.charAt(pos);
            pos++;
            // special check for whitespace
            if (c != ' ' && Character.isWhitespace(c)) {
                c = '\t';
            }
            
            switch (c) {
                case '/':
                case EOF:
                    if (state == STATE_PREFIX_START && c != EOF) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                                ""double slash '//' not allowed."");
                        return false;
                    }
                    if (state == STATE_PREFIX
                            || state == STATE_NAME
                            || state == STATE_INDEX_END
                            || state == STATE_URI_END) {

                        // eof path element
                        if (name == null) {
                            if (wasSlash) {
                                listener.error('\'' + jcrPath + ""' is not a valid path: "" +
                                        ""Trailing slashes not allowed in prefixes and names."");
                                return false;
                            }
                            name = jcrPath.substring(lastPos, pos - 1);
                        }

                        if (!JcrNameParser.parse(name, listener, index)) {
                            return false;
                        }
                        state = STATE_PREFIX_START;
                        lastPos = pos;
                        name = null;
                        index = 0;
                    } else if (state == STATE_DOT) {
                        if (!listener.current()) {
                            return false;
                        }
                        lastPos = pos;
                        state = STATE_PREFIX_START;
                    } else if (state == STATE_DOTDOT) {
                        if (!listener.parent()) {
                            return false;
                        }
                        lastPos = pos;
                        state = STATE_PREFIX_START;
                    } else if (state != STATE_URI
                            && !(state == STATE_PREFIX_START && c == EOF)) { // ignore trailing slash
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not a valid name character."");
                        return false;
                    }
                    break;

                case '.':
                    if (state == STATE_PREFIX_START) {
                        state = STATE_DOT;
                    } else if (state == STATE_DOT) {
                        state = STATE_DOTDOT;
                    } else if (state == STATE_DOTDOT) {
                        state = STATE_PREFIX;
                    } else if (state == STATE_INDEX_END) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid after index. '/' expected."");
                        return false;
                    }
                    break;

                case ':':
                    if (state == STATE_PREFIX_START) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. Prefix "" +
                                ""must not be empty"");
                        return false;
                    } else if (state == STATE_PREFIX) {
                        if (wasSlash) {
                            listener.error('\'' + jcrPath + ""' is not a valid path: "" +
                                    ""Trailing slashes not allowed in prefixes and names."");
                            return false;
                        }
                        state = STATE_NAME_START;
                        // don't reset the lastPos/pos since prefix+name are passed together to the NameResolver
                    } else if (state != STATE_URI) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid name character"");
                        return false;
                    }
                    break;

                case '[':
                    if (state == STATE_PREFIX || state == STATE_NAME) {
                        if (wasSlash) {
                            listener.error('\'' + jcrPath + ""' is not a valid path: "" +
                                    ""Trailing slashes not allowed in prefixes and names."");
                            return false;
                        }
                        state = STATE_INDEX;
                        name = jcrPath.substring(lastPos, pos - 1);
                        lastPos = pos;
                    }
                    break;

                case ']':
                    if (state == STATE_INDEX) {
                        try {
                            index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));
                        } catch (NumberFormatException e) {
                            listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                                    ""NumberFormatException in index: "" +
                                    jcrPath.substring(lastPos, pos - 1));
                            return false;
                        }
                        if (index < 0) {
                            listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                                    ""Index number invalid: "" + index);
                            return false;
                        }
                        state = STATE_INDEX_END;
                    } else {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not a valid name character."");
                        return false;
                    }
                    break;

                case ' ':
                    if (state == STATE_PREFIX_START || state == STATE_NAME_START) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid name start"");
                        return false;
                    } else if (state == STATE_INDEX_END) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid after index. '/' expected."");
                        return false;
                    } else if (state == STATE_DOT || state == STATE_DOTDOT) {
                        state = STATE_PREFIX;
                    }
                    break;

                case '\t':
                    listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                            ""Whitespace not a allowed in name."");
                    return false;
                case '*':
                case '|':
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                            ""' not a valid name character."");
                    return false;
                case '{':
                    if (state == STATE_PREFIX_START && lastPos == pos-1) {
                        // '{' marks the start of a uri enclosed in an expanded name
                        // instead of the usual namespace prefix, if it is
                        // located at the beginning of a new segment.
                        state = STATE_URI;
                    } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {
                        // otherwise it's part of the local name
                        state = STATE_NAME;
                    }
                    break;

                case '}':
                    if (state == STATE_URI) {
                        state = STATE_URI_END;
                    }
                    break;

                default:
                    if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {
                        state = STATE_PREFIX;
                    } else if (state == STATE_NAME_START) {
                        state = STATE_NAME;
                    } else if (state == STATE_INDEX_END) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid after index. '/' expected."");
                        return false;
                    }
            }
            wasSlash = c == ' ';
        }
        return true;
    }","public static boolean parse(String jcrPath, Listener listener) {
        // check for length
        int len = jcrPath == null ? 0 : jcrPath.length();

        // shortcut for root path
        if (len == 1 && jcrPath.charAt(0) == '/') {
            listener.root();
            return true;
        }

        // short cut for empty path
        if (len == 0) {
            return true;
        }

        // check if absolute path
        int pos = 0;
        if (jcrPath.charAt(0) == '/') {
            if (!listener.root()) {
                return false;
            }
            pos++;
        }

        // parse the path
        int state = STATE_PREFIX_START;

        int lastPos = pos;
        String name = null;

        int index = 0;
        boolean wasSlash = false;

        while (pos <= len) {
            char c = pos == len ? EOF : jcrPath.charAt(pos);
            pos++;

            switch (c) {
                case '/':
                case EOF:
                    if (state == STATE_PREFIX_START && c != EOF) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                                ""double slash '//' not allowed."");
                        return false;
                    }
                    if (state == STATE_PREFIX
                            || state == STATE_NAME
                            || state == STATE_INDEX_END
                            || state == STATE_URI_END) {

                        // eof path element
                        if (name == null) {
                            if (wasSlash) {
                                listener.error('\'' + jcrPath + ""' is not a valid path: "" +
                                        ""Trailing slashes not allowed in prefixes and names."");
                                return false;
                            }
                            name = jcrPath.substring(lastPos, pos - 1);
                        }

                        if (!JcrNameParser.parse(name, listener, index)) {
                            return false;
                        }
                        state = STATE_PREFIX_START;
                        lastPos = pos;
                        name = null;
                        index = 0;
                    } else if (state == STATE_DOT) {
                        if (!listener.current()) {
                            return false;
                        }
                        lastPos = pos;
                        state = STATE_PREFIX_START;
                    } else if (state == STATE_DOTDOT) {
                        if (!listener.parent()) {
                            return false;
                        }
                        lastPos = pos;
                        state = STATE_PREFIX_START;
                    } else if (state != STATE_URI
                            && !(state == STATE_PREFIX_START && c == EOF)) { // ignore trailing slash
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not a valid name character."");
                        return false;
                    }
                    break;

                case '.':
                    if (state == STATE_PREFIX_START) {
                        state = STATE_DOT;
                    } else if (state == STATE_DOT) {
                        state = STATE_DOTDOT;
                    } else if (state == STATE_DOTDOT) {
                        state = STATE_PREFIX;
                    } else if (state == STATE_INDEX_END) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid after index. '/' expected."");
                        return false;
                    }
                    break;

                case ':':
                    if (state == STATE_PREFIX_START) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. Prefix "" +
                                ""must not be empty"");
                        return false;
                    } else if (state == STATE_PREFIX) {
                        if (wasSlash) {
                            listener.error('\'' + jcrPath + ""' is not a valid path: "" +
                                    ""Trailing slashes not allowed in prefixes and names."");
                            return false;
                        }
                        state = STATE_NAME_START;
                        // don't reset the lastPos/pos since prefix+name are passed together to the NameResolver
                    } else if (state != STATE_URI) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid name character"");
                        return false;
                    }
                    break;

                case '[':
                    if (state == STATE_PREFIX || state == STATE_NAME) {
                        if (wasSlash) {
                            listener.error('\'' + jcrPath + ""' is not a valid path: "" +
                                    ""Trailing slashes not allowed in prefixes and names."");
                            return false;
                        }
                        state = STATE_INDEX;
                        name = jcrPath.substring(lastPos, pos - 1);
                        lastPos = pos;
                    }
                    break;

                case ']':
                    if (state == STATE_INDEX) {
                        try {
                            index = Integer.parseInt(jcrPath.substring(lastPos, pos - 1));
                        } catch (NumberFormatException e) {
                            listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                                    ""NumberFormatException in index: "" +
                                    jcrPath.substring(lastPos, pos - 1));
                            return false;
                        }
                        if (index < 0) {
                            listener.error('\'' + jcrPath + ""' is not a valid path. "" +
                                    ""Index number invalid: "" + index);
                            return false;
                        }
                        state = STATE_INDEX_END;
                    } else {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not a valid name character."");
                        return false;
                    }
                    break;

                case '*':
                case '|':
                    listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                            ""' not a valid name character."");
                    return false;
                case '{':
                    if (state == STATE_PREFIX_START && lastPos == pos-1) {
                        // '{' marks the start of a uri enclosed in an expanded name
                        // instead of the usual namespace prefix, if it is
                        // located at the beginning of a new segment.
                        state = STATE_URI;
                    } else if (state == STATE_NAME_START || state == STATE_DOT || state == STATE_DOTDOT) {
                        // otherwise it's part of the local name
                        state = STATE_NAME;
                    }
                    break;

                case '}':
                    if (state == STATE_URI) {
                        state = STATE_URI_END;
                    }
                    break;

                default:
                    if (state == STATE_PREFIX_START || state == STATE_DOT || state == STATE_DOTDOT) {
                        state = STATE_PREFIX;
                    } else if (state == STATE_NAME_START) {
                        state = STATE_NAME;
                    } else if (state == STATE_INDEX_END) {
                        listener.error('\'' + jcrPath + ""' is not a valid path. '"" + c +
                                ""' not valid after index. '/' expected."");
                        return false;
                    }
            }
            wasSlash = c == '/';
        }
        return true;
    }",1,"[36, 37, 38, 39, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 213]"
18708,bugs-dot-jar_ACCUMULO-3218_1b35d263,"public ClientConfiguration withSsl(boolean sslEnabled, boolean useJsseConfig) {
    return with(ClientProperty.INSTANCE_RPC_SSL_ENABLED, String.valueOf(sslEnabled)).with(ClientProperty.RPC_USE_JSSE, String.valueOf(useJsseConfig));
  }","public ClientConfiguration withSsl(boolean sslEnabled, boolean useJsseConfig) {
    return with(ClientProperty.INSTANCE_RPC_SSL_ENABLED, String.valueOf(sslEnabled)).with(ClientProperty.RPC_USE_JSSE, String.valueOf(useJsseConfig));
  }",0,[0]
6888,bugs-dot-jar_OAK-2062_5c4589bd,"public String currentPath() {
        return cursor == null ? null : currentRow.getPath();
    }","public String currentPath() {
        return cursor == null ? null : currentRow.getPath();
    }",0,[0]
34341,bugs-dot-jar_CAMEL-3281_f7dd2fff,"public OnExceptionDefinition onException(Class... exceptions) {
        OnExceptionDefinition last = null;
        for (Class ex : exceptions) {
            last = last == null ? onException(ex) : last.onException(ex);
        }
        return last != null ? last : onException(Exception.class);
    }","public OnExceptionDefinition onException(Class... exceptions) {
        OnExceptionDefinition last = null;
        for (Class ex : exceptions) {
            last = last == null ? onException(ex) : last.onException(ex);
        }
        return last != null ? last : onException(Exception.class);
    }",0,[0]
9552,bugs-dot-jar_WICKET-2281_6e0b40bc,"public void addCookie(final Cookie cookie)
	{
		cookies.add(cookie);
	}","public void addCookie(final Cookie cookie)
	{
		cookies.add(cookie);
	}",0,[0]
8987,bugs-dot-jar_ACCUMULO-1051_25cf3ccd,"public String serialize() {
    StringBuilder sb = new StringBuilder(HEADER);
    String sep = """";
    for (ByteSequence auth : auths) {
      sb.append(sep);
      sep = "","";
      sb.append(new String(Base64.encodeBase64(auth.toArray())));
    }
    
    return sb.toString();
  }","public String serialize() {
    StringBuilder sb = new StringBuilder(HEADER);
    String sep = """";
    for (ByteSequence auth : auths) {
      sb.append(sep);
      sep = "","";
      sb.append(new String(Base64.encodeBase64(auth.toArray())));
    }
    
    return sb.toString();
  }",0,[0]
35384,bugs-dot-jar_ACCUMULO-1986_2d97b875,"private byte[] readBytes(SimpleReader in) {
    int len = (int)in.readVLong();
    if (len == 0)
      return EMPTY_BYTES;
    
    byte bytes[] = new byte[len];
    in.readBytes(bytes);
    return bytes;
  }","private byte[] readBytes(SimpleReader in) {
    int len = (int)in.readVLong();
    if (len == 0)
      return EMPTY_BYTES;
    
    byte bytes[] = new byte[len];
    in.readBytes(bytes);
    return bytes;
  }",0,[0]
12370,bugs-dot-jar_WICKET-4841_ce172da8,"@SuppressWarnings(""unchecked"")
	@Override
	public List<String> getHeaders(String name)
	{
		List<String> result = new ArrayList<String>();
		Enumeration<String> e = httpServletRequest.getHeaders(name);
		while (e.hasMoreElements())
		{
			result.add(e.nextElement());
		}
		return Collections.unmodifiableList(result);
	}","@SuppressWarnings(""unchecked"")
	@Override
	public List<String> getHeaders(String name)
	{
		List<String> result = new ArrayList<String>();
		Enumeration<String> e = httpServletRequest.getHeaders(name);
		while (e.hasMoreElements())
		{
			result.add(e.nextElement());
		}
		return Collections.unmodifiableList(result);
	}",0,[0]
21410,bugs-dot-jar_CAMEL-9672_84922699,"public Object getManagedObjectForProducer(CamelContext context, Producer producer) {
        ManagedProducer mp = new ManagedProducer(context, producer);
        mp.init(context.getManagementStrategy());
        return mp;
    }","public Object getManagedObjectForProducer(CamelContext context, Producer producer) {
        ManagedProducer mp = new ManagedProducer(context, producer);
        mp.init(context.getManagementStrategy());
        return mp;
    }",0,[0]
271,Bears-12,"public BuilderBasedDeserializer(BuilderBasedDeserializer src, ObjectIdReader oir) {
        super(src, oir);
        _buildMethod = src._buildMethod;
    }","public BuilderBasedDeserializer(BuilderBasedDeserializer src, ObjectIdReader oir) {
        super(src, oir);
        _buildMethod = src._buildMethod;
    }",0,[0]
1540,bugs-dot-jar_MATH-290_b01fcc31,"private Integer getBasicRow(final int col) {
        return getBasicRow(col, true);
    }","private Integer getBasicRow(final int col) {
        return getBasicRow(col, true);
    }",0,[0]
3607,bugs-dot-jar_WICKET-4256_09166ea8,"final void setId(final String id)
	{
		if (!(this instanceof Page))
		{
			if (Strings.isEmpty(id))
			{
				throw new WicketRuntimeException(""Null or empty component ID's are not allowed."");
			}
		}

		if ((id != null) && (id.indexOf(':') != -1 || id.indexOf('~') != -1))
		{
			throw new WicketRuntimeException(""The component ID must not contain ':' or '~' chars."");
		}

		this.id = id;
	}","final void setId(final String id)
	{
		if (!(this instanceof Page))
		{
			if (Strings.isEmpty(id))
			{
				throw new WicketRuntimeException(""Null or empty component ID's are not allowed."");
			}
		}

		if ((id != null) && (id.indexOf(':') != -1 || id.indexOf('~') != -1))
		{
			throw new WicketRuntimeException(""The component ID must not contain ':' or '~' chars."");
		}

		this.id = id;
	}",0,[0]
19131,bugs-dot-jar_OAK-1215_a9efe3c4,"public PropertyValue currentOakProperty(String oakPropertyName) {
        boolean relative = oakPropertyName.indexOf('/') >= 0;
        Tree t = currentTree();
        if (relative) {
            for (String p : PathUtils.elements(PathUtils.getParentPath(oakPropertyName))) {
                if (t == null) {
                    return null;
                }
                if (p.equals("".."")) {
                    t = t.isRoot() ? null : t.getParent();
                } else if (p.equals(""."")) {
                    // same node
                } else {
                    t = t.getChild(p);
                }
            }
            oakPropertyName = PathUtils.getName(oakPropertyName);
        }
        if (t == null || !t.exists()) {
            return null;
        }
        if (oakPropertyName.equals(QueryImpl.JCR_PATH)) {
            String path = currentPath();
            String local = getLocalPath(path);
            if (local == null) {
                // not a local path
                return null;
            }
            return PropertyValues.newString(local);
        } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {
            return currentRow.getValue(QueryImpl.JCR_SCORE);
        } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {
            return currentRow.getValue(QueryImpl.REP_EXCERPT);
        }
        return PropertyValues.create(t.getProperty(oakPropertyName));
    }","public PropertyValue currentOakProperty(String oakPropertyName) {
        return currentOakProperty(oakPropertyName, null);
    }",1,"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]"
15462,bugs-dot-jar_MATH-555_328513f3,"public static byte sign(final byte x) {
        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
    }","public static byte sign(final byte x) {
        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;
    }",0,[0]
12580,bugs-dot-jar_MATH-864_abe53a53,"private static RealMatrix sumRows(final RealMatrix m) {
        double[][] d = new double[1][m.getColumnDimension()];
        for (int c = 0; c < m.getColumnDimension(); c++) {
            double sum = 0;
            for (int r = 0; r < m.getRowDimension(); r++) {
                sum += m.getEntry(r, c);
            }
            d[0][c] = sum;
        }
        return new Array2DRowRealMatrix(d, false);
    }","private static RealMatrix sumRows(final RealMatrix m) {
        double[][] d = new double[1][m.getColumnDimension()];
        for (int c = 0; c < m.getColumnDimension(); c++) {
            double sum = 0;
            for (int r = 0; r < m.getRowDimension(); r++) {
                sum += m.getEntry(r, c);
            }
            d[0][c] = sum;
        }
        return new Array2DRowRealMatrix(d, false);
    }",0,[0]
14553,bugs-dot-jar_WICKET-5176_34634266,"@Override
	public void setObject(String object)
	{
		throw new UnsupportedOperationException();
	}","@Override
	public void setObject(String object)
	{
		throw new UnsupportedOperationException();
	}",0,[0]
2553,bugs-dot-jar_MNG-3131_56cd921f,"public List<Parameter> getParameters()
    {
        return parameters;
    }","public List<Parameter> getParameters()
    {
        return parameters;
    }",0,[0]
40352,bugs-dot-jar_LOG4J2-219_ed951c76,"private Object createPluginObject(final PluginType type, final Node node, final LogEvent event)
    {
        final Class clazz = type.getPluginClass();

        if (Map.class.isAssignableFrom(clazz)) {
            try {
                @SuppressWarnings(""unchecked"")
                final Map<String, Object> map = (Map<String, Object>) clazz.newInstance();
                for (final Node child : node.getChildren()) {
                    map.put(child.getName(), child.getObject());
                }
                return map;
            } catch (final Exception ex) {
                LOGGER.warn(""Unable to create Map for "" + type.getElementName() + "" of class "" +
                    clazz);
            }
        }

        if (List.class.isAssignableFrom(clazz)) {
            try {
                @SuppressWarnings(""unchecked"")
                final List<Object> list = (List<Object>) clazz.newInstance();
                for (final Node child : node.getChildren()) {
                    list.add(child.getObject());
                }
                return list;
            } catch (final Exception ex) {
                LOGGER.warn(""Unable to create List for "" + type.getElementName() + "" of class "" +
                    clazz);
            }
        }

        Method factoryMethod = null;

        for (final Method method : clazz.getMethods()) {
            if (method.isAnnotationPresent(PluginFactory.class)) {
                factoryMethod = method;
                break;
            }
        }
        if (factoryMethod == null) {
            return null;
        }

        final Annotation[][] parmArray = factoryMethod.getParameterAnnotations();
        final Class[] parmClasses = factoryMethod.getParameterTypes();
        if (parmArray.length != parmClasses.length) {
            LOGGER.error(""Number of parameter annotations does not equal the number of paramters"");
        }
        final Object[] parms = new Object[parmClasses.length];

        int index = 0;
        final Map<String, String> attrs = node.getAttributes();
        final List<Node> children = node.getChildren();
        final StringBuilder sb = new StringBuilder();
        final List<Node> used = new ArrayList<Node>();

        /*
         * For each parameter:
         * If the parameter is an attribute store the value of the attribute in the parameter array.
         * If the parameter is an element:
         *   Determine if the required parameter is an array.
         *     If so, if a child contains the array, use it,
         *      otherwise create the array from all child nodes of the correct type.
         *     Store the array into the parameter array.
         *   If not an array, store the object in the child node into the parameter array.
         */
        for (final Annotation[] parmTypes : parmArray) {
            for (final Annotation a : parmTypes) {
                if (sb.length() == 0) {
                    sb.append("" with params("");
                } else {
                    sb.append("", "");
                }
                if (a instanceof PluginNode) {
                    parms[index] = node;
                    sb.append(""Node="").append(node.getName());
                } else if (a instanceof PluginConfiguration) {
                    parms[index] = this;
                    if (this.name != null) {
                        sb.append(""Configuration("").append(name).append("")"");
                    } else {
                        sb.append(""Configuration"");
                    }
                } else if (a instanceof PluginValue) {
                    final String name = ((PluginValue) a).value();
                    String v = node.getValue();
                    if (v == null) {
                        v = getAttrValue(""value"", attrs);
                    }
                    final String value = subst.replace(event, v);
                    sb.append(name).append(""=\"""").append(value).append(""\"""");
                    parms[index] = value;
                } else if (a instanceof PluginAttr) {
                    final String name = ((PluginAttr) a).value();
                    final String value = subst.replace(event, getAttrValue(name, attrs));
                    sb.append(name).append(""=\"""").append(value).append(""\"""");
                    parms[index] = value;
                } else if (a instanceof PluginElement) {
                    final PluginElement elem = (PluginElement) a;
                    final String name = elem.value();
                    if (parmClasses[index].isArray()) {
                        final Class<?> parmClass = parmClasses[index].getComponentType();
                        final List<Object> list = new ArrayList<Object>();
                        sb.append(name).append(""={"");
                        boolean first = true;
                        for (final Node child : children) {
                            final PluginType childType = child.getType();
                            if (elem.value().equalsIgnoreCase(childType.getElementName()) ||
                                parmClass.isAssignableFrom(childType.getPluginClass())) {
                                used.add(child);
                                if (!first) {
                                    sb.append("", "");
                                }
                                first = false;
                                final Object obj = child.getObject();
                                if (obj == null) {
                                    LOGGER.error(""Null object returned for "" + child.getName() + "" in "" +
                                        node.getName());
                                    continue;
                                }
                                if (obj.getClass().isArray()) {
                                    printArray(sb, (Object[]) obj);
                                    parms[index] = obj;
                                    break;
                                }
                                sb.append(child.toString());
                                list.add(obj);
                            }
                        }
                        sb.append(""}"");
                        if (parms[index] != null) {
                            break;
                        }
                        if (list.size() > 0 && !parmClass.isAssignableFrom(list.get(0).getClass())) {
                            LOGGER.error(""Attempted to assign List containing class "" +
                                list.get(0).getClass().getName() + "" to array of type "" + parmClass +
                                "" for attribute "" + name);
                            break;
                        }
                        final Object[] array = (Object[]) Array.newInstance(parmClass, list.size());
                        int i = 0;
                        for (final Object obj : list) {
                            array[i] = obj;
                            ++i;
                        }
                        parms[index] = array;
                    } else {
                        final Class<?> parmClass = parmClasses[index];
                        boolean present = false;
                        for (final Node child : children) {
                            final PluginType childType = child.getType();
                            if (elem.value().equals(childType.getElementName()) ||
                                parmClass.isAssignableFrom(childType.getPluginClass())) {
                                sb.append(child.getName()).append(""("").append(child.toString()).append("")"");
                                present = true;
                                used.add(child);
                                parms[index] = child.getObject();
                                break;
                            }
                        }
                        if (!present) {
                            sb.append(""null"");
                        }
                    }
                }
            }
            ++index;
        }
        if (sb.length() > 0) {
            sb.append("")"");
        }

        if (attrs.size() > 0) {
            final StringBuilder eb = new StringBuilder();
            for (final String key : attrs.keySet()) {
                if (eb.length() == 0) {
                    eb.append(node.getName());
                    eb.append("" contains "");
                    if (attrs.size() == 1) {
                        eb.append(""an invalid element or attribute "");
                    } else {
                        eb.append(""invalid attributes "");
                    }
                } else {
                    eb.append("", "");
                }
                eb.append(""\"""");
                eb.append(key);
                eb.append(""\"""");

            }
            LOGGER.error(eb.toString());
        }

        if (!type.isDeferChildren() && used.size() != children.size()) {
            for (final Node child : children) {
                if (used.contains(child)) {
                    continue;
                }
                final String nodeType = node.getType().getElementName();
                final String start = nodeType.equals(node.getName()) ? node.getName() : nodeType + "" "" + node.getName();
                LOGGER.error(start + "" has no parameter that matches element "" + child.getName());
            }
        }

        try {
            final int mod = factoryMethod.getModifiers();
            if (!Modifier.isStatic(mod)) {
                LOGGER.error(factoryMethod.getName() + "" method is not static on class "" +
                    clazz.getName() + "" for element "" + node.getName());
                return null;
            }
            LOGGER.debug(""Calling {} on class {} for element {}{}"", factoryMethod.getName(), clazz.getName(),
                node.getName(), sb.toString());
            //if (parms.length > 0) {
                return factoryMethod.invoke(null, parms);
            //}
            //return factoryMethod.invoke(null, node);
        } catch (final Exception e) {
            LOGGER.error(""Unable to invoke method "" + factoryMethod.getName() + "" in class "" +
                clazz.getName() + "" for element "" + node.getName(), e);
        }
        return null;
    }","private Object createPluginObject(final PluginType type, final Node node, final LogEvent event)
    {
        final Class clazz = type.getPluginClass();

        if (Map.class.isAssignableFrom(clazz)) {
            try {
                @SuppressWarnings(""unchecked"")
                final Map<String, Object> map = (Map<String, Object>) clazz.newInstance();
                for (final Node child : node.getChildren()) {
                    map.put(child.getName(), child.getObject());
                }
                return map;
            } catch (final Exception ex) {
                LOGGER.warn(""Unable to create Map for "" + type.getElementName() + "" of class "" +
                    clazz);
            }
        }

        if (List.class.isAssignableFrom(clazz)) {
            try {
                @SuppressWarnings(""unchecked"")
                final List<Object> list = (List<Object>) clazz.newInstance();
                for (final Node child : node.getChildren()) {
                    list.add(child.getObject());
                }
                return list;
            } catch (final Exception ex) {
                LOGGER.warn(""Unable to create List for "" + type.getElementName() + "" of class "" +
                    clazz);
            }
        }

        Method factoryMethod = null;

        for (final Method method : clazz.getMethods()) {
            if (method.isAnnotationPresent(PluginFactory.class)) {
                factoryMethod = method;
                break;
            }
        }
        if (factoryMethod == null) {
            return null;
        }

        final Annotation[][] parmArray = factoryMethod.getParameterAnnotations();
        final Class[] parmClasses = factoryMethod.getParameterTypes();
        if (parmArray.length != parmClasses.length) {
            LOGGER.error(""Number of parameter annotations does not equal the number of paramters"");
        }
        final Object[] parms = new Object[parmClasses.length];

        int index = 0;
        final Map<String, String> attrs = node.getAttributes();
        final List<Node> children = node.getChildren();
        final StringBuilder sb = new StringBuilder();
        final List<Node> used = new ArrayList<Node>();

        /*
         * For each parameter:
         * If the parameter is an attribute store the value of the attribute in the parameter array.
         * If the parameter is an element:
         *   Determine if the required parameter is an array.
         *     If so, if a child contains the array, use it,
         *      otherwise create the array from all child nodes of the correct type.
         *     Store the array into the parameter array.
         *   If not an array, store the object in the child node into the parameter array.
         */
        for (final Annotation[] parmTypes : parmArray) {
            for (final Annotation a : parmTypes) {
                if (sb.length() == 0) {
                    sb.append("" with params("");
                } else {
                    sb.append("", "");
                }
                if (a instanceof PluginNode) {
                    parms[index] = node;
                    sb.append(""Node="").append(node.getName());
                } else if (a instanceof PluginConfiguration) {
                    parms[index] = this;
                    if (this.name != null) {
                        sb.append(""Configuration("").append(name).append("")"");
                    } else {
                        sb.append(""Configuration"");
                    }
                } else if (a instanceof PluginValue) {
                    final String name = ((PluginValue) a).value();
                    String v = node.getValue();
                    if (v == null) {
                        v = getAttrValue(""value"", attrs);
                    }
                    final String value = subst.replace(event, v);
                    sb.append(name).append(""=\"""").append(value).append(""\"""");
                    parms[index] = value;
                } else if (a instanceof PluginAttr) {
                    final String name = ((PluginAttr) a).value();
                    final String value = subst.replace(event, getAttrValue(name, attrs));
                    sb.append(name).append(""=\"""").append(value).append(""\"""");
                    parms[index] = value;
                } else if (a instanceof PluginElement) {
                    final PluginElement elem = (PluginElement) a;
                    final String name = elem.value();
                    if (parmClasses[index].isArray()) {
                        final Class<?> parmClass = parmClasses[index].getComponentType();
                        final List<Object> list = new ArrayList<Object>();
                        sb.append(name).append(""={"");
                        boolean first = true;
                        for (final Node child : children) {
                            final PluginType childType = child.getType();
                            if (elem.value().equalsIgnoreCase(childType.getElementName()) ||
                                parmClass.isAssignableFrom(childType.getPluginClass())) {
                                used.add(child);
                                if (!first) {
                                    sb.append("", "");
                                }
                                first = false;
                                final Object obj = child.getObject();
                                if (obj == null) {
                                    LOGGER.error(""Null object returned for "" + child.getName() + "" in "" +
                                        node.getName());
                                    continue;
                                }
                                if (obj.getClass().isArray()) {
                                    printArray(sb, (Object[]) obj);
                                    parms[index] = obj;
                                    break;
                                }
                                sb.append(child.toString());
                                list.add(obj);
                            }
                        }
                        sb.append(""}"");
                        if (parms[index] != null) {
                            break;
                        }
                        if (list.size() > 0 && !parmClass.isAssignableFrom(list.get(0).getClass())) {
                            LOGGER.error(""Attempted to assign List containing class "" +
                                list.get(0).getClass().getName() + "" to array of type "" + parmClass +
                                "" for attribute "" + name);
                            break;
                        }
                        final Object[] array = (Object[]) Array.newInstance(parmClass, list.size());
                        int i = 0;
                        for (final Object obj : list) {
                            array[i] = obj;
                            ++i;
                        }
                        parms[index] = array;
                    } else {
                        final Class<?> parmClass = parmClasses[index];
                        boolean present = false;
                        for (final Node child : children) {
                            final PluginType childType = child.getType();
                            if (elem.value().equals(childType.getElementName()) ||
                                parmClass.isAssignableFrom(childType.getPluginClass())) {
                                sb.append(child.getName()).append(""("").append(child.toString()).append("")"");
                                present = true;
                                used.add(child);
                                parms[index] = child.getObject();
                                break;
                            }
                        }
                        if (!present) {
                            sb.append(""null"");
                        }
                    }
                }
            }
            ++index;
        }
        if (sb.length() > 0) {
            sb.append("")"");
        }

        if (attrs.size() > 0) {
            final StringBuilder eb = new StringBuilder();
            for (final String key : attrs.keySet()) {
                if (eb.length() == 0) {
                    eb.append(node.getName());
                    eb.append("" contains "");
                    if (attrs.size() == 1) {
                        eb.append(""an invalid element or attribute "");
                    } else {
                        eb.append(""invalid attributes "");
                    }
                } else {
                    eb.append("", "");
                }
                eb.append(""\"""");
                eb.append(key);
                eb.append(""\"""");

            }
            LOGGER.error(eb.toString());
        }

        if (!type.isDeferChildren() && used.size() != children.size()) {
            for (final Node child : children) {
                if (used.contains(child)) {
                    continue;
                }
                final String nodeType = node.getType().getElementName();
                final String start = nodeType.equals(node.getName()) ? node.getName() : nodeType + "" "" + node.getName();
                LOGGER.error(start + "" has no parameter that matches element "" + child.getName());
            }
        }

        try {
            final int mod = factoryMethod.getModifiers();
            if (!Modifier.isStatic(mod)) {
                LOGGER.error(factoryMethod.getName() + "" method is not static on class "" +
                    clazz.getName() + "" for element "" + node.getName());
                return null;
            }
            LOGGER.debug(""Calling {} on class {} for element {}{}"", factoryMethod.getName(), clazz.getName(),
                node.getName(), sb.toString());
            //if (parms.length > 0) {
                return factoryMethod.invoke(null, parms);
            //}
            //return factoryMethod.invoke(null, node);
        } catch (final Exception e) {
            LOGGER.error(""Unable to invoke method "" + factoryMethod.getName() + "" in class "" +
                clazz.getName() + "" for element "" + node.getName(), e);
        }
        return null;
    }",0,[0]
34314,bugs-dot-jar_OAK-1668_63070cf9,"@Override
    public String getPlan(Filter filter, NodeState root) {
        FullTextExpression ft = filter.getFullTextConstraint();
        Set<String> relPaths = getRelativePaths(ft);
        if (relPaths.size() > 1) {
            return new MultiLuceneIndex(filter, root, relPaths).getPlan();
        }
        String parent = relPaths.size() == 0 ? """" : relPaths.iterator().next();
        // we only restrict non-full-text conditions if there is
        // no relative property in the full-text constraint
        boolean nonFullTextConstraints = parent.isEmpty();
        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer) + "" ft:("" + ft + "")"";
        if (!parent.isEmpty()) {
            plan += "" parent:"" + parent;
        }
        return plan;
    }","@Override
    public String getPlan(Filter filter, NodeState root) {
        FullTextExpression ft = filter.getFullTextConstraint();
        Set<String> relPaths = getRelativePaths(ft);
        if (relPaths.size() > 1) {
            return new MultiLuceneIndex(filter, root, relPaths).getPlan();
        }
        String parent = relPaths.size() == 0 ? """" : relPaths.iterator().next();
        // we only restrict non-full-text conditions if there is
        // no relative property in the full-text constraint
        boolean nonFullTextConstraints = parent.isEmpty();
        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer, getIndexDef(root)) + "" ft:("" + ft + "")"";
        if (!parent.isEmpty()) {
            plan += "" parent:"" + parent;
        }
        return plan;
    }",1,[11]
5915,bugs-dot-jar_OAK-3110_d10362c0,"@Override
    public void close() throws IOException {
        this.closed = true;
    }","@Override
    public void close() throws IOException {
        this.closed = true;
    }",0,[0]
31304,bugs-dot-jar_CAMEL-8125_36e7b668,"public static Boolean parseBoolean(CamelContext camelContext, String text) throws Exception {
        // ensure we support property placeholders
        String s = camelContext.resolvePropertyPlaceholders(text);
        if (s != null) {
            s = s.trim().toLowerCase(Locale.ENGLISH);
            if (s.equals(""true"") || s.equals(""false"")) {
                return ""true"".equals(s) ? Boolean.TRUE : Boolean.FALSE;
            } else {
                if (s.equals(text)) {
                    throw new IllegalArgumentException(""Error parsing ["" + s + ""] as a Boolean."");
                } else {
                    throw new IllegalArgumentException(""Error parsing ["" + s + ""] from property "" + text + "" as a Boolean."");
                }
            }
        }
        return null;
    }","public static Boolean parseBoolean(CamelContext camelContext, String text) throws Exception {
        // ensure we support property placeholders
        String s = camelContext.resolvePropertyPlaceholders(text);
        if (s != null) {
            s = s.trim().toLowerCase(Locale.ENGLISH);
            if (s.equals(""true"") || s.equals(""false"")) {
                return ""true"".equals(s) ? Boolean.TRUE : Boolean.FALSE;
            } else {
                if (s.equals(text)) {
                    throw new IllegalArgumentException(""Error parsing ["" + s + ""] as a Boolean."");
                } else {
                    throw new IllegalArgumentException(""Error parsing ["" + s + ""] from property "" + text + "" as a Boolean."");
                }
            }
        }
        return null;
    }",0,[0]
10678,bugs-dot-jar_MATH-1065_996c0c16,"@Override
    public double sample() {
        return innerDistribution.sample();
    }","@Override
    public double sample() {
        return innerDistribution.sample();
    }",0,[0]
553,bugs-dot-jar_MNG-5687_3d2d8619,"public List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive )
    {
        if ( project == null )
        {
            throw new IllegalArgumentException( ""project missing"" );
        }

        Collection<String> projectIds = new HashSet<String>();

        getDownstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );

        return getProjects( projectIds );
    }","public List<MavenProject> getDownstreamProjects( MavenProject project, boolean transitive )
    {
        if ( project == null )
        {
            throw new IllegalArgumentException( ""project missing"" );
        }

        Set<String> projectIds = new HashSet<String>();

        getDownstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );

        return getSortedProjects( projectIds );
    }",1,"[7, 11]"
14877,bugs-dot-jar_OAK-3318_e12e2052,"public InputStream getTikaConfig(){
        return ConfigUtil.getBlob(getTikaConfigNode(), TIKA_CONFIG).getNewStream();
    }","public InputStream getTikaConfig(){
        return ConfigUtil.getBlob(getTikaConfigNode(), TIKA_CONFIG).getNewStream();
    }",0,[0]
22633,bugs-dot-jar_OAK-47_b62f1c26,"private NodeImpl getRevisionIfExists(String revisionId) {
        NodeImpl node = getRoot();
        NodeImpl head = node.getNode(""head"");
        String headRev;
        headRev = head.getProperty(""rev"");
        headRev = headRev == null ? null : JsopTokenizer.decodeQuoted(headRev);
        // we can't rely on headRevId, as it's a volatile field
        if (revisionId.equals(headRev)) {
            return head;
        } else {
            long rev = Revision.parseId(revisionId);
            return getRevisionNode(node, rev, rev).getNode(""head"");
        }
    }","private NodeImpl getRevisionIfExists(String revisionId) {
        NodeImpl node = getRoot();
        NodeImpl head = node.getNode(""head"");
        String headRev;
        headRev = head.getProperty(""rev"");
        headRev = headRev == null ? null : JsopTokenizer.decodeQuoted(headRev);
        // we can't rely on headRevId, as it's a volatile field
        if (revisionId.equals(headRev)) {
            return head;
        } else {
            long rev = Revision.parseId(revisionId);
            return getRevisionNode(node, rev, rev).getNode(""head"");
        }
    }",0,[0]
14255,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public void removeConstraint(ByteBuffer login, String tableName, int number) throws TException {
    try {
      getConnector(login).tableOperations().removeConstraint(tableName, number);
    } catch (Exception e) {
      throw translateException(e);
    }
  }","@Override
  public void removeConstraint(ByteBuffer login, String tableName, int number) throws TException {
    try {
      getConnector(login).tableOperations().removeConstraint(tableName, number);
    } catch (Exception e) {
      throw translateException(e);
    }
  }",0,[0]
9681,bugs-dot-jar_CAMEL-4542_c408c3ed,"public void setRef(String ref) {
        this.ref = ref;
    }","public void setRef(String ref) {
        this.ref = ref;
    }",0,[0]
7621,bugs-dot-jar_OAK-1178_f2bb1a17,"private void ensureChildOrderProperty() {
        if (!nodeBuilder.hasProperty(OAK_CHILD_ORDER)) {
            nodeBuilder.setProperty(
                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, nodeBuilder.getChildNodeNames()));
        }
    }","private void ensureChildOrderProperty() {
        if (!nodeBuilder.hasProperty(OAK_CHILD_ORDER)) {
            nodeBuilder.setProperty(
                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, nodeBuilder.getChildNodeNames()));
        }
    }",0,[0]
2016,bugs-dot-jar_WICKET-2961_3d8c9d75,"public final void detach()
	{
		// if the component has been previously attached via attach()
		// detach it now
		setFlag(FLAG_DETACHING, true);
		onDetach();
		if (getFlag(FLAG_DETACHING))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly detached. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onDetach() in the override of onDetach() method"");
		}
		setFlag(FLAG_ATTACHED, false);

		setFlag(FLAG_CONFIGURED, false);

		// always detach models because they can be attached without the
		// component. eg component has a compoundpropertymodel and one of its
		// children component's getmodelobject is called
		detachModels();

		// detach any behaviors
		detachBehaviors();

		// always detach children because components can be attached
		// independently of their parents
		detachChildren();

		// reset the model to null when the current model is a IWrapModel and
		// the model that created it/wrapped in it is a IComponentInheritedModel
		// The model will be created next time.
		if (getFlag(FLAG_INHERITABLE_MODEL))
		{
			setModelImpl(null);
			setFlag(FLAG_INHERITABLE_MODEL, false);
		}

		// clear out enabled state metadata
		setMetaData(ENABLED_IN_HIERARCHY_CACHE_KEY, null);

		// notify any detach listener
		IDetachListener detachListener = getApplication().getFrameworkSettings()
			.getDetachListener();
		if (detachListener != null)
		{
			detachListener.onDetach(this);
		}
	}","public final void detach()
	{
		// if the component has been previously attached via attach()
		// detach it now
		setFlag(FLAG_DETACHING, true);
		onDetach();
		if (getFlag(FLAG_DETACHING))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly detached. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onDetach() in the override of onDetach() method"");
		}
		setFlag(FLAG_ATTACHED, false);

		setFlag(FLAG_CONFIGURED, false);

		// always detach models because they can be attached without the
		// component. eg component has a compoundpropertymodel and one of its
		// children component's getmodelobject is called
		detachModels();

		// detach any behaviors
		detachBehaviors();

		// always detach children because components can be attached
		// independently of their parents
		detachChildren();

		// reset the model to null when the current model is a IWrapModel and
		// the model that created it/wrapped in it is a IComponentInheritedModel
		// The model will be created next time.
		if (getFlag(FLAG_INHERITABLE_MODEL))
		{
			setModelImpl(null);
			setFlag(FLAG_INHERITABLE_MODEL, false);
		}

		// clear out enabled state metadata
		setMetaData(ENABLED_IN_HIERARCHY_CACHE_KEY, null);

		// notify any detach listener
		IDetachListener detachListener = getApplication().getFrameworkSettings()
			.getDetachListener();
		if (detachListener != null)
		{
			detachListener.onDetach(this);
		}
	}",0,[0]
330,Bears-15,"@Override
    public boolean hasIgnoreMarker(AnnotatedMember m) {
        return _isIgnorable(m);
    }","@Override
    public boolean hasIgnoreMarker(AnnotatedMember m) {
        return _isIgnorable(m);
    }",0,[0]
1852,Bears-211,"@Override
    protected Object readResolve() {
        return new SmileFactory(this, _objectCodec);
    }","@Override
    protected Object readResolve() {
        return new SmileFactory(this, _objectCodec);
    }",0,[0]
22696,bugs-dot-jar_CAMEL-8584_dd0f74c0,"private boolean openCircuit(final Exchange exchange, final AsyncCallback callback) {
        boolean output = rejectExchange(exchange, callback);
        state.set(STATE_OPEN);
        logState();
        return output;
    }","private boolean openCircuit(final Exchange exchange, final AsyncCallback callback) {
        boolean output = rejectExchange(exchange, callback);
        state.set(STATE_OPEN);
        logState();
        return output;
    }",0,[0]
4611,bugs-dot-jar_MATH-950_424cbd20,"public double integrate(final FirstOrderDifferentialEquations equations,
                            final double t0, final double[] y0, final double t, final double[] y)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

        if (y0.length != equations.getDimension()) {
            throw new DimensionMismatchException(y0.length, equations.getDimension());
        }
        if (y.length != equations.getDimension()) {
            throw new DimensionMismatchException(y.length, equations.getDimension());
        }

        // prepare expandable stateful equations
        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
        expandableODE.setTime(t0);
        expandableODE.setPrimaryState(y0);

        // perform integration
        integrate(expandableODE, t);

        // extract results back from the stateful equations
        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
        return expandableODE.getTime();

    }","public double integrate(final FirstOrderDifferentialEquations equations,
                            final double t0, final double[] y0, final double t, final double[] y)
        throws DimensionMismatchException, NumberIsTooSmallException,
               MaxCountExceededException, NoBracketingException {

        if (y0.length != equations.getDimension()) {
            throw new DimensionMismatchException(y0.length, equations.getDimension());
        }
        if (y.length != equations.getDimension()) {
            throw new DimensionMismatchException(y.length, equations.getDimension());
        }

        // prepare expandable stateful equations
        final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);
        expandableODE.setTime(t0);
        expandableODE.setPrimaryState(y0);

        // perform integration
        integrate(expandableODE, t);

        // extract results back from the stateful equations
        System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);
        return expandableODE.getTime();

    }",0,[0]
27807,bugs-dot-jar_CAMEL-8053_cac72b14,"public void setExceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicyStrategy) {
        ObjectHelper.notNull(exceptionPolicyStrategy, ""ExceptionPolicyStrategy"");
        this.exceptionPolicyStrategy = exceptionPolicyStrategy;
    }","public void setExceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicyStrategy) {
        ObjectHelper.notNull(exceptionPolicyStrategy, ""ExceptionPolicyStrategy"");
        this.exceptionPolicyStrategy = exceptionPolicyStrategy;
    }",0,[0]
26797,bugs-dot-jar_OAK-3020_147515ae,"private List<Field> newBinary(
            PropertyState property, NodeState state, String nodePath, String path) {
        List<Field> fields = new ArrayList<Field>();
        Metadata metadata = new Metadata();

        //jcr:mimeType is mandatory for a binary to be indexed
        String type = state.getString(JcrConstants.JCR_MIMETYPE);

        if (type == null || !isSupportedMediaType(type)){
            log.trace(""Ignoring binary content for node {} due to unsupported "" +
                    ""(or null) jcr:mimeType [{}]"", nodePath, type);
            return fields;
        }

        metadata.set(Metadata.CONTENT_TYPE, type);
        if (JCR_DATA.equals(property.getName())) {
            String encoding = state.getString(JcrConstants.JCR_ENCODING);
            if (encoding != null) { // not mandatory
                metadata.set(Metadata.CONTENT_ENCODING, encoding);
            }
        }

        for (Blob v : property.getValue(Type.BINARIES)) {
            if (nodePath != null){
                fields.add(newFulltextField(nodePath, parseStringValue(v, metadata, path)));
            } else {
                fields.add(newFulltextField(parseStringValue(v, metadata, path)));
            }

        }
        return fields;
    }","private List<Field> newBinary(
            PropertyState property, NodeState state, String nodePath, String path) {
        List<Field> fields = new ArrayList<Field>();
        Metadata metadata = new Metadata();

        //jcr:mimeType is mandatory for a binary to be indexed
        String type = state.getString(JcrConstants.JCR_MIMETYPE);

        if (type == null || !isSupportedMediaType(type)){
            log.trace(""Ignoring binary content for node {} due to unsupported "" +
                    ""(or null) jcr:mimeType [{}]"", nodePath, type);
            return fields;
        }

        metadata.set(Metadata.CONTENT_TYPE, type);
        if (JCR_DATA.equals(property.getName())) {
            String encoding = state.getString(JcrConstants.JCR_ENCODING);
            if (encoding != null) { // not mandatory
                metadata.set(Metadata.CONTENT_ENCODING, encoding);
            }
        }

        for (Blob v : property.getValue(Type.BINARIES)) {
            if (nodePath != null){
                fields.add(newFulltextField(nodePath, parseStringValue(v, metadata, path)));
            } else {
                fields.add(newFulltextField(parseStringValue(v, metadata, path)));
            }

        }
        return fields;
    }",0,[0]
23593,bugs-dot-jar_FLINK-1290_45fb6d82,"@Override
	public LocalProperties computeLocalProperties(LocalProperties in1, LocalProperties in2) {
		LocalProperties comb = LocalProperties.combine(in1, in2);
		return comb.clearUniqueFieldSets();
	}","@Override
	public LocalProperties computeLocalProperties(LocalProperties in1, LocalProperties in2) {
		LocalProperties comb = LocalProperties.combine(in1, in2);
		return comb.clearUniqueFieldSets();
	}",0,[0]
26054,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"public VersioningIterator(SortedKeyValueIterator<Key,Value> iterator, int maxVersions) {
    super(iterator, maxVersions);
  }","public VersioningIterator(SortedKeyValueIterator<Key,Value> iterator, int maxVersions) {
    super();
    this.setSource(iterator);
    this.maxVersions = maxVersions;
  }",1,[1]
5816,bugs-dot-jar_MATH-1230_96eb80ef,"protected static double getInvertedCoefficientSum(final RealVector coefficients) {
        double sum = 0;
        for (double coefficient : coefficients.toArray()) {
            sum -= coefficient;
        }
        return sum;
    }","protected static double getInvertedCoefficientSum(final RealVector coefficients) {
        double sum = 0;
        for (double coefficient : coefficients.toArray()) {
            sum -= coefficient;
        }
        return sum;
    }",0,[0]
422,Bears-15,"@Override
    public Iterator<PropertyWriter> properties() {
        return Arrays.<PropertyWriter>asList(_props).iterator();
    }","@Override
    public Iterator<PropertyWriter> properties() {
        return Arrays.<PropertyWriter>asList(_props).iterator();
    }",0,[0]
34855,bugs-dot-jar_CAMEL-8964_ea8ee025,"public static void stopAndShutdownServices(Collection<?> services) throws Exception {
        if (services == null) {
            return;
        }
        Exception firstException = null;

        for (Object value : services) {

            try {
                // must stop it first
                stopService(value);

                // then try to shutdown
                if (value instanceof ShutdownableService) {
                    ShutdownableService service = (ShutdownableService)value;
                    LOG.trace(""Shutting down service: {}"", service);
                    service.shutdown();
                }
            } catch (Exception e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Caught exception shutting down service: "" + value, e);
                }
                if (firstException == null) {
                    firstException = e;
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }","public static void stopAndShutdownServices(Collection<?> services) throws Exception {
        if (services == null) {
            return;
        }
        Exception firstException = null;

        for (Object value : services) {

            try {
                // must stop it first
                stopService(value);

                // then try to shutdown
                if (value instanceof ShutdownableService) {
                    ShutdownableService service = (ShutdownableService)value;
                    LOG.trace(""Shutting down service: {}"", service);
                    service.shutdown();
                }
            } catch (Exception e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Caught exception shutting down service: "" + value, e);
                }
                if (firstException == null) {
                    firstException = e;
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }",0,[0]
23655,bugs-dot-jar_MATH-744_8a83581e,"@Override
    public boolean equals(final Object other) {
        boolean ret = false;

        if (this == other) {
            ret = true;
        } else if (other instanceof BigFraction) {
            BigFraction rhs = ((BigFraction) other).reduce();
            BigFraction thisOne = this.reduce();
            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);
        }

        return ret;
    }","@Override
    public boolean equals(final Object other) {
        boolean ret = false;

        if (this == other) {
            ret = true;
        } else if (other instanceof BigFraction) {
            BigFraction rhs = ((BigFraction) other).reduce();
            BigFraction thisOne = this.reduce();
            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);
        }

        return ret;
    }",0,[0]
36098,bugs-dot-jar_CAMEL-9444_baece126,"public ValidateDefinition validate(Predicate predicate) {
        ValidateDefinition answer = new ValidateDefinition(predicate);
        addOutput(answer);
        return answer;
    }","public ValidateDefinition validate(Predicate predicate) {
        ValidateDefinition answer = new ValidateDefinition(predicate);
        addOutput(answer);
        return answer;
    }",0,[0]
38519,bugs-dot-jar_CAMEL-9124_9da2c05a,"public String getUseExponentialBackOff() {
        return useExponentialBackOff;
    }","public String getUseExponentialBackOff() {
        return useExponentialBackOff;
    }",0,[0]
9828,bugs-dot-jar_OAK-3634_90ad50da,"@Override
    public <T extends Document> T find(Collection<T> collection, String id) {
        return find(collection, id, Integer.MAX_VALUE);
    }","@Override
    public <T extends Document> T find(Collection<T> collection, String id) {
        return find(collection, id, Integer.MAX_VALUE);
    }",0,[0]
804,bugs-dot-jar_ACCUMULO-412_5594b2e0,"private static Map<KeyExtent,String> locationsOf(Map<Path,List<TabletLocation>> assignments) {
    Map<KeyExtent,String> result = new HashMap<KeyExtent,String>();
    for (List<TabletLocation> entry : assignments.values()) {
      for (TabletLocation tl : entry) {
        result.put(tl.tablet_extent, tl.tablet_location);
      }
    }
    return result;
  }","private static Map<KeyExtent,String> locationsOf(Map<Path,List<TabletLocation>> assignments) {
    Map<KeyExtent,String> result = new HashMap<KeyExtent,String>();
    for (List<TabletLocation> entry : assignments.values()) {
      for (TabletLocation tl : entry) {
        result.put(tl.tablet_extent, tl.tablet_location);
      }
    }
    return result;
  }",0,[0]
1041,Bears-137,"@Override
    protected Object decode(
            ChannelHandlerContext ctx, Channel channel, ChannelBuffer buf) throws Exception {

        if (buf.readableBytes() < 10) {
            return null;
        }

        int beginIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), new StringFinder(""$$""));
        if (beginIndex == -1) {
            return null;
        } else if (beginIndex > buf.readerIndex()) {
            buf.readerIndex(beginIndex);
        }

        int length;

        int flagIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), new StringFinder(""AA""));
        if (flagIndex != -1 && flagIndex - beginIndex == 6) {
            length = Integer.parseInt(buf.toString(buf.readerIndex() + 2, 4, StandardCharsets.US_ASCII));
        } else {
            length = Integer.parseInt(buf.toString(buf.readerIndex() + 2, 2, StandardCharsets.US_ASCII), 16);
        }

        if (length <= buf.readableBytes()) {
            return buf.readBytes(length);
        }

        return null;
    }","@Override
    protected Object decode(
            ChannelHandlerContext ctx, Channel channel, ChannelBuffer buf) throws Exception {

        if (buf.readableBytes() < 10) {
            return null;
        }

        int beginIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), new StringFinder(""$$""));
        if (beginIndex == -1) {
            return null;
        } else if (beginIndex > buf.readerIndex()) {
            buf.readerIndex(beginIndex);
        }

        int length;

        int separatorIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '|');
        if (separatorIndex > 0 && separatorIndex - beginIndex > 19) {
            length = Integer.parseInt(buf.toString(buf.readerIndex() + 2, 4, StandardCharsets.US_ASCII));
        } else {
            length = Integer.parseInt(buf.toString(buf.readerIndex() + 2, 2, StandardCharsets.US_ASCII), 16);
        }

        if (length <= buf.readableBytes()) {
            return buf.readBytes(length);
        }

        return null;
    }",1,"[17, 18]"
381,Bears-15,"@Override
    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)
    {
        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);
        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);
    }","@Override
    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)
    {
        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);
        return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);
    }",0,[0]
26584,bugs-dot-jar_WICKET-3420_be97d017,"protected IManageablePage deserializePage(final byte data[])
	{
		return (IManageablePage)WicketObjects.byteArrayToObject(data);
	}","protected IManageablePage deserializePage(final byte data[])
	{
		return (IManageablePage)WicketObjects.byteArrayToObject(data);
	}",0,[0]
27421,bugs-dot-jar_MATH-1297_56434517,"public double getMaxGrowth() {
        return maxGrowth;
    }","public double getMaxGrowth() {
        return maxGrowth;
    }",0,[0]
23468,bugs-dot-jar_LOG4J2-127_029e79da,"public void debug(Marker marker, String message, Throwable t) {
        if (isEnabled(Level.DEBUG, marker, message, t)) {
            log(marker, FQCN, Level.DEBUG, new SimpleMessage(message), t);
        }
    }","public void debug(Marker marker, String message, Throwable t) {
        if (isEnabled(Level.DEBUG, marker, message, t)) {
            log(marker, FQCN, Level.DEBUG, new SimpleMessage(message), t);
        }
    }",0,[0]
10294,bugs-dot-jar_OAK-3897_94c6c575,"@Nonnull
    private Commit newBranchCommit(@Nonnull RevisionVector base,
                                   @Nullable DocumentNodeStoreBranch branch) {
        checkArgument(checkNotNull(base).isBranch(),
                ""base must be a branch revision: "" + base);

        checkOpen();
        return new Commit(this, newRevision(), base, branch);
    }","@Nonnull
    private Commit newBranchCommit(@Nonnull RevisionVector base,
                                   @Nullable DocumentNodeStoreBranch branch) {
        checkArgument(checkNotNull(base).isBranch(),
                ""base must be a branch revision: "" + base);

        checkOpen();
        return new Commit(this, newRevision(), base, branch);
    }",0,[0]
16404,bugs-dot-jar_CAMEL-7163_5f726d0b,"public void setBodyMaxChars(int bodyMaxChars) {
        backlogDebugger.setBodyMaxChars(bodyMaxChars);
    }","public void setBodyMaxChars(int bodyMaxChars) {
        backlogDebugger.setBodyMaxChars(bodyMaxChars);
    }",0,[0]
32494,bugs-dot-jar_OAK-926_e1ae968c,"@Nonnull
    private Map<String, String> getDeleted() {
        return ValueMap.create(this, DELETED);
    }","@Nonnull
    private Map<String, String> getDeleted() {
        return ValueMap.create(this, DELETED);
    }",0,[0]
11144,bugs-dot-jar_MATH-1269_a94ff90a,"public static int getExponent(final double d) {
        // NaN and Infinite will return 1024 anywho so can use raw bits
        return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;
    }","public static int getExponent(final double d) {
        // NaN and Infinite will return 1024 anywho so can use raw bits
        return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;
    }",0,[0]
16480,bugs-dot-jar_OAK-1977_4bfbfcdd,"static OrderedContentMirrorStoreStrategy getStrategy(NodeState indexMeta) {
        if (OrderDirection.isAscending(indexMeta)) {
            return STORE;
        } else {
            return REVERSED_STORE;
        }
    }","static OrderedContentMirrorStoreStrategy getStrategy(NodeState indexMeta) {
        if (OrderDirection.isAscending(indexMeta)) {
            return STORE;
        } else {
            return REVERSED_STORE;
        }
    }",0,[0]
18499,bugs-dot-jar_WICKET-5569_5efb8091,"@Override
	public abstract IMarkupFragment getMarkup(final MarkupContainer container, final Component child);","@Override
	public abstract IMarkupFragment getMarkup(final MarkupContainer container, final Component child);",0,[0]
2797,bugs-dot-jar_OAK-2174_5931a4a7,"private void updateIndex(
            NodeState before, String beforeCheckpoint,
            NodeState after, String afterCheckpoint, String afterTime)
            throws CommitFailedException {
        // start collecting runtime statistics
        preAsyncRunStatsStats(indexStats);

        // create an update callback for tracking index updates
        // and maintaining the update lease
        AsyncUpdateCallback callback =
                new AsyncUpdateCallback(beforeCheckpoint, afterCheckpoint);
        try {
            NodeBuilder builder = store.getRoot().builder();

            IndexUpdate indexUpdate =
                    new IndexUpdate(provider, name, after, builder, callback);
            CommitFailedException exception =
                    EditorDiff.process(VisibleEditor.wrap(indexUpdate), before, after);
            if (exception != null) {
                throw exception;
            }

            builder.child(ASYNC).setProperty(name, afterCheckpoint);
            builder.child(ASYNC).setProperty(PropertyStates.createProperty(lastIndexedTo, afterTime, Type.DATE));
            if (callback.isDirty() || before == MISSING_NODE) {
                if (switchOnSync) {
                    reindexedDefinitions.addAll(
                            indexUpdate.getReindexedDefinitions());
                } else {
                    postAsyncRunStatsStatus(indexStats);
                }
            } else if (switchOnSync) {
                log.debug(""No changes detected after diff; will try to""
                        + "" switch to synchronous updates on {}"",
                        reindexedDefinitions);

                // no changes after diff, switch to sync on the async defs
                for (String path : reindexedDefinitions) {
                    NodeBuilder c = builder;
                    for (String p : elements(path)) {
                        c = c.getChildNode(p);
                    }
                    if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {
                        c.removeProperty(ASYNC_PROPERTY_NAME);
                    }
                }
                reindexedDefinitions.clear();
            }
            mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);
        } finally {
            callback.close();
        }

        postAsyncRunStatsStatus(indexStats);
    }","private void updateIndex(
            NodeState before, String beforeCheckpoint,
            NodeState after, String afterCheckpoint, String afterTime)
            throws CommitFailedException {
        // start collecting runtime statistics
        preAsyncRunStatsStats(indexStats);

        // create an update callback for tracking index updates
        // and maintaining the update lease
        AsyncUpdateCallback callback =
                new AsyncUpdateCallback(beforeCheckpoint, afterCheckpoint);
        try {
            NodeBuilder builder = store.getRoot().builder();

            IndexUpdate indexUpdate =
                    new IndexUpdate(provider, name, after, builder, callback);
            CommitFailedException exception =
                    EditorDiff.process(VisibleEditor.wrap(indexUpdate), before, after);
            if (exception != null) {
                throw exception;
            }

            builder.child(ASYNC).setProperty(name, afterCheckpoint);
            builder.child(ASYNC).setProperty(PropertyStates.createProperty(lastIndexedTo, afterTime, Type.DATE));
            if (callback.isDirty() || before == MISSING_NODE) {
                if (switchOnSync) {
                    reindexedDefinitions.addAll(
                            indexUpdate.getReindexedDefinitions());
                } else {
                    postAsyncRunStatsStatus(indexStats);
                }
            } else {
                if (switchOnSync) {
                    log.debug(
                            ""No changes detected after diff; will try to switch to synchronous updates on {}"",
                            reindexedDefinitions);

                    // no changes after diff, switch to sync on the async defs
                    for (String path : reindexedDefinitions) {
                        NodeBuilder c = builder;
                        for (String p : elements(path)) {
                            c = c.getChildNode(p);
                        }
                        if (c.exists() && !c.getBoolean(REINDEX_PROPERTY_NAME)) {
                            c.removeProperty(ASYNC_PROPERTY_NAME);
                        }
                    }
                    reindexedDefinitions.clear();
                }
                postAsyncRunStatsStatus(indexStats);
            }
            mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);
        } finally {
            callback.close();
        }
    }",1,"[31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43, 46, 53]"
27516,bugs-dot-jar_CAMEL-3791_52106681,"protected void handleException(Exchange exchange, RedeliveryData data) {
        Exception e = exchange.getException();

        // store the original caused exception in a property, so we can restore it later
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);

        // find the error handler to use (if any)
        OnExceptionDefinition exceptionPolicy = getExceptionPolicy(exchange, e);
        if (exceptionPolicy != null) {
            data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(exchange.getContext(), data.currentRedeliveryPolicy);
            data.handledPredicate = exceptionPolicy.getHandledPolicy();
            data.continuedPredicate = exceptionPolicy.getContinuedPolicy();
            data.retryWhilePredicate = exceptionPolicy.getRetryWhilePolicy();
            data.useOriginalInMessage = exceptionPolicy.isUseOriginalMessage();
            data.asyncDelayedRedelivery = exceptionPolicy.isAsyncDelayedRedelivery(exchange.getContext());

            // route specific failure handler?
            Processor processor = exceptionPolicy.getErrorHandler();
            if (processor != null) {
                data.failureProcessor = processor;
            }
            // route specific on redelivery?
            processor = exceptionPolicy.getOnRedelivery();
            if (processor != null) {
                data.onRedeliveryProcessor = processor;
            }
        }

        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId()
                + "". On delivery attempt: "" + data.redeliveryCounter + "" caught: "" + e;
        logFailedDelivery(true, false, false, exchange, msg, data, e);

        data.redeliveryCounter = incrementRedeliveryCounter(exchange, e, data);
    }","protected void handleException(Exchange exchange, RedeliveryData data) {
        Exception e = exchange.getException();

        // store the original caused exception in a property, so we can restore it later
        exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);

        // find the error handler to use (if any)
        OnExceptionDefinition exceptionPolicy = getExceptionPolicy(exchange, e);
        if (exceptionPolicy != null) {
            data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(exchange.getContext(), data.currentRedeliveryPolicy);
            data.handledPredicate = exceptionPolicy.getHandledPolicy();
            data.continuedPredicate = exceptionPolicy.getContinuedPolicy();
            data.retryWhilePredicate = exceptionPolicy.getRetryWhilePolicy();
            data.useOriginalInMessage = exceptionPolicy.isUseOriginalMessage();
            data.asyncDelayedRedelivery = exceptionPolicy.isAsyncDelayedRedelivery(exchange.getContext());

            // route specific failure handler?
            Processor processor = exceptionPolicy.getErrorHandler();
            if (processor != null) {
                data.failureProcessor = processor;
            }
            // route specific on redelivery?
            processor = exceptionPolicy.getOnRedelivery();
            if (processor != null) {
                data.onRedeliveryProcessor = processor;
            }
        }

        String msg = ""Failed delivery for exchangeId: "" + exchange.getExchangeId()
                + "". On delivery attempt: "" + data.redeliveryCounter + "" caught: "" + e;
        logFailedDelivery(true, false, false, exchange, msg, data, e);

        data.redeliveryCounter = incrementRedeliveryCounter(exchange, e, data);
    }",0,[0]
13219,bugs-dot-jar_MATH-393_d4b02f6a,"public double getRelativeAccuracy() {
        return optimizer.getRelativeAccuracy();
    }","public double getRelativeAccuracy() {
        return optimizer.getRelativeAccuracy();
    }",0,[0]
8983,bugs-dot-jar_ACCUMULO-1051_25cf3ccd,"public boolean contains(ByteSequence auth) {
    return auths.contains(auth);
  }","public boolean contains(ByteSequence auth) {
    return auths.contains(auth);
  }",0,[0]
38,Bears-3,"public BeanPropertyMap withProperty(SettableBeanProperty newProp)
    {
        // First: may be able to just replace?
        String key = getPropertyName(newProp);

        for (int i = 1, end = _hashArea.length; i < end; i += 2) {
            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
            if ((prop != null) && prop.getName().equals(key)) {
                _hashArea[i] = newProp;
                _propsInOrder[_findFromOrdered(prop)] = newProp;
                return this;
            }
        }
        // If not, append
        final int slot = _hashCode(key);
        final int hashSize = _hashMask+1;
        int ix = (slot<<1);
        
        // primary slot not free?
        if (_hashArea[ix] != null) {
            // secondary?
            ix = (hashSize + (slot >> 1)) << 1;
            if (_hashArea[ix] != null) {
                // ok, spill over.
                ix = ((hashSize + (hashSize >> 1) ) << 1) + _spillCount;
                _spillCount += 2;
                if (ix >= _hashArea.length) {
                    _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);
                    // Uncomment for debugging only
                    /*
for (int i = 0; i < _hashArea.length; i += 2) {
    if (_hashArea[i] != null) {
        System.err.println(""Property #""+(i/2)+"" '""+_hashArea[i]+""'..."");
    }
}
System.err.println(""And new propr #""+slot+"" '""+key+""'"");
*/
                
                }
            }
        }
        _hashArea[ix] = key;
        _hashArea[ix+1] = newProp;

        int last = _propsInOrder.length;
        _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);
        _propsInOrder[last] = newProp;

        // should we just create a new one? Or is resetting ok?
        
        return this;
    }","public BeanPropertyMap withProperty(SettableBeanProperty newProp)
    {
        // First: may be able to just replace?
        String key = getPropertyName(newProp);

        for (int i = 1, end = _hashArea.length; i < end; i += 2) {
            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];
            if ((prop != null) && prop.getName().equals(key)) {
                _hashArea[i] = newProp;
                _propsInOrder[_findFromOrdered(prop)] = newProp;
                return this;
            }
        }
        // If not, append
        final int slot = _hashCode(key);
        final int hashSize = _hashMask+1;
        int ix = (slot<<1);
        
        // primary slot not free?
        if (_hashArea[ix] != null) {
            // secondary?
            ix = (hashSize + (slot >> 1)) << 1;
            if (_hashArea[ix] != null) {
                // ok, spill over.
                ix = ((hashSize + (hashSize >> 1) ) << 1) + _spillCount;
                _spillCount += 2;
                if (ix >= _hashArea.length) {
                    _hashArea = Arrays.copyOf(_hashArea, _hashArea.length + 4);
                    // Uncomment for debugging only
                    /*
for (int i = 0; i < _hashArea.length; i += 2) {
    if (_hashArea[i] != null) {
        System.err.println(""Property #""+(i/2)+"" '""+_hashArea[i]+""'..."");
    }
}
System.err.println(""And new propr #""+slot+"" '""+key+""'"");
*/
                
                }
            }
        }
        _hashArea[ix] = key;
        _hashArea[ix+1] = newProp;

        int last = _propsInOrder.length;
        _propsInOrder = Arrays.copyOf(_propsInOrder, last+1);
        _propsInOrder[last] = newProp;

        // should we just create a new one? Or is resetting ok?
        
        return this;
    }",0,[0]
17280,bugs-dot-jar_WICKET-4260_925cae5c,"@Override
	public String encodeRedirectURL(CharSequence url)
	{
		return httpServletResponse.encodeRedirectURL(url.toString());
	}","@Override
	public String encodeRedirectURL(CharSequence url)
	{
		return httpServletResponse.encodeRedirectURL(url.toString());
	}",0,[0]
30525,bugs-dot-jar_CAMEL-4211_4efddb3f,"public static String sanitizeUri(String uri) {
        return uri == null ? null : SECRETS.matcher(uri).replaceAll(""$1=******"");
    }","public static String sanitizeUri(String uri) {
        return uri == null ? null : SECRETS.matcher(uri).replaceAll(""$1=******"");
    }",0,[0]
8163,bugs-dot-jar_FLINK-2121_03340919,"public void setMinSplitSize(long minSplitSize) {
		if (minSplitSize < 0) {
			throw new IllegalArgumentException(""The minimum split size cannot be negative."");
		}
		
		this.minSplitSize = minSplitSize;
	}","public void setMinSplitSize(long minSplitSize) {
		if (minSplitSize < 0) {
			throw new IllegalArgumentException(""The minimum split size cannot be negative."");
		}
		
		this.minSplitSize = minSplitSize;
	}",0,[0]
3658,bugs-dot-jar_WICKET-3715_557de7bc,"public String getContentType()
	{
		return item.getContentType();
	}","public String getContentType()
	{
		return item.getContentType();
	}",0,[0]
588,bugs-dot-jar_WICKET-5570_57d8f051,"@Override
	public void renderHead(Component component, IHeaderResponse response)
	{
		super.renderHead(component, response);

		response.render(JavaScriptHeaderItem.forScript(
			""if (typeof(Wicket.TimerHandles) === 'undefined') {Wicket.TimerHandles = {}}"",
			WICKET_TIMERS_ID));

		if (component.getRequestCycle().find(AjaxRequestTarget.class) == null)
		{
			// complete page is rendered, so timeout has to be rendered again
			hasTimeout = false;
		}

		if (isStopped() == false)
		{
			addTimeout(response);
		}
	}","@Override
	public void renderHead(Component component, IHeaderResponse response)
	{
		super.renderHead(component, response);

		if (component.getRequestCycle().find(AjaxRequestTarget.class) == null)
		{
			// complete page is rendered, so timeout has to be rendered again
			hasTimeout = false;
		}

		if (isStopped() == false)
		{
			addTimeout(response);
		}
	}",1,"[5, 6, 7]"
7175,bugs-dot-jar_CAMEL-3545_050c542e,"public MethodCallExpression(Class<?> type, String method) {
        this(type, method, null);
    }","public MethodCallExpression(Class<?> type, String method) {
        this(type, method, null);
    }",0,[0]
5793,bugs-dot-jar_CAMEL-3760_5225e6e3,"protected String getContextId(String name) {
        return hostName + ""/"" + (name != null ? name : VALUE_UNKNOWN);
    }","protected String getContextId(String name) {
        return hostName + ""/"" + (name != null ? name : VALUE_UNKNOWN);
    }",0,[0]
27031,bugs-dot-jar_LOG4J2-793_73400bfb,"private static EventDataConverter createConverter() {
        try {
            Class.forName(""org.slf4j.ext.EventData"");
            return new EventDataConverter();
        } catch (final ClassNotFoundException cnfe) {
            return null;
        }
    }","private static EventDataConverter createConverter() {
        try {
            Class.forName(""org.slf4j.ext.EventData"");
            return new EventDataConverter();
        } catch (final ClassNotFoundException cnfe) {
            return null;
        }
    }",0,[0]
33294,bugs-dot-jar_ACCUMULO-795_9453bcfa,"public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException,
      TableExistsException {
    
    List<ByteBuffer> args = Arrays.asList(ByteBuffer.wrap(oldTableName.getBytes()), ByteBuffer.wrap(newTableName.getBytes()));
    Map<String,String> opts = new HashMap<String,String>();
    doTableOperation(TableOperation.RENAME, args, opts);
  }","public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException,
      TableExistsException {
    
    List<ByteBuffer> args = Arrays.asList(ByteBuffer.wrap(oldTableName.getBytes()), ByteBuffer.wrap(newTableName.getBytes()));
    Map<String,String> opts = new HashMap<String,String>();
    doTableOperation(TableOperation.RENAME, args, opts);
  }",0,[0]
11211,bugs-dot-jar_WICKET-1931_986848f7,"public void setPath(final String path)
	{
		this.path = path;
	}","public void setPath(final String path)
	{
		this.path = path;
	}",0,[0]
33566,bugs-dot-jar_WICKET-4520_b91154ea,"public final BehaviorInstantiationListenerCollection getBehaviorInstantiationListeners()
	{
		return behaviorInstantiationListeners;
	}","public final BehaviorInstantiationListenerCollection getBehaviorInstantiationListeners()
	{
		return behaviorInstantiationListeners;
	}",0,[0]
258,Bears-9,"@Override
    public Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException {
        /* Sometimes, however, we get an array wrapper; specifically
         * when an array or list has been serialized with type information.
         */
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromArray(p, ctxt);
        }
        return deserializeTypedFromObject(p, ctxt);
    }","@Override
    public Object deserializeTypedFromAny(JsonParser p, DeserializationContext ctxt) throws IOException {
        /* Sometimes, however, we get an array wrapper; specifically
         * when an array or list has been serialized with type information.
         */
        if (p.getCurrentToken() == JsonToken.START_ARRAY) {
            return super.deserializeTypedFromArray(p, ctxt);
        }
        return deserializeTypedFromObject(p, ctxt);
    }",0,[0]
10041,bugs-dot-jar_FLINK-2707_3e233a38,"@SuppressWarnings(""unchecked"")
	public StreamingRuntimeContext(
			Environment env,
			ExecutionConfig executionConfig,
			KeySelector<?, ?> statePartitioner,
			StateHandleProvider<?> provider,
			Map<String, Accumulator<?, ?>> accumulatorMap) {
		
		super(env.getTaskName(), env.getNumberOfSubtasks(), env.getIndexInSubtaskGroup(),
				env.getUserClassLoader(), executionConfig,
				env.getDistributedCacheEntries(), accumulatorMap);
		
		this.env = env;
		this.statePartitioner = statePartitioner;
		this.states = new HashMap<>();
		this.partitionedStates = new LinkedList<>();
		this.provider = (StateHandleProvider<Serializable>) provider;
	}","@SuppressWarnings(""unchecked"")
	public StreamingRuntimeContext(
			Environment env,
			ExecutionConfig executionConfig,
			KeySelector<?, ?> statePartitioner,
			StateHandleProvider<?> provider,
			Map<String, Accumulator<?, ?>> accumulatorMap) {
		
		super(env.getTaskName(), env.getNumberOfSubtasks(), env.getIndexInSubtaskGroup(),
				env.getUserClassLoader(), executionConfig,
				env.getDistributedCacheEntries(), accumulatorMap);
		
		this.env = env;
		this.statePartitioner = statePartitioner;
		this.states = new HashMap<>();
		this.partitionedStates = new LinkedList<>();
		this.provider = (StateHandleProvider<Serializable>) provider;
	}",0,[0]
1814,bugs-dot-jar_CAMEL-8146_17475d80,"public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }","public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }",0,[0]
15698,bugs-dot-jar_CAMEL-7562_689147e9,"private ProcessorDefinitionHelper() {
    }","private ProcessorDefinitionHelper() {
    }",0,[0]
3499,bugs-dot-jar_WICKET-4256_09166ea8,"public final void success(final Serializable message)
	{
		getSession().getFeedbackMessages().success(this, message);
		getSession().dirty();
	}","public final void success(final Serializable message)
	{
		getSession().getFeedbackMessages().success(this, message);
		getSession().dirty();
	}",0,[0]
4395,bugs-dot-jar_CAMEL-4682_1e54865c,"@Override
    public String toString() {
        return ""CamelContext("" + getName() + "")"";
    }","@Override
    public String toString() {
        return ""CamelContext("" + getName() + "")"";
    }",0,[0]
13845,bugs-dot-jar_CAMEL-4011_cbffff59,"@Converter
    public static String fromCharArray(char[] value) {
        return new String(value);
    }","@Converter
    public static String fromCharArray(char[] value) {
        return new String(value);
    }",0,[0]
8001,bugs-dot-jar_ACCUMULO-3242_15e83709,"protected static void retryOrThrow(Retry retry, KeeperException e) throws KeeperException {
    log.warn(""Saw (possibly) transient exception communicating with ZooKeeper"", e);
    if (retry.canRetry()) {
      retry.useRetry();
      return;
    }

    log.error(""Retry attempts ("" + retry.retriesCompleted() + "") exceeded trying to communicate with ZooKeeper"");
    throw e;
  }","protected static void retryOrThrow(Retry retry, KeeperException e) throws KeeperException {
    log.warn(""Saw (possibly) transient exception communicating with ZooKeeper"", e);
    if (retry.canRetry()) {
      retry.useRetry();
      return;
    }

    log.error(""Retry attempts ("" + retry.retriesCompleted() + "") exceeded trying to communicate with ZooKeeper"");
    throw e;
  }",0,[0]
38752,bugs-dot-jar_OAK-276_1bf5c550,"public ChildNodeEntriesMap getCNEMap(Id id) throws NotFoundException,
            Exception {
        verifyInitialized();

        ChildNodeEntriesMap map = (ChildNodeEntriesMap) cache.get(id);
        if (map != null) {
            return map;
        }

        map = pm.readCNEMap(id);

        cache.put(id, map);

        return map;
    }","public ChildNodeEntriesMap getCNEMap(Id id) throws NotFoundException,
            Exception {
        verifyInitialized();

        ChildNodeEntriesMap map = (ChildNodeEntriesMap) cache.get(id);
        if (map != null) {
            return map;
        }

        map = pm.readCNEMap(id);

        cache.put(id, map);

        return map;
    }",0,[0]
5799,bugs-dot-jar_MATH-1230_96eb80ef,"public SimplexSolver(final double epsilon, final int maxUlps, final double cutOff) {
        this.epsilon = epsilon;
        this.maxUlps = maxUlps;
        this.cutOff = cutOff;
        this.pivotSelection = PivotSelectionRule.DANTZIG;
    }","public SimplexSolver(final double epsilon, final int maxUlps, final double cutOff) {
        this.epsilon = epsilon;
        this.maxUlps = maxUlps;
        this.cutOff = cutOff;
        this.pivotSelection = PivotSelectionRule.DANTZIG;
    }",0,[0]
34360,bugs-dot-jar_MATH-546_b6bf8f41,"private T getPointFromLargestVarianceCluster(final Collection<Cluster<T>> clusters) {

        double maxVariance = Double.NEGATIVE_INFINITY;
        Cluster<T> selected = null;
        for (final Cluster<T> cluster : clusters) {
            if (!cluster.getPoints().isEmpty()) {

                // compute the distance variance of the current cluster
                final T center = cluster.getCenter();
                final Variance stat = new Variance();
                for (final T point : cluster.getPoints()) {
                    stat.increment(point.distanceFrom(center));
                }
                final double variance = stat.getResult();

                // select the cluster with the largest variance
                if (variance > maxVariance) {
                    maxVariance = variance;
                    selected = cluster;
                }

            }
        }

        // did we find at least one non-empty cluster ?
        if (selected == null) {
            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
        }

        // extract a random point from the cluster
        final List<T> selectedPoints = selected.getPoints();
        return selectedPoints.remove(random.nextInt(selectedPoints.size()));

    }","private T getPointFromLargestVarianceCluster(final Collection<Cluster<T>> clusters) {

        double maxVariance = Double.NEGATIVE_INFINITY;
        Cluster<T> selected = null;
        for (final Cluster<T> cluster : clusters) {
            if (!cluster.getPoints().isEmpty()) {

                // compute the distance variance of the current cluster
                final T center = cluster.getCenter();
                final Variance stat = new Variance();
                for (final T point : cluster.getPoints()) {
                    stat.increment(point.distanceFrom(center));
                }
                final double variance = stat.getResult();

                // select the cluster with the largest variance
                if (variance > maxVariance) {
                    maxVariance = variance;
                    selected = cluster;
                }

            }
        }

        // did we find at least one non-empty cluster ?
        if (selected == null) {
            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
        }

        // extract a random point from the cluster
        final List<T> selectedPoints = selected.getPoints();
        return selectedPoints.remove(random.nextInt(selectedPoints.size()));

    }",0,[0]
36505,bugs-dot-jar_MATH-1093_7cfbc0da,"private BSPTree<Sphere1D> nextInternalNode(BSPTree<Sphere1D> node) {

        if (childAfter(node).getCut() != null) {
            // the next node is in the sub-tree
            return leafAfter(node).getParent();
        }

        // there is nothing left deeper in the tree, we backtrack
        while (isAfterParent(node)) {
            node = node.getParent();
        }
        return node.getParent();

    }","private BSPTree<Sphere1D> nextInternalNode(BSPTree<Sphere1D> node) {

        if (childAfter(node).getCut() != null) {
            // the next node is in the sub-tree
            return leafAfter(node).getParent();
        }

        // there is nothing left deeper in the tree, we backtrack
        while (isAfterParent(node)) {
            node = node.getParent();
        }
        return node.getParent();

    }",0,[0]
7056,bugs-dot-jar_LOG4J2-763_97203de8,"public MessageFormatMessage(final String messagePattern, final Object... arguments) {
        this.messagePattern = messagePattern;
        this.argArray = arguments;
        if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {
            this.throwable = (Throwable) arguments[arguments.length - 1];
        }
    }","public MessageFormatMessage(final String messagePattern, final Object... arguments) {
        this.messagePattern = messagePattern;
        this.argArray = arguments;
        if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {
            this.throwable = (Throwable) arguments[arguments.length - 1];
        }
        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time
    }",1,[]
39291,bugs-dot-jar_OAK-4353_b0014b7d,"File getFile() {
        return file;
    }","File getFile() {
        return file;
    }",0,[0]
7838,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }

        if (!(other instanceof RealVector)) {
            return false;
        }

        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }

        if (rhs.isNaN()) {
            return this.isNaN();
        }

        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    }","@Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }

        if (!(other instanceof RealVector)) {
            return false;
        }

        RealVector rhs = (RealVector) other;
        if (data.length != rhs.getDimension()) {
            return false;
        }

        if (rhs.isNaN()) {
            return this.isNaN();
        }

        for (int i = 0; i < data.length; ++i) {
            if (data[i] != rhs.getEntry(i)) {
                return false;
            }
        }
        return true;
    }",0,[0]
9465,bugs-dot-jar_WICKET-5319_c863b032,"@Override
	public Url mapHandler(final IRequestHandler requestHandler)
	{
		final Url url = wrappedMapper.mapHandler(requestHandler);

		if (url == null)
		{
			return null;
		}

		return encryptUrl(url);
	}","@Override
	public Url mapHandler(final IRequestHandler requestHandler)
	{
		final Url url = wrappedMapper.mapHandler(requestHandler);

		if (url == null)
		{
			return null;
		}

		if (url.isFull())
		{
			// do not encrypt full urls
			return url;
		}

		return encryptUrl(url);
	}",1,[]
31379,bugs-dot-jar_ACCUMULO-2952_11d11e0d,"List<TabletMigration> move(ServerCounts tooMuch, ServerCounts tooLittle, int count, Map<String,Map<KeyExtent,TabletStats>> donerTabletStats) {
    
    List<TabletMigration> result = new ArrayList<TabletMigration>();
    if (count == 0)
      return result;
    
    // Copy counts so we can update them as we propose migrations
    Map<String,Integer> tooMuchMap = tabletCountsPerTable(tooMuch.status);
    Map<String,Integer> tooLittleMap = tabletCountsPerTable(tooLittle.status);
    
    for (int i = 0; i < count; i++) {
      String table;
      Integer tooLittleCount;
      if (tableToBalance == null) {
        // find a table to migrate
        // look for an uneven table count
        int biggestDifference = 0;
        String biggestDifferenceTable = null;
        for (Entry<String,Integer> tableEntry : tooMuchMap.entrySet()) {
          String tableID = tableEntry.getKey();
          if (tooLittleMap.get(tableID) == null)
            tooLittleMap.put(tableID, 0);
          int diff = tableEntry.getValue() - tooLittleMap.get(tableID);
          if (diff > biggestDifference) {
            biggestDifference = diff;
            biggestDifferenceTable = tableID;
          }
        }
        if (biggestDifference < 2) {
          table = busiest(tooMuch.status.tableMap);
        } else {
          table = biggestDifferenceTable;
        }
      } else {
        // just balance the given table
        table = tableToBalance;
      }
      Map<KeyExtent,TabletStats> onlineTabletsForTable = donerTabletStats.get(table);
      try {
        if (onlineTabletsForTable == null) {
          onlineTabletsForTable = new HashMap<KeyExtent,TabletStats>();
          for (TabletStats stat : getOnlineTabletsForTable(tooMuch.server, table))
            onlineTabletsForTable.put(new KeyExtent(stat.extent), stat);
          donerTabletStats.put(table, onlineTabletsForTable);
        }
      } catch (Exception ex) {
        log.error(""Unable to select a tablet to move"", ex);
        return result;
      }
      KeyExtent extent = selectTablet(tooMuch.server, onlineTabletsForTable);
      onlineTabletsForTable.remove(extent);
      if (extent == null)
        return result;
      tooMuchMap.put(table, tooMuchMap.get(table) - 1);
      /**
       * If a table grows from 1 tablet then tooLittleMap.get(table) can return a null, since there is only one tabletserver that holds all of the tablets. Here
       * we check to see if in fact that is the case and if so set the value to 0.
       */
      tooLittleCount = tooLittleMap.get(table);
      if (tooLittleCount == null) {
        tooLittleCount = 0;
      }
      tooLittleMap.put(table, tooLittleCount + 1);
      
      result.add(new TabletMigration(extent, tooMuch.server, tooLittle.server));
    }
    return result;
  }","List<TabletMigration> move(ServerCounts tooMuch, ServerCounts tooLittle, int count, Map<String,Map<KeyExtent,TabletStats>> donerTabletStats) {
    
    List<TabletMigration> result = new ArrayList<TabletMigration>();
    if (count == 0)
      return result;
    
    // Copy counts so we can update them as we propose migrations
    Map<String,Integer> tooMuchMap = tabletCountsPerTable(tooMuch.status);
    Map<String,Integer> tooLittleMap = tabletCountsPerTable(tooLittle.status);
    
    for (int i = 0; i < count; i++) {
      String table;
      Integer tooLittleCount;
      if (tableToBalance == null) {
        // find a table to migrate
        // look for an uneven table count
        int biggestDifference = 0;
        String biggestDifferenceTable = null;
        for (Entry<String,Integer> tableEntry : tooMuchMap.entrySet()) {
          String tableID = tableEntry.getKey();
          if (tooLittleMap.get(tableID) == null)
            tooLittleMap.put(tableID, 0);
          int diff = tableEntry.getValue() - tooLittleMap.get(tableID);
          if (diff > biggestDifference) {
            biggestDifference = diff;
            biggestDifferenceTable = tableID;
          }
        }
        if (biggestDifference < 2) {
          table = busiest(tooMuch.status.tableMap);
        } else {
          table = biggestDifferenceTable;
        }
      } else {
        // just balance the given table
        table = tableToBalance;
      }
      Map<KeyExtent,TabletStats> onlineTabletsForTable = donerTabletStats.get(table);
      try {
        if (onlineTabletsForTable == null) {
          onlineTabletsForTable = new HashMap<KeyExtent,TabletStats>();
          for (TabletStats stat : getOnlineTabletsForTable(tooMuch.server, table))
            onlineTabletsForTable.put(new KeyExtent(stat.extent), stat);
          donerTabletStats.put(table, onlineTabletsForTable);
        }
      } catch (Exception ex) {
        log.error(""Unable to select a tablet to move"", ex);
        return result;
      }
      KeyExtent extent = selectTablet(tooMuch.server, onlineTabletsForTable);
      onlineTabletsForTable.remove(extent);
      if (extent == null)
        return result;
      tooMuchMap.put(table, tooMuchMap.get(table) - 1);
      /**
       * If a table grows from 1 tablet then tooLittleMap.get(table) can return a null, since there is only one tabletserver that holds all of the tablets. Here
       * we check to see if in fact that is the case and if so set the value to 0.
       */
      tooLittleCount = tooLittleMap.get(table);
      if (tooLittleCount == null) {
        tooLittleCount = 0;
      }
      tooLittleMap.put(table, tooLittleCount + 1);
      tooMuch.count--;
      tooLittle.count++;
      result.add(new TabletMigration(extent, tooMuch.server, tooLittle.server));
    }
    return result;
  }",1,[]
36943,bugs-dot-jar_OAK-1933_2e16a983,"@Override
    public String toString() {
        return protect(constraint1) + "" and "" + protect(constraint2);
    }","@Override
    public String toString() {
        return protect(constraint1) + "" and "" + protect(constraint2);
    }",0,[0]
2702,bugs-dot-jar_OAK-1932_913c2f53,"public synchronized void flush() {
        if (length > 0) {
            int refcount = segment.getRefCount();

            int rootcount = roots.size();
            buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);
            buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;

            int blobrefcount = blobrefs.size();
            buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);
            buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;

            length = align(
                    refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,
                    16);

            int pos = refcount * 16;
            if (pos + length <= buffer.length) {
                // the whole segment fits to the space *after* the referenced
                // segment identifiers we've already written, so we can safely
                // copy those bits ahead even if concurrent code is still
                // reading from that part of the buffer
                System.arraycopy(buffer, 0, buffer, buffer.length-length, pos);
                pos += buffer.length - length;
            } else {
                // this might leave some empty space between the header and
                // the record data, but this case only occurs when the
                // segment is >252kB in size and the maximum overhead is <<4kB,
                // which is acceptable
                length = buffer.length;
            }

            for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {
                int offset = entry.getKey().getOffset();
                buffer[pos++] = (byte) entry.getValue().ordinal();
                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));
                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);
            }

            for (RecordId blobref : blobrefs) {
                int offset = blobref.getOffset();
                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));
                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);
            }

            SegmentId id = segment.getSegmentId();
            log.debug(""Writing data segment {} ({} bytes)"", id, length);
            store.writeSegment(id, buffer, buffer.length - length, length);

            // Keep this segment in memory as it's likely to be accessed soon
            ByteBuffer data;
            if (buffer.length - length > 4096) {
                data = ByteBuffer.allocate(length);
                data.put(buffer, buffer.length - length, length);
                data.rewind();
            } else {
                data = ByteBuffer.wrap(buffer, buffer.length - length, length);
            }
            tracker.setSegment(id, new Segment(tracker, id, data));

            buffer = createNewBuffer();
            roots.clear();
            blobrefs.clear();
            length = 0;
            position = buffer.length;
            segment = new Segment(tracker, buffer);
            segment.getSegmentId().setSegment(segment);
        }
    }","public synchronized void flush() {
        if (length > 0) {
            int refcount = segment.getRefCount();

            int rootcount = roots.size();
            buffer[Segment.ROOT_COUNT_OFFSET] = (byte) (rootcount >> 8);
            buffer[Segment.ROOT_COUNT_OFFSET + 1] = (byte) rootcount;

            int blobrefcount = blobrefs.size();
            buffer[Segment.BLOBREF_COUNT_OFFSET] = (byte) (blobrefcount >> 8);
            buffer[Segment.BLOBREF_COUNT_OFFSET + 1] = (byte) blobrefcount;

            length = align(
                    refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,
                    16);

            int pos = refcount * 16;
            if (pos + length <= buffer.length) {
                // the whole segment fits to the space *after* the referenced
                // segment identifiers we've already written, so we can safely
                // copy those bits ahead even if concurrent code is still
                // reading from that part of the buffer
                System.arraycopy(buffer, 0, buffer, buffer.length-length, pos);
                pos += buffer.length - length;
            } else {
                // this might leave some empty space between the header and
                // the record data, but this case only occurs when the
                // segment is >252kB in size and the maximum overhead is <<4kB,
                // which is acceptable
                length = buffer.length;
            }

            for (Map.Entry<RecordId, RecordType> entry : roots.entrySet()) {
                int offset = entry.getKey().getOffset();
                buffer[pos++] = (byte) entry.getValue().ordinal();
                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));
                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);
            }

            for (RecordId blobref : blobrefs) {
                int offset = blobref.getOffset();
                buffer[pos++] = (byte) (offset >> (8 + Segment.RECORD_ALIGN_BITS));
                buffer[pos++] = (byte) (offset >> Segment.RECORD_ALIGN_BITS);
            }

            SegmentId id = segment.getSegmentId();
            log.debug(""Writing data segment {} ({} bytes)"", id, length);
            store.writeSegment(id, buffer, buffer.length - length, length);

            // Keep this segment in memory as it's likely to be accessed soon
            ByteBuffer data;
            if (buffer.length - length > 4096) {
                data = ByteBuffer.allocate(length);
                data.put(buffer, buffer.length - length, length);
                data.rewind();
            } else {
                data = ByteBuffer.wrap(buffer, buffer.length - length, length);
            }
            tracker.setSegment(id, new Segment(tracker, id, data));

            buffer = createNewBuffer();
            roots.clear();
            blobrefs.clear();
            length = 0;
            position = buffer.length;
            segment = new Segment(tracker, buffer);
            segment.getSegmentId().setSegment(segment);
        }
    }",0,[0]
11349,bugs-dot-jar_OAK-395_e6c31270,"@Override
    public void unlock() throws RepositoryException {
        String lockOwner = sessionDelegate.getOakPathOrThrow(JCR_LOCK_OWNER);
        String lockIsDeep = sessionDelegate.getOakPathOrThrow(JCR_LOCK_IS_DEEP);
        try {
            Root root = sessionDelegate.getContentSession().getLatestRoot();
            Tree tree = root.getTree(dlg.getPath());
            if (tree == null) {
                throw new ItemNotFoundException();
            }
            tree.removeProperty(lockOwner);
            tree.removeProperty(lockIsDeep);
            root.commit();
        } catch (CommitFailedException e) {
            throw new RepositoryException(""Unable to unlock "" + this, e);
        }

        getSession().refresh(true);
    }","@Override
    public void unlock() throws RepositoryException {
        String lockOwner = sessionDelegate.getOakPathOrThrow(JCR_LOCK_OWNER);
        String lockIsDeep = sessionDelegate.getOakPathOrThrow(JCR_LOCK_IS_DEEP);
        try {
            Root root = sessionDelegate.getContentSession().getLatestRoot();
            Tree tree = root.getTree(dlg.getPath());
            if (tree == null) {
                throw new ItemNotFoundException();
            }
            tree.removeProperty(lockOwner);
            tree.removeProperty(lockIsDeep);
            root.commit();
        } catch (CommitFailedException e) {
            throw new RepositoryException(""Unable to unlock "" + this, e);
        }

        getSession().refresh(true);
    }",0,[0]
15708,bugs-dot-jar_CAMEL-7562_689147e9,"public static boolean willCreateNewThreadPool(RouteContext routeContext, ExecutorServiceAwareDefinition<?> definition, boolean useDefault) {
        ExecutorServiceManager manager = routeContext.getCamelContext().getExecutorServiceManager();
        ObjectHelper.notNull(manager, ""ExecutorServiceManager"", routeContext.getCamelContext());
        
        if (definition.getExecutorService() != null) {
            // no there is a custom thread pool configured
            return false;
        } else if (definition.getExecutorServiceRef() != null) {
            ExecutorService answer = routeContext.getCamelContext().getRegistry().lookupByNameAndType(definition.getExecutorServiceRef(), ExecutorService.class);
            // if no existing thread pool, then we will have to create a new thread pool
            return answer == null;
        } else if (useDefault) {
            return true;
        }

        return false;
    }","public static boolean willCreateNewThreadPool(RouteContext routeContext, ExecutorServiceAwareDefinition<?> definition, boolean useDefault) {
        ExecutorServiceManager manager = routeContext.getCamelContext().getExecutorServiceManager();
        ObjectHelper.notNull(manager, ""ExecutorServiceManager"", routeContext.getCamelContext());
        
        if (definition.getExecutorService() != null) {
            // no there is a custom thread pool configured
            return false;
        } else if (definition.getExecutorServiceRef() != null) {
            ExecutorService answer = routeContext.getCamelContext().getRegistry().lookupByNameAndType(definition.getExecutorServiceRef(), ExecutorService.class);
            // if no existing thread pool, then we will have to create a new thread pool
            return answer == null;
        } else if (useDefault) {
            return true;
        }

        return false;
    }",0,[0]
1650,Bears-194,"private void analyzeSinkMethodArgs(Node simpleNode) {
		if (isAnyArgumentTainted(simpleNode)) {
			addSecurityViolation(this, this.rc, simpleNode, getMessage(), """");
		}

	}","private void analyzeSinkMethodArgs(Node simpleNode) {
		if (isAnyArgumentTainted(simpleNode)) {
			addSecurityViolation(this, this.rc, simpleNode, getMessage(), """");
		}

	}",0,[0]
1998,bugs-dot-jar_WICKET-2961_3d8c9d75,"protected void onMarkupAttached()
	{
		if (log.isDebugEnabled())
		{
			log.debug(""Markup available "" + toString());
		}

		// get the markup ID from the markup if available
		markupIdFromMarkup = getMarkupIdFromMarkup();

		// move the component to its real parent if necessary
// moveComponentToItsRealParent();
	}","protected void onMarkupAttached()
	{
		if (log.isDebugEnabled())
		{
			log.debug(""Markup available "" + toString());
		}

		// get the markup ID from the markup if available
		markupIdFromMarkup = getMarkupIdFromMarkup();

		// move the component to its real parent if necessary
// moveComponentToItsRealParent();
	}",0,[0]
2463,bugs-dot-jar_OAK-238_24ce6788,"@Override
    public Value createValue(Node value) throws RepositoryException {
        return createValue(value, false);
    }","@Override
    public Value createValue(Node value) throws RepositoryException {
        return createValue(value, false);
    }",0,[0]
13423,bugs-dot-jar_MATH-434_133cbc2d,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);
            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
                final double ratio = rhs / entry;
                if (MathUtils.equals(ratio, minRatio, epsilon)) {
                    minRatioPositions.add(i);
                } else if (ratio < minRatio) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
          return null;
        } else if (minRatioPositions.size() > 1) {
          // there's a degeneracy as indicated by a tie in the minimum ratio test
          // check if there's an artificial variable that can be forced out of the basis
          for (Integer row : minRatioPositions) {
            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
              int column = i + tableau.getArtificialVariableOffset();
              if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) &&
                  row.equals(tableau.getBasicRow(column))) {
                return row;
              }
            }
          }
        }
        return minRatioPositions.get(0);
    }","private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);
            
            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {
                final double ratio = rhs / entry;
                final int cmp = MathUtils.compareTo(ratio, minRatio, getEpsilon(ratio));
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
          return null;
        } else if (minRatioPositions.size() > 1) {
          // there's a degeneracy as indicated by a tie in the minimum ratio test
          // check if there's an artificial variable that can be forced out of the basis
          for (Integer row : minRatioPositions) {
            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
              int column = i + tableau.getArtificialVariableOffset();
              final double entry = tableau.getEntry(row, column);
              if (MathUtils.equals(entry, 1d, getEpsilon(entry)) &&
                  row.equals(tableau.getBasicRow(column))) {
                return row;
              }
            }
          }
        }
        return minRatioPositions.get(0);
    }",1,"[7, 9, 11, 27]"
23318,bugs-dot-jar_CAMEL-3395_8433e6db,"public static void copyResultsPreservePattern(Exchange result, Exchange source) {

        // --------------------------------------------------------------------
        //  TODO: merge logic with that of copyResults()
        // --------------------------------------------------------------------

        if (source == result) {
            // no need to copy
            return;
        }

        // copy in message
        result.getIn().copyFrom(source.getIn());

        // copy out message
        if (source.hasOut()) {
            // exchange pattern sensitive
            Message resultMessage = source.getOut().isFault() ? result.getOut() : getResultMessage(result);
            resultMessage.copyFrom(source.getOut());
        }

        // copy exception
        result.setException(source.getException());

        // copy properties
        if (source.hasProperties()) {
            result.getProperties().putAll(source.getProperties());
        }
    }","public static void copyResultsPreservePattern(Exchange result, Exchange source) {

        // --------------------------------------------------------------------
        //  TODO: merge logic with that of copyResults()
        // --------------------------------------------------------------------

        if (source == result) {
            // no need to copy
            return;
        }

        // copy in message
        result.getIn().copyFrom(source.getIn());

        // copy out message
        if (source.hasOut()) {
            // exchange pattern sensitive
            Message resultMessage = source.getOut().isFault() ? result.getOut() : getResultMessage(result);
            resultMessage.copyFrom(source.getOut());
        }

        // copy exception
        result.setException(source.getException());

        // copy properties
        if (source.hasProperties()) {
            result.getProperties().putAll(source.getProperties());
        }
    }",0,[0]
22534,bugs-dot-jar_OAK-606_f0fbacab,"@Nonnull
    public String getName() throws InvalidItemStateException {
        return PathUtils.getName(getPath());
    }","@Nonnull
    public String getName() throws InvalidItemStateException {
        return PathUtils.getName(getPath());
    }",0,[0]
32490,bugs-dot-jar_OAK-926_e1ae968c,"@CheckForNull
    private String getCommitValue(Revision revision) {
        String r = revision.toString();
        String value = getLocalRevisions().get(r);
        if (value == null) {
            // check previous
            for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {
                value = prev.getLocalRevisions().get(r);
                if (value != null) {
                    break;
                }
            }
        }
        return value;
    }","@CheckForNull
    private String getCommitValue(Revision revision) {
        String r = revision.toString();
        String value = getLocalRevisions().get(r);
        if (value == null) {
            // check previous
            for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {
                value = prev.getLocalRevisions().get(r);
                if (value != null) {
                    break;
                }
            }
        }
        return value;
    }",0,[0]
19839,bugs-dot-jar_LOG4J2-470_50340d0c,"public Interpolator() {
        this.defaultLookup = new MapLookup(new HashMap<String, String>());
        lookups.put(""sys"", new SystemPropertiesLookup());
        lookups.put(""env"", new EnvironmentLookup());
        lookups.put(""jndi"", new JndiLookup());
        try {
            if (Class.forName(""javax.servlet.ServletContext"") != null) {
                lookups.put(""web"", new WebLookup());
            }
        } catch (ClassNotFoundException ex) {
            LOGGER.debug(""ServletContext not present - WebLookup not added"");
        } catch (Exception ex) {
            LOGGER.error(""Unable to locate ServletContext"", ex);
        }
    }","public Interpolator() {
        this((Map<String, String>) null);
    }",1,"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]"
620,bugs-dot-jar_MNG-5727_ce6f0bfd,"public List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories )
    {
        if ( repositories == null )
        {
            return null;
        }

        Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>();

        for ( ArtifactRepository repository : repositories )
        {
            String key = repository.getId();

            List<ArtifactRepository> aliasedRepos = reposByKey.get( key );

            if ( aliasedRepos == null )
            {
                aliasedRepos = new ArrayList<ArtifactRepository>();
                reposByKey.put( key, aliasedRepos );
            }

            aliasedRepos.add( repository );
        }

        List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>();

        for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() )
        {
            List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>();

            List<ArtifactRepositoryPolicy> releasePolicies =
                new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                releasePolicies.add( aliasedRepo.getReleases() );
                mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() );
            }

            ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );

            List<ArtifactRepositoryPolicy> snapshotPolicies =
                new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                snapshotPolicies.add( aliasedRepo.getSnapshots() );
            }

            ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy( snapshotPolicies );

            ArtifactRepository aliasedRepo = aliasedRepos.get( 0 );

            ArtifactRepository effectiveRepository =
                createArtifactRepository( aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(),
                                          snapshotPolicy, releasePolicy );

            effectiveRepository.setAuthentication( aliasedRepo.getAuthentication() );

            effectiveRepository.setProxy( aliasedRepo.getProxy() );

            effectiveRepository.setMirroredRepositories( mirroredRepos );

            effectiveRepositories.add( effectiveRepository );
        }

        return effectiveRepositories;
    }","public List<ArtifactRepository> getEffectiveRepositories( List<ArtifactRepository> repositories )
    {
        if ( repositories == null )
        {
            return null;
        }

        Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>();

        for ( ArtifactRepository repository : repositories )
        {
            String key = repository.getId();

            List<ArtifactRepository> aliasedRepos = reposByKey.get( key );

            if ( aliasedRepos == null )
            {
                aliasedRepos = new ArrayList<ArtifactRepository>();
                reposByKey.put( key, aliasedRepos );
            }

            aliasedRepos.add( repository );
        }

        List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>();

        for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() )
        {
            List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>();

            List<ArtifactRepositoryPolicy> releasePolicies =
                new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                releasePolicies.add( aliasedRepo.getReleases() );
                mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() );
            }

            ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );

            List<ArtifactRepositoryPolicy> snapshotPolicies =
                new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );

            for ( ArtifactRepository aliasedRepo : aliasedRepos )
            {
                snapshotPolicies.add( aliasedRepo.getSnapshots() );
            }

            ArtifactRepositoryPolicy snapshotPolicy = getEffectivePolicy( snapshotPolicies );

            ArtifactRepository aliasedRepo = aliasedRepos.get( 0 );

            ArtifactRepository effectiveRepository =
                createArtifactRepository( aliasedRepo.getId(), aliasedRepo.getUrl(), aliasedRepo.getLayout(),
                                          snapshotPolicy, releasePolicy );

            effectiveRepository.setAuthentication( aliasedRepo.getAuthentication() );

            effectiveRepository.setProxy( aliasedRepo.getProxy() );

            effectiveRepository.setMirroredRepositories( mirroredRepos );

            effectiveRepositories.add( effectiveRepository );
        }

        return effectiveRepositories;
    }",0,[0]
16583,bugs-dot-jar_CAMEL-4536_df9f4a6a,"public static AsyncProcessor convert(Processor value) {
        if (value instanceof AsyncProcessor) {
            return (AsyncProcessor)value;
        }
        return new ProcessorToAsyncProcessorBridge(value);
    }","public static AsyncProcessor convert(Processor value) {
        if (value instanceof AsyncProcessor) {
            return (AsyncProcessor)value;
        }
        return new ProcessorToAsyncProcessorBridge(value);
    }",0,[0]
12796,bugs-dot-jar_MATH-1208_ce2badf0,"public void load(URL url) throws IOException, NullArgumentException, ZeroException {
        MathUtils.checkNotNull(url);
        Charset charset = Charset.forName(FILE_CHARSET);
        BufferedReader in =
            new BufferedReader(new InputStreamReader(url.openStream(), charset));
        try {
            DataAdapter da = new StreamDataAdapter(in);
            da.computeStats();
            if (sampleStats.getN() == 0) {
                throw new ZeroException(LocalizedFormats.URL_CONTAINS_NO_DATA, url);
            }
            // new adapter for the second pass
            in = new BufferedReader(new InputStreamReader(url.openStream(), charset));
            fillBinStats(new StreamDataAdapter(in));
            loaded = true;
        } finally {
           try {
               in.close();
           } catch (IOException ex) { //NOPMD
               // ignore
           }
        }
    }","public void load(URL url) throws IOException, NullArgumentException, ZeroException {
        MathUtils.checkNotNull(url);
        Charset charset = Charset.forName(FILE_CHARSET);
        BufferedReader in =
            new BufferedReader(new InputStreamReader(url.openStream(), charset));
        try {
            DataAdapter da = new StreamDataAdapter(in);
            da.computeStats();
            if (sampleStats.getN() == 0) {
                throw new ZeroException(LocalizedFormats.URL_CONTAINS_NO_DATA, url);
            }
            // new adapter for the second pass
            in = new BufferedReader(new InputStreamReader(url.openStream(), charset));
            fillBinStats(new StreamDataAdapter(in));
            loaded = true;
        } finally {
           try {
               in.close();
           } catch (IOException ex) { //NOPMD
               // ignore
           }
        }
    }",0,[0]
17200,bugs-dot-jar_WICKET-294_5c592d85,"protected void addBookmarkablePageParameters(final Request request,
			final RequestParameters parameters)
	{
		final String requestString = request
				.getParameter(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);
		if (requestString != null)
		{
			final String[] components = Strings.split(requestString, Component.PATH_SEPARATOR);
			if (components.length != 2)
			{
				throw new WicketRuntimeException(""Invalid bookmarkablePage parameter: ""
						+ requestString + "", expected: 'pageMapName:pageClassName'"");
			}

			// Extract any pagemap name
			final String pageMapName = components[0];
			parameters.setPageMapName(pageMapName.length() == 0
					? PageMap.DEFAULT_NAME
					: pageMapName);

			// Extract bookmarkable page class name
			final String pageClassName = components[1];
			parameters.setBookmarkablePageClass(pageClassName);
		}
	}","protected void addBookmarkablePageParameters(final Request request,
			final RequestParameters parameters)
	{
		final String requestString = request
				.getParameter(WebRequestCodingStrategy.BOOKMARKABLE_PAGE_PARAMETER_NAME);
		if (requestString != null)
		{
			final String[] components = Strings.split(requestString, Component.PATH_SEPARATOR);
			if (components.length != 2)
			{
				throw new WicketRuntimeException(""Invalid bookmarkablePage parameter: ""
						+ requestString + "", expected: 'pageMapName:pageClassName'"");
			}

			// Extract any pagemap name
			final String pageMapName = components[0];
			parameters.setPageMapName(pageMapName.length() == 0
					? PageMap.DEFAULT_NAME
					: pageMapName);

			// Extract bookmarkable page class name
			final String pageClassName = components[1];
			parameters.setBookmarkablePageClass(pageClassName);
		}
	}",0,[0]
12097,bugs-dot-jar_OAK-642_7a84b3a8,"@Override
    public boolean hasNode(final String relPath) throws RepositoryException {
        checkStatus();

        return sessionDelegate.perform(new SessionOperation<Boolean>() {
            @Override
            public Boolean perform() throws RepositoryException {
                String oakPath = sessionDelegate.getOakPath(relPath);
                return dlg.getChild(oakPath) != null;
            }
        });
    }","@Override
    public boolean hasNode(final String relPath) throws RepositoryException {
        checkStatus();

        return sessionDelegate.perform(new SessionOperation<Boolean>() {
            @Override
            public Boolean perform() throws RepositoryException {
                String oakPath = sessionDelegate.getOakPath(relPath);
                return dlg.getChild(oakPath) != null;
            }
        });
    }",0,[0]
30965,bugs-dot-jar_LOG4J2-410_8f0c4871,"@Override
    public void warn(final String format, final Object arg1, final Object arg2) {
        if (logger.isWarnEnabled()) {
            final ParameterizedMessage msg = new ParameterizedMessage(format, arg1, arg2);
            logger.log(null, FQCN, Level.WARN, msg, msg.getThrowable());
        }
    }","@Override
    public void warn(final String format, final Object arg1, final Object arg2) {
        if (logger.isWarnEnabled()) {
            final ParameterizedMessage msg = new ParameterizedMessage(format, arg1, arg2);
            logger.log(null, FQCN, Level.WARN, msg, msg.getThrowable());
        }
    }",0,[0]
8954,bugs-dot-jar_FLINK-2082_0cfa43d7,"public void flushOutputs() throws IOException, InterruptedException {
		for (StreamOutput<?> streamOutput : getOutputs()) {
			streamOutput.close();
		}
	}","public void flushOutputs() throws IOException, InterruptedException {
		for (StreamOutput<?> streamOutput : getOutputs()) {
			streamOutput.close();
		}
	}",0,[0]
10297,bugs-dot-jar_OAK-3897_94c6c575,"private boolean checkNodeNotExistsFromChildrenCache(String path,
                                                        RevisionVector rev) {
        if (PathUtils.denotesRoot(path)) {
            return false;
        }

        final String parentPath = PathUtils.getParentPath(path);
        PathRev key = childNodeCacheKey(parentPath, rev, null);//read first child cache entry
        DocumentNodeState.Children children = nodeChildrenCache.getIfPresent(key);
        String lookupChildName = PathUtils.getName(path);

        //Does not know about children so cannot say for sure
        if (children == null) {
            return false;
        }

        //List not complete so cannot say for sure
        if (children.hasMore) {
            return false;
        }

        int childPosition = Collections.binarySearch(children.children, lookupChildName);
        if (childPosition < 0) {
            //Node does not exist for sure
            LOG.trace(""Child node as per path {} does not exist at revision {}"", path, rev);
            return true;
        }

        return false;
    }","private boolean checkNodeNotExistsFromChildrenCache(String path,
                                                        RevisionVector rev) {
        if (PathUtils.denotesRoot(path)) {
            return false;
        }

        final String parentPath = PathUtils.getParentPath(path);
        PathRev key = childNodeCacheKey(parentPath, rev, null);//read first child cache entry
        DocumentNodeState.Children children = nodeChildrenCache.getIfPresent(key);
        String lookupChildName = PathUtils.getName(path);

        //Does not know about children so cannot say for sure
        if (children == null) {
            return false;
        }

        //List not complete so cannot say for sure
        if (children.hasMore) {
            return false;
        }

        int childPosition = Collections.binarySearch(children.children, lookupChildName);
        if (childPosition < 0) {
            //Node does not exist for sure
            LOG.trace(""Child node as per path {} does not exist at revision {}"", path, rev);
            return true;
        }

        return false;
    }",0,[0]
23603,bugs-dot-jar_OAK-4423_08f0b280,"@Override
    public NodeState merge(
            @Nonnull NodeBuilder builder, @Nonnull CommitHook commitHook,
            @Nonnull CommitInfo info) throws CommitFailedException {
        checkArgument(builder instanceof SegmentNodeBuilder);
        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;
        checkArgument(snb.isRootBuilder());
        checkNotNull(commitHook);

        try {
            commitSemaphore.acquire();
            try {
                Commit commit = new Commit(snb, commitHook, info);
                NodeState merged = commit.execute();
                snb.reset(merged);
                return merged;
            } finally {
                commitSemaphore.release();
            }
        } catch (InterruptedException e) {
            currentThread().interrupt();
            throw new CommitFailedException(
                    ""Segment"", 2, ""Merge interrupted"", e);
        } catch (SegmentOverflowException e) {
            throw new CommitFailedException(
                    ""Segment"", 3, ""Merge failed"", e);
        }
    }","@Override
    public NodeState merge(
            @Nonnull NodeBuilder builder, @Nonnull CommitHook commitHook,
            @Nonnull CommitInfo info) throws CommitFailedException {
        checkArgument(builder instanceof SegmentNodeBuilder);
        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;
        checkArgument(snb.isRootBuilder());
        checkNotNull(commitHook);

        try {
            commitSemaphore.acquire();
            try {
                Commit commit = new Commit(snb, commitHook, info);
                NodeState merged = commit.execute();
                snb.reset(merged);
                return merged;
            } finally {
                commitSemaphore.release();
            }
        } catch (InterruptedException e) {
            currentThread().interrupt();
            throw new CommitFailedException(
                    ""Segment"", 2, ""Merge interrupted"", e);
        } catch (SegmentOverflowException e) {
            throw new CommitFailedException(
                    ""Segment"", 3, ""Merge failed"", e);
        }
    }",0,[0]
20803,bugs-dot-jar_CAMEL-5215_033eb6fe,"protected GenericFileProducer(GenericFileEndpoint<T> endpoint, GenericFileOperations<T> operations) {
        super(endpoint);
        this.endpoint = endpoint;
        this.operations = operations;
    }","protected GenericFileProducer(GenericFileEndpoint<T> endpoint, GenericFileOperations<T> operations) {
        super(endpoint);
        this.endpoint = endpoint;
        this.operations = operations;
    }",0,[0]
2646,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void pingTabletServer(ByteBuffer login, String tserver) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      getConnector(login).instanceOperations().ping(tserver);
    } catch (Exception e) {
      handleException(e);
    }
  }","@Override
  public void pingTabletServer(ByteBuffer login, String tserver) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      getConnector(login).instanceOperations().ping(tserver);
    } catch (Exception e) {
      handleException(e);
    }
  }",0,[0]
5783,bugs-dot-jar_CAMEL-3760_5225e6e3,"public ObjectName getObjectNameForTracer(CamelContext context, InterceptStrategy tracer) throws MalformedObjectNameException {
        StringBuilder buffer = new StringBuilder();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(context)).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_TRACER + "","");
        buffer.append(KEY_NAME + ""="")
            .append(""Tracer"")
            .append(""("").append(ObjectHelper.getIdentityHashCode(tracer)).append("")"");
        return createObjectName(buffer);
    }","public ObjectName getObjectNameForTracer(CamelContext context, InterceptStrategy tracer) throws MalformedObjectNameException {
        StringBuilder buffer = new StringBuilder();
        buffer.append(domainName).append("":"");
        buffer.append(KEY_CONTEXT + ""="").append(getContextId(context)).append("","");
        buffer.append(KEY_TYPE + ""="" + TYPE_TRACER + "","");
        buffer.append(KEY_NAME + ""="")
            .append(""Tracer"")
            .append(""("").append(ObjectHelper.getIdentityHashCode(tracer)).append("")"");
        return createObjectName(buffer);
    }",0,[0]
25202,bugs-dot-jar_OAK-3549_9772f5b2,"boolean updateClusterState() {
        boolean hasChanged = false;
        long now = clock.getTime();
        Set<Integer> inactive = Sets.newHashSet();
        for (ClusterNodeInfoDocument doc : ClusterNodeInfoDocument.all(store)) {
            int cId = doc.getClusterId();
            if (cId != this.clusterId && !doc.isActive()) {
                inactive.add(cId);
            } else {
                hasChanged |= activeClusterNodes.put(cId, doc.getLeaseEndTime())==null;
            }
        }
        hasChanged |= activeClusterNodes.keySet().removeAll(inactive);
        hasChanged |= inactiveClusterNodes.keySet().retainAll(inactive);
        for (Integer clusterId : inactive) {
            hasChanged |= inactiveClusterNodes.putIfAbsent(clusterId, now)==null;
        }
        return hasChanged;
    }","boolean updateClusterState() {
        boolean hasChanged = false;
        long now = clock.getTime();
        Set<Integer> inactive = Sets.newHashSet();
        for (ClusterNodeInfoDocument doc : ClusterNodeInfoDocument.all(store)) {
            int cId = doc.getClusterId();
            if (cId != this.clusterId && !doc.isActive()) {
                inactive.add(cId);
            } else {
                hasChanged |= activeClusterNodes.put(cId, doc.getLeaseEndTime())==null;
            }
        }
        hasChanged |= activeClusterNodes.keySet().removeAll(inactive);
        hasChanged |= inactiveClusterNodes.keySet().retainAll(inactive);
        for (Integer clusterId : inactive) {
            hasChanged |= inactiveClusterNodes.putIfAbsent(clusterId, now)==null;
        }
        return hasChanged;
    }",0,[0]
25305,bugs-dot-jar_ACCUMULO-193_8ad5a888,"public TKey toThrift() {
    return new TKey(ByteBuffer.wrap(row), ByteBuffer.wrap(colFamily), ByteBuffer.wrap(colQualifier), ByteBuffer.wrap(colVisibility), timestamp);
  }","public TKey toThrift() {
    return new TKey(ByteBuffer.wrap(row), ByteBuffer.wrap(colFamily), ByteBuffer.wrap(colQualifier), ByteBuffer.wrap(colVisibility), timestamp);
  }",0,[0]
29345,bugs-dot-jar_LOG4J2-268_8faf7f77,"@Override
    public Map<String, String> getContextMap() {
        return ctx;
    }","@Override
    public Map<String, String> getContextMap() {
        return ctx;
    }",0,[0]
1531,bugs-dot-jar_MNG-5212_712c4fff,"private static List<ComponentDescriptor<?>> clone( List<MojoDescriptor> mojos, PluginDescriptor pluginDescriptor )
    {
        List<ComponentDescriptor<?>> clones = null;

        if ( mojos != null )
        {
            clones = new ArrayList<ComponentDescriptor<?>>( mojos.size() );

            for ( MojoDescriptor mojo : mojos )
            {
                MojoDescriptor clone = mojo.clone();
                clone.setPluginDescriptor( pluginDescriptor );
                clones.add( clone );
            }
        }

        return clones;
    }","private static List<ComponentDescriptor<?>> clone( List<MojoDescriptor> mojos, PluginDescriptor pluginDescriptor )
    {
        List<ComponentDescriptor<?>> clones = null;

        if ( mojos != null )
        {
            clones = new ArrayList<ComponentDescriptor<?>>( mojos.size() );

            for ( MojoDescriptor mojo : mojos )
            {
                MojoDescriptor clone = mojo.clone();
                clone.setPluginDescriptor( pluginDescriptor );
                clones.add( clone );
            }
        }

        return clones;
    }",0,[0]
32833,bugs-dot-jar_MATH-373_bfe4623c,"public static void copy(SumOfLogs source, SumOfLogs dest) {
        dest.n = source.n;
        dest.value = source.value;
    }","public static void copy(SumOfLogs source, SumOfLogs dest) {
        dest.n = source.n;
        dest.value = source.value;
    }",0,[0]
27142,bugs-dot-jar_MATH-395_962315ba,"protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,
                                              final double defaultAbsoluteAccuracy) {
        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);
        resultComputed = false;
        setMaxEvaluations(Integer.MAX_VALUE);
    }","protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,
                                              final double defaultAbsoluteAccuracy) {
        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);
        resultComputed = false;
        setMaxEvaluations(Integer.MAX_VALUE);
    }",0,[0]
155,bugs-dot-jar_WICKET-2065_9da430fb,"public IndexedHybridUrlCodingStrategy(String mountPath, Class pageClass)
	{
		super(mountPath, pageClass);
	}","public IndexedHybridUrlCodingStrategy(String mountPath, Class pageClass)
	{
		super(mountPath, pageClass);
	}",0,[0]
1083,Bears-141,"public String getLastName() {
        return lastName;
    }","public String getLastName() {
        return lastName;
    }",0,[0]
34503,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"public void checkConstraints() {
    ConstraintChecker cc = constraintChecker.get();

    if (cc.classLoaderChanged()) {
      ConstraintChecker ncc = new ConstraintChecker(acuTableConf);
      constraintChecker.compareAndSet(cc, ncc);
    }
  }","public void checkConstraints() {
    ConstraintChecker cc = constraintChecker.get();

    if (cc.classLoaderChanged()) {
      ConstraintChecker ncc = new ConstraintChecker(acuTableConf);
      constraintChecker.compareAndSet(cc, ncc);
    }
  }",0,[0]
8594,bugs-dot-jar_WICKET-3309_debca73b,"private void visitItemAndChildren(TreeItem item, IItemCallback callback)
	{
		callback.visitItem(item);
		visitItemChildren(item, callback);
	}","private void visitItemAndChildren(TreeItem item, IItemCallback callback)
	{
		callback.visitItem(item);
		visitItemChildren(item, callback);
	}",0,[0]
28896,bugs-dot-jar_LOG4J2-1008_0c20bfd8,"public ClassLoader getClassLoader() {
        return classloader != null ? classloader : (classloader = Loader.getClassLoader(ResolverUtil.class, null));
    }","public ClassLoader getClassLoader() {
        return classloader != null ? classloader : (classloader = Loader.getClassLoader(ResolverUtil.class, null));
    }",0,[0]
8615,bugs-dot-jar_CAMEL-8227_54d7fc59,"public RecipientListProcessor(CamelContext camelContext, ProducerCache producerCache, Iterator<Object> iter, AggregationStrategy aggregationStrategy) {
        super(camelContext, null, aggregationStrategy);
        this.producerCache = producerCache;
        this.iter = iter;
    }","public RecipientListProcessor(CamelContext camelContext, ProducerCache producerCache, Iterator<Object> iter, AggregationStrategy aggregationStrategy) {
        super(camelContext, null, aggregationStrategy);
        this.producerCache = producerCache;
        this.iter = iter;
    }",0,[0]
1034,bugs-dot-jar_CAMEL-9238_169b981e,"public String getCharset() {
        return charset;
    }","public String getCharset() {
        return charset;
    }",0,[0]
3421,bugs-dot-jar_LOG4J2-102_7f391872,"public int getValue() {
        return facility.getCode() << 3 + severity.getCode();
    }","public int getValue() {
        return facility.getCode() << 3 + severity.getCode();
    }",0,[0]
213,bugs-dot-jar_WICKET-2368_fae1601b,"private void setNextAvailableId()
	{
		if (getApplication().getSessionSettings().isPageIdUniquePerSession())
		{
			setNumericId(getSession().nextPageId());
		}
		else
		{
			// Set the numeric id on this page
			setNumericId(getPageMap().nextId());
		}
	}","private void setNextAvailableId()
	{
		if (getApplication().getSessionSettings().isPageIdUniquePerSession())
		{
			setNumericId(getSession().nextPageId());
		}
		else
		{
			// Set the numeric id on this page
			setNumericId(getPageMap().nextId());
		}
	}",0,[0]
32551,bugs-dot-jar_OAK-4300_06c367af,"private static String determineIndexPath(NodeState defn, @Nullable  NodeBuilder defnb) {
        String indexPath = defn.getString(IndexConstants.INDEX_PATH);
        if (indexPath == null && defnb != null){
            indexPath = defnb.getString(IndexConstants.INDEX_PATH);
        }
        return indexPath;
    }","private static String determineIndexPath(NodeState defn, @Nullable  NodeBuilder defnb) {
        String indexPath = defn.getString(IndexConstants.INDEX_PATH);
        if (indexPath == null && defnb != null){
            indexPath = defnb.getString(IndexConstants.INDEX_PATH);
        }
        return indexPath;
    }",0,[0]
32814,bugs-dot-jar_MATH-373_bfe4623c,"public Sum() {
        n = 0;
        value = Double.NaN;
    }","public Sum() {
        n = 0;
        value = 0;
    }",1,[2]
38013,bugs-dot-jar_OAK-738_8ed779dc,"private Property internalRemoveProperty(final String jcrName)
            throws RepositoryException {
        final String oakName = getOakPathOrThrow(checkNotNull(jcrName));
        return perform(new ItemWriteOperation<Property>() {
            @Override
            protected Property perform() throws RepositoryException {
                // TODO: Avoid extra JCR method calls (OAK-672)
                if (hasProperty(jcrName)) {
                    Property property = getProperty(jcrName);
                    property.remove();
                    return property;
                } else {
                    // Return a property instance which throws on access. See OAK-395
                    return new PropertyImpl(dlg.getProperty(oakName), sessionContext);
                }
            }
        });
    }","private Property internalRemoveProperty(final String jcrName)
            throws RepositoryException {
        final String oakName = getOakPathOrThrow(checkNotNull(jcrName));
        return perform(new ItemWriteOperation<Property>() {
            @Override
            protected Property perform() throws RepositoryException {
                // TODO: Avoid extra JCR method calls (OAK-672)
                if (hasProperty(jcrName)) {
                    Property property = getProperty(jcrName);
                    property.remove();
                    return property;
                } else {
                    // Return a property instance which throws on access. See OAK-395
                    return new PropertyImpl(dlg.getProperty(oakName), sessionContext);
                }
            }
        });
    }",0,[0]
37098,bugs-dot-jar_WICKET-172_99e22ce4,"@Override
	protected void internalOnAttach()
	{
		super.internalOnAttach();

		if (isVisibleInHierarchy())
		{

			IItemFactory<T> itemFactory = new IItemFactory<T>()
			{

				public Item<T> newItem(MarkupContainer<?> parent, int index, IModel<T> model)
				{
					String id = RefreshingView.this.newChildId();
					Item<T> item = RefreshingView.this.newItem(parent, id, index, model);
					RefreshingView.this.populateItem(item);
					return item;
				}

			};

			Iterator<IModel<T>> models = getItemModels();
			Iterator<Item<T>> items = getItemReuseStrategy().getItems(RefreshingView.this, itemFactory, models, getItems());
			removeAll();
			addItems(items);
		}

	}","@Override
	protected void internalOnAttach()
	{
		super.internalOnAttach();

		if (isVisibleInHierarchy())
		{

			IItemFactory<T> itemFactory = new IItemFactory<T>()
			{

				public Item<T> newItem(MarkupContainer<?> parent, int index, IModel<T> model)
				{
					String id = RefreshingView.this.newChildId();
					Item<T> item = RefreshingView.this.newItem(parent, id, index, model);
					RefreshingView.this.populateItem(item);
					return item;
				}

			};

			Iterator<IModel<T>> models = getItemModels();
			Iterator<Item<T>> items = getItemReuseStrategy().getItems(RefreshingView.this, itemFactory, models, getItems());
			removeAll();
			addItems(items);
		}

	}",0,[0]
13688,bugs-dot-jar_OAK-3079_33c18762,"public void performRecoveryIfNeeded(){
        if(isRecoveryNeeded()){
            List<Integer> clusterIds = getRecoveryCandidateNodes();
            log.info(""Starting last revision recovery for following clusterId {}"", clusterIds);
            for(int clusterId : clusterIds){
                recover(clusterId);
            }
        }
    }","public void performRecoveryIfNeeded(){
        if(isRecoveryNeeded()){
            List<Integer> clusterIds = getRecoveryCandidateNodes();
            log.info(""Starting last revision recovery for following clusterId {}"", clusterIds);
            for(int clusterId : clusterIds){
                recover(clusterId);
            }
        }
    }",0,[0]
1959,bugs-dot-jar_CAMEL-3535_b56d2962,"public void setParallelProcessing(boolean parallelProcessing) {
        this.parallelProcessing = parallelProcessing;
    }","public void setParallelProcessing(boolean parallelProcessing) {
        this.parallelProcessing = parallelProcessing;
    }",0,[0]
25249,bugs-dot-jar_ACCUMULO-193_8ad5a888,"public Key(byte[] row, byte[] cf, byte[] cq, byte[] cv, long ts, boolean deleted, boolean copy) {
    init(row, 0, row.length, cf, 0, cf.length, cq, 0, cq.length, cv, 0, cv.length, ts, deleted, copy);
  }","public Key(byte[] row, byte[] cf, byte[] cq, byte[] cv, long ts, boolean deleted, boolean copy) {
    init(row, 0, row.length, cf, 0, cf.length, cq, 0, cq.length, cv, 0, cv.length, ts, deleted, copy);
  }",0,[0]
2409,bugs-dot-jar_OAK-225_e33328e0,"static String removeParens(String s) {
        if (s.startsWith(""("") && s.endsWith("")"")) {
            return s.substring(1, s.length() - 1);
        }
        return s;
    }","static String removeParens(String s) {
        if (s.startsWith(""("") && s.endsWith("")"")) {
            return s.substring(1, s.length() - 1);
        }
        return s;
    }",0,[0]
39579,bugs-dot-jar_OAK-1674_073b814c,"protected void buildPath(StringBuilder sb) {
        if (!isRoot()) {
            getParent().buildPath(sb);
            sb.append('/').append(name);
        }
    }","protected void buildPath(StringBuilder sb) {
        if (!isRoot()) {
            getParent().buildPath(sb);
            sb.append('/').append(name);
        }
    }",0,[0]
2599,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void changeUserAuthorizations(ByteBuffer login, String user, Set<ByteBuffer> authorizations)
      throws org.apache.accumulo.proxy.thrift.AccumuloException, org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      Set<String> auths = new HashSet<String>();
      for (ByteBuffer auth : authorizations) {
        auths.add(ByteBufferUtil.toString(auth));
      }
      getConnector(login).securityOperations().changeUserAuthorizations(user, new Authorizations(auths.toArray(new String[0])));
    } catch (Exception e) {
      handleException(e);
    }
  }","@Override
  public void changeUserAuthorizations(ByteBuffer login, String user, Set<ByteBuffer> authorizations)
      throws org.apache.accumulo.proxy.thrift.AccumuloException, org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      Set<String> auths = new HashSet<String>();
      for (ByteBuffer auth : authorizations) {
        auths.add(ByteBufferUtil.toString(auth));
      }
      getConnector(login).securityOperations().changeUserAuthorizations(user, new Authorizations(auths.toArray(new String[0])));
    } catch (Exception e) {
      handleException(e);
    }
  }",0,[0]
33387,bugs-dot-jar_LOG4J2-210_aeb6fc9d,"public Throwable getThrowable() {
        return null;
    }","public Throwable getThrowable() {
        return null;
    }",0,[0]
16272,bugs-dot-jar_FLINK-3189_a5b05566,"public static void printHelp() {
		System.out.println(""./flink <ACTION> [OPTIONS] [ARGUMENTS]"");
		System.out.println();
		System.out.println(""The following actions are available:"");

		printHelpForRun();
		printHelpForInfo();
		printHelpForList();
		printHelpForCancel();
		printHelpForSavepoint();

		System.out.println();
	}","public static void printHelp() {
		System.out.println(""./flink <ACTION> [OPTIONS] [ARGUMENTS]"");
		System.out.println();
		System.out.println(""The following actions are available:"");

		printHelpForRun();
		printHelpForInfo();
		printHelpForList();
		printHelpForCancel();
		printHelpForSavepoint();

		System.out.println();
	}",0,[0]
9829,bugs-dot-jar_OAK-3634_90ad50da,"@Override
    public <T extends Document> T find(final Collection<T> collection, final String id, int maxCacheAge) {
        return readDocumentCached(collection, id, maxCacheAge);
    }","@Override
    public <T extends Document> T find(final Collection<T> collection, final String id, int maxCacheAge) {
        return readDocumentCached(collection, id, maxCacheAge);
    }",0,[0]
36253,bugs-dot-jar_CAMEL-9444_baece126,"@Override
    @SuppressWarnings(""unchecked"")
    public Type end() {
        // allow end() to return to previous type so you can continue in the DSL
        return (Type) super.end();
    }","@Override
    @SuppressWarnings(""unchecked"")
    public Type end() {
        // allow end() to return to previous type so you can continue in the DSL
        return (Type) super.end();
    }",0,[0]
12590,bugs-dot-jar_MATH-864_abe53a53,"private static double max(final double[] m) {
        double max = -Double.MAX_VALUE;
        for (int r = 0; r < m.length; r++) {
            if (max < m[r]) {
                max = m[r];
            }
        }
        return max;
    }","private static double max(final double[] m) {
        double max = -Double.MAX_VALUE;
        for (int r = 0; r < m.length; r++) {
            if (max < m[r]) {
                max = m[r];
            }
        }
        return max;
    }",0,[0]
24885,bugs-dot-jar_CAMEL-7100_00a9b02b,"public static String newStringFromBytes(byte[] bytes) {
        try {
            return new String(bytes, UTF8_CHARSET.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(""Impossible failure: Charset.forName(\""UTF-8\"") returns invalid name."", e);
        }
    }","public static String newStringFromBytes(byte[] bytes) {
        try {
            return new String(bytes, UTF8_CHARSET.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(""Impossible failure: Charset.forName(\""UTF-8\"") returns invalid name."", e);
        }
    }",0,[0]
39586,bugs-dot-jar_OAK-1674_073b814c,"@Override
    public Status getPropertyStatus(@Nonnull String name) {
        if (!hasProperty(name)) {
            return null;
        } else if (nodeBuilder.isNew(name)) {
            return NEW;
        } else if (nodeBuilder.isReplaced(name)) {
            return MODIFIED;
        } else {
            return UNCHANGED;
        }
    }","@Override
    public Status getPropertyStatus(@Nonnull String name) {
        if (!hasProperty(name)) {
            return null;
        } else if (nodeBuilder.isNew(name)) {
            return NEW;
        } else if (nodeBuilder.isReplaced(name)) {
            return MODIFIED;
        } else {
            return UNCHANGED;
        }
    }",0,[0]
1641,Bears-194,"private void handleDataFlowNode(DataFlowNode iDataFlowNode) {
		for (VariableAccess access : iDataFlowNode.getVariableAccess()) {
			if (access.isDefinition()) {
				String variableName = access.getVariableName();
				handleVariableDefinition(iDataFlowNode, variableName);
				//handleVariableReference(iDataFlowNode);
				return;
			}
		}
		handleVariableReference(iDataFlowNode);
	}","private void handleDataFlowNode(DataFlowNode iDataFlowNode) {
		for (VariableAccess access : iDataFlowNode.getVariableAccess()) {
			if (access.isDefinition()) {
				String variableName = access.getVariableName();
				handleVariableDefinition(iDataFlowNode, variableName);
				//handleVariableReference(iDataFlowNode);
				return;
			}
		}
		handleVariableReference(iDataFlowNode);
	}",0,[0]
17304,bugs-dot-jar_OAK-1985_f620b79b,"@Override
    public TokenInfo createToken(String userId, Map<String, ?> attributes) {
        String error = ""Failed to create login token. "";
        NodeUtil tokenParent = getTokenParent(userId);
        if (tokenParent != null) {
            try {
                long creationTime = new Date().getTime();
                NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);
                tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());

                String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));
                String nodeId = getIdentifier(tokenNode.getTree());
                String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();

                String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId), options);
                tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);

                long exp;
                if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {
                    exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());
                } else {
                    exp = tokenExpiration;
                }
                long expTime = createExpirationTime(creationTime, exp);
                tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);

                for (String name : attributes.keySet()) {
                    if (!RESERVED_ATTRIBUTES.contains(name)) {
                        String attr = attributes.get(name).toString();
                        tokenNode.setString(name, attr);
                    }
                }
                root.commit();
                return new TokenInfoImpl(tokenNode, token, userId);
            } catch (NoSuchAlgorithmException e) {
                // error while generating login token
                log.error(error, e.getMessage());
            } catch (UnsupportedEncodingException e) {
                // error while generating login token
                log.error(error, e.getMessage());
            } catch (CommitFailedException e) {
                // conflict while committing changes
                log.warn(error, e.getMessage());
            } catch (AccessDeniedException e) {
                log.warn(error, e.getMessage());
            }
        } else {
            log.warn(""Unable to get/create token store for user "" + userId);
        }
        return null;
    }","@Override
    public TokenInfo createToken(String userId, Map<String, ?> attributes) {
        String error = ""Failed to create login token. "";
        User user = getUser(userId);
        NodeUtil tokenParent = getTokenParent(user);
        if (tokenParent != null) {
            try {
                String id = user.getID();
                long creationTime = new Date().getTime();
                NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);
                tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());

                String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));
                String nodeId = getIdentifier(tokenNode.getTree());
                String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();

                String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, id), options);
                tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);

                long exp;
                if (attributes.containsKey(PARAM_TOKEN_EXPIRATION)) {
                    exp = Long.parseLong(attributes.get(PARAM_TOKEN_EXPIRATION).toString());
                } else {
                    exp = tokenExpiration;
                }
                long expTime = createExpirationTime(creationTime, exp);
                tokenNode.setDate(TOKEN_ATTRIBUTE_EXPIRY, expTime);

                for (String name : attributes.keySet()) {
                    if (!RESERVED_ATTRIBUTES.contains(name)) {
                        String attr = attributes.get(name).toString();
                        tokenNode.setString(name, attr);
                    }
                }
                root.commit();
                return new TokenInfoImpl(tokenNode, token, id);
            } catch (NoSuchAlgorithmException e) {
                // error while generating login token
                log.error(error, e.getMessage());
            } catch (UnsupportedEncodingException e) {
                // error while generating login token
                log.error(error, e.getMessage());
            } catch (CommitFailedException e) {
                // conflict while committing changes
                log.warn(error, e.getMessage());
            } catch (RepositoryException e) {
                log.warn(error, e.getMessage());
            }
        } else {
            log.warn(""Unable to get/create token store for user "" + userId);
        }
        return null;
    }",1,"[3, 14, 33, 43]"
3779,bugs-dot-jar_FLINK-2460_a17d4e82,"protected long getTotalNumberOfBytes() {
		return totalNumberOfBytes;
	}","protected long getTotalNumberOfBytes() {
		return totalNumberOfBytes;
	}",0,[0]
3497,bugs-dot-jar_WICKET-4256_09166ea8,"public final boolean hasFeedbackMessage()
	{
		return getSession().getFeedbackMessages().hasMessageFor(this);
	}","public final boolean hasFeedbackMessage()
	{
		return getSession().getFeedbackMessages().hasMessageFor(this);
	}",0,[0]
24065,bugs-dot-jar_OAK-579_7d72e6ed,"@Override
    public void init(Query query) {
        // nothing to do
    }","@Override
    public void init(Query query) {
        // nothing to do
    }",0,[0]
28373,bugs-dot-jar_WICKET-3511_4a875f46,"public IResourceStream locate(Class<?> scope, String path, String style, String variation,
		Locale locale, String extension, boolean strict)
	{
		Key key = new Key(scope.getName(), path, locale, style, variation);
		IResourceStream resourceStream = getCopyFromCache(key);

		if (resourceStream == null)
		{
			resourceStream = delegate.locate(scope, path, style, variation, locale, extension,
				strict);

			updateCache(key, resourceStream);
		}

		return resourceStream;
	}","public IResourceStream locate(Class<?> scope, String path, String style, String variation,
		Locale locale, String extension, boolean strict)
	{
		Key key = new Key(scope.getName(), path, locale, style, variation);
		IResourceStreamReference resourceStreamReference = cache.get(key);

		final IResourceStream result;
		if (resourceStreamReference == null)
		{
			result = delegate.locate(scope, path, style, variation, locale, extension, strict);

			updateCache(key, result);
		}
		else
		{
			result = resourceStreamReference.getReference();
		}

		return result;
	}",1,"[4, 6, 8, 9, 11, 14]"
30743,bugs-dot-jar_OAK-2695_0598498e,"@Nonnull
    @Override
    public NodeState getChildNode(@Nonnull String name) {
        if (!hasChildren) {
            checkValidName(name);
            return EmptyNodeState.MISSING_NODE;
        }
        String p = PathUtils.concat(getPath(), name);
        DocumentNodeState child = store.getNode(p, lastRevision);
        if (child == null) {
            checkValidName(name);
            return EmptyNodeState.MISSING_NODE;
        } else {
            return child;
        }
    }","@Nonnull
    @Override
    public NodeState getChildNode(@Nonnull String name) {
        return getChildNode(name, lastRevision);
    }",1,"[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]"
19796,bugs-dot-jar_LOG4J2-470_50340d0c,"protected BaseConfiguration() {
        pluginManager = new PluginManager(""Core"");
        rootNode = new Node();
    }","protected BaseConfiguration() {
        componentMap.put(Configuration.CONTEXT_PROPERTIES, properties);
        pluginManager = new PluginManager(""Core"");
        rootNode = new Node();
    }",1,[]
1771,Bears-202,"public ClassGraph disableModuleScanning() {
        scanSpec.scanModules = false;
        return this;
    }","public ClassGraph disableModuleScanning() {
        scanSpec.scanModules = false;
        return this;
    }",0,[0]
8010,bugs-dot-jar_ACCUMULO-3242_15e83709,"public static void recursiveCopyPersistent(ZooKeeperConnectionInfo info, String source, String destination, NodeExistsPolicy policy) throws KeeperException,
      InterruptedException {
    Stat stat = null;
    if (!exists(info, source))
      throw KeeperException.create(Code.NONODE, source);
    if (exists(info, destination)) {
      switch (policy) {
        case OVERWRITE:
          break;
        case SKIP:
          return;
        case FAIL:
        default:
          throw KeeperException.create(Code.NODEEXISTS, source);
      }
    }

    stat = new Stat();
    byte[] data = getData(info, source, stat);

    if (stat.getEphemeralOwner() == 0) {
      if (data == null)
        throw KeeperException.create(Code.NONODE, source);
      putPersistentData(info, destination, data, policy);
      if (stat.getNumChildren() > 0) {
        List<String> children;
        final Retry retry = RETRY_FACTORY.create();
        while (true) {
          try {
            children = getZooKeeper(info).getChildren(source, false);
            break;
          } catch (KeeperException e) {
            final Code c = e.code();
            if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {
              retryOrThrow(retry, e);
            } else {
              throw e;
            }
          }
          retry.waitForNextAttempt();
        }
        for (String child : children)
          recursiveCopyPersistent(info, source + ""/"" + child, destination + ""/"" + child, policy);
      }
    }
  }","public static void recursiveCopyPersistent(ZooKeeperConnectionInfo info, String source, String destination, NodeExistsPolicy policy) throws KeeperException,
      InterruptedException {
    Stat stat = null;
    if (!exists(info, source))
      throw KeeperException.create(Code.NONODE, source);
    if (exists(info, destination)) {
      switch (policy) {
        case OVERWRITE:
          break;
        case SKIP:
          return;
        case FAIL:
        default:
          throw KeeperException.create(Code.NODEEXISTS, source);
      }
    }

    stat = new Stat();
    byte[] data = getData(info, source, stat);

    if (stat.getEphemeralOwner() == 0) {
      if (data == null)
        throw KeeperException.create(Code.NONODE, source);
      putPersistentData(info, destination, data, policy);
      if (stat.getNumChildren() > 0) {
        List<String> children;
        final Retry retry = RETRY_FACTORY.create();
        while (true) {
          try {
            children = getZooKeeper(info).getChildren(source, false);
            break;
          } catch (KeeperException e) {
            final Code c = e.code();
            if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {
              retryOrThrow(retry, e);
            } else {
              throw e;
            }
          }
          retry.waitForNextAttempt();
        }
        for (String child : children) {
          recursiveCopyPersistent(info, source + ""/"" + child, destination + ""/"" + child, policy);
        }
      }
    }
  }",1,[41]
10296,bugs-dot-jar_OAK-3897_94c6c575,"private boolean dispatch(@Nonnull final String jsonDiff,
                             @Nonnull final DocumentNodeState node,
                             @Nonnull final DocumentNodeState base,
                             @Nonnull final NodeStateDiff diff) {
        return DiffCache.parseJsopDiff(jsonDiff, new DiffCache.Diff() {
            @Override
            public boolean childNodeAdded(String name) {
                return diff.childNodeAdded(name,
                        node.getChildNode(name));
            }

            @Override
            public boolean childNodeChanged(String name) {
                boolean continueComparison = true;
                NodeState baseChild = base.getChildNode(name);
                NodeState nodeChild = node.getChildNode(name);
                if (baseChild.exists()) {
                    if (nodeChild.exists()) {
                        continueComparison = diff.childNodeChanged(name,
                                baseChild, nodeChild);
                    } else {
                        continueComparison = diff.childNodeDeleted(name,
                                baseChild);
                    }
                } else {
                    if (nodeChild.exists()) {
                        continueComparison = diff.childNodeAdded(name,
                                nodeChild);
                    }
                }
                return continueComparison;
            }

            @Override
            public boolean childNodeDeleted(String name) {
                return diff.childNodeDeleted(name,
                        base.getChildNode(name));
            }
        });
    }","private boolean dispatch(@Nonnull final String jsonDiff,
                             @Nonnull final DocumentNodeState node,
                             @Nonnull final DocumentNodeState base,
                             @Nonnull final NodeStateDiff diff) {
        return DiffCache.parseJsopDiff(jsonDiff, new DiffCache.Diff() {
            @Override
            public boolean childNodeAdded(String name) {
                return diff.childNodeAdded(name,
                        node.getChildNode(name));
            }

            @Override
            public boolean childNodeChanged(String name) {
                boolean continueComparison = true;
                NodeState baseChild = base.getChildNode(name);
                NodeState nodeChild = node.getChildNode(name);
                if (baseChild.exists()) {
                    if (nodeChild.exists()) {
                        continueComparison = diff.childNodeChanged(name,
                                baseChild, nodeChild);
                    } else {
                        continueComparison = diff.childNodeDeleted(name,
                                baseChild);
                    }
                } else {
                    if (nodeChild.exists()) {
                        continueComparison = diff.childNodeAdded(name,
                                nodeChild);
                    }
                }
                return continueComparison;
            }

            @Override
            public boolean childNodeDeleted(String name) {
                return diff.childNodeDeleted(name,
                        base.getChildNode(name));
            }
        });
    }",0,[0]
25035,bugs-dot-jar_OAK-1227_117b0a3d,"@Override @Nonnull
    public Property setProperty(String name, double value)
            throws RepositoryException {
        Value v = getValueFactory().createValue(value);
        return internalSetProperty(name, v, false);
    }","@Override @Nonnull
    public Property setProperty(String name, double value)
            throws RepositoryException {
        Value v = getValueFactory().createValue(value);
        return internalSetProperty(name, v, false);
    }",0,[0]
18695,bugs-dot-jar_ACCUMULO-3218_1b35d263,"public static ClientConfiguration loadDefault() {
    return loadFromSearchPath(getDefaultSearchPath());
  }","public static ClientConfiguration loadDefault() {
    return loadFromSearchPath(getDefaultSearchPath());
  }",0,[0]
15616,bugs-dot-jar_ACCUMULO-1190_e29dc4f5,"private AuthenticationToken getToken(String principal, Map<String, String> properties) throws AccumuloSecurityException, AccumuloException {
    Properties props = new Properties();
    props.putAll(properties);
    return instance.getAuthenticator().login(principal, props);
  }","private AuthenticationToken getToken(String principal, Map<String, String> properties) throws AccumuloSecurityException, AccumuloException {
    Properties props = new Properties();
    props.putAll(properties);
    return instance.getAuthenticator().login(principal, props);
  }",0,[0]
3831,bugs-dot-jar_ACCUMULO-1544_0cf2ff72,"List<ProcessReference> references(Process... procs) {
    List<ProcessReference> result = new ArrayList<ProcessReference>();
    for (Process proc : procs) {
      result.add(new ProcessReference(proc));
    }
    return result;
  }","List<ProcessReference> references(Process... procs) {
    List<ProcessReference> result = new ArrayList<ProcessReference>();
    for (Process proc : procs) {
      result.add(new ProcessReference(proc));
    }
    return result;
  }",0,[0]
28658,bugs-dot-jar_FLINK-2734_8b40bb7a,"public KeyedDataStream(DataStream<T> dataStream, KeySelector<T, ?> keySelector) {
		super(dataStream.getExecutionEnvironment(), new PartitionTransformation<T>(dataStream.getTransformation(), new HashPartitioner<T>(keySelector)));
		this.keySelector = keySelector;
	}","public KeyedDataStream(DataStream<T> dataStream, KeySelector<T, ?> keySelector) {
		super(dataStream.getExecutionEnvironment(), new PartitionTransformation<T>(dataStream.getTransformation(), new HashPartitioner<T>(keySelector)));
		this.keySelector = keySelector;
	}",0,[0]
5362,bugs-dot-jar_FLINK-3534_734ba01d,"public Configuration getJobConfiguration() {
		return jobConfiguration;
	}","public Configuration getJobConfiguration() {
		return jobConfiguration;
	}",0,[0]
8616,bugs-dot-jar_CAMEL-8227_54d7fc59,"@Deprecated
    public RecipientListProcessor(CamelContext camelContext, ProducerCache producerCache, Iterator<Object> iter, AggregationStrategy aggregationStrategy,
                                  boolean parallelProcessing, ExecutorService executorService, boolean shutdownExecutorService,
                                  boolean streaming, boolean stopOnException, long timeout, Processor onPrepare, boolean shareUnitOfWork) {
        super(camelContext, null, aggregationStrategy, parallelProcessing, executorService, shutdownExecutorService,
                streaming, stopOnException, timeout, onPrepare, shareUnitOfWork, false);
        this.producerCache = producerCache;
        this.iter = iter;
    }","@Deprecated
    public RecipientListProcessor(CamelContext camelContext, ProducerCache producerCache, Iterator<Object> iter, AggregationStrategy aggregationStrategy,
                                  boolean parallelProcessing, ExecutorService executorService, boolean shutdownExecutorService,
                                  boolean streaming, boolean stopOnException, long timeout, Processor onPrepare, boolean shareUnitOfWork) {
        super(camelContext, null, aggregationStrategy, parallelProcessing, executorService, shutdownExecutorService,
                streaming, stopOnException, timeout, onPrepare, shareUnitOfWork, false);
        this.producerCache = producerCache;
        this.iter = iter;
    }",0,[0]
11185,bugs-dot-jar_WICKET-1931_986848f7,"public String getRequestedSessionId()
	{
		if (session instanceof MockHttpSession && ((MockHttpSession)session).isTemporary())
			return null;
		return session.getId();
	}","public String getRequestedSessionId()
	{
		if (session instanceof MockHttpSession && ((MockHttpSession)session).isTemporary())
			return null;
		return session.getId();
	}",0,[0]
7831,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public void set(double value) {
        Arrays.fill(data, value);
    }","@Override
    public void set(double value) {
        Arrays.fill(data, value);
    }",0,[0]
5312,bugs-dot-jar_FLINK-3534_734ba01d,"public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {
		if (scheduler == null) {
			throw new IllegalArgumentException(""Cannot send null Scheduler when scheduling execution."");
		}

		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();
		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint();

		// sanity check
		if (locationConstraint != null && sharingGroup == null) {
			throw new RuntimeException(""Trying to schedule with co-location constraint but without slot sharing allowed."");
		}

		if (transitionState(CREATED, SCHEDULED)) {

			ScheduledUnit toSchedule = locationConstraint == null ?
				new ScheduledUnit(this, sharingGroup) :
				new ScheduledUnit(this, sharingGroup, locationConstraint);

			// IMPORTANT: To prevent leaks of cluster resources, we need to make sure that slots are returned
			//     in all cases where the deployment failed. we use many try {} finally {} clauses to assure that
			if (queued) {
				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule);

				future.setFutureAction(new SlotAllocationFutureAction() {
					@Override
					public void slotAllocated(SimpleSlot slot) {
						try {
							deployToSlot(slot);
						}
						catch (Throwable t) {
							try {
								slot.releaseSlot();
							} finally {
								markFailed(t);
							}
						}
					}
				});
			}
			else {
				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule);
				try {
					deployToSlot(slot);
				}
				catch (Throwable t) {
					try {
						slot.releaseSlot();
					} finally {
						markFailed(t);
					}
				}
			}

			return true;
		}
		else {
			// call race, already deployed, or already done
			return false;
		}
	}","public boolean scheduleForExecution(Scheduler scheduler, boolean queued) throws NoResourceAvailableException {
		if (scheduler == null) {
			throw new IllegalArgumentException(""Cannot send null Scheduler when scheduling execution."");
		}

		final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();
		final CoLocationConstraint locationConstraint = vertex.getLocationConstraint();

		// sanity check
		if (locationConstraint != null && sharingGroup == null) {
			throw new RuntimeException(""Trying to schedule with co-location constraint but without slot sharing allowed."");
		}

		if (transitionState(CREATED, SCHEDULED)) {

			ScheduledUnit toSchedule = locationConstraint == null ?
				new ScheduledUnit(this, sharingGroup) :
				new ScheduledUnit(this, sharingGroup, locationConstraint);

			// IMPORTANT: To prevent leaks of cluster resources, we need to make sure that slots are returned
			//     in all cases where the deployment failed. we use many try {} finally {} clauses to assure that
			if (queued) {
				SlotAllocationFuture future = scheduler.scheduleQueued(toSchedule);

				future.setFutureAction(new SlotAllocationFutureAction() {
					@Override
					public void slotAllocated(SimpleSlot slot) {
						try {
							deployToSlot(slot);
						}
						catch (Throwable t) {
							try {
								slot.releaseSlot();
							} finally {
								markFailed(t);
							}
						}
					}
				});
			}
			else {
				SimpleSlot slot = scheduler.scheduleImmediately(toSchedule);
				try {
					deployToSlot(slot);
				}
				catch (Throwable t) {
					try {
						slot.releaseSlot();
					} finally {
						markFailed(t);
					}
				}
			}

			return true;
		}
		else {
			// call race, already deployed, or already done
			return false;
		}
	}",0,[0]
4728,bugs-dot-jar_MATH-326_ce185345,"public ArrayRealVector add(ArrayRealVector v)
        throws IllegalArgumentException {
        return (ArrayRealVector) add(v.data);
    }","public ArrayRealVector add(ArrayRealVector v)
        throws IllegalArgumentException {
        return (ArrayRealVector) add(v.data);
    }",0,[0]
268,Bears-12,"protected BuilderBasedDeserializer(BuilderBasedDeserializer src)
    {
        this(src, src._ignoreAllUnknown);
    }","protected BuilderBasedDeserializer(BuilderBasedDeserializer src)
    {
        this(src, src._ignoreAllUnknown);
    }",0,[0]
159,bugs-dot-jar_WICKET-2065_9da430fb,"@Override
	protected ValueMap decodeParameters(String urlFragment, Map urlParameters)
	{
		PageParameters params = new PageParameters();
		if (urlFragment == null)
		{
			return params;
		}
		if (urlFragment.startsWith(""/""))
		{
			urlFragment = urlFragment.substring(1);
		}
		if (urlFragment.length() > 0 && urlFragment.endsWith(""/""))
		{
			urlFragment = urlFragment.substring(0, urlFragment.length() - 1);
		}

		if (urlFragment.length() > 0)
		{
			String[] parts = urlFragment.split(""/"");
			for (int i = 0; i < parts.length; i++)
			{
				if (WebRequestCodingStrategy.PAGEMAP.equals(parts[i]))
				{
					i++;
					params.put(
						WebRequestCodingStrategy.PAGEMAP,
						WebRequestCodingStrategy.decodePageMapName(urlDecodePathComponent(parts[i])));
				}
				else if (WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.equals(parts[i]))
				{
					i++;
					params.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME,
						urlDecodePathComponent(parts[i]));
				}
				else
				{
					params.put(String.valueOf(i), urlDecodePathComponent(parts[i]));
				}
			}
		}
		return params;
	}","@Override
	protected ValueMap decodeParameters(String urlFragment, Map urlParameters)
	{
		PageParameters params = new PageParameters();
		if (urlFragment == null)
		{
			return params;
		}
		if (urlFragment.startsWith(""/""))
		{
			urlFragment = urlFragment.substring(1);
		}
		if (urlFragment.length() > 0 && urlFragment.endsWith(""/""))
		{
			urlFragment = urlFragment.substring(0, urlFragment.length() - 1);
		}

		if (urlFragment.length() > 0)
		{
			String[] parts = urlFragment.split(""/"");
			for (int i = 0; i < parts.length; i++)
			{
				if (WebRequestCodingStrategy.PAGEMAP.equals(parts[i]))
				{
					i++;
					params.put(
						WebRequestCodingStrategy.PAGEMAP,
						WebRequestCodingStrategy.decodePageMapName(urlDecodePathComponent(parts[i])));
				}
				else if (WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME.equals(parts[i]))
				{
					i++;
					params.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME,
						urlDecodePathComponent(parts[i]));
				}
				else
				{
					params.put(String.valueOf(i), urlDecodePathComponent(parts[i]));
				}
			}
		}
		return params;
	}",0,[0]
37058,bugs-dot-jar_OAK-1270_70564c7c,"private static Query getQuery(Filter filter, IndexReader reader,
            boolean nonFullTextConstraints, Analyzer analyzer) {
        List<Query> qs = new ArrayList<Query>();
        FullTextExpression ft = filter.getFullTextConstraint();
        if (ft == null) {
            // there might be no full-text constraint
            // when using the LowCostLuceneIndexProvider
            // which is used for testing
        } else {
            qs.add(getFullTextQuery(ft, analyzer));
        }
        if (nonFullTextConstraints) {
            addNonFullTextConstraints(qs, filter, reader);
        }
        if (qs.size() == 0) {
            return new MatchAllDocsQuery();
        }
        if (qs.size() == 1) {
            return qs.get(0);
        }
        BooleanQuery bq = new BooleanQuery();
        for (Query q : qs) {
            bq.add(q, MUST);
        }
        return bq;
    }","private static Query getQuery(Filter filter, IndexReader reader,
            boolean nonFullTextConstraints, Analyzer analyzer) {
        List<Query> qs = new ArrayList<Query>();
        FullTextExpression ft = filter.getFullTextConstraint();
        if (ft == null) {
            // there might be no full-text constraint
            // when using the LowCostLuceneIndexProvider
            // which is used for testing
        } else {
            qs.add(getFullTextQuery(ft, analyzer, reader));
        }
        if (nonFullTextConstraints) {
            addNonFullTextConstraints(qs, filter, reader);
        }
        if (qs.size() == 0) {
            return new MatchAllDocsQuery();
        }
        if (qs.size() == 1) {
            return qs.get(0);
        }
        BooleanQuery bq = new BooleanQuery();
        for (Query q : qs) {
            bq.add(q, MUST);
        }
        return bq;
    }",1,[9]
17767,bugs-dot-jar_CAMEL-5720_4a05eccf,"public boolean isShutdownTimeoutCheckerExecutorService() {
        return shutdownTimeoutCheckerExecutorService;
    }","public boolean isShutdownTimeoutCheckerExecutorService() {
        return shutdownTimeoutCheckerExecutorService;
    }",0,[0]
17069,bugs-dot-jar_LOG4J2-398_2c966ad9,"@Override
    public void createConfiguration(final Node node, final LogEvent event) {
        final PluginType<?> type = node.getType();
        if (type != null && type.isDeferChildren()) {
            node.setObject(createPluginObject(type, node, event));
        } else {
            for (final Node child : node.getChildren()) {
                createConfiguration(child, event);
            }

            if (type == null) {
                if (node.getParent() != null) {
                    LOGGER.error(""Unable to locate plugin for "" + node.getName());
                }
            } else {
                node.setObject(createPluginObject(type, node, event));
            }
        }
    }","@Override
    public void createConfiguration(final Node node, final LogEvent event) {
        final PluginType<?> type = node.getType();
        if (type != null && type.isDeferChildren()) {
            node.setObject(createPluginObject(type, node, event));
        } else {
            for (final Node child : node.getChildren()) {
                createConfiguration(child, event);
            }

            if (type == null) {
                if (node.getParent() != null) {
                    LOGGER.error(""Unable to locate plugin for "" + node.getName());
                }
            } else {
                node.setObject(createPluginObject(type, node, event));
            }
        }
    }",0,[0]
10043,bugs-dot-jar_FLINK-2707_3e233a38,"public Configuration getTaskStubParameters() {
		return new TaskConfig(env.getTaskConfiguration()).getStubParameters();
	}","public Configuration getTaskStubParameters() {
		return new TaskConfig(env.getTaskConfiguration()).getStubParameters();
	}",0,[0]
17797,bugs-dot-jar_WICKET-4358_02ebc8ae,"protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycle)
	{
		IRequestHandler scheduled = requestCycle.getRequestHandlerScheduledAfterCurrent();

		// keep the original response
		final Response originalResponse = requestCycle.getResponse();

		// buffered web response for page
		BufferedWebResponse response = new BufferedWebResponse((WebResponse)originalResponse);

		// keep the original base URL
		Url originalBaseUrl = requestCycle.getUrlRenderer().setBaseUrl(targetUrl);

		try
		{
			requestCycle.setResponse(response);
			getPage().renderPage();

			if (scheduled == null && requestCycle.getRequestHandlerScheduledAfterCurrent() != null)
			{
				// This is a special case. During page render another request handler got scheduled.
				// The handler
				// will want to overwrite the response, so we need to let it
				return null;
			}
			else
			{
				return response;
			}
		}
		finally
		{
			// restore original response and base URL
			requestCycle.setResponse(originalResponse);
			requestCycle.getUrlRenderer().setBaseUrl(originalBaseUrl);
		}
	}","protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycle)
	{
		IRequestHandler scheduled = requestCycle.getRequestHandlerScheduledAfterCurrent();

		// keep the original response
		final WebResponse originalResponse = (WebResponse) requestCycle.getResponse();

		// buffered web response for page
		BufferedWebResponse response = new BufferedWebResponse(originalResponse);

		// keep the original base URL
		Url originalBaseUrl = requestCycle.getUrlRenderer().setBaseUrl(targetUrl);

		try
		{
			requestCycle.setResponse(response);
			getPage().renderPage();

			if (scheduled == null && requestCycle.getRequestHandlerScheduledAfterCurrent() != null)
			{
				// This is a special case.
				// During page render another request handler got scheduled and will want to overwrite
				// the response, so we need to let it.
				// Just preserve the meta data headers
				originalResponse.reset(); // clear the initial actions because they are already copied into the new response's actions
				response.writeMetaData(originalResponse);
				return null;
			}
			else
			{
				return response;
			}
		}
		finally
		{
			// restore original response and base URL
			requestCycle.setResponse(originalResponse);
			requestCycle.getUrlRenderer().setBaseUrl(originalBaseUrl);
		}
	}",1,"[5, 8, 20, 21, 22]"
931,Bears-124,"public EskyProtocolDecoder(EskyProtocol protocol) {
        super(protocol);
    }","public EskyProtocolDecoder(EskyProtocol protocol) {
        super(protocol);
    }",0,[0]
21587,bugs-dot-jar_FLINK-1471_d033fa8f,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <X> TypeInformation<X> privateGetForObject(X value) {
		Validate.notNull(value);
		
		// check if we can extract the types from tuples, otherwise work with the class
		if (value instanceof Tuple) {
			Tuple t = (Tuple) value;
			int numFields = t.getArity();
			if(numFields != countFieldsInClass(value.getClass())) {
				// not a tuple since it has more fields. 
				return analyzePojo((Class<X>) value.getClass(), new ArrayList<Type>(), null, null, null); // we immediately call analyze Pojo here, because
				// there is currently no other type that can handle such a class.
			}
			
			TypeInformation<?>[] infos = new TypeInformation[numFields];
			for (int i = 0; i < numFields; i++) {
				Object field = t.getField(i);
				
				if (field == null) {
					throw new InvalidTypesException(""Automatic type extraction is not possible on candidates with null values. ""
							+ ""Please specify the types directly."");
				}
				
				infos[i] = privateGetForObject(field);
			}
			return (TypeInformation<X>) new TupleTypeInfo(value.getClass(), infos);
		} else {
			return privateGetForClass((Class<X>) value.getClass(), new ArrayList<Type>());
		}
	}","@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <X> TypeInformation<X> privateGetForObject(X value) {
		Validate.notNull(value);
		
		// check if we can extract the types from tuples, otherwise work with the class
		if (value instanceof Tuple) {
			Tuple t = (Tuple) value;
			int numFields = t.getArity();
			if(numFields != countFieldsInClass(value.getClass())) {
				// not a tuple since it has more fields. 
				return analyzePojo((Class<X>) value.getClass(), new ArrayList<Type>(), null, null, null); // we immediately call analyze Pojo here, because
				// there is currently no other type that can handle such a class.
			}
			
			TypeInformation<?>[] infos = new TypeInformation[numFields];
			for (int i = 0; i < numFields; i++) {
				Object field = t.getField(i);
				
				if (field == null) {
					throw new InvalidTypesException(""Automatic type extraction is not possible on candidates with null values. ""
							+ ""Please specify the types directly."");
				}
				
				infos[i] = privateGetForObject(field);
			}
			return (TypeInformation<X>) new TupleTypeInfo(value.getClass(), infos);
		} else {
			return privateGetForClass((Class<X>) value.getClass(), new ArrayList<Type>());
		}
	}",0,[0]
635,bugs-dot-jar_MNG-5727_ce6f0bfd,"public static ArtifactRepository buildArtifactRepository( org.apache.maven.settings.Repository repo )
        throws InvalidRepositoryException
    {
        return buildArtifactRepository( fromSettingsRepository( repo ) );
    }","public static ArtifactRepository buildArtifactRepository( org.apache.maven.settings.Repository repo )
        throws InvalidRepositoryException
    {
        return buildArtifactRepository( fromSettingsRepository( repo ) );
    }",0,[0]
1941,bugs-dot-jar_CAMEL-3535_b56d2962,"public void setCompletionTimeout(long completionTimeout) {
        this.completionTimeout = completionTimeout;
    }","public void setCompletionTimeout(long completionTimeout) {
        this.completionTimeout = completionTimeout;
    }",0,[0]
32964,bugs-dot-jar_WICKET-3333_ddf7e8a2,"public final void onLinkClicked()
	{
		// Invoke subclass handler
		onClick();
	}","public final void onLinkClicked()
	{
		// Invoke subclass handler
		onClick();
	}",0,[0]
1016,bugs-dot-jar_ACCUMULO-3408_81d25bc2,"public static String commas(double d, double warnMin, double warnMax, double errMin, double errMax) {
    if (d < errMin || d > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(d));
    if (d < warnMin || d > warnMax)
      return String.format(""<span class='warning'>%s</span>"", bigNumberForQuantity(d));
    return bigNumberForQuantity(d);
  }","public static String commas(double d, double warnMin, double warnMax, double errMin, double errMax) {
    if (d < errMin || d > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(d));
    if (d < warnMin || d > warnMax)
      return String.format(""<span class='warning'>%s</span>"", bigNumberForQuantity(d));
    return bigNumberForQuantity(d);
  }",0,[0]
12058,bugs-dot-jar_OAK-642_7a84b3a8,"@Override
    public boolean isModified() {
        try {
            return sessionDelegate.perform(new SessionOperation<Boolean>() {
                @Override
                public Boolean perform() throws InvalidItemStateException {
                    return !dlg.isStale() && dlg.getStatus() == Status.MODIFIED;
                }
            });
        } catch (RepositoryException e) {
            return false;
        }
    }","@Override
    public boolean isModified() {
        try {
            return sessionDelegate.perform(new SessionOperation<Boolean>() {
                @Override
                public Boolean perform() throws InvalidItemStateException {
                    return !dlg.isStale() && dlg.getStatus() == Status.MODIFIED;
                }
            });
        } catch (RepositoryException e) {
            return false;
        }
    }",0,[0]
18727,bugs-dot-jar_CAMEL-8106_39ccf5d6,"public int getGroup() {
        return group;
    }","public int getGroup() {
        return group;
    }",0,[0]
23353,bugs-dot-jar_LOG4J2-302_300bc575,"public DefaultThreadContextStack(final boolean useStack) {
        this.useStack = useStack;
    }","public DefaultThreadContextStack(final boolean useStack) {
        this.useStack = useStack;
    }",0,[0]
1121,bugs-dot-jar_WICKET-5546_f1af9e03,"public String getMarkupId(boolean createIfDoesNotExist)
	{
		Object storedMarkupId = getMarkupIdImpl();
		if (storedMarkupId instanceof String)
		{
			return (String)storedMarkupId;
		}

		if (storedMarkupId == null && createIfDoesNotExist == false)
		{
			return null;
		}

		int generatedMarkupId = storedMarkupId instanceof Integer ? (Integer)storedMarkupId
			: getSession().nextSequenceValue();

		if (generatedMarkupId == 0xAD)
		{
			// WICKET-4559 skip suffix 'ad' because some ad-blocking solutions may hide the
// component
			generatedMarkupId = getSession().nextSequenceValue();
		}

		if (storedMarkupId == null)
		{
			setMarkupIdImpl(generatedMarkupId);
		}

		String markupIdPrefix = ""id"";
		if (getApplication().usesDevelopmentConfig())
		{
			// in non-deployment mode we make the markup id include component id
			// so it is easier to debug
			markupIdPrefix = getId();
		}

		String markupIdPostfix = Integer.toHexString(generatedMarkupId).toLowerCase();

		String markupId = markupIdPrefix + markupIdPostfix;

		// make sure id is compliant with w3c requirements (starts with a letter)
		char c = markupId.charAt(0);
		if (!Character.isLetter(c))
		{
			markupId = ""id"" + markupId;
		}

		// escape some noncompliant characters
		markupId = Strings.replaceAll(markupId, ""_"", ""__"").toString();
		markupId = markupId.replace('.', '_');
		markupId = markupId.replace('-', '_');
		markupId = markupId.replace(' ', '_');

		return markupId;
	}","public String getMarkupId(boolean createIfDoesNotExist)
	{
		Object storedMarkupId = getMarkupIdImpl();
		if (storedMarkupId instanceof String)
		{
			return (String)storedMarkupId;
		}

		if (storedMarkupId == null && createIfDoesNotExist == false)
		{
			return null;
		}

		int generatedMarkupId = storedMarkupId instanceof Integer ? (Integer)storedMarkupId
			: getSession().nextSequenceValue();

		if (generatedMarkupId == 0xAD)
		{
			// WICKET-4559 skip suffix 'ad' because some ad-blocking solutions may hide the
// component
			generatedMarkupId = getSession().nextSequenceValue();
		}

		if (storedMarkupId == null)
		{
			setMarkupIdImpl(generatedMarkupId);
		}

		String markupIdPrefix = ""id"";
		if (getApplication().usesDevelopmentConfig())
		{
			// in non-deployment mode we make the markup id include component id
			// so it is easier to debug
			markupIdPrefix = getId();
		}

		String markupIdPostfix = Integer.toHexString(generatedMarkupId).toLowerCase();

		String markupId = markupIdPrefix + markupIdPostfix;

		// make sure id is compliant with w3c requirements (starts with a letter)
		char c = markupId.charAt(0);
		if (!Character.isLetter(c))
		{
			markupId = ""id"" + markupId;
		}

		// escape some noncompliant characters
		markupId = Strings.replaceAll(markupId, ""_"", ""__"").toString();
		markupId = markupId.replace('.', '_');
		markupId = markupId.replace('-', '_');
		markupId = markupId.replace(' ', '_');

		return markupId;
	}",0,[0]
20736,bugs-dot-jar_CAMEL-7459_57ba1bde,"public static String sanitizeUri(String uri) {
        // use xxxxx as replacement as that works well with JMX also
        String sanitized = uri;
        if (uri != null) {
            sanitized = SECRETS.matcher(sanitized).replaceAll(""$1=xxxxxx"");
            sanitized = USERINFO_PASSWORD.matcher(sanitized).replaceFirst(""$1xxxxxx$3"");
        }
        return sanitized;
    }","public static String sanitizeUri(String uri) {
        // use xxxxx as replacement as that works well with JMX also
        String sanitized = uri;
        if (uri != null) {
            sanitized = SECRETS.matcher(sanitized).replaceAll(""$1=xxxxxx"");
            sanitized = USERINFO_PASSWORD.matcher(sanitized).replaceFirst(""$1xxxxxx$3"");
        }
        return sanitized;
    }",0,[0]
16967,bugs-dot-jar_WICKET-5728_3cc3fe95,"public DequeueContext newDequeueContext()
	{
		Markup markup = getAssociatedMarkup();
		if (markup == null)
		{
			return null;
		}
		return new DequeueContext(markup, this, false);
	}","public DequeueContext newDequeueContext()
	{
		Markup markup = getAssociatedMarkup();
		if (markup == null)
		{
			return null;
		}
		return new DequeueContext(markup, this, false);
	}",0,[0]
19168,bugs-dot-jar_ACCUMULO-776_dc9f23d9,"public static void setStart(IteratorSetting is, String start, boolean startInclusive) {
    is.addOption(START, start);
    is.addOption(START_INCL, Boolean.toString(startInclusive));
  }","public static void setStart(IteratorSetting is, String start, boolean startInclusive) {
    SimpleDateFormat dateParser = initDateParser();
    try {
      long startTS = dateParser.parse(start).getTime();
      setStart(is, startTS, startInclusive);
    } catch (ParseException e) {
      throw new IllegalArgumentException(""couldn't parse "" + start);
    }
  }",1,"[1, 2]"
39499,bugs-dot-jar_MATH-305_ef9b639a,"public static int pow(final int k, int e)
        throws IllegalArgumentException {

        if (e < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                ""cannot raise an integral value to a negative power ({0}^{1})"",
                k, e);
        }

        int result = 1;
        int k2p    = k;
        while (e != 0) {
            if ((e & 0x1) != 0) {
                result *= k2p;
            }
            k2p *= k2p;
            e = e >> 1;
        }

        return result;

    }","public static int pow(final int k, int e)
        throws IllegalArgumentException {

        if (e < 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                ""cannot raise an integral value to a negative power ({0}^{1})"",
                k, e);
        }

        int result = 1;
        int k2p    = k;
        while (e != 0) {
            if ((e & 0x1) != 0) {
                result *= k2p;
            }
            k2p *= k2p;
            e = e >> 1;
        }

        return result;

    }",0,[0]
3039,bugs-dot-jar_FLINK-2754_68912126,"@Override
	public int size() {
		return this.numRecords;
	}","@Override
	public int size() {
		return this.numRecords;
	}",0,[0]
17895,bugs-dot-jar_OAK-1075_79467350,"public static boolean match(PropertyValue p1, PropertyState p2) {
        return match(p1, create(p2));
    }","public static boolean match(PropertyValue p1, PropertyState p2) {
        return match(p1, create(p2));
    }",0,[0]
19850,bugs-dot-jar_LOG4J2-470_50340d0c,"private ClassLoader getClassLoader() {
        try {
            // if container is Servlet 3.0, use its getClassLoader method
            // this may look odd, but the call below will throw NoSuchMethodError if user is on Servlet 2.5
            // we compile against 3.0 to support Log4jServletContainerInitializer, but we don't require 3.0
            return this.servletContext.getClassLoader();
        } catch (final Throwable ignore) {
            // otherwise, use this class's class loader
            return Log4jWebInitializerImpl.class.getClassLoader();
        }
    }","private ClassLoader getClassLoader() {
        try {
            // if container is Servlet 3.0, use its getClassLoader method
            // this may look odd, but the call below will throw NoSuchMethodError if user is on Servlet 2.5
            // we compile against 3.0 to support Log4jServletContainerInitializer, but we don't require 3.0
            return this.servletContext.getClassLoader();
        } catch (final Throwable ignore) {
            // otherwise, use this class's class loader
            return Log4jWebInitializerImpl.class.getClassLoader();
        }
    }",0,[0]
36420,bugs-dot-jar_CAMEL-7418_cabee0e9,"public <T> T lookup(String name, Class<T> type) {
        return lookupByNameAndType(name, type);
    }","public <T> T lookup(String name, Class<T> type) {
        return lookupByNameAndType(name, type);
    }",0,[0]
1746,Bears-197,"@Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final URIBuilder that = (URIBuilder) o;

        if (port != that.port) return false;
        if (encode != that.encode) return false;
        if (scheme != null ? !scheme.equals(that.scheme) : that.scheme != null) return false;
        if (encodedSchemeSpecificPart != null ? !encodedSchemeSpecificPart.equals(that.encodedSchemeSpecificPart) : that.encodedSchemeSpecificPart != null)
            return false;
        if (encodedAuthority != null ? !encodedAuthority.equals(that.encodedAuthority) : that.encodedAuthority != null)
            return false;
        if (userInfo != null ? !userInfo.equals(that.userInfo) : that.userInfo != null) return false;
        if (encodedUserInfo != null ? !encodedUserInfo.equals(that.encodedUserInfo) : that.encodedUserInfo != null)
            return false;
        if (host != null ? !host.equals(that.host) : that.host != null) return false;
        if (path != null ? !path.equals(that.path) : that.path != null) return false;
        if (encodedPath != null ? !encodedPath.equals(that.encodedPath) : that.encodedPath != null) return false;
        if (encodedQuery != null ? !encodedQuery.equals(that.encodedQuery) : that.encodedQuery != null) return false;
        if (queryParams != null ? !queryParams.equals(that.queryParams) : that.queryParams != null) return false;
        if (query != null ? !query.equals(that.query) : that.query != null) return false;
        if (fragment != null ? !fragment.equals(that.fragment) : that.fragment != null) return false;
        return !(encodedFragment != null ? !encodedFragment.equals(that.encodedFragment) : that.encodedFragment != null);

    }","@Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final URIBuilder that = (URIBuilder) o;

        if (port != that.port) return false;
        if (encode != that.encode) return false;
        if (scheme != null ? !scheme.equals(that.scheme) : that.scheme != null) return false;
        if (encodedSchemeSpecificPart != null ? !encodedSchemeSpecificPart.equals(that.encodedSchemeSpecificPart) : that.encodedSchemeSpecificPart != null)
            return false;
        if (encodedAuthority != null ? !encodedAuthority.equals(that.encodedAuthority) : that.encodedAuthority != null)
            return false;
        if (userInfo != null ? !userInfo.equals(that.userInfo) : that.userInfo != null) return false;
        if (encodedUserInfo != null ? !encodedUserInfo.equals(that.encodedUserInfo) : that.encodedUserInfo != null)
            return false;
        if (host != null ? !host.equals(that.host) : that.host != null) return false;
        if (path != null ? !path.equals(that.path) : that.path != null) return false;
        if (encodedPath != null ? !encodedPath.equals(that.encodedPath) : that.encodedPath != null) return false;
        if (encodedQuery != null ? !encodedQuery.equals(that.encodedQuery) : that.encodedQuery != null) return false;
        if (queryParams != null ? !queryParams.equals(that.queryParams) : that.queryParams != null) return false;
        if (query != null ? !query.equals(that.query) : that.query != null) return false;
        if (fragment != null ? !fragment.equals(that.fragment) : that.fragment != null) return false;
        return !(encodedFragment != null ? !encodedFragment.equals(that.encodedFragment) : that.encodedFragment != null);

    }",0,[0]
16265,bugs-dot-jar_FLINK-3189_a5b05566,"private static Options getRunOptionsWithoutDeprecatedOptions(Options options) {
		Options o = getProgramSpecificOptionsWithoutDeprecatedOptions(options);
		return getJobManagerAddressOption(o);
	}","private static Options getRunOptionsWithoutDeprecatedOptions(Options options) {
		Options o = getProgramSpecificOptionsWithoutDeprecatedOptions(options);
		return getJobManagerAddressOption(o);
	}",0,[0]
2386,bugs-dot-jar_CAMEL-5140_8898d491,"protected void doStart() throws Exception {
        ServiceHelper.startService(getProcessor());
    }","protected void doStart() throws Exception {
        ServiceHelper.startService(getProcessor());
    }",0,[0]
25361,bugs-dot-jar_OAK-4038_557eec4f,"@Override
    public boolean isAccessible(String path) {
        PermissionProvider permissionProvider = selector.getQuery().getExecutionContext().getPermissionProvider();
        return permissionProvider != null && permissionProvider.isGranted(path, Session.ACTION_READ);
    }","@Override
    public boolean isAccessible(String path) {
        PermissionProvider permissionProvider = selector.getQuery().getExecutionContext().getPermissionProvider();
        return permissionProvider != null && permissionProvider.isGranted(path, Session.ACTION_READ);
    }",0,[0]
24037,bugs-dot-jar_OAK-579_7d72e6ed,"@Override
    public String getPlan(NodeState rootState) {
        return left.getPlan(rootState) + ' ' + joinType +
                "" "" + right.getPlan(rootState) + "" on "" + joinCondition;
    }","@Override
    public String getPlan(NodeState rootState) {
        StringBuilder buff = new StringBuilder();
        buff.append(left.getPlan(rootState)).
            append(' ').
            append(joinType).
            append(' ').
            append(right.getPlan(rootState)).
            append("" on "").
            append(joinCondition);
        return buff.toString();
    }",1,"[2, 3]"
13173,bugs-dot-jar_OAK-2434_8159fc21,"private static int getPropertyType(PropertyDefinition defn, String name, int defaultVal){
        if (defn.isTypeDefined()) {
            return defn.getType();
        }
        return defaultVal;
    }","private static int getPropertyType(PropertyDefinition defn, String name, int defaultVal){
        if (defn.isTypeDefined()) {
            return defn.getType();
        }
        return defaultVal;
    }",0,[0]
10285,bugs-dot-jar_OAK-3897_94c6c575,"BackgroundReadStats backgroundRead() {
        BackgroundReadStats stats = new BackgroundReadStats();
        long time = clock.getTime();
        String id = Utils.getIdFromPath(""/"");
        NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
        if (doc == null) {
            return stats;
        }
        alignWithExternalRevisions(doc);

        StringSort externalSort = JournalEntry.newSorter();

        Map<Integer, Revision> lastRevMap = doc.getLastRev();
        try {
            RevisionVector headRevision = getHeadRevision();
            Set<Revision> externalChanges = Sets.newHashSet();
            for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
                int machineId = e.getKey();
                if (machineId == clusterId) {
                    // ignore own lastRev
                    continue;
                }
                Revision r = e.getValue();
                Revision last = headRevision.getRevision(machineId);
                if (last == null) {
                    // make sure we see all changes when a cluster node joins
                    last = new Revision(0, 0, machineId);
                }
                if (r.compareRevisionTime(last) > 0) {
                    // OAK-2345
                    // only consider as external change if
                    // the revision changed for the machineId
                    externalChanges.add(r);
                    // collect external changes
                    if (externalSort != null) {
                        // add changes for this particular clusterId to the externalSort
                        try {
                            fillExternalChanges(externalSort, last, r, store);
                        } catch (IOException e1) {
                            LOG.error(""backgroundRead: Exception while reading external changes from journal: "" + e1, e1);
                            IOUtils.closeQuietly(externalSort);
                            externalSort = null;
                        }
                    }
                }
            }

            stats.readHead = clock.getTime() - time;
            time = clock.getTime();

            if (!externalChanges.isEmpty()) {
                // invalidate caches
                if (externalSort == null) {
                    // if no externalSort available, then invalidate the classic way: everything
                    stats.cacheStats = store.invalidateCache();
                    docChildrenCache.invalidateAll();
                } else {
                    try {
                        externalSort.sort();
                        stats.cacheStats = store.invalidateCache(pathToId(externalSort));
                        // OAK-3002: only invalidate affected items (using journal)
                        long origSize = docChildrenCache.size();
                        if (origSize == 0) {
                            // if docChildrenCache is empty, don't bother
                            // calling invalidateAll either way
                            // (esp calling invalidateAll(Iterable) will
                            // potentially iterate over all keys even though
                            // there's nothing to be deleted)
                            LOG.trace(""backgroundRead: docChildrenCache nothing to invalidate"");
                        } else {
                            // however, if the docChildrenCache is not empty,
                            // use the invalidateAll(Iterable) variant,
                            // passing it a Iterable<StringValue>, as that's
                            // what is contained in the cache
                            docChildrenCache.invalidateAll(asStringValueIterable(externalSort));
                            long newSize = docChildrenCache.size();
                            LOG.trace(""backgroundRead: docChildrenCache invalidation result: orig: {}, new: {} "", origSize, newSize);
                        }
                    } catch (Exception ioe) {
                        LOG.error(""backgroundRead: got IOException during external sorting/cache invalidation (as a result, invalidating entire cache): ""+ioe, ioe);
                        stats.cacheStats = store.invalidateCache();
                        docChildrenCache.invalidateAll();
                    }
                }
                stats.cacheInvalidationTime = clock.getTime() - time;
                time = clock.getTime();

                // make sure no local commit is in progress
                backgroundOperationLock.writeLock().lock();
                try {
                    stats.lock = clock.getTime() - time;

                    RevisionVector oldHead = getHeadRevision();
                    RevisionVector newHead = oldHead;
                    for (Revision r : externalChanges) {
                        newHead = newHead.update(r);
                    }
                    setRoot(newHead);
                    commitQueue.headRevisionChanged();
                    time = clock.getTime();
                    if (externalSort != null) {
                        // then there were external changes and reading them
                        // was successful -> apply them to the diff cache
                        try {
                            JournalEntry.applyTo(externalSort, diffCache, oldHead, newHead);
                        } catch (Exception e1) {
                            LOG.error(""backgroundRead: Exception while processing external changes from journal: {}"", e1, e1);
                        }
                    }
                    stats.populateDiffCache = clock.getTime() - time;
                    time = clock.getTime();

                    dispatcher.contentChanged(getRoot().fromExternalChange(), null);
                } finally {
                    backgroundOperationLock.writeLock().unlock();
                }
                stats.dispatchChanges = clock.getTime() - time;
            }
        } finally {
            IOUtils.closeQuietly(externalSort);
        }

        return stats;
    }","BackgroundReadStats backgroundRead() {
        BackgroundReadStats stats = new BackgroundReadStats();
        long time = clock.getTime();
        String id = Utils.getIdFromPath(""/"");
        NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);
        if (doc == null) {
            return stats;
        }
        alignWithExternalRevisions(doc);

        StringSort externalSort = JournalEntry.newSorter();

        Map<Integer, Revision> lastRevMap = doc.getLastRev();
        try {
            RevisionVector headRevision = getHeadRevision();
            Set<Revision> externalChanges = Sets.newHashSet();
            for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {
                int machineId = e.getKey();
                if (machineId == clusterId) {
                    // ignore own lastRev
                    continue;
                }
                Revision r = e.getValue();
                Revision last = headRevision.getRevision(machineId);
                if (last == null) {
                    // make sure we see all changes when a cluster node joins
                    last = new Revision(0, 0, machineId);
                }
                if (r.compareRevisionTime(last) > 0) {
                    // OAK-2345
                    // only consider as external change if
                    // the revision changed for the machineId
                    externalChanges.add(r);
                    // collect external changes
                    if (externalSort != null) {
                        // add changes for this particular clusterId to the externalSort
                        try {
                            fillExternalChanges(externalSort, last, r, store);
                        } catch (IOException e1) {
                            LOG.error(""backgroundRead: Exception while reading external changes from journal: "" + e1, e1);
                            IOUtils.closeQuietly(externalSort);
                            externalSort = null;
                        }
                    }
                }
            }

            stats.readHead = clock.getTime() - time;
            time = clock.getTime();

            if (!externalChanges.isEmpty()) {
                // invalidate caches
                if (externalSort == null) {
                    // if no externalSort available, then invalidate the classic way: everything
                    stats.cacheStats = store.invalidateCache();
                    docChildrenCache.invalidateAll();
                } else {
                    try {
                        externalSort.sort();
                        stats.cacheStats = store.invalidateCache(pathToId(externalSort));
                        // OAK-3002: only invalidate affected items (using journal)
                        long origSize = docChildrenCache.size();
                        if (origSize == 0) {
                            // if docChildrenCache is empty, don't bother
                            // calling invalidateAll either way
                            // (esp calling invalidateAll(Iterable) will
                            // potentially iterate over all keys even though
                            // there's nothing to be deleted)
                            LOG.trace(""backgroundRead: docChildrenCache nothing to invalidate"");
                        } else {
                            // however, if the docChildrenCache is not empty,
                            // use the invalidateAll(Iterable) variant,
                            // passing it a Iterable<StringValue>, as that's
                            // what is contained in the cache
                            docChildrenCache.invalidateAll(asStringValueIterable(externalSort));
                            long newSize = docChildrenCache.size();
                            LOG.trace(""backgroundRead: docChildrenCache invalidation result: orig: {}, new: {} "", origSize, newSize);
                        }
                    } catch (Exception ioe) {
                        LOG.error(""backgroundRead: got IOException during external sorting/cache invalidation (as a result, invalidating entire cache): ""+ioe, ioe);
                        stats.cacheStats = store.invalidateCache();
                        docChildrenCache.invalidateAll();
                    }
                }
                stats.cacheInvalidationTime = clock.getTime() - time;
                time = clock.getTime();

                // make sure no local commit is in progress
                backgroundOperationLock.writeLock().lock();
                try {
                    stats.lock = clock.getTime() - time;

                    RevisionVector oldHead = getHeadRevision();
                    RevisionVector newHead = oldHead;
                    for (Revision r : externalChanges) {
                        newHead = newHead.update(r);
                    }
                    setRoot(newHead);
                    commitQueue.headRevisionChanged();
                    time = clock.getTime();
                    if (externalSort != null) {
                        // then there were external changes and reading them
                        // was successful -> apply them to the diff cache
                        try {
                            JournalEntry.applyTo(externalSort, diffCache, oldHead, newHead);
                        } catch (Exception e1) {
                            LOG.error(""backgroundRead: Exception while processing external changes from journal: {}"", e1, e1);
                        }
                    }
                    stats.populateDiffCache = clock.getTime() - time;
                    time = clock.getTime();

                    dispatcher.contentChanged(getRoot().fromExternalChange(), null);
                } finally {
                    backgroundOperationLock.writeLock().unlock();
                }
                stats.dispatchChanges = clock.getTime() - time;
            }
        } finally {
            IOUtils.closeQuietly(externalSort);
        }

        return stats;
    }",0,[0]
18936,bugs-dot-jar_OAK-546_428e32c6,"@Override
    public Result executeQuery(String statement, String language, long limit,
            long offset, Map<String, ? extends PropertyValue> bindings,
            NamePathMapper namePathMapper) throws ParseException {
        Query q = parseQuery(statement, language);
        q.setRootTree(getRootTree());
        q.setRootState(getRootState());
        q.setNamePathMapper(namePathMapper);
        q.setLimit(limit);
        q.setOffset(offset);
        if (bindings != null) {
            for (Entry<String, ? extends PropertyValue> e : bindings.entrySet()) {
                q.bindValue(e.getKey(), e.getValue());
            }
        }
        q.setQueryEngine(this);
        q.prepare();
        return q.executeQuery();
    }","@Override
    public Result executeQuery(String statement, String language, long limit,
            long offset, Map<String, ? extends PropertyValue> bindings,
            NamePathMapper namePathMapper) throws ParseException {
        if (limit < 0) {
            throw new IllegalArgumentException(""Limit may not be negative, is: "" + limit);
        }
        if (offset < 0) {
            throw new IllegalArgumentException(""Offset may not be negative, is: "" + offset);
        }
        Query q = parseQuery(statement, language);
        q.setRootTree(getRootTree());
        q.setRootState(getRootState());
        q.setNamePathMapper(namePathMapper);
        q.setLimit(limit);
        q.setOffset(offset);
        if (bindings != null) {
            for (Entry<String, ? extends PropertyValue> e : bindings.entrySet()) {
                q.bindValue(e.getKey(), e.getValue());
            }
        }
        q.setQueryEngine(this);
        q.prepare();
        return q.executeQuery();
    }",1,[]
34261,bugs-dot-jar_WICKET-4184_a0150366,"public void setCharAt(final int index, final char ch)
	{
		if ((index < 0) || (index >= count))
		{
			throw new StringIndexOutOfBoundsException(index);
		}
		value[index] = ch;
	}","public void setCharAt(final int index, final char ch)
	{
		if ((index < 0) || (index >= count))
		{
			throw new StringIndexOutOfBoundsException(index);
		}
		value[index] = ch;
	}",0,[0]
1686,Bears-197,"public static String constructServiceUrl(final HttpServletRequest request, final HttpServletResponse response,
            final String service, final String serverNames, final String serviceParameterName,
            final String artifactParameterName, final boolean encode) {
        if (CommonUtils.isNotBlank(service)) {
            return encode ? response.encodeURL(service) : service;
        }

        final String serverName = findMatchingServerName(request, serverNames);
        final URIBuilder originalRequestUrl = new URIBuilder(request.getRequestURL().toString(), encode);
        originalRequestUrl.setParameters(request.getQueryString());

        final URIBuilder builder;

        boolean containsScheme = true;
        if (!serverName.startsWith(""https://"") && !serverName.startsWith(""http://"")) {
            builder = new URIBuilder(encode);
            builder.setScheme(request.isSecure() ? ""https"" : ""http"");
            builder.setHost(serverName);
            containsScheme = false;
        }  else {
            builder = new URIBuilder(serverName, encode);
        }


        if (!serverNameContainsPort(containsScheme, serverName) && !requestIsOnStandardPort(request)) {
            builder.setPort(request.getServerPort());
        }

        builder.setEncodedPath(request.getRequestURI());

        final List<String> serviceParameterNames = Arrays.asList(serviceParameterName.split("",""));
        if (!serviceParameterNames.isEmpty() && !originalRequestUrl.getQueryParams().isEmpty()) {
            for (final URIBuilder.BasicNameValuePair pair : originalRequestUrl.getQueryParams()) {
                String name = pair.getName();
                if (!name.equals(artifactParameterName) && !serviceParameterNames.contains(name)) {
                    if (name.contains(""&"") || name.contains(""="") ){
                        URIBuilder encodedParamBuilder = new URIBuilder();
                        encodedParamBuilder.setParameters(name);
                        for (final URIBuilder.BasicNameValuePair pair2 :encodedParamBuilder.getQueryParams()){
                            String name2 = pair2.getName();
                            if (!name2.equals(artifactParameterName) && !serviceParameterNames.contains(name2)) {
                                builder.addParameter(name2, pair2.getValue());
                            }
                        }
                    } else {
                        builder.addParameter(name, pair.getValue());
                    }
                }
            }
        }

        final String result = builder.toString();
        final String returnValue = encode ? response.encodeURL(result) : result;
        LOGGER.debug(""serviceUrl generated: {}"", returnValue);
        return returnValue;
    }","public static String constructServiceUrl(final HttpServletRequest request, final HttpServletResponse response,
            final String service, final String serverNames, final String serviceParameterName,
            final String artifactParameterName, final boolean encode) {
        if (CommonUtils.isNotBlank(service)) {
            return encode ? response.encodeURL(service) : service;
        }

        final String serverName = findMatchingServerName(request, serverNames);
        final URIBuilder originalRequestUrl = new URIBuilder(request.getRequestURL().toString(), encode);
        originalRequestUrl.setParameters(request.getQueryString());

        final URIBuilder builder;
        if (!serverName.startsWith(""https://"") && !serverName.startsWith(""http://"")) {
            String scheme = request.isSecure() ? ""https://"" : ""http://"";
            builder = new URIBuilder(scheme + serverName, encode);
        } else {
            builder = new URIBuilder(serverName, encode);
        }

        if (builder.getPort() == -1 && !requestIsOnStandardPort(request)) {
            builder.setPort(request.getServerPort());
        }

        builder.setEncodedPath(builder.getEncodedPath() + request.getRequestURI());

        final List<String> serviceParameterNames = Arrays.asList(serviceParameterName.split("",""));
        if (!serviceParameterNames.isEmpty() && !originalRequestUrl.getQueryParams().isEmpty()) {
            for (final URIBuilder.BasicNameValuePair pair : originalRequestUrl.getQueryParams()) {
                String name = pair.getName();
                if (!name.equals(artifactParameterName) && !serviceParameterNames.contains(name)) {
                    if (name.contains(""&"") || name.contains(""="") ){
                        URIBuilder encodedParamBuilder = new URIBuilder();
                        encodedParamBuilder.setParameters(name);
                        for (final URIBuilder.BasicNameValuePair pair2 :encodedParamBuilder.getQueryParams()){
                            String name2 = pair2.getName();
                            if (!name2.equals(artifactParameterName) && !serviceParameterNames.contains(name2)) {
                                builder.addParameter(name2, pair2.getValue());
                            }
                        }
                    } else {
                        builder.addParameter(name, pair.getValue());
                    }
                }
            }
        }

        final String result = builder.toString();
        final String returnValue = encode ? response.encodeURL(result) : result;
        LOGGER.debug(""serviceUrl generated: {}"", returnValue);
        return returnValue;
    }",1,"[13, 15, 16, 17, 18, 19, 24, 28]"
9802,bugs-dot-jar_OAK-3634_90ad50da,"<T extends Document> ReadPreference getMongoReadPreference(Collection<T> collection,
                                                               String parentId,
                                                               DocumentReadPreference preference) {
        switch(preference){
            case PRIMARY:
                return ReadPreference.primary();
            case PREFER_PRIMARY :
                return ReadPreference.primaryPreferred();
            case PREFER_SECONDARY :
                return getConfiguredReadPreference(collection);
            case PREFER_SECONDARY_IF_OLD_ENOUGH:
                if(collection != Collection.NODES){
                    return ReadPreference.primary();
                }

                // read from primary unless parent has not been modified
                // within replication lag period
                ReadPreference readPreference = ReadPreference.primary();
                if (parentId != null) {
                    long replicationSafeLimit = getTime() - maxReplicationLagMillis;
                    NodeDocument cachedDoc = nodesCache.getIfPresent(parentId);
                    // FIXME: this is not quite accurate, because ancestors
                    // are updated in a background thread (_lastRev). We
                    // will need to revise this for low maxReplicationLagMillis
                    // values
                    if (cachedDoc != null && !cachedDoc.hasBeenModifiedSince(replicationSafeLimit)) {

                        //If parent has been modified loooong time back then there children
                        //would also have not be modified. In that case we can read from secondary
                        readPreference = getConfiguredReadPreference(collection);
                    }
                }
                return readPreference;
            default:
                throw new IllegalArgumentException(""Unsupported usage "" + preference);
        }
    }","<T extends Document> ReadPreference getMongoReadPreference(Collection<T> collection,
                                                               String parentId,
                                                               DocumentReadPreference preference) {
        switch(preference){
            case PRIMARY:
                return ReadPreference.primary();
            case PREFER_PRIMARY :
                return ReadPreference.primaryPreferred();
            case PREFER_SECONDARY :
                return getConfiguredReadPreference(collection);
            case PREFER_SECONDARY_IF_OLD_ENOUGH:
                if(collection != Collection.NODES){
                    return ReadPreference.primary();
                }

                // read from primary unless parent has not been modified
                // within replication lag period
                ReadPreference readPreference = ReadPreference.primary();
                if (parentId != null) {
                    long replicationSafeLimit = getTime() - maxReplicationLagMillis;
                    NodeDocument cachedDoc = nodesCache.getIfPresent(parentId);
                    // FIXME: this is not quite accurate, because ancestors
                    // are updated in a background thread (_lastRev). We
                    // will need to revise this for low maxReplicationLagMillis
                    // values
                    if (cachedDoc != null && !cachedDoc.hasBeenModifiedSince(replicationSafeLimit)) {

                        //If parent has been modified loooong time back then there children
                        //would also have not be modified. In that case we can read from secondary
                        readPreference = getConfiguredReadPreference(collection);
                    }
                }
                return readPreference;
            default:
                throw new IllegalArgumentException(""Unsupported usage "" + preference);
        }
    }",0,[0]
5925,bugs-dot-jar_OAK-3110_d10362c0,"private static File initializerWorkDir(File indexRootDir) throws IOException {
        File workDir = new File(indexRootDir, WORK_DIR_NAME);
        FileUtils.deleteDirectory(workDir);
        checkState(workDir.mkdirs(), ""Cannot create directory %s"", workDir);
        return workDir;
    }","private static File initializerWorkDir(File indexRootDir) throws IOException {
        File workDir = new File(indexRootDir, WORK_DIR_NAME);
        FileUtils.deleteDirectory(workDir);
        checkState(workDir.mkdirs(), ""Cannot create directory %s"", workDir);
        return workDir;
    }",0,[0]
27030,bugs-dot-jar_LOG4J2-793_73400bfb,"private void writeObject(final ObjectOutputStream aOutputStream) throws IOException {
        // perform the default serialization for all non-transient, non-static fields
        aOutputStream.defaultWriteObject();
    }","private void writeObject(final ObjectOutputStream aOutputStream) throws IOException {
        // perform the default serialization for all non-transient, non-static fields
        aOutputStream.defaultWriteObject();
    }",0,[0]
9843,bugs-dot-jar_OAK-3634_90ad50da,"@Override
    public <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update) {
        return internalCreateOrUpdate(collection, update, false, true);
    }","@Override
    public <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update) {
        return internalCreateOrUpdate(collection, update, false, true);
    }",0,[0]
40095,bugs-dot-jar_OAK-1429_c2f5ca6c,"String diff(@Nonnull final String fromRevisionId,
                @Nonnull final String toRevisionId,
                @Nonnull final String path) throws MicroKernelException {
        if (fromRevisionId.equals(toRevisionId)) {
            return """";
        }
        Revision fromRev = Revision.fromString(fromRevisionId);
        Revision toRev = Revision.fromString(toRevisionId);
        final DocumentNodeState from = getNode(path, fromRev);
        final DocumentNodeState to = getNode(path, toRev);
        if (from == null || to == null) {
            // TODO implement correct behavior if the node does't/didn't exist
            String msg = String.format(""Diff is only supported if the node exists in both cases. "" +
                    ""Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s"",
                    path, fromRev, from != null, toRev, to != null);
            throw new MicroKernelException(msg);
        }
        PathRev key = diffCacheKey(path, fromRev, toRev);
        try {
            JsopWriter writer = new JsopStream();
            diffProperties(from, to, writer);
            return writer.toString() + diffCache.get(key, new Callable<StringValue>() {
                @Override
                public StringValue call() throws Exception {
                    return new StringValue(diffImpl(from, to));
                }
            });
        } catch (ExecutionException e) {
            if (e.getCause() instanceof MicroKernelException) {
                throw (MicroKernelException) e.getCause();
            } else {
                throw new MicroKernelException(e.getCause());
            }
        }
    }","String diff(@Nonnull final String fromRevisionId,
                @Nonnull final String toRevisionId,
                @Nonnull final String path) throws MicroKernelException {
        if (fromRevisionId.equals(toRevisionId)) {
            return """";
        }
        Revision fromRev = Revision.fromString(fromRevisionId);
        Revision toRev = Revision.fromString(toRevisionId);
        final DocumentNodeState from = getNode(path, fromRev);
        final DocumentNodeState to = getNode(path, toRev);
        if (from == null || to == null) {
            // TODO implement correct behavior if the node does't/didn't exist
            String msg = String.format(""Diff is only supported if the node exists in both cases. "" +
                    ""Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s"",
                    path, fromRev, from != null, toRev, to != null);
            throw new MicroKernelException(msg);
        }
        PathRev key = diffCacheKey(path, fromRev, toRev);
        try {
            JsopWriter writer = new JsopStream();
            diffProperties(from, to, writer);
            String compactDiff = diffCache.get(key, new Callable<StringValue>() {
                @Override
                public StringValue call() throws Exception {
                    return new StringValue(diffImpl(from, to));
                }
            }).toString();
            JsopTokenizer t = new JsopTokenizer(compactDiff);
            int r;
            do {
                r = t.read();
                switch (r) {
                    case '+':
                    case '^': {
                        String name = t.readString();
                        t.read(':');
                        t.read('{');
                        t.read('}');
                        writer.tag((char) r).key(PathUtils.concat(path, name));
                        writer.object().endObject().newline();
                        break;
                    }
                    case '-': {
                        String name = t.readString();
                        writer.tag('-').value(PathUtils.concat(path, name));
                        writer.newline();
                    }
                }
            } while (r != JsopReader.END);
            return writer.toString();
        } catch (ExecutionException e) {
            if (e.getCause() instanceof MicroKernelException) {
                throw (MicroKernelException) e.getCause();
            } else {
                throw new MicroKernelException(e.getCause());
            }
        }
    }",1,"[21, 26]"
11684,bugs-dot-jar_CAMEL-5796_de6dd425,"public OnExceptionDefinition onException(Class<? extends Throwable> exceptionType) {
        OnExceptionDefinition answer = new OnExceptionDefinition(exceptionType);
        addOutput(answer);
        return answer;
    }","public OnExceptionDefinition onException(Class<? extends Throwable> exceptionType) {
        OnExceptionDefinition answer = new OnExceptionDefinition(exceptionType);
        addOutput(answer);
        return answer;
    }",0,[0]
27947,bugs-dot-jar_CAMEL-8053_cac72b14,"private void doStartCamel() throws Exception {
        if (applicationContextClassLoader == null) {
            // Using the TCCL as the default value of ApplicationClassLoader
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            if (cl == null) {
                // use the classloader that loaded this class
                cl = this.getClass().getClassLoader();
            }
            setApplicationContextClassLoader(cl);
        }

        if (log.isDebugEnabled()) {
            log.debug(""Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}"",
                    new Object[]{getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader()});
        }

        if (isStreamCaching()) {
            log.info(""StreamCaching is enabled on CamelContext: {}"", getName());
        }

        if (isTracing()) {
            // tracing is added in the DefaultChannel so we can enable it on the fly
            log.info(""Tracing is enabled on CamelContext: {}"", getName());
        }

        if (isUseMDCLogging()) {
            // log if MDC has been enabled
            log.info(""MDC logging is enabled on CamelContext: {}"", getName());
        }

        if (isHandleFault()) {
            // only add a new handle fault if not already configured
            if (HandleFault.getHandleFault(this) == null) {
                log.info(""HandleFault is enabled on CamelContext: {}"", getName());
                addInterceptStrategy(new HandleFault());
            }
        }

        if (getDelayer() != null && getDelayer() > 0) {
            log.info(""Delayer is enabled with: {} ms. on CamelContext: {}"", getDelayer(), getName());
        }
        
        // register debugger
        if (getDebugger() != null) {
            log.info(""Debugger: {} is enabled on CamelContext: {}"", getDebugger(), getName());
            // register this camel context on the debugger
            getDebugger().setCamelContext(this);
            startService(getDebugger());
            addInterceptStrategy(new Debug(getDebugger()));
        }

        // start management strategy before lifecycles are started
        ManagementStrategy managementStrategy = getManagementStrategy();
        // inject CamelContext if aware
        if (managementStrategy instanceof CamelContextAware) {
            ((CamelContextAware) managementStrategy).setCamelContext(this);
        }
        ServiceHelper.startService(managementStrategy);

        // start lifecycle strategies
        ServiceHelper.startServices(lifecycleStrategies);
        Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();
        while (it.hasNext()) {
            LifecycleStrategy strategy = it.next();
            try {
                strategy.onContextStart(this);
            } catch (VetoCamelContextStartException e) {
                // okay we should not start Camel since it was vetoed
                log.warn(""Lifecycle strategy vetoed starting CamelContext ({}) due {}"", getName(), e.getMessage());
                throw e;
            } catch (Exception e) {
                log.warn(""Lifecycle strategy "" + strategy + "" failed starting CamelContext ({}) due {}"", getName(), e.getMessage());
                throw e;
            }
        }

        // start notifiers as services
        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
            if (notifier instanceof Service) {
                Service service = (Service) notifier;
                for (LifecycleStrategy strategy : lifecycleStrategies) {
                    strategy.onServiceAdd(this, service, null);
                }
            }
            if (notifier instanceof Service) {
                startService((Service)notifier);
            }
        }

        // must let some bootstrap service be started before we can notify the starting event
        EventHelper.notifyCamelContextStarting(this);

        forceLazyInitialization();

        // re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.
        // and we needed to create endpoints up-front as it may be accessed before this context is started
        endpoints = new EndpointRegistry(this, endpoints);
        addService(endpoints);
        // special for executorServiceManager as want to stop it manually
        doAddService(executorServiceManager, false);
        addService(producerServicePool);
        addService(inflightRepository);
        addService(shutdownStrategy);
        addService(packageScanClassResolver);
        addService(restRegistry);

        if (runtimeEndpointRegistry != null) {
            if (runtimeEndpointRegistry instanceof EventNotifier) {
                getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);
            }
            addService(runtimeEndpointRegistry);
        }

        // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance
        // due we use properties component for property placeholder resolution at runtime
        Component existing = lookupPropertiesComponent();
        if (existing != null) {
            // store reference to the existing properties component
            if (existing instanceof PropertiesComponent) {
                propertiesComponent = (PropertiesComponent) existing;
            } else {
                // properties component must be expected type
                throw new IllegalArgumentException(""Found properties component of type: "" + existing.getClass() + "" instead of expected: "" + PropertiesComponent.class);
            }
        }

        // start components
        startServices(components.values());

        // start the route definitions before the routes is started
        startRouteDefinitions(routeDefinitions);

        // is there any stream caching enabled then log an info about this and its limit of spooling to disk, so people is aware of this
        boolean streamCachingInUse = isStreamCaching();
        if (!streamCachingInUse) {
            for (RouteDefinition route : routeDefinitions) {
                Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());
                if (routeCache != null && routeCache) {
                    streamCachingInUse = true;
                    break;
                }
            }
        }

        if (isAllowUseOriginalMessage()) {
            log.info(""AllowUseOriginalMessage is enabled. If access to the original message is not needed,""
                    + "" then its recommended to turn this option off as it may improve performance."");
        }

        if (streamCachingInUse) {
            // stream caching is in use so enable the strategy
            getStreamCachingStrategy().setEnabled(true);
            addService(getStreamCachingStrategy());
        } else {
            // log if stream caching is not in use as this can help people to enable it if they use streams
            log.info(""StreamCaching is not in use. If using streams then its recommended to enable stream caching.""
                    + "" See more details at http://camel.apache.org/stream-caching.html"");
        }

        // start routes
        if (doNotStartRoutesOnFirstStart) {
            log.debug(""Skip starting of routes as CamelContext has been configured with autoStartup=false"");
        }

        // invoke this logic to warmup the routes and if possible also start the routes
        doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);

        // starting will continue in the start method
    }","private void doStartCamel() throws Exception {
        if (applicationContextClassLoader == null) {
            // Using the TCCL as the default value of ApplicationClassLoader
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            if (cl == null) {
                // use the classloader that loaded this class
                cl = this.getClass().getClassLoader();
            }
            setApplicationContextClassLoader(cl);
        }

        if (log.isDebugEnabled()) {
            log.debug(""Using ClassResolver={}, PackageScanClassResolver={}, ApplicationContextClassLoader={}"",
                    new Object[]{getClassResolver(), getPackageScanClassResolver(), getApplicationContextClassLoader()});
        }

        if (isStreamCaching()) {
            log.info(""StreamCaching is enabled on CamelContext: {}"", getName());
        }

        if (isTracing()) {
            // tracing is added in the DefaultChannel so we can enable it on the fly
            log.info(""Tracing is enabled on CamelContext: {}"", getName());
        }

        if (isUseMDCLogging()) {
            // log if MDC has been enabled
            log.info(""MDC logging is enabled on CamelContext: {}"", getName());
        }

        if (isHandleFault()) {
            // only add a new handle fault if not already configured
            if (HandleFault.getHandleFault(this) == null) {
                log.info(""HandleFault is enabled on CamelContext: {}"", getName());
                addInterceptStrategy(new HandleFault());
            }
        }

        if (getDelayer() != null && getDelayer() > 0) {
            log.info(""Delayer is enabled with: {} ms. on CamelContext: {}"", getDelayer(), getName());
        }
        
        // register debugger
        if (getDebugger() != null) {
            log.info(""Debugger: {} is enabled on CamelContext: {}"", getDebugger(), getName());
            // register this camel context on the debugger
            getDebugger().setCamelContext(this);
            startService(getDebugger());
            addInterceptStrategy(new Debug(getDebugger()));
        }

        // start management strategy before lifecycles are started
        ManagementStrategy managementStrategy = getManagementStrategy();
        // inject CamelContext if aware
        if (managementStrategy instanceof CamelContextAware) {
            ((CamelContextAware) managementStrategy).setCamelContext(this);
        }
        ServiceHelper.startService(managementStrategy);

        // start lifecycle strategies
        ServiceHelper.startServices(lifecycleStrategies);
        Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();
        while (it.hasNext()) {
            LifecycleStrategy strategy = it.next();
            try {
                strategy.onContextStart(this);
            } catch (VetoCamelContextStartException e) {
                // okay we should not start Camel since it was vetoed
                log.warn(""Lifecycle strategy vetoed starting CamelContext ({}) due {}"", getName(), e.getMessage());
                throw e;
            } catch (Exception e) {
                log.warn(""Lifecycle strategy "" + strategy + "" failed starting CamelContext ({}) due {}"", getName(), e.getMessage());
                throw e;
            }
        }

        // start notifiers as services
        for (EventNotifier notifier : getManagementStrategy().getEventNotifiers()) {
            if (notifier instanceof Service) {
                Service service = (Service) notifier;
                for (LifecycleStrategy strategy : lifecycleStrategies) {
                    strategy.onServiceAdd(this, service, null);
                }
            }
            if (notifier instanceof Service) {
                startService((Service)notifier);
            }
        }

        // must let some bootstrap service be started before we can notify the starting event
        EventHelper.notifyCamelContextStarting(this);

        forceLazyInitialization();

        // re-create endpoint registry as the cache size limit may be set after the constructor of this instance was called.
        // and we needed to create endpoints up-front as it may be accessed before this context is started
        endpoints = new EndpointRegistry(this, endpoints);
        addService(endpoints);
        // special for executorServiceManager as want to stop it manually
        doAddService(executorServiceManager, false);
        addService(producerServicePool);
        addService(inflightRepository);
        addService(shutdownStrategy);
        addService(packageScanClassResolver);
        addService(restRegistry);

        if (runtimeEndpointRegistry != null) {
            if (runtimeEndpointRegistry instanceof EventNotifier) {
                getManagementStrategy().addEventNotifier((EventNotifier) runtimeEndpointRegistry);
            }
            addService(runtimeEndpointRegistry);
        }

        // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance
        // due we use properties component for property placeholder resolution at runtime
        Component existing = lookupPropertiesComponent();
        if (existing != null) {
            // store reference to the existing properties component
            if (existing instanceof PropertiesComponent) {
                propertiesComponent = (PropertiesComponent) existing;
            } else {
                // properties component must be expected type
                throw new IllegalArgumentException(""Found properties component of type: "" + existing.getClass() + "" instead of expected: "" + PropertiesComponent.class);
            }
        }

        // start components
        startServices(components.values());

        // start the route definitions before the routes is started
        startRouteDefinitions(routeDefinitions);

        // is there any stream caching enabled then log an info about this and its limit of spooling to disk, so people is aware of this
        boolean streamCachingInUse = isStreamCaching();
        if (!streamCachingInUse) {
            for (RouteDefinition route : routeDefinitions) {
                Boolean routeCache = CamelContextHelper.parseBoolean(this, route.getStreamCache());
                if (routeCache != null && routeCache) {
                    streamCachingInUse = true;
                    break;
                }
            }
        }

        if (isAllowUseOriginalMessage()) {
            log.info(""AllowUseOriginalMessage is enabled. If access to the original message is not needed,""
                    + "" then its recommended to turn this option off as it may improve performance."");
        }

        if (streamCachingInUse) {
            // stream caching is in use so enable the strategy
            getStreamCachingStrategy().setEnabled(true);
            addService(getStreamCachingStrategy());
        } else {
            // log if stream caching is not in use as this can help people to enable it if they use streams
            log.info(""StreamCaching is not in use. If using streams then its recommended to enable stream caching.""
                    + "" See more details at http://camel.apache.org/stream-caching.html"");
        }

        // start routes
        if (doNotStartRoutesOnFirstStart) {
            log.debug(""Skip starting of routes as CamelContext has been configured with autoStartup=false"");
        }

        // invoke this logic to warmup the routes and if possible also start the routes
        doStartOrResumeRoutes(routeServices, true, !doNotStartRoutesOnFirstStart, false, true);

        // starting will continue in the start method
    }",0,[0]
33580,bugs-dot-jar_WICKET-4520_b91154ea,"public final void setExceptionSettings(final IExceptionSettings exceptionSettings)
	{
		this.exceptionSettings = exceptionSettings;
	}","public final void setExceptionSettings(final IExceptionSettings exceptionSettings)
	{
		this.exceptionSettings = exceptionSettings;
	}",0,[0]
24116,bugs-dot-jar_FLINK-3513_d90672fd,"private void configureRestartStrategy() {
		jobGraph.setRestartStrategyConfiguration(streamGraph.getExecutionConfig().getRestartStrategy());
	}","private void configureRestartStrategy() {
		jobGraph.setRestartStrategyConfiguration(streamGraph.getExecutionConfig().getRestartStrategy());
	}",0,[0]
19857,bugs-dot-jar_WICKET-1718_bb7f9cf5,"@Override
	protected void onRender()
	{
		// Configure the response such as headers etc.
		configureResponse((WebResponse)RequestCycle.get().getResponse());

		// The rules if and when to insert an xml decl in the response are a bit tricky. Allow the
		// user to replace the default per page and per application.
		renderXmlDecl();

		super.onRender();
	}","@Override
	protected void onRender()
	{
		// Configure the response such as headers etc.
		configureResponse((WebResponse)RequestCycle.get().getResponse());

		// The rules if and when to insert an xml decl in the response are a bit tricky. Allow the
		// user to replace the default per page and per application.
		renderXmlDecl();

		super.onRender();
	}",0,[0]
4754,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapCbrtToSelf() {
        for (int i = 0; i < data.length; i++) {
            data[i] = Math.cbrt(data[i]);
        }
        return this;
    }","public RealVector mapCbrtToSelf() {
        for (int i = 0; i < data.length; i++) {
            data[i] = Math.cbrt(data[i]);
        }
        return this;
    }",0,[0]
31294,bugs-dot-jar_CAMEL-8125_36e7b668,"public static <T> T lookup(CamelContext context, String name, Class<T> beanType) {
        return context.getRegistry().lookupByNameAndType(name, beanType);
    }","public static <T> T lookup(CamelContext context, String name, Class<T> beanType) {
        return context.getRegistry().lookupByNameAndType(name, beanType);
    }",0,[0]
19873,bugs-dot-jar_ACCUMULO-3229_891584fb,"public int start() throws IOException {
    if (configError)
      return 1;
    
    String input;
    if (isVerbose())
      printInfo();
    
    String home = System.getProperty(""HOME"");
    if (home == null)
      home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
      log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
      History history = new History();
      history.setHistoryFile(new File(historyPath));
      reader.setHistory(history);
    } catch (IOException e) {
      log.warn(""Unable to load history file at "" + historyPath);
    }
    
    ShellCompletor userCompletor = null;
    
    if (execFile != null) {
      java.util.Scanner scanner = new java.util.Scanner(new File(execFile), Constants.UTF8.name());
      try {
        while (scanner.hasNextLine() && !hasExited()) {
          execCommand(scanner.nextLine(), true, isVerbose());
        }
      } finally {
        scanner.close();
      }
    } else if (execCommand != null) {
      for (String command : execCommand.split(""\n"")) {
        execCommand(command, true, isVerbose());
      }
      return exitCode;
    }
    
    while (true) {
      if (hasExited())
        return exitCode;
      
      // If tab completion is true we need to reset
      if (tabCompletion) {
        if (userCompletor != null)
          reader.removeCompletor(userCompletor);
        
        userCompletor = setupCompletion();
        reader.addCompletor(userCompletor);
      }
      
      reader.setDefaultPrompt(getDefaultPrompt());
      input = reader.readLine();
      if (input == null) {
        reader.printNewline();
        return exitCode;
      } // user canceled
      
      execCommand(input, disableAuthTimeout, false);
    }
  }","public int start() throws IOException {
    if (configError)
      return 1;
    
    String input;
    if (isVerbose())
      printInfo();
    
    String home = System.getProperty(""HOME"");
    if (home == null)
      home = System.getenv(""HOME"");
    String configDir = home + ""/.accumulo"";
    String historyPath = configDir + ""/shell_history.txt"";
    File accumuloDir = new File(configDir);
    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
      log.warn(""Unable to make directory for history at "" + accumuloDir);
    try {
      History history = new History();
      history.setHistoryFile(new File(historyPath));
      reader.setHistory(history);
    } catch (IOException e) {
      log.warn(""Unable to load history file at "" + historyPath);
    }
    
    ShellCompletor userCompletor = null;
    
    if (execFile != null) {
      java.util.Scanner scanner = new java.util.Scanner(new File(execFile), Constants.UTF8.name());
      try {
        while (scanner.hasNextLine() && !hasExited()) {
          execCommand(scanner.nextLine(), true, isVerbose());
        }
      } finally {
        scanner.close();
      }
    } else if (execCommand != null) {
      for (String command : execCommand.split(""\n"")) {
        execCommand(command, true, isVerbose());
      }
      return exitCode;
    }
    
    while (true) {
      if (hasExited())
        return exitCode;
      
      // If tab completion is true we need to reset
      if (tabCompletion) {
        if (userCompletor != null)
          reader.removeCompletor(userCompletor);
        
        userCompletor = setupCompletion();
        reader.addCompletor(userCompletor);
      }
      
      reader.setDefaultPrompt(getDefaultPrompt());
      input = reader.readLine();
      if (input == null) {
        reader.printNewline();
        return exitCode;
      } // user canceled
      
      execCommand(input, disableAuthTimeout, false);
    }
  }",0,[0]
16968,bugs-dot-jar_WICKET-5728_3cc3fe95,"protected DequeueTagAction canDequeueTag(ComponentTag tag)
	{
		if (tag instanceof WicketTag)
		{
			WicketTag wicketTag = (WicketTag)tag;
			if (wicketTag.isContainerTag())
			{
				return DequeueTagAction.DEQUEUE;
			}
			else if (wicketTag.getAutoComponentFactory() != null)
			{
				return DequeueTagAction.DEQUEUE;
			}
			else if (wicketTag.isFragmentTag())
			{
				return DequeueTagAction.SKIP;
			}
			else if (wicketTag.isChildTag())
			{
				return DequeueTagAction.IGNORE;
			}
			else
			{
				return null; // don't know
			}
		}
		return DequeueTagAction.DEQUEUE;
	}","protected DequeueTagAction canDequeueTag(ComponentTag tag)
	{
		if (tag instanceof WicketTag)
		{
			WicketTag wicketTag = (WicketTag)tag;
			if (wicketTag.isContainerTag())
			{
				return DequeueTagAction.DEQUEUE;
			}
			else if (wicketTag.getAutoComponentFactory() != null)
			{
				return DequeueTagAction.DEQUEUE;
			}
			else if (wicketTag.isFragmentTag())
			{
				return DequeueTagAction.SKIP;
			}
			else if (wicketTag.isChildTag())
			{
				return DequeueTagAction.IGNORE;
			}
			else
			{
				return null; // don't know
			}
		}
		return DequeueTagAction.DEQUEUE;
	}",0,[0]
8299,bugs-dot-jar_MATH-934_724795b5,"public Complex sinh() {
        if (isNaN) {
            return NaN;
        }

        return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),
            FastMath.cosh(real) * FastMath.sin(imaginary));
    }","public Complex sinh() {
        if (isNaN) {
            return NaN;
        }

        return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),
            FastMath.cosh(real) * FastMath.sin(imaginary));
    }",0,[0]
38917,bugs-dot-jar_OAK-4358_74cbba24,"public static String getKeyUpperLimit(String path) {
        String to = PathUtils.concat(path, ""z"");
        to = getIdFromPath(to);
        to = to.substring(0, to.length() - 2) + ""0"";
        return to;
    }","public static String getKeyUpperLimit(String path) {
        String to = PathUtils.concat(path, ""z"");
        to = getIdFromPath(to);
        to = to.substring(0, to.length() - 2) + ""0"";
        return to;
    }",0,[0]
21575,bugs-dot-jar_FLINK-1471_d033fa8f,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <OUT,IN1,IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy,
			ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
		Validate.notNull(clazz);
		
		if (clazz.equals(Object.class)) {
			return new GenericTypeInfo<OUT>(clazz);
		}
		
		// check for arrays
		if (clazz.isArray()) {

			// primitive arrays: int[], byte[], ...
			PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);
			if (primitiveArrayInfo != null) {
				return primitiveArrayInfo;
			}
			
			// basic type arrays: String[], Integer[], Double[]
			BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);
			if (basicArrayInfo != null) {
				return basicArrayInfo;
			}
			
			// object arrays
			else {
				return ObjectArrayTypeInfo.getInfoFor(clazz);
			}
		}
		
		// check for writable types
		if(Writable.class.isAssignableFrom(clazz)) {
			return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);
		}
		
		// check for basic types
		TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);
		if (basicTypeInfo != null) {
			return basicTypeInfo;
		}
		
		// check for subclasses of Value
		if (Value.class.isAssignableFrom(clazz)) {
			Class<? extends Value> valueClass = clazz.asSubclass(Value.class);
			return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);
		}
		
		// check for subclasses of Tuple
		if (Tuple.class.isAssignableFrom(clazz)) {
			throw new InvalidTypesException(""Type information extraction for tuples cannot be done based on the class."");
		}

		// check for Enums
		if(Enum.class.isAssignableFrom(clazz)) {
			return (TypeInformation<OUT>) new EnumTypeInfo(clazz);
		}

		if (alreadySeen.contains(clazz)) {
			return new GenericTypeInfo<OUT>(clazz);
		}

		alreadySeen.add(clazz);

		if (Modifier.isInterface(clazz.getModifiers())) {
			// Interface has no members and is therefore not handled as POJO
			return new GenericTypeInfo<OUT>(clazz);
		}

		if (clazz.equals(Class.class)) {
			// special case handling for Class, this should not be handled by the POJO logic
			return new GenericTypeInfo<OUT>(clazz);
		}

		try {
			TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);
			if (pojoType != null) {
				return pojoType;
			}
		} catch (InvalidTypesException e) {
			if(LOG.isDebugEnabled()) {
				LOG.debug(""Unable to handle type ""+clazz+"" as POJO. Message: ""+e.getMessage(), e);
			}
			// ignore and create generic type info
		}

		// return a generic type
		return new GenericTypeInfo<OUT>(clazz);
	}","@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <OUT,IN1,IN2> TypeInformation<OUT> privateGetForClass(Class<OUT> clazz, ArrayList<Type> typeHierarchy,
			ParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
		Validate.notNull(clazz);
		
		if (clazz.equals(Object.class)) {
			return new GenericTypeInfo<OUT>(clazz);
		}
		
		// check for arrays
		if (clazz.isArray()) {

			// primitive arrays: int[], byte[], ...
			PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = PrimitiveArrayTypeInfo.getInfoFor(clazz);
			if (primitiveArrayInfo != null) {
				return primitiveArrayInfo;
			}
			
			// basic type arrays: String[], Integer[], Double[]
			BasicArrayTypeInfo<OUT, ?> basicArrayInfo = BasicArrayTypeInfo.getInfoFor(clazz);
			if (basicArrayInfo != null) {
				return basicArrayInfo;
			}
			
			// object arrays
			else {
				return ObjectArrayTypeInfo.getInfoFor(clazz);
			}
		}
		
		// check for writable types
		if(Writable.class.isAssignableFrom(clazz)) {
			return (TypeInformation<OUT>) WritableTypeInfo.getWritableTypeInfo((Class<? extends Writable>) clazz);
		}
		
		// check for basic types
		TypeInformation<OUT> basicTypeInfo = BasicTypeInfo.getInfoFor(clazz);
		if (basicTypeInfo != null) {
			return basicTypeInfo;
		}
		
		// check for subclasses of Value
		if (Value.class.isAssignableFrom(clazz)) {
			Class<? extends Value> valueClass = clazz.asSubclass(Value.class);
			return (TypeInformation<OUT>) ValueTypeInfo.getValueTypeInfo(valueClass);
		}
		
		// check for subclasses of Tuple
		if (Tuple.class.isAssignableFrom(clazz)) {
			throw new InvalidTypesException(""Type information extraction for tuples cannot be done based on the class."");
		}

		// check for Enums
		if(Enum.class.isAssignableFrom(clazz)) {
			return (TypeInformation<OUT>) new EnumTypeInfo(clazz);
		}

		if (alreadySeen.contains(clazz)) {
			return new GenericTypeInfo<OUT>(clazz);
		}

		alreadySeen.add(clazz);

		if (Modifier.isInterface(clazz.getModifiers())) {
			// Interface has no members and is therefore not handled as POJO
			return new GenericTypeInfo<OUT>(clazz);
		}

		if (clazz.equals(Class.class)) {
			// special case handling for Class, this should not be handled by the POJO logic
			return new GenericTypeInfo<OUT>(clazz);
		}

		try {
			TypeInformation<OUT> pojoType = analyzePojo(clazz, new ArrayList<Type>(typeHierarchy), parameterizedType, in1Type, in2Type);
			if (pojoType != null) {
				return pojoType;
			}
		} catch (InvalidTypesException e) {
			if(LOG.isDebugEnabled()) {
				LOG.debug(""Unable to handle type ""+clazz+"" as POJO. Message: ""+e.getMessage(), e);
			}
			// ignore and create generic type info
		}

		// return a generic type
		return new GenericTypeInfo<OUT>(clazz);
	}",0,[0]
30554,bugs-dot-jar_CAMEL-7795_19b2aa31,"@Override
    public void endTransactedBy(Object key) {
        MDC.remove(MDC_TRANSACTION_KEY);
        super.endTransactedBy(key);
    }","@Override
    public void endTransactedBy(Object key) {
        MDC.remove(MDC_TRANSACTION_KEY);
        super.endTransactedBy(key);
    }",0,[0]
31389,bugs-dot-jar_CAMEL-9340_1cab39f6,"public static IdempotentRepository<String> fileIdempotentRepository(File fileStore, int cacheSize, long maxFileStoreSize) {
        FileIdempotentRepository repository = new FileIdempotentRepository(fileStore, new LRUCache<String, Object>(cacheSize));
        repository.setMaxFileStoreSize(maxFileStoreSize);
        return repository;
    }","public static IdempotentRepository<String> fileIdempotentRepository(File fileStore, int cacheSize, long maxFileStoreSize) {
        FileIdempotentRepository repository = new FileIdempotentRepository(fileStore, new LRUCache<String, Object>(cacheSize));
        repository.setMaxFileStoreSize(maxFileStoreSize);
        return repository;
    }",0,[0]
1657,bugs-dot-jar_OAK-1297_73cc2442,"@Override
    public boolean isNew() {
        return exists() && !getBaseState().exists();
    }","@Override
    public boolean isNew() {
        return exists() && !getBaseState().exists();
    }",0,[0]
14322,bugs-dot-jar_LOG4J2-260_9d817953,"List<String> getThrowableString(final Throwable throwable) {
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        try {
            throwable.printStackTrace(pw);
        } catch (final RuntimeException ex) {
            // Ignore any exceptions.
        }
        pw.flush();
        final LineNumberReader reader = new LineNumberReader(new StringReader(sw.toString()));
        final ArrayList<String> lines = new ArrayList<String>();
        try {
          String line = reader.readLine();
          while (line != null) {
            lines.add(line);
            line = reader.readLine();
          }
        } catch (final IOException ex) {
            if (ex instanceof InterruptedIOException) {
                Thread.currentThread().interrupt();
            }
            lines.add(ex.toString());
        }
        return lines;
    }","List<String> getThrowableString(final Throwable throwable) {
        final StringWriter sw = new StringWriter();
        final PrintWriter pw = new PrintWriter(sw);
        try {
            throwable.printStackTrace(pw);
        } catch (final RuntimeException ex) {
            // Ignore any exceptions.
        }
        pw.flush();
        final LineNumberReader reader = new LineNumberReader(new StringReader(sw.toString()));
        final ArrayList<String> lines = new ArrayList<String>();
        try {
          String line = reader.readLine();
          while (line != null) {
            lines.add(line);
            line = reader.readLine();
          }
        } catch (final IOException ex) {
            if (ex instanceof InterruptedIOException) {
                Thread.currentThread().interrupt();
            }
            lines.add(ex.toString());
        }
        return lines;
    }",0,[0]
6198,bugs-dot-jar_OAK-510_f63d745a,"void checkAlive() throws RepositoryException {
        sessionDelegate.checkAlive();
        dlg.checkNotStale();
    }","void checkAlive() throws RepositoryException {
        sessionDelegate.checkAlive();
        dlg.checkNotStale();
    }",0,[0]
2011,bugs-dot-jar_WICKET-2961_3d8c9d75,"public final void beforeRender()
	{
		if (!(this instanceof IFeedback))
		{
			internalBeforeRender();
		}
		else
		{
			// this component is a feedback. Feedback must be initialized last, so that
			// they can collect messages from other components
			List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);
			if (feedbacks == null)
			{
				feedbacks = new ArrayList<Component>();
				getRequestCycle().setMetaData(FEEDBACK_LIST, feedbacks);
			}
			feedbacks.add(this);
		}
	}","public final void beforeRender()
	{
		if (!(this instanceof IFeedback))
		{
			internalBeforeRender();
		}
		else
		{
			// this component is a feedback. Feedback must be initialized last, so that
			// they can collect messages from other components
			List<Component> feedbacks = getRequestCycle().getMetaData(FEEDBACK_LIST);
			if (feedbacks == null)
			{
				feedbacks = new ArrayList<Component>();
				getRequestCycle().setMetaData(FEEDBACK_LIST, feedbacks);
			}
			feedbacks.add(this);
		}
	}",0,[0]
4339,bugs-dot-jar_CAMEL-4682_1e54865c,"protected boolean shouldStartRoutes() {
        return isStarted() && !isStarting();
    }","protected boolean shouldStartRoutes() {
        return isStarted() && !isStarting();
    }",0,[0]
40,bugs-dot-jar_OAK-1822_3e83a4c1,"@Nonnull
    NavigableMap<Revision, Range> getPreviousRanges() {
        if (previous == null) {
            Map<Revision, String> map = getLocalMap(PREVIOUS);
            if (map.isEmpty()) {
                previous = EMPTY_RANGE_MAP;
            } else {
                NavigableMap<Revision, Range> transformed = new TreeMap<Revision, Range>(
                        StableRevisionComparator.REVERSE);
                for (Map.Entry<Revision, String> entry : map.entrySet()) {
                    Range r = Range.fromEntry(entry.getKey(), entry.getValue());
                    transformed.put(r.high, r);
                }
                previous = Maps.unmodifiableNavigableMap(transformed);
            }
        }
        return previous;
    }","@Nonnull
    NavigableMap<Revision, Range> getPreviousRanges() {
        if (previous == null) {
            Map<Revision, String> map = getLocalMap(PREVIOUS);
            if (map.isEmpty()) {
                previous = EMPTY_RANGE_MAP;
            } else {
                NavigableMap<Revision, Range> transformed = new TreeMap<Revision, Range>(
                        StableRevisionComparator.REVERSE);
                for (Map.Entry<Revision, String> entry : map.entrySet()) {
                    Range r = Range.fromEntry(entry.getKey(), entry.getValue());
                    transformed.put(r.high, r);
                }
                previous = Maps.unmodifiableNavigableMap(transformed);
            }
        }
        return previous;
    }",0,[0]
11239,bugs-dot-jar_CAMEL-7130_cc192f87,"public XsltBuilder outputBytes() {
        setResultHandlerFactory(new StreamResultHandlerFactory());
        return this;
    }","public XsltBuilder outputBytes() {
        setResultHandlerFactory(new StreamResultHandlerFactory());
        return this;
    }",0,[0]
4845,bugs-dot-jar_MATH-326_ce185345,"private double getLInfDistance(OpenMapRealVector v) {
        double max = 0;
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));
            if (delta > max) {
                max = delta;
            }
        }
        iter = v.getEntries().iterator();
        while (iter.hasNext()) {
            iter.advance();
            int key = iter.key();
            if (!entries.containsKey(key)) {
                if (iter.value() > max) {
                    max = iter.value();
                }
            }
        }
        return max;
    }","private double getLInfDistance(OpenMapRealVector v) {
        double max = 0;
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));
            if (delta > max) {
                max = delta;
            }
        }
        iter = v.getEntries().iterator();
        while (iter.hasNext()) {
            iter.advance();
            int key = iter.key();
            if (!entries.containsKey(key)) {
                if (iter.value() > max) {
                    max = iter.value();
                }
            }
        }
        return max;
    }",0,[0]
27016,bugs-dot-jar_LOG4J2-793_73400bfb,"@Override
    public void error(final String format, final Object arg1, final Object arg2) {
        logger.logIfEnabled(FQCN, Level.ERROR, null, format, arg1, arg2);
    }","@Override
    public void error(final String format, final Object arg1, final Object arg2) {
        logger.logIfEnabled(FQCN, Level.ERROR, null, format, arg1, arg2);
    }",0,[0]
1101,bugs-dot-jar_WICKET-5546_f1af9e03,"final void internalOnRemove()
	{
		setFlag(FLAG_REMOVING_FROM_HIERARCHY, true);
		onRemove();
		if (getFlag(FLAG_REMOVING_FROM_HIERARCHY))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly removed from hierachy. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onRemove() in the override of onRemove() method"");
		}
		new Behaviors(this).onRemove(this);
		removeChildren();
	}","final void internalOnRemove()
	{
		setFlag(FLAG_REMOVING_FROM_HIERARCHY, true);
		onRemove();
		if (getFlag(FLAG_REMOVING_FROM_HIERARCHY))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly removed from hierachy. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onRemove() in the override of onRemove() method"");
		}
		new Behaviors(this).onRemove(this);
		removeChildren();
	}",0,[0]
40425,bugs-dot-jar_WICKET-442_246d53c5,"public void replaceWith(Component replacement)
	{
		if (replacement == null)
		{
			throw new IllegalArgumentException(""Argument [[replacement]] cannot be null."");
		}
		if (!getId().equals(replacement.getId()))
		{
			throw new IllegalArgumentException(
					""Replacement component must have the same id as the component it will replace. Replacement id [[""
							+ replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null)
		{
			throw new IllegalStateException(
					""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
	}","public void replaceWith(Component replacement)
	{
		if (replacement == null)
		{
			throw new IllegalArgumentException(""Argument [[replacement]] cannot be null."");
		}
		if (!getId().equals(replacement.getId()))
		{
			throw new IllegalArgumentException(
					""Replacement component must have the same id as the component it will replace. Replacement id [[""
							+ replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null)
		{
			throw new IllegalStateException(
					""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
	}",0,[0]
6870,bugs-dot-jar_OAK-2062_5c4589bd,"public Iterable<String> getWildcardColumns() {
        return nodeType.getNames(REP_NAMED_SINGLE_VALUED_PROPERTIES);
    }","public Iterable<String> getWildcardColumns() {
        return nodeType.getNames(REP_NAMED_SINGLE_VALUED_PROPERTIES);
    }",0,[0]
24500,bugs-dot-jar_OAK-4420_d645112f,"@Override
    public String toString() {
        return String.format(""SegmentTarNodeStore[%s]"", dir);
    }","@Override
    public String toString() {
        return String.format(""SegmentTarNodeStore[%s]"", dir);
    }",0,[0]
2282,bugs-dot-jar_MNG-4918_691a03a7,"public Artifact getParentArtifact()
    {
        if ( parentArtifact == null && model.getParent() != null )
        {
            Parent p = model.getParent();
            parentArtifact = repositorySystem.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p.getVersion() );
        }
        return parentArtifact;
    }","public Artifact getParentArtifact()
    {
        if ( parentArtifact == null && model.getParent() != null )
        {
            Parent p = model.getParent();
            parentArtifact = repositorySystem.createProjectArtifact( p.getGroupId(), p.getArtifactId(), p.getVersion() );
        }
        return parentArtifact;
    }",0,[0]
15515,bugs-dot-jar_WICKET-3428_ffc0cae9,"public Url mapUrlFor(IRequestHandler handler)
	{
		return requestMapper.mapHandler(handler);
	}","public Url mapUrlFor(IRequestHandler handler)
	{
		return requestMapper.mapHandler(handler);
	}",0,[0]
3213,bugs-dot-jar_WICKET-3767_84c3baac,"public boolean processChildren()
	{
		return true;
	}","public boolean processChildren()
	{
		return true;
	}",0,[0]
7247,bugs-dot-jar_WICKET-5881_8c83c5c5,"@Override
	protected void onComponentTag(final ComponentTag tag)
	{
		tag.put(""name"", getInputName());

		if (!isEnabledInHierarchy())
		{
			onDisabled(tag);
		}

		if (isRequired())
		{
			onRequired(tag);
		}

		super.onComponentTag(tag);
	}","@Override
	protected void onComponentTag(final ComponentTag tag)
	{
		tag.put(""name"", getInputName());

		if (!isEnabledInHierarchy())
		{
			onDisabled(tag);
		}

		if (isRequired())
		{
			onRequired(tag);
		}

		super.onComponentTag(tag);
	}",0,[0]
12400,bugs-dot-jar_MATH-1088_63d88c74,"public int getSize() {
        return totalSize;
    }","public int getSize() {
        return totalSize;
    }",0,[0]
1248,Bears-156,"@Override
    public boolean supportsEntityJoin() {
        return false;
    }","@Override
    public boolean supportsEntityJoin() {
        return false;
    }",0,[0]
38409,bugs-dot-jar_OAK-1244_b4a93c81,"private void collectUUIDs(Tree tree) {
        if(tree == null){
            return;
        }

        String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);
        if(uuid != null){
            uuids.add(uuid);
        }

        for(Tree child : tree.getChildren()){
            collectUUIDs(child);
        }
    }","private void collectUUIDs(Tree tree) {
        if(tree == null){
            return;
        }

        String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);
        if(uuid != null){
            uuids.add(uuid);
        }

        for(Tree child : tree.getChildren()){
            collectUUIDs(child);
        }
    }",0,[0]
15402,bugs-dot-jar_FLINK-2484_d738430c,"private void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws IOException {
		final long barrierId = receivedBarrier.getId();

		if (numReceivedBarriers > 0) {
			// subsequent barrier of a checkpoint.
			if (barrierId == currentCheckpointId) {
				// regular case
				onBarrier(channelIndex);
			}
			else if (barrierId > currentCheckpointId) {
				// we did not complete the current checkpoint
				LOG.warn(""Received checkpoint barrier for checkpoint {} before completing current checkpoint {}. "" +
						""Skipping current checkpoint."", barrierId, currentCheckpointId);

				releaseBlocks();
				currentCheckpointId = barrierId;
				onBarrier(channelIndex);
			}
			else {
				// ignore trailing barrier from aborted checkpoint
				return;
			}
			
		}
		else if (barrierId > currentCheckpointId) {
			// first barrier of a new checkpoint
			currentCheckpointId = barrierId;
			onBarrier(channelIndex);
		}
		else {
			// trailing barrier from previous (skipped) checkpoint
			return;
		}

		// check if we have all barriers
		if (numReceivedBarriers == totalNumberOfInputChannels) {
			if (LOG.isDebugEnabled()) {
				LOG.debug(""Received all barrier, triggering checkpoint {} at {}"",
						receivedBarrier.getId(), receivedBarrier.getTimestamp());
			}

			if (checkpointHandler != null) {
				checkpointHandler.onEvent(receivedBarrier);
			}
			
			releaseBlocks();
		}
	}","private void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws IOException {
		final long barrierId = receivedBarrier.getId();

		if (numReceivedBarriers > 0) {
			// subsequent barrier of a checkpoint.
			if (barrierId == currentCheckpointId) {
				// regular case
				onBarrier(channelIndex);
			}
			else if (barrierId > currentCheckpointId) {
				// we did not complete the current checkpoint
				LOG.warn(""Received checkpoint barrier for checkpoint {} before completing current checkpoint {}. "" +
						""Skipping current checkpoint."", barrierId, currentCheckpointId);

				releaseBlocks();
				currentCheckpointId = barrierId;
				onBarrier(channelIndex);
			}
			else {
				// ignore trailing barrier from aborted checkpoint
				return;
			}
			
		}
		else if (barrierId > currentCheckpointId) {
			// first barrier of a new checkpoint
			currentCheckpointId = barrierId;
			onBarrier(channelIndex);
		}
		else {
			// trailing barrier from previous (skipped) checkpoint
			return;
		}

		// check if we have all barriers
		if (numReceivedBarriers == totalNumberOfInputChannels) {
			if (LOG.isDebugEnabled()) {
				LOG.debug(""Received all barrier, triggering checkpoint {} at {}"",
						receivedBarrier.getId(), receivedBarrier.getTimestamp());
			}

			if (checkpointHandler != null) {
				checkpointHandler.onEvent(receivedBarrier);
			}
			
			releaseBlocks();
		}
	}",0,[0]
10287,bugs-dot-jar_OAK-3897_94c6c575,"private void cleanCollisions() {
        String id = Utils.getIdFromPath(""/"");
        NodeDocument root = store.find(NODES, id);
        if (root == null) {
            return;
        }
        RevisionVector head = getHeadRevision();
        Map<Revision, String> map = root.getLocalMap(NodeDocument.COLLISIONS);
        UpdateOp op = new UpdateOp(id, false);
        for (Revision r : map.keySet()) {
            if (r.getClusterId() == clusterId) {
                // remove collision if there is no active branch with
                // this revision and the revision is before the current
                // head. That is, the collision cannot be related to commit
                // which is progress.
                if (branches.getBranchCommit(r) == null 
                        && !head.isRevisionNewer(r)) {
                    NodeDocument.removeCollision(op, r);
                }
            }
        }
        if (op.hasChanges()) {
            LOG.debug(""Removing collisions {}"", op.getChanges().keySet());
            store.findAndUpdate(NODES, op);
        }
    }","private void cleanCollisions() {
        String id = Utils.getIdFromPath(""/"");
        NodeDocument root = store.find(NODES, id);
        if (root == null) {
            return;
        }
        RevisionVector head = getHeadRevision();
        Map<Revision, String> map = root.getLocalMap(NodeDocument.COLLISIONS);
        UpdateOp op = new UpdateOp(id, false);
        for (Revision r : map.keySet()) {
            if (r.getClusterId() == clusterId) {
                // remove collision if there is no active branch with
                // this revision and the revision is before the current
                // head. That is, the collision cannot be related to commit
                // which is progress.
                if (branches.getBranchCommit(r) == null 
                        && !head.isRevisionNewer(r)) {
                    NodeDocument.removeCollision(op, r);
                }
            }
        }
        if (op.hasChanges()) {
            LOG.debug(""Removing collisions {}"", op.getChanges().keySet());
            store.findAndUpdate(NODES, op);
        }
    }",0,[0]
22433,bugs-dot-jar_CAMEL-6447_020c451a,"@Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""choice{"");
        boolean first = true;
        for (Processor processor : filters) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(""when "");
            builder.append(processor);
        }
        if (otherwise != null) {
            builder.append("", otherwise: "");
            builder.append(otherwise);
        }
        builder.append(""}"");
        return builder.toString();
    }","@Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""choice{"");
        boolean first = true;
        for (Processor processor : filters) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(""when "");
            builder.append(processor);
        }
        if (otherwise != null) {
            builder.append("", otherwise: "");
            builder.append(otherwise);
        }
        builder.append(""}"");
        return builder.toString();
    }",0,[0]
2876,bugs-dot-jar_OAK-1364_05c89637,"@Override
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            put(e.getKey(), e.getValue());
        }
    }","@Override
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            put(e.getKey(), e.getValue());
        }
    }",0,[0]
3280,bugs-dot-jar_CAMEL-5699_6d63a502,"public boolean isShowFiles() {
        return showFiles;
    }","public boolean isShowFiles() {
        return showFiles;
    }",0,[0]
28813,bugs-dot-jar_WICKET-3719_5ad32df9,"public final int size()
	{
		return markupElements.size();
	}","public final int size()
	{
		return markupElements.size();
	}",0,[0]
8258,bugs-dot-jar_CAMEL-3727_ff2713d1,"public ExecutorService getExecutorService() {
        return executorService;
    }","public ExecutorService getExecutorService() {
        return executorService;
    }",0,[0]
1427,bugs-dot-jar_OAK-185_7fe28a0e,"@Override
    @Nonnull
    public Property setProperty(String name, boolean value) throws RepositoryException {
        return setProperty(name, getValueFactory().createValue(value), PropertyType.BOOLEAN);
    }","@Override
    @Nonnull
    public Property setProperty(String name, boolean value) throws RepositoryException {
        return setProperty(name, getValueFactory().createValue(value), PropertyType.BOOLEAN);
    }",0,[0]
2245,bugs-dot-jar_MNG-4918_691a03a7,"public String getDescription()
    {
        return getModel().getDescription();
    }","public String getDescription()
    {
        return getModel().getDescription();
    }",0,[0]
1169,Bears-152,"public Boolean isRegister() {
        return register;
    }","public Boolean isRegister() {
        return register;
    }",0,[0]
5165,bugs-dot-jar_ACCUMULO-3006_d6472040,"protected VolumeManagerImpl(Map<String,Volume> volumes, Volume defaultVolume, AccumuloConfiguration conf) {
    this.volumesByName = volumes;
    this.defaultVolume = defaultVolume;
    // We may have multiple directories used in a single FileSystem (e.g. testing)
    this.volumesByFileSystemUri = HashMultimap.create();
    invertVolumesByFileSystem(volumesByName, volumesByFileSystemUri);
    this.conf = conf;
    ensureSyncIsEnabled();
    chooser = Property.createInstanceFromPropertyName(conf, Property.GENERAL_VOLUME_CHOOSER, VolumeChooser.class, new RandomVolumeChooser());
  }","protected VolumeManagerImpl(Map<String,Volume> volumes, Volume defaultVolume, AccumuloConfiguration conf) {
    this.volumesByName = volumes;
    this.defaultVolume = defaultVolume;
    // We may have multiple directories used in a single FileSystem (e.g. testing)
    this.volumesByFileSystemUri = HashMultimap.create();
    invertVolumesByFileSystem(volumesByName, volumesByFileSystemUri);
    this.conf = conf;
    ensureSyncIsEnabled();
    chooser = Property.createInstanceFromPropertyName(conf, Property.GENERAL_VOLUME_CHOOSER, VolumeChooser.class, new RandomVolumeChooser());
  }",0,[0]
145,bugs-dot-jar_WICKET-2065_9da430fb,"public AbstractRequestTargetUrlCodingStrategy(final String mountPath)
	{
		if (mountPath == null)
		{
			throw new IllegalArgumentException(""Mount path cannot be null or empty"");
		}
		this.mountPath = mountPath.startsWith(""/"") ? mountPath.substring(1) : mountPath;
		if (this.mountPath.startsWith(""resources/"") || this.mountPath.equals(""resources""))
		{
			throw new IllegalArgumentException(""Mount path cannot be under '/resources'"");
		}
	}","public AbstractRequestTargetUrlCodingStrategy(final String mountPath)
	{
		if (mountPath == null)
		{
			throw new IllegalArgumentException(""Mount path cannot be null or empty"");
		}
		this.mountPath = mountPath.startsWith(""/"") ? mountPath.substring(1) : mountPath;
		if (this.mountPath.startsWith(""resources/"") || this.mountPath.equals(""resources""))
		{
			throw new IllegalArgumentException(""Mount path cannot be under '/resources'"");
		}
	}",0,[0]
31600,bugs-dot-jar_OAK-3433_b76b31f7,"@Nonnull
    public Collection<String> getPaths() {
        return map.keySet();
    }","@Nonnull
    public Collection<String> getPaths() {
        return map.keySet();
    }",0,[0]
1204,bugs-dot-jar_WICKET-5546_f1af9e03,"public String toString(final boolean detailed)
	{
		try
		{
			final StringBuilder buffer = new StringBuilder();
			buffer.append(""[Component id = "").append(getId());

			if (detailed)
			{
				final Page page = findPage();
				if (page == null)
				{
					buffer.append("", page = <No Page>, path = "")
						.append(getPath())
						.append('.')
						.append(Classes.simpleName(getClass()));
				}
				else
				{
					buffer.append("", page = "")
						.append(getPage().getPageClass().getName())
						.append("", path = "")
						.append(getPath())
						.append('.')
						.append(Classes.simpleName(getClass()))
						.append("", isVisible = "")
						.append((determineVisibility()))
						.append("", isVersioned = "")
						.append(isVersioned());
				}

				if (markup != null)
				{
					buffer.append("", markup = "").append(new MarkupStream(getMarkup()).toString());
				}
			}

			buffer.append(']');

			return buffer.toString();
		}
		catch (Exception e)
		{
			log.warn(""Error while building toString()"", e);
			return String.format(
				""[Component id = %s <attributes are not available because exception %s was thrown during toString()>]"",
				getId(), e.getClass().getName());
		}
	}","public String toString(final boolean detailed)
	{
		try
		{
			final StringBuilder buffer = new StringBuilder();
			buffer.append(""[Component id = "").append(getId());

			if (detailed)
			{
				final Page page = findPage();
				if (page == null)
				{
					buffer.append("", page = <No Page>, path = "")
						.append(getPath())
						.append('.')
						.append(Classes.simpleName(getClass()));
				}
				else
				{
					buffer.append("", page = "")
						.append(getPage().getPageClass().getName())
						.append("", path = "")
						.append(getPath())
						.append('.')
						.append(Classes.simpleName(getClass()))
						.append("", isVisible = "")
						.append((determineVisibility()))
						.append("", isVersioned = "")
						.append(isVersioned());
				}

				if (markup != null)
				{
					buffer.append("", markup = "").append(new MarkupStream(getMarkup()).toString());
				}
			}

			buffer.append(']');

			return buffer.toString();
		}
		catch (Exception e)
		{
			log.warn(""Error while building toString()"", e);
			return String.format(
				""[Component id = %s <attributes are not available because exception %s was thrown during toString()>]"",
				getId(), e.getClass().getName());
		}
	}",0,[0]
13762,bugs-dot-jar_CAMEL-6936_4954d573,"public Processor getCustomProcessor() {
        return customProcessor;
    }","public Processor getCustomProcessor() {
        return customProcessor;
    }",0,[0]
10866,bugs-dot-jar_CAMEL-3757_c1b2f2f8,"public InterceptSendToEndpoint(final Endpoint destination, boolean skip) {
        this.delegate = destination;
        this.skip = skip;
    }","public InterceptSendToEndpoint(final Endpoint destination, boolean skip) {
        this.delegate = destination;
        this.skip = skip;
    }",0,[0]
9794,bugs-dot-jar_OAK-3634_90ad50da,"@SuppressWarnings(""unchecked"")
    @CheckForNull
    private <T extends Document> T findAndModify(Collection<T> collection,
                                                 UpdateOp updateOp,
                                                 boolean upsert,
                                                 boolean checkConditions) {
        DBCollection dbCollection = getDBCollection(collection);
        // make sure we don't modify the original updateOp
        updateOp = updateOp.copy();
        DBObject update = createUpdate(updateOp);

        Lock lock = null;
        if (collection == Collection.NODES) {
            lock = nodeLocks.acquire(updateOp.getId());
        }
        final long start = PERFLOG.start();
        try {
            // get modCount of cached document
            Number modCount = null;
            T cachedDoc = null;
            if (collection == Collection.NODES) {
                cachedDoc = (T) nodesCache.getIfPresent(updateOp.getId());
                if (cachedDoc != null) {
                    modCount = cachedDoc.getModCount();
                }
            }

            // perform a conditional update with limited result
            // if we have a matching modCount
            if (modCount != null) {

                QueryBuilder query = createQueryForUpdate(updateOp.getId(),
                        updateOp.getConditions());
                query.and(Document.MOD_COUNT).is(modCount);

                WriteResult result = dbCollection.update(query.get(), update);
                if (result.getN() > 0) {
                    // success, update cached document
                    if (collection == Collection.NODES) {
                        NodeDocument newDoc = (NodeDocument) applyChanges(collection, cachedDoc, updateOp);
                        nodesCache.put(newDoc);
                    }
                    // return previously cached document
                    return cachedDoc;
                }
            }

            // conditional update failed or not possible
            // perform operation and get complete document
            QueryBuilder query = createQueryForUpdate(updateOp.getId(), updateOp.getConditions());
            DBObject oldNode = dbCollection.findAndModify(query.get(), null, null /*sort*/, false /*remove*/, update, false /*returnNew*/, upsert);
            if (checkConditions && oldNode == null) {
                return null;
            }
            T oldDoc = convertFromDBObject(collection, oldNode);
            if (oldDoc != null) {
                if (collection == Collection.NODES) {
                    NodeDocument newDoc = (NodeDocument) applyChanges(collection, oldDoc, updateOp);
                    nodesCache.put(newDoc);
                }
                oldDoc.seal();
            } else if (upsert) {
                if (collection == Collection.NODES) {
                    NodeDocument doc = (NodeDocument) collection.newDocument(this);
                    UpdateUtils.applyChanges(doc, updateOp);
                    nodesCache.putIfAbsent(doc);
                }
            } else {
                // updateOp without conditions and not an upsert
                // this means the document does not exist
            }
            return oldDoc;
        } catch (Exception e) {
            throw DocumentStoreException.convert(e);
        } finally {
            if (lock != null) {
                lock.unlock();
            }
            PERFLOG.end(start, 1, ""findAndModify [{}]"", updateOp.getId());
        }
    }","@SuppressWarnings(""unchecked"")
    @CheckForNull
    private <T extends Document> T findAndModify(Collection<T> collection,
                                                 UpdateOp updateOp,
                                                 boolean upsert,
                                                 boolean checkConditions) {
        DBCollection dbCollection = getDBCollection(collection);
        // make sure we don't modify the original updateOp
        updateOp = updateOp.copy();
        DBObject update = createUpdate(updateOp);

        Lock lock = null;
        if (collection == Collection.NODES) {
            lock = nodeLocks.acquire(updateOp.getId());
        }
        final long start = PERFLOG.start();
        try {
            // get modCount of cached document
            Number modCount = null;
            T cachedDoc = null;
            if (collection == Collection.NODES) {
                cachedDoc = (T) nodesCache.getIfPresent(updateOp.getId());
                if (cachedDoc != null) {
                    modCount = cachedDoc.getModCount();
                }
            }

            // perform a conditional update with limited result
            // if we have a matching modCount
            if (modCount != null) {

                QueryBuilder query = createQueryForUpdate(updateOp.getId(),
                        updateOp.getConditions());
                query.and(Document.MOD_COUNT).is(modCount);

                WriteResult result = dbCollection.update(query.get(), update);
                if (result.getN() > 0) {
                    // success, update cached document
                    if (collection == Collection.NODES) {
                        NodeDocument newDoc = (NodeDocument) applyChanges(collection, cachedDoc, updateOp);
                        nodesCache.put(newDoc);
                    }
                    // return previously cached document
                    return cachedDoc;
                }
            }

            // conditional update failed or not possible
            // perform operation and get complete document
            QueryBuilder query = createQueryForUpdate(updateOp.getId(), updateOp.getConditions());
            DBObject oldNode = dbCollection.findAndModify(query.get(), null, null /*sort*/, false /*remove*/, update, false /*returnNew*/, upsert);
            if (checkConditions && oldNode == null) {
                return null;
            }
            T oldDoc = convertFromDBObject(collection, oldNode);
            if (oldDoc != null) {
                if (collection == Collection.NODES) {
                    NodeDocument newDoc = (NodeDocument) applyChanges(collection, oldDoc, updateOp);
                    nodesCache.put(newDoc);
                }
                oldDoc.seal();
            } else if (upsert) {
                if (collection == Collection.NODES) {
                    NodeDocument doc = (NodeDocument) collection.newDocument(this);
                    UpdateUtils.applyChanges(doc, updateOp);
                    nodesCache.putIfAbsent(doc);
                }
            } else {
                // updateOp without conditions and not an upsert
                // this means the document does not exist
            }
            return oldDoc;
        } catch (Exception e) {
            throw DocumentStoreException.convert(e);
        } finally {
            if (lock != null) {
                lock.unlock();
            }
            PERFLOG.end(start, 1, ""findAndModify [{}]"", updateOp.getId());
        }
    }",0,[0]
15220,bugs-dot-jar_WICKET-4070_d450acb0,"public final CharSequence getJsForInterfaceUrl(CharSequence url)
	{
		/*
		 * since the passed in url is handled when the current url is form's action url and not the
		 * current request's url we rerender the passed in url to be relative to the form's action
		 * url
		 */
		UrlRenderer renderer = getRequestCycle().getUrlRenderer();
		Url oldBase = renderer.getBaseUrl();
		try
		{
			Url action = Url.parse(getActionUrl().toString());
			renderer.setBaseUrl(action);
			url = renderer.renderUrl(Url.parse(url.toString()));
		}
		finally
		{
			renderer.setBaseUrl(oldBase);
		}

		Form<?> root = getRootForm();
		return new AppendingStringBuffer(""document.getElementById('"").append(
			root.getHiddenFieldId())
			.append(""').value='"")
			.append(url)
			.append(""';document.getElementById('"")
			.append(root.getMarkupId())
			.append(""').submit();"");
	}","public final CharSequence getJsForInterfaceUrl(CharSequence url)
	{
		/*
		 * since the passed in url is handled when the current url is form's action url and not the
		 * current request's url we rerender the passed in url to be relative to the form's action
		 * url
		 */
		UrlRenderer renderer = getRequestCycle().getUrlRenderer();
		Url oldBase = renderer.getBaseUrl();
		try
		{
			Url action = Url.parse(getActionUrl().toString());
			renderer.setBaseUrl(action);
			url = renderer.renderUrl(Url.parse(url.toString()));
		}
		finally
		{
			renderer.setBaseUrl(oldBase);
		}

		Form<?> root = getRootForm();
		return new AppendingStringBuffer(""document.getElementById('"").append(
			root.getHiddenFieldId())
			.append(""').value='"")
			.append(url)
			.append(""';document.getElementById('"")
			.append(root.getMarkupId())
			.append(""').submit();"");
	}",0,[0]
12874,bugs-dot-jar_MNG-2221_cc859f5c,"private static void mergePluginExecutionDefinitions( PluginExecution child, PluginExecution parent )
    {
        if ( child.getPhase() == null )
        {
            child.setPhase( parent.getPhase() );
        }

        List parentGoals = parent.getGoals();
        List childGoals = child.getGoals();

        List goals = new ArrayList();

        if ( childGoals != null && !childGoals.isEmpty() )
        {
            goals.addAll( childGoals );
        }

        if ( parentGoals != null )
        {
            for ( Iterator goalIterator = parentGoals.iterator(); goalIterator.hasNext(); )
            {
                String goal = (String) goalIterator.next();

                if ( !goals.contains( goal ) )
                {
                    goals.add( goal );
                }
            }
        }

        child.setGoals( goals );

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );
    }","private static void mergePluginExecutionDefinitions( PluginExecution child, PluginExecution parent )
    {
        if ( child.getPhase() == null )
        {
            child.setPhase( parent.getPhase() );
        }

        List parentGoals = parent.getGoals();
        List childGoals = child.getGoals();

        List goals = new ArrayList();

        if ( childGoals != null && !childGoals.isEmpty() )
        {
            goals.addAll( childGoals );
        }

        if ( parentGoals != null )
        {
            for ( Iterator goalIterator = parentGoals.iterator(); goalIterator.hasNext(); )
            {
                String goal = (String) goalIterator.next();

                if ( !goals.contains( goal ) )
                {
                    goals.add( goal );
                }
            }
        }

        child.setGoals( goals );

        Xpp3Dom childConfiguration = (Xpp3Dom) child.getConfiguration();
        Xpp3Dom parentConfiguration = (Xpp3Dom) parent.getConfiguration();

        childConfiguration = Xpp3Dom.mergeXpp3Dom( childConfiguration, parentConfiguration );

        child.setConfiguration( childConfiguration );
    }",0,[0]
36652,bugs-dot-jar_MATH-904_6844aba9,"private static void reducePayneHanek(double x, double result[])
    {
        /* Convert input double to bits */
        long inbits = Double.doubleToLongBits(x);
        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;

        /* Convert to fixed point representation */
        inbits &= 0x000fffffffffffffL;
        inbits |= 0x0010000000000000L;

        /* Normalize input to be between 0.5 and 1.0 */
        exponent++;
        inbits <<= 11;

        /* Based on the exponent, get a shifted copy of recip2pi */
        long shpi0;
        long shpiA;
        long shpiB;
        int idx = exponent >> 6;
        int shift = exponent - (idx << 6);

        if (shift != 0) {
            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);
            shpi0 |= RECIP_2PI[idx] >>> (64-shift);
            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));
            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));
        } else {
            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];
            shpiA = RECIP_2PI[idx];
            shpiB = RECIP_2PI[idx+1];
        }

        /* Multiply input by shpiA */
        long a = inbits >>> 32;
        long b = inbits & 0xffffffffL;

        long c = shpiA >>> 32;
        long d = shpiA & 0xffffffffL;

        long ac = a * c;
        long bd = b * d;
        long bc = b * c;
        long ad = a * d;

        long prodB = bd + (ad << 32);
        long prodA = ac + (ad >>> 32);

        boolean bita = (bd & 0x8000000000000000L) != 0;
        boolean bitb = (ad & 0x80000000L ) != 0;
        boolean bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prodB = prodB + (bc << 32);
        prodA = prodA + (bc >>> 32);

        bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply input by shpiB */
        c = shpiB >>> 32;
        d = shpiB & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac = ac + ((bc + ad) >>> 32);

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prodB += ac;
        bitsum = (prodB & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply by shpi0 */
        c = shpi0 >>> 32;
        d = shpi0 & 0xffffffffL;

        bd = b * d;
        bc = b * c;
        ad = a * d;

        prodA += bd + ((bc + ad) << 32);

        /*
         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
         * PI/2, so use the following steps:
         * 1.) multiply by 4.
         * 2.) do a fixed point muliply by PI/4.
         * 3.) Convert to floating point.
         * 4.) Multiply by 2
         */

        /* This identifies the quadrant */
        int intPart = (int)(prodA >>> 62);

        /* Multiply by 4 */
        prodA <<= 2;
        prodA |= prodB >>> 62;
        prodB <<= 2;

        /* Multiply by PI/4 */
        a = prodA >>> 32;
        b = prodA & 0xffffffffL;

        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;

        ac = a * c;
        bd = b * d;
        bc = b * c;
        ad = a * d;

        long prod2B = bd + (ad << 32);
        long prod2A = ac + (ad >>> 32);

        bita = (bd & 0x8000000000000000L) != 0;
        bitb = (ad & 0x80000000L ) != 0;
        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prod2B = prod2B + (bc << 32);
        prod2A = prod2A + (bc >>> 32);

        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply input by pio4bits[1] */
        c = PI_O_4_BITS[1] >>> 32;
        d = PI_O_4_BITS[1] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac = ac + ((bc + ad) >>> 32);

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply inputB by pio4bits[0] */
        a = prodB >>> 32;
        b = prodB & 0xffffffffL;
        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac = ac + ((bc + ad) >>> 32);

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Convert to double */
        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits
        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits

        double sumA = tmpA + tmpB;
        double sumB = -(sumA - tmpA - tmpB);

        /* Multiply by PI/2 and return */
        result[0] = intPart;
        result[1] = sumA * 2.0;
        result[2] = sumB * 2.0;
    }","private static void reducePayneHanek(double x, double result[])
    {
        /* Convert input double to bits */
        long inbits = Double.doubleToLongBits(x);
        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;

        /* Convert to fixed point representation */
        inbits &= 0x000fffffffffffffL;
        inbits |= 0x0010000000000000L;

        /* Normalize input to be between 0.5 and 1.0 */
        exponent++;
        inbits <<= 11;

        /* Based on the exponent, get a shifted copy of recip2pi */
        long shpi0;
        long shpiA;
        long shpiB;
        int idx = exponent >> 6;
        int shift = exponent - (idx << 6);

        if (shift != 0) {
            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);
            shpi0 |= RECIP_2PI[idx] >>> (64-shift);
            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));
            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));
        } else {
            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];
            shpiA = RECIP_2PI[idx];
            shpiB = RECIP_2PI[idx+1];
        }

        /* Multiply input by shpiA */
        long a = inbits >>> 32;
        long b = inbits & 0xffffffffL;

        long c = shpiA >>> 32;
        long d = shpiA & 0xffffffffL;

        long ac = a * c;
        long bd = b * d;
        long bc = b * c;
        long ad = a * d;

        long prodB = bd + (ad << 32);
        long prodA = ac + (ad >>> 32);

        boolean bita = (bd & 0x8000000000000000L) != 0;
        boolean bitb = (ad & 0x80000000L ) != 0;
        boolean bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prodB = prodB + (bc << 32);
        prodA = prodA + (bc >>> 32);

        bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply input by shpiB */
        c = shpiB >>> 32;
        d = shpiB & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac = ac + ((bc + ad) >>> 32);

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prodB += ac;
        bitsum = (prodB & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply by shpi0 */
        c = shpi0 >>> 32;
        d = shpi0 & 0xffffffffL;

        bd = b * d;
        bc = b * c;
        ad = a * d;

        prodA += bd + ((bc + ad) << 32);

        /*
         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
         * PI/2, so use the following steps:
         * 1.) multiply by 4.
         * 2.) do a fixed point muliply by PI/4.
         * 3.) Convert to floating point.
         * 4.) Multiply by 2
         */

        /* This identifies the quadrant */
        int intPart = (int)(prodA >>> 62);

        /* Multiply by 4 */
        prodA <<= 2;
        prodA |= prodB >>> 62;
        prodB <<= 2;

        /* Multiply by PI/4 */
        a = prodA >>> 32;
        b = prodA & 0xffffffffL;

        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;

        ac = a * c;
        bd = b * d;
        bc = b * c;
        ad = a * d;

        long prod2B = bd + (ad << 32);
        long prod2A = ac + (ad >>> 32);

        bita = (bd & 0x8000000000000000L) != 0;
        bitb = (ad & 0x80000000L ) != 0;
        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prod2B = prod2B + (bc << 32);
        prod2A = prod2A + (bc >>> 32);

        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply input by pio4bits[1] */
        c = PI_O_4_BITS[1] >>> 32;
        d = PI_O_4_BITS[1] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac = ac + ((bc + ad) >>> 32);

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply inputB by pio4bits[0] */
        a = prodB >>> 32;
        b = prodB & 0xffffffffL;
        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac = ac + ((bc + ad) >>> 32);

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Convert to double */
        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits
        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits

        double sumA = tmpA + tmpB;
        double sumB = -(sumA - tmpA - tmpB);

        /* Multiply by PI/2 and return */
        result[0] = intPart;
        result[1] = sumA * 2.0;
        result[2] = sumB * 2.0;
    }",0,[0]
38284,bugs-dot-jar_CAMEL-3314_4badd9c5,"@SuppressWarnings(""unchecked"")
    public Type sort(Expression expression, Comparator comparator) {
        addOutput(new SortDefinition(expression, comparator));
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    public Type sort(Expression expression, Comparator comparator) {
        addOutput(new SortDefinition(expression, comparator));
        return (Type) this;
    }",0,[0]
25743,bugs-dot-jar_OAK-3396_c83755c3,"private void applyAttributes(Map<String, Object> props, Entry entry)
            throws LdapInvalidAttributeValueException {
        for (Attribute attr: entry.getAttributes()) {
            if (attr.isHumanReadable()) {
                final Object propValue;
                // for multivalue properties, store as collection
                if (attr.size() > 1) {
                    List<String> values = new ArrayList<String>();
                    for (Value<?> value : attr) {
                        values.add(value.getString());
                    }
                    propValue = values;
                } else {
                    propValue = attr.getString();
                }
                props.put(attr.getId(), propValue);
            }
        }
    }","private void applyAttributes(Map<String, Object> props, Entry entry)
            throws LdapInvalidAttributeValueException {
        for (Attribute attr: entry.getAttributes()) {
            if (attr.isHumanReadable()) {
                final Object propValue;
                // for multivalue properties, store as collection
                if (attr.size() > 1) {
                    List<String> values = new ArrayList<String>();
                    for (Value<?> value : attr) {
                        values.add(value.getString());
                    }
                    propValue = values;
                } else {
                    propValue = attr.getString();
                }
                props.put(attr.getId(), propValue);
            }
        }
    }",0,[0]
33898,bugs-dot-jar_WICKET-3166_4d7f7359,"public final void detach()
	{
		// if the component has been previously attached via attach()
		// detach it now
		setFlag(FLAG_DETACHING, true);
		onDetach();
		if (getFlag(FLAG_DETACHING))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly detached. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onDetach() in the override of onDetach() method"");
		}
		setFlag(FLAG_CONFIGURED, false);

		// always detach models because they can be attached without the
		// component. eg component has a compoundpropertymodel and one of its
		// children component's getmodelobject is called
		detachModels();

		// detach any behaviors
		new Behaviors(this).detach();

		// always detach children because components can be attached
		// independently of their parents
		detachChildren();

		// reset the model to null when the current model is a IWrapModel and
		// the model that created it/wrapped in it is a IComponentInheritedModel
		// The model will be created next time.
		if (getFlag(FLAG_INHERITABLE_MODEL))
		{
			setModelImpl(null);
			setFlag(FLAG_INHERITABLE_MODEL, false);
		}

		// clear out enabled state metadata
		clearEnabledInHierarchyCache();

		// notify any detach listener
		IDetachListener detachListener = getApplication().getFrameworkSettings()
			.getDetachListener();
		if (detachListener != null)
		{
			detachListener.onDetach(this);
		}
	}","public final void detach()
	{
		// if the component has been previously attached via attach()
		// detach it now
		setFlag(FLAG_DETACHING, true);
		onDetach();
		if (getFlag(FLAG_DETACHING))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly detached. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onDetach() in the override of onDetach() method"");
		}
		setFlag(FLAG_CONFIGURED, false);

		// always detach models because they can be attached without the
		// component. eg component has a compoundpropertymodel and one of its
		// children component's getmodelobject is called
		detachModels();

		// detach any behaviors
		new Behaviors(this).detach();

		// always detach children because components can be attached
		// independently of their parents
		detachChildren();

		// reset the model to null when the current model is a IWrapModel and
		// the model that created it/wrapped in it is a IComponentInheritedModel
		// The model will be created next time.
		if (getFlag(FLAG_INHERITABLE_MODEL))
		{
			setModelImpl(null);
			setFlag(FLAG_INHERITABLE_MODEL, false);
		}

		// clear out enabled state metadata
		clearEnabledInHierarchyCache();

		// notify any detach listener
		IDetachListener detachListener = getApplication().getFrameworkSettings()
			.getDetachListener();
		if (detachListener != null)
		{
			detachListener.onDetach(this);
		}
	}",0,[0]
22640,bugs-dot-jar_WICKET-5204_9e6efa61,"public DateTimeField(final String id)
	{
		this(id, null);
	}","public DateTimeField(final String id)
	{
		this(id, null);
	}",0,[0]
27380,bugs-dot-jar_WICKET-4301_50b52742,"protected synchronized void setLastModifiedTime(Time time)
	{
		lastModifiedTime = time;
	}","protected synchronized void setLastModifiedTime(Time time)
	{
		lastModifiedTime = time;
	}",0,[0]
22547,bugs-dot-jar_FLINK-1820_39d526e6,"@Override
	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ByteValue reusable) {
		int val = 0;
		boolean neg = false;
		
		this.result = reusable;

		final int delimLimit = limit-delimiter.length+1;
		
		if (bytes[startPos] == '-') {
			neg = true;
			startPos++;
			
			// check for empty field with only the sign
			if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
				return -1;
			}
		}

		for (int i = startPos; i < limit; i++) {

			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
				reusable.setValue((byte) (neg ? -val : val));
				return i + delimiter.length;
			}
			if (bytes[i] < 48 || bytes[i] > 57) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
				return -1;
			}
			val *= 10;
			val += bytes[i] - 48;
			
			if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
				return -1;
			}
		}
		
		reusable.setValue((byte) (neg ? -val : val));
		return limit;
	}","@Override
	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ByteValue reusable) {
		int val = 0;
		boolean neg = false;
		
		this.result = reusable;

		final int delimLimit = limit-delimiter.length+1;
		
		if (bytes[startPos] == '-') {
			neg = true;
			startPos++;
			
			// check for empty field with only the sign
			if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
				return -1;
			}
		}

		for (int i = startPos; i < limit; i++) {

			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
				if (i == startPos) {
					setErrorState(ParseErrorState.EMPTY_STRING);
					return -1;
				}
				reusable.setValue((byte) (neg ? -val : val));
				return i + delimiter.length;
			}
			if (bytes[i] < 48 || bytes[i] > 57) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
				return -1;
			}
			val *= 10;
			val += bytes[i] - 48;
			
			if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
				return -1;
			}
		}
		
		reusable.setValue((byte) (neg ? -val : val));
		return limit;
	}",1,[]
36653,bugs-dot-jar_MATH-904_6844aba9,"public static double sin(double x) {
        boolean negative = false;
        int quadrant = 0;
        double xa;
        double xb = 0.0;

        /* Take absolute value of the input */
        xa = x;
        if (x < 0) {
            negative = true;
            xa = -xa;
        }

        /* Check for zero and negative zero */
        if (xa == 0.0) {
            long bits = Double.doubleToLongBits(x);
            if (bits < 0) {
                return -0.0;
            }
            return 0.0;
        }

        if (xa != xa || xa == Double.POSITIVE_INFINITY) {
            return Double.NaN;
        }

        /* Perform any argument reduction */
        if (xa > 3294198.0) {
            // PI * (2**20)
            // Argument too big for CodyWaite reduction.  Must use
            // PayneHanek.
            double reduceResults[] = new double[3];
            reducePayneHanek(xa, reduceResults);
            quadrant = ((int) reduceResults[0]) & 3;
            xa = reduceResults[1];
            xb = reduceResults[2];
        } else if (xa > 1.5707963267948966) {
            final CodyWaite cw = new CodyWaite(xa, xb);
            quadrant = cw.getK() & 3;
            xa = cw.getRemA();
            xb = cw.getRemB();
        }

        if (negative) {
            quadrant ^= 2;  // Flip bit 1
        }

        switch (quadrant) {
            case 0:
                return sinQ(xa, xb);
            case 1:
                return cosQ(xa, xb);
            case 2:
                return -sinQ(xa, xb);
            case 3:
                return -cosQ(xa, xb);
            default:
                return Double.NaN;
        }
    }","public static double sin(double x) {
        boolean negative = false;
        int quadrant = 0;
        double xa;
        double xb = 0.0;

        /* Take absolute value of the input */
        xa = x;
        if (x < 0) {
            negative = true;
            xa = -xa;
        }

        /* Check for zero and negative zero */
        if (xa == 0.0) {
            long bits = Double.doubleToLongBits(x);
            if (bits < 0) {
                return -0.0;
            }
            return 0.0;
        }

        if (xa != xa || xa == Double.POSITIVE_INFINITY) {
            return Double.NaN;
        }

        /* Perform any argument reduction */
        if (xa > 3294198.0) {
            // PI * (2**20)
            // Argument too big for CodyWaite reduction.  Must use
            // PayneHanek.
            double reduceResults[] = new double[3];
            reducePayneHanek(xa, reduceResults);
            quadrant = ((int) reduceResults[0]) & 3;
            xa = reduceResults[1];
            xb = reduceResults[2];
        } else if (xa > 1.5707963267948966) {
            final CodyWaite cw = new CodyWaite(xa, xb);
            quadrant = cw.getK() & 3;
            xa = cw.getRemA();
            xb = cw.getRemB();
        }

        if (negative) {
            quadrant ^= 2;  // Flip bit 1
        }

        switch (quadrant) {
            case 0:
                return sinQ(xa, xb);
            case 1:
                return cosQ(xa, xb);
            case 2:
                return -sinQ(xa, xb);
            case 3:
                return -cosQ(xa, xb);
            default:
                return Double.NaN;
        }
    }",0,[0]
953,bugs-dot-jar_WICKET-2033_420ac965,"@Override
	protected CharSequence getPreconditionScript()
	{
		return ""return Wicket.$$(this)&amp;&amp;Wicket.$$('"" + getForm().getMarkupId() + ""')"";
	}","@Override
	protected CharSequence getPreconditionScript()
	{
		return ""return Wicket.$$(this)&&Wicket.$$('"" + getForm().getMarkupId() + ""')"";
	}",1,[3]
955,Bears-126,"private static boolean hasStatus(int type) {
        return type == MSG_STATUS || type == MSG_LBS_STATUS
                || type == MSG_GPS_LBS_STATUS_1 || type == MSG_GPS_LBS_STATUS_2 || type == MSG_GPS_LBS_STATUS_3;
    }","private static boolean hasStatus(int type) {
        return type == MSG_STATUS || type == MSG_LBS_STATUS
                || type == MSG_GPS_LBS_STATUS_1 || type == MSG_GPS_LBS_STATUS_2 || type == MSG_GPS_LBS_STATUS_3;
    }",0,[0]
2304,bugs-dot-jar_MNG-4918_691a03a7,"@Deprecated
    public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId )
    {
        Xpp3Dom dom = null;

        // ----------------------------------------------------------------------
        // I would like to be able to lookup the Mojo object using a key but
        // we have a limitation in modello that will be remedied shortly. So
        // for now I have to iterate through and see what we have.
        // ----------------------------------------------------------------------

        if ( getReportPlugins() != null )
        {
            for ( Iterator<ReportPlugin> iterator = getReportPlugins().iterator(); iterator.hasNext(); )
            {
                ReportPlugin plugin = iterator.next();

                if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) )
                {
                    dom = (Xpp3Dom) plugin.getConfiguration();

                    if ( reportSetId != null )
                    {
                        ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );
                        if ( reportSet != null )
                        {
                            Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();
                            if ( executionConfiguration != null )
                            {
                                Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );
                                dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );
                            }
                        }
                    }
                    break;
                }
            }
        }

        if ( dom != null )
        {
            // make a copy so the original in the POM doesn't get messed with
            dom = new Xpp3Dom( dom );
        }

        return dom;
    }","@Deprecated
    public Xpp3Dom getReportConfiguration( String pluginGroupId, String pluginArtifactId, String reportSetId )
    {
        Xpp3Dom dom = null;

        // ----------------------------------------------------------------------
        // I would like to be able to lookup the Mojo object using a key but
        // we have a limitation in modello that will be remedied shortly. So
        // for now I have to iterate through and see what we have.
        // ----------------------------------------------------------------------

        if ( getReportPlugins() != null )
        {
            for ( Iterator<ReportPlugin> iterator = getReportPlugins().iterator(); iterator.hasNext(); )
            {
                ReportPlugin plugin = iterator.next();

                if ( pluginGroupId.equals( plugin.getGroupId() ) && pluginArtifactId.equals( plugin.getArtifactId() ) )
                {
                    dom = (Xpp3Dom) plugin.getConfiguration();

                    if ( reportSetId != null )
                    {
                        ReportSet reportSet = plugin.getReportSetsAsMap().get( reportSetId );
                        if ( reportSet != null )
                        {
                            Xpp3Dom executionConfiguration = (Xpp3Dom) reportSet.getConfiguration();
                            if ( executionConfiguration != null )
                            {
                                Xpp3Dom newDom = new Xpp3Dom( executionConfiguration );
                                dom = Xpp3Dom.mergeXpp3Dom( newDom, dom );
                            }
                        }
                    }
                    break;
                }
            }
        }

        if ( dom != null )
        {
            // make a copy so the original in the POM doesn't get messed with
            dom = new Xpp3Dom( dom );
        }

        return dom;
    }",0,[0]
1880,bugs-dot-jar_FLINK-1145_22c370d9,"private TypeExtractor() {
		alreadySeen = new HashSet<Class<?>>();
	}","private TypeExtractor() {
		alreadySeen = new HashSet<Class<?>>();
	}",0,[0]
40703,bugs-dot-jar_WICKET-442_246d53c5,"public AbstractListenerInterfaceRequestTarget(final Page page, final Component component,
			RequestListenerInterface listener)
	{
		this(page, component, listener, null);
	}","public AbstractListenerInterfaceRequestTarget(final Page page, final Component component,
			RequestListenerInterface listener)
	{
		this(page, component, listener, null);
	}",0,[0]
35291,bugs-dot-jar_ACCUMULO-1732_941e3cb1,"public static void setScanAuthorizations(Job job, Authorizations auths) {
    InputConfigurator.setScanAuthorizations(CLASS, job.getConfiguration(), auths);
  }","public static void setScanAuthorizations(Job job, Authorizations auths) {
    InputConfigurator.setScanAuthorizations(CLASS, job.getConfiguration(), auths);
  }",0,[0]
9629,bugs-dot-jar_CAMEL-5707_3f70d612,"public NotifyBuilder from(final String endpointUri) {
        stack.add(new EventPredicateSupport() {

            @Override
            public boolean isAbstract() {
                // is abstract as its a filter
                return true;
            }

            @Override
            public boolean onExchange(Exchange exchange) {
                // filter non matching exchanges
                return EndpointHelper.matchEndpoint(context, exchange.getFromEndpoint().getEndpointUri(), endpointUri);
            }

            public boolean matches() {
                // should be true as we use the onExchange to filter
                return true;
            }

            @Override
            public String toString() {
                return ""from("" + endpointUri + "")"";
            }
        });
        return this;
    }","public NotifyBuilder from(final String endpointUri) {
        stack.add(new EventPredicateSupport() {

            @Override
            public boolean isAbstract() {
                // is abstract as its a filter
                return true;
            }

            @Override
            public boolean onExchange(Exchange exchange) {
                // filter non matching exchanges
                return EndpointHelper.matchEndpoint(context, exchange.getFromEndpoint().getEndpointUri(), endpointUri);
            }

            public boolean matches() {
                // should be true as we use the onExchange to filter
                return true;
            }

            @Override
            public String toString() {
                return ""from("" + endpointUri + "")"";
            }
        });
        return this;
    }",0,[0]
24846,bugs-dot-jar_CAMEL-5187_8cadc344,"public void setMBeanServer(MBeanServer mbeanServer) {
        server = mbeanServer;
    }","public void setMBeanServer(MBeanServer mbeanServer) {
        server = mbeanServer;
    }",0,[0]
1194,Bears-152,"@Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }","@Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }",0,[0]
10282,bugs-dot-jar_OAK-3897_94c6c575,"boolean renewClusterIdLease() {
        return clusterNodeInfo.renewLease();
    }","boolean renewClusterIdLease() {
        return clusterNodeInfo.renewLease();
    }",0,[0]
1267,Bears-156,"@Override
    public boolean supportsRootTreatTreatJoin() {
        return false;
    }","@Override
    public boolean supportsRootTreatTreatJoin() {
        return false;
    }",0,[0]
1234,Bears-154,"public static MicroserviceConfigLoader getMicroserviceConfigLoader() {
    return (MicroserviceConfigLoader) getProperty(MICROSERVICE_CONFIG_LOADER_KEY);
  }","public static MicroserviceConfigLoader getMicroserviceConfigLoader() {
    return (MicroserviceConfigLoader) getProperty(MICROSERVICE_CONFIG_LOADER_KEY);
  }",0,[0]
298,Bears-14,"protected JavaType materializeAbstractType(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        // May have multiple resolvers, call in precedence order until one returns non-null
        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {
            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);
            if (concrete != null) {
                return concrete;
            }
        }
        return null;
    }","protected JavaType materializeAbstractType(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        // May have multiple resolvers, call in precedence order until one returns non-null
        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {
            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), beanDesc);
            if (concrete != null) {
                return concrete;
            }
        }
        return null;
    }",0,[0]
4511,bugs-dot-jar_OAK-2420_24cb1908,"public int getPendingWriteCount() {
        return unsavedLastRevisions.getPaths().size();
    }","public int getPendingWriteCount() {
        return unsavedLastRevisions.getPaths().size();
    }",0,[0]
756,Bears-83,"public static void insertAllMethods(CtType<?> targetType, Template<?> template) {

		CtClass<?> sourceClass = getTemplateCtClass(targetType, template);
		insertAllMethods(targetType, template, sourceClass);
	}","public static void insertAllMethods(CtType<?> targetType, Template<?> template) {

		CtClass<?> sourceClass = getTemplateCtClass(targetType, template);
		insertAllMethods(targetType, template, sourceClass);
	}",0,[0]
18079,bugs-dot-jar_WICKET-5147_184e51e9,"public void dirty(final boolean isInitialization)
	{
		checkHierarchyChange(this);

		if (getFlag(FLAG_PREVENT_DIRTY))
		{
			return;
		}

		final IPageManager pageManager = getSession().getPageManager();
		if (!getFlag(FLAG_IS_DIRTY) && (isVersioned() && pageManager.supportsVersioning() ||

		// we need to get pageId for new page instances even when the page doesn't need
		// versioning, otherwise pages override each other in the page store and back button
		// support is broken
			isInitialization))
		{
			setFlag(FLAG_IS_DIRTY, true);
			setNextAvailableId();
			pageManager.touchPage(this);
		}
	}","public void dirty(final boolean isInitialization)
	{
		checkHierarchyChange(this);

		if (getFlag(FLAG_PREVENT_DIRTY))
		{
			return;
		}

		final IPageManager pageManager = getSession().getPageManager();
		if (!getFlag(FLAG_IS_DIRTY) && (isVersioned() && pageManager.supportsVersioning() ||

		// we need to get pageId for new page instances even when the page doesn't need
		// versioning, otherwise pages override each other in the page store and back button
		// support is broken
			isInitialization))
		{
			setFlag(FLAG_IS_DIRTY, true);
			setNextAvailableId();
			pageManager.touchPage(this);
		}
	}",0,[0]
35533,bugs-dot-jar_WICKET-5662_9aec4f33,"public boolean isSingletonBean()
	{
		if (singletonCache == null)
		{
			singletonCache = getSpringContext().isSingleton(getBeanName());
		}
		return singletonCache;
	}","public boolean isSingletonBean()
	{
		if (singletonCache == null)
		{
			singletonCache = getSpringContext().isSingleton(getBeanName());
		}
		return singletonCache;
	}",0,[0]
25103,bugs-dot-jar_OAK-1227_117b0a3d,"@Override
    public void setMixins(String[] strings) throws RepositoryException {
        throw new UnsupportedRepositoryOperationException(""TODO: JackrabbitNode.setMixins (OAK-770"");
    }","@Override
    public void setMixins(String[] strings) throws RepositoryException {
        throw new UnsupportedRepositoryOperationException(""TODO: JackrabbitNode.setMixins (OAK-770"");
    }",0,[0]
34871,bugs-dot-jar_CAMEL-5570_a57830ed,"@Override
    public String getLabel() {
        return ""onException["" + description() + ""]"";
    }","@Override
    public String getLabel() {
        return ""onException["" + description() + ""]"";
    }",0,[0]
26243,bugs-dot-jar_LOG4J2-430_238ce8aa,"private String getId(final StructuredDataId id) {
        final StringBuilder sb = new StringBuilder();
        if (id == null || id.getName() == null) {
            sb.append(defaultId);
        } else {
            sb.append(id.getName());
        }
        int ein = id != null ? id.getEnterpriseNumber() : enterpriseNumber;
        if (ein < 0) {
            ein = enterpriseNumber;
        }
        if (ein >= 0) {
            sb.append(""@"").append(ein);
        }
        return sb.toString();
    }","private String getId(final StructuredDataId id) {
        final StringBuilder sb = new StringBuilder();
        if (id == null || id.getName() == null) {
            sb.append(defaultId);
        } else {
            sb.append(id.getName());
        }
        int ein = id != null ? id.getEnterpriseNumber() : enterpriseNumber;
        if (ein < 0) {
            ein = enterpriseNumber;
        }
        if (ein >= 0) {
            sb.append(""@"").append(ein);
        }
        return sb.toString();
    }",0,[0]
22770,bugs-dot-jar_MATH-778_5b9302d5,"public Dfp nextAfter(final Dfp x) {

        // make sure we don't mix number with different precision
        if (field.getRadixDigits() != x.field.getRadixDigits()) {
            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
            final Dfp result = newInstance(getZero());
            result.nans = QNAN;
            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);
        }

        // if this is greater than x
        boolean up = false;
        if (this.lessThan(x)) {
            up = true;
        }

        if (compare(this, x) == 0) {
            return newInstance(x);
        }

        if (lessThan(getZero())) {
            up = !up;
        }

        final Dfp inc;
        Dfp result;
        if (up) {
            inc = newInstance(getOne());
            inc.exp = this.exp-mant.length+1;
            inc.sign = this.sign;

            if (this.equals(getZero())) {
                inc.exp = MIN_EXP-mant.length;
            }

            result = add(inc);
        } else {
            inc = newInstance(getOne());
            inc.exp = this.exp;
            inc.sign = this.sign;

            if (this.equals(inc)) {
                inc.exp = this.exp-mant.length;
            } else {
                inc.exp = this.exp-mant.length+1;
            }

            if (this.equals(getZero())) {
                inc.exp = MIN_EXP-mant.length;
            }

            result = this.subtract(inc);
        }

        if (result.classify() == INFINITE && this.classify() != INFINITE) {
            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);
            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);
        }

        if (result.equals(getZero()) && this.equals(getZero()) == false) {
            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);
            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);
        }

        return result;

    }","public Dfp nextAfter(final Dfp x) {

        // make sure we don't mix number with different precision
        if (field.getRadixDigits() != x.field.getRadixDigits()) {
            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
            final Dfp result = newInstance(getZero());
            result.nans = QNAN;
            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);
        }

        // if this is greater than x
        boolean up = false;
        if (this.lessThan(x)) {
            up = true;
        }

        if (compare(this, x) == 0) {
            return newInstance(x);
        }

        if (lessThan(getZero())) {
            up = !up;
        }

        final Dfp inc;
        Dfp result;
        if (up) {
            inc = newInstance(getOne());
            inc.exp = this.exp-mant.length+1;
            inc.sign = this.sign;

            if (this.equals(getZero())) {
                inc.exp = MIN_EXP-mant.length;
            }

            result = add(inc);
        } else {
            inc = newInstance(getOne());
            inc.exp = this.exp;
            inc.sign = this.sign;

            if (this.equals(inc)) {
                inc.exp = this.exp-mant.length;
            } else {
                inc.exp = this.exp-mant.length+1;
            }

            if (this.equals(getZero())) {
                inc.exp = MIN_EXP-mant.length;
            }

            result = this.subtract(inc);
        }

        if (result.classify() == INFINITE && this.classify() != INFINITE) {
            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);
            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);
        }

        if (result.equals(getZero()) && this.equals(getZero()) == false) {
            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);
            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);
        }

        return result;

    }",0,[0]
18830,bugs-dot-jar_MATH-935_48dde378,"public void pow(final double[] operand, final int operandOffset, final double p,
                    final double[] result, final int resultOffset) {

        // create the function value and derivatives
        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]
        double[] function = new double[1 + order];
        double xk = FastMath.pow(operand[operandOffset], p - order);
        for (int i = order; i > 0; --i) {
            function[i] = xk;
            xk *= operand[operandOffset];
        }
        function[0] = xk;
        double coefficient = p;
        for (int i = 1; i <= order; ++i) {
            function[i] *= coefficient;
            coefficient *= p - i;
        }

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }","public void pow(final double[] operand, final int operandOffset, final double p,
                    final double[] result, final int resultOffset) {

        // create the function value and derivatives
        // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]
        double[] function = new double[1 + order];
        double xk = FastMath.pow(operand[operandOffset], p - order);
        for (int i = order; i > 0; --i) {
            function[i] = xk;
            xk *= operand[operandOffset];
        }
        function[0] = xk;
        double coefficient = p;
        for (int i = 1; i <= order; ++i) {
            function[i] *= coefficient;
            coefficient *= p - i;
        }

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }",0,[0]
108,Bears-6,"public AnnotatedMember getAnySetterField()
    {
        if (!_collected) {
            collectAll();
        }
        if (_anySetterField != null) {
            if (_anySetterField.size() > 1) {
                reportProblem(""Multiple 'any-Setters' defined (""+_anySetters.get(0)+"" vs ""
                        +_anySetterField.get(1)+"")"");
            }
            return _anySetterField.getFirst();
        }
        return null;
    }","public AnnotatedMember getAnySetterField()
    {
        if (!_collected) {
            collectAll();
        }
        if (_anySetterField != null) {
            if (_anySetterField.size() > 1) {
                reportProblem(""Multiple 'any-Setters' defined (""+_anySetters.get(0)+"" vs ""
                        +_anySetterField.get(1)+"")"");
            }
            return _anySetterField.getFirst();
        }
        return null;
    }",0,[0]
9635,bugs-dot-jar_CAMEL-5707_3f70d612,"public NotifyBuilder whenReceived(final int number) {
        stack.add(new EventPredicateSupport() {
            private AtomicInteger current = new AtomicInteger();

            @Override
            public boolean onExchangeCreated(Exchange exchange) {
                current.incrementAndGet();
                return true;
            }

            public boolean matches() {
                return current.get() >= number;
            }

            @Override
            public void reset() {
                current.set(0);
            }

            @Override
            public String toString() {
                return ""whenReceived("" + number + "")"";
            }
        });
        return this;
    }","public NotifyBuilder whenReceived(final int number) {
        stack.add(new EventPredicateSupport() {
            private AtomicInteger current = new AtomicInteger();

            @Override
            public boolean onExchangeCreated(Exchange exchange) {
                current.incrementAndGet();
                return true;
            }

            public boolean matches() {
                return current.get() >= number;
            }

            @Override
            public void reset() {
                current.set(0);
            }

            @Override
            public String toString() {
                return ""whenReceived("" + number + "")"";
            }
        });
        return this;
    }",0,[0]
1881,Bears-211,"@Override
    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException
    {
        if (_cfgDelegateToTextual) {
            return super._createGenerator(out, ctxt);
        }
        return _nonByteTarget(); 
    }","@Override
    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException
    {
        if (_cfgDelegateToTextual) {
            return super._createGenerator(out, ctxt);
        }
        return _nonByteTarget(); 
    }",0,[0]
36426,bugs-dot-jar_CAMEL-7418_cabee0e9,"protected Context createContext() throws NamingException {
        Hashtable<?, ?> properties = new Hashtable<Object, Object>(System.getProperties());
        return new InitialContext(properties);
    }","protected Context createContext() throws NamingException {
        Hashtable<?, ?> properties = new Hashtable<Object, Object>(System.getProperties());
        return new InitialContext(properties);
    }",0,[0]
3159,bugs-dot-jar_CAMEL-7736_7ad36e3d,"public boolean isEventNotifierEnabled() {
        return eventNotifierEnabled;
    }","public boolean isEventNotifierEnabled() {
        return eventNotifierEnabled;
    }",0,[0]
1932,Bears-230,"private void onAfter(SQLException e) {
    Scope scope = currentScope.get();
    if (scope == null) return;
    Tags.ERROR.set(scope.span(), e != null);
    scope.close();
  }","private void onAfter(SQLException e) {
    Scope scope = currentScope.get();
    if (scope == null) return;
    Tags.ERROR.set(scope.span(), e != null);
    scope.close();
  }",0,[0]
9327,bugs-dot-jar_OAK-1122_5286861d,"public MicroKernelImpl(Repository rep) {
        this.rep = rep;
        try {
            // initialize commit gate with current head
            gate.commit(rep.getHeadRevision().toString());
        } catch (Exception e) {
            throw new MicroKernelException(e);
        }
    }","public MicroKernelImpl(Repository rep) {
        this.rep = rep;
        try {
            // initialize commit gate with current head
            gate.commit(rep.getHeadRevision().toString());
        } catch (Exception e) {
            throw new MicroKernelException(e);
        }
    }",0,[0]
3010,bugs-dot-jar_MATH-358_061f5017,"public AdamsMoultonIntegrator(final int nSteps,
                                  final double minStep, final double maxStep,
                                  final double scalAbsoluteTolerance,
                                  final double scalRelativeTolerance)
        throws IllegalArgumentException {
        super(""Adams-Moulton"", nSteps, nSteps + 1, minStep, maxStep,
              scalAbsoluteTolerance, scalRelativeTolerance);
    }","public AdamsMoultonIntegrator(final int nSteps,
                                  final double minStep, final double maxStep,
                                  final double scalAbsoluteTolerance,
                                  final double scalRelativeTolerance)
        throws IllegalArgumentException {
        super(""Adams-Moulton"", nSteps, nSteps + 1, minStep, maxStep,
              scalAbsoluteTolerance, scalRelativeTolerance);
    }",0,[0]
8899,bugs-dot-jar_OAK-1761_f37ce716,"@CheckForNull
    DocumentNodeState readNode(String path, Revision readRevision) {
        String id = Utils.getIdFromPath(path);
        Revision lastRevision = getPendingModifications().get(path);
        NodeDocument doc = store.find(Collection.NODES, id);
        if (doc == null) {
            return null;
        }
        return doc.getNodeAtRevision(this, readRevision, lastRevision);
    }","@CheckForNull
    DocumentNodeState readNode(String path, Revision readRevision) {
        String id = Utils.getIdFromPath(path);
        Revision lastRevision = getPendingModifications().get(path);
        NodeDocument doc = store.find(Collection.NODES, id);
        if (doc == null) {
            return null;
        }
        return doc.getNodeAtRevision(this, readRevision, lastRevision);
    }",0,[0]
25049,bugs-dot-jar_OAK-1227_117b0a3d,"@Override
    @Nonnull
    public String getUUID() throws RepositoryException {
        return perform(new NodeOperation<String>(dlg) {
            @Override
            public String perform() throws RepositoryException {
                // TODO: avoid nested calls
                if (isNodeType(NodeType.MIX_REFERENCEABLE)) {
                    return getIdentifier();
                }
                throw new UnsupportedRepositoryOperationException(""Node is not referenceable."");
            }
        });
    }","@Override
    @Nonnull
    public String getUUID() throws RepositoryException {
        return perform(new NodeOperation<String>(dlg) {
            @Override
            public String perform() throws RepositoryException {
                // TODO: avoid nested calls
                if (isNodeType(NodeType.MIX_REFERENCEABLE)) {
                    return getIdentifier();
                }
                throw new UnsupportedRepositoryOperationException(""Node is not referenceable."");
            }
        });
    }",0,[0]
182,Bears-6,"public void addAll(POJOPropertyBuilder src)
    {
        _fields = merge(_fields, src._fields);
        _ctorParameters = merge(_ctorParameters, src._ctorParameters);
        _getters= merge(_getters, src._getters);
        _setters = merge(_setters, src._setters);
    }","public void addAll(POJOPropertyBuilder src)
    {
        _fields = merge(_fields, src._fields);
        _ctorParameters = merge(_ctorParameters, src._ctorParameters);
        _getters= merge(_getters, src._getters);
        _setters = merge(_setters, src._setters);
    }",0,[0]
154,Bears-6,"@Override
    public boolean couldDeserialize() {
        return (_ctorParameters != null) || (_setters != null) || (_fields != null);
    }","@Override
    public boolean couldDeserialize() {
        return (_ctorParameters != null) || (_setters != null) || (_fields != null);
    }",0,[0]
13128,bugs-dot-jar_CAMEL-6987_37e0e6bb,"public static void copyHeaders(Message source, Message target, boolean override) {
        if (!source.hasHeaders()) {
            return;
        }

        for (Map.Entry<String, Object> entry : source.getHeaders().entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            if (target.getHeader(key) == null || override) {
                target.setHeader(key, value);
            }
        }
    }","public static void copyHeaders(Message source, Message target, boolean override) {
        if (!source.hasHeaders()) {
            return;
        }

        for (Map.Entry<String, Object> entry : source.getHeaders().entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            if (target.getHeader(key) == null || override) {
                target.setHeader(key, value);
            }
        }
    }",0,[0]
3128,bugs-dot-jar_OAK-1216_e403e003,"@Nonnull
    public String getOakPathOrThrow(String jcrPath) throws RepositoryException {
        String oakPath = getOakPath(jcrPath);
        if (oakPath != null) {
            return oakPath;
        } else {
            throw new RepositoryException(""Invalid name or path: "" + jcrPath);
        }
    }","@Nonnull
    public String getOakPathOrThrow(String jcrPath) throws RepositoryException {
        String oakPath = getOakPath(jcrPath);
        if (oakPath != null) {
            return oakPath;
        } else {
            // check if the path is an SNS path with an index > 1 and throw a PathNotFoundException instead (see OAK-1216)
            if (getOakPathKeepIndex(jcrPath) != null) {
                throw new PathNotFoundException(jcrPath);
            } else {
                throw new RepositoryException(""Invalid name or path: "" + jcrPath);
            }

        }
    }",1,[6]
1671,bugs-dot-jar_OAK-1297_73cc2442,"protected static void annotateSourcePath(NodeBuilder builder, String path) {
        PropertyState base = builder.getBaseState().getProperty(MoveDetector.SOURCE_PATH);
        PropertyState head = builder.getNodeState().getProperty(MoveDetector.SOURCE_PATH);
        if (Objects.equal(base, head)) {
            if (!builder.hasProperty(MoveDetector.SOURCE_PATH)) {
                builder.setProperty(MoveDetector.SOURCE_PATH, path);
            }
        }
    }","protected static void annotateSourcePath(NodeBuilder builder, String path) {
        PropertyState base = builder.getBaseState().getProperty(MoveDetector.SOURCE_PATH);
        PropertyState head = builder.getNodeState().getProperty(MoveDetector.SOURCE_PATH);
        if (Objects.equal(base, head)) {
            builder.setProperty(MoveDetector.SOURCE_PATH, path);
        }
    }",1,"[4, 5, 6]"
8265,bugs-dot-jar_WICKET-4548_9a6a06be,"public IValidationError getError()
	{
		return error;
	}","public IValidationError getError()
	{
		return error;
	}",0,[0]
205,Bears-6,"protected <T> T fromMemberAnnotations(WithMember<T> func)
    {
        T result = null;
        if (_annotationIntrospector != null) {
            if (_forSerialization) {
                if (_getters != null) {
                    result = func.withMember(_getters.value);
                }
            } else {
                if (_ctorParameters != null) {
                    result = func.withMember(_ctorParameters.value);
                }
                if (result == null && _setters != null) {
                    result = func.withMember(_setters.value);
                }
            }
            if (result == null && _fields != null) {
                result = func.withMember(_fields.value);
            }
        }
        return result;
    }","protected <T> T fromMemberAnnotations(WithMember<T> func)
    {
        T result = null;
        if (_annotationIntrospector != null) {
            if (_forSerialization) {
                if (_getters != null) {
                    result = func.withMember(_getters.value);
                }
            } else {
                if (_ctorParameters != null) {
                    result = func.withMember(_ctorParameters.value);
                }
                if (result == null && _setters != null) {
                    result = func.withMember(_setters.value);
                }
            }
            if (result == null && _fields != null) {
                result = func.withMember(_fields.value);
            }
        }
        return result;
    }",0,[0]
140,Bears-6,"@Override
    public POJOPropertyBuilder withName(PropertyName newName) {
        return new POJOPropertyBuilder(this, newName);
    }","@Override
    public POJOPropertyBuilder withName(PropertyName newName) {
        return new POJOPropertyBuilder(this, newName);
    }",0,[0]
7205,bugs-dot-jar_WICKET-5881_8c83c5c5,"public final String getDefaultLabel(String defaultValue)
	{
		return getLocalizer().getString(getId(), getParent(), defaultValue);
	}","public final String getDefaultLabel(String defaultValue)
	{
		return getLocalizer().getString(getId(), getParent(), defaultValue);
	}",0,[0]
1937,bugs-dot-jar_CAMEL-3535_b56d2962,"public void setCompletionPredicate(Predicate completionPredicate) {
        this.completionPredicate = completionPredicate;
    }","public void setCompletionPredicate(Predicate completionPredicate) {
        this.completionPredicate = completionPredicate;
    }",0,[0]
3242,bugs-dot-jar_WICKET-3767_84c3baac,"public final void setModel(IModel<T> model)
	{
		setDefaultModel(model);
	}","public final void setModel(IModel<T> model)
	{
		setDefaultModel(model);
	}",0,[0]
16173,bugs-dot-jar_WICKET-5476_813d8bee,"public Radio(final String id)
	{
		this(id, null, null);
	}","public Radio(final String id)
	{
		this(id, null, null);
	}",0,[0]
20866,bugs-dot-jar_CAMEL-5215_033eb6fe,"private IOHelper() {
        //Utility Class
    }","private IOHelper() {
        //Utility Class
    }",0,[0]
34294,bugs-dot-jar_WICKET-4184_a0150366,"public int lastIndexOf(final String str)
	{
		return lastIndexOf(str, count);
	}","public int lastIndexOf(final String str)
	{
		return lastIndexOf(str, count);
	}",0,[0]
15217,bugs-dot-jar_WICKET-4070_d450acb0,"public final IFormSubmitter findSubmittingButton()
	{
		IFormSubmittingComponent submittingComponent = getPage().visitChildren(
			IFormSubmittingComponent.class, new IVisitor<Component, IFormSubmittingComponent>()
			{
				public void component(final Component component,
					final IVisit<IFormSubmittingComponent> visit)
				{
					// Get submitting component
					final IFormSubmittingComponent submittingComponent = (IFormSubmittingComponent)component;
					final Form<?> form = submittingComponent.getForm();

					// Check for component-name or component-name.x request string
					if ((form != null) && (form.getRootForm() == Form.this))
					{
						String name = submittingComponent.getInputName();
						IRequestParameters parameters = getRequest().getRequestParameters();
						if ((!parameters.getParameterValue(name).isNull()) ||
							!parameters.getParameterValue(name + "".x"").isNull())
						{
							if (!component.isVisibleInHierarchy())
							{
								throw new WicketRuntimeException(""Submit Button "" +
									submittingComponent.getInputName() + "" (path="" +
									component.getPageRelativePath() + "") is not visible"");
							}
							if (!component.isEnabledInHierarchy())
							{
								throw new WicketRuntimeException(""Submit Button "" +
									submittingComponent.getInputName() + "" (path="" +
									component.getPageRelativePath() + "") is not enabled"");
							}
							visit.stop(submittingComponent);
						}
					}
				}
			});

		return submittingComponent;
	}","public final IFormSubmitter findSubmittingButton()
	{
		IFormSubmittingComponent submittingComponent = getPage().visitChildren(
			IFormSubmittingComponent.class, new IVisitor<Component, IFormSubmittingComponent>()
			{
				public void component(final Component component,
					final IVisit<IFormSubmittingComponent> visit)
				{
					// Get submitting component
					final IFormSubmittingComponent submittingComponent = (IFormSubmittingComponent)component;
					final Form<?> form = submittingComponent.getForm();

					// Check for component-name or component-name.x request string
					if ((form != null) && (form.getRootForm() == Form.this))
					{
						String name = submittingComponent.getInputName();
						IRequestParameters parameters = getRequest().getRequestParameters();
						if ((!parameters.getParameterValue(name).isNull()) ||
							!parameters.getParameterValue(name + "".x"").isNull())
						{
							if (!component.isVisibleInHierarchy())
							{
								throw new WicketRuntimeException(""Submit Button "" +
									submittingComponent.getInputName() + "" (path="" +
									component.getPageRelativePath() + "") is not visible"");
							}
							if (!component.isEnabledInHierarchy())
							{
								throw new WicketRuntimeException(""Submit Button "" +
									submittingComponent.getInputName() + "" (path="" +
									component.getPageRelativePath() + "") is not enabled"");
							}
							visit.stop(submittingComponent);
						}
					}
				}
			});

		return submittingComponent;
	}",0,[0]
36323,bugs-dot-jar_CAMEL-9444_baece126,"public SplitDefinition executorService(ExecutorService executorService) {
        setExecutorService(executorService);
        return this;
    }","public SplitDefinition executorService(ExecutorService executorService) {
        setExecutorService(executorService);
        return this;
    }",0,[0]
19926,bugs-dot-jar_FLINK-3052_8dc70f2e,"@Override
	public void clearInterestingProperties() {
		super.clearInterestingProperties();
		
		this.singleRoot.accept(InterestingPropertiesClearer.INSTANCE);
		this.rootConnection.clearInterestingProperties();
	}","@Override
	public void clearInterestingProperties() {
		super.clearInterestingProperties();
		
		this.singleRoot.accept(InterestingPropertiesClearer.INSTANCE);
		this.rootConnection.clearInterestingProperties();
	}",0,[0]
351,Bears-15,"@Override
    public Object findKeySerializer(Annotated a)
    {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        if (ann != null) {
            @SuppressWarnings(""rawtypes"")
            Class<? extends JsonSerializer> serClass = ann.keyUsing();
            if (serClass != JsonSerializer.None.class) {
                return serClass;
            }
        }
        return null;
    }","@Override
    public Object findKeySerializer(Annotated a)
    {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        if (ann != null) {
            @SuppressWarnings(""rawtypes"")
            Class<? extends JsonSerializer> serClass = ann.keyUsing();
            if (serClass != JsonSerializer.None.class) {
                return serClass;
            }
        }
        return null;
    }",0,[0]
1036,Bears-136,"public EelinkProtocolEncoder(boolean connectionless) {
        this.connectionless = connectionless;
    }","public EelinkProtocolEncoder(boolean connectionless) {
        this.connectionless = connectionless;
    }",0,[0]
4637,bugs-dot-jar_MATH-326_ce185345,"public double getDistance(double[] v) throws IllegalArgumentException {
        return getDistance(new ArrayRealVector(v,false));
    }","public double getDistance(double[] v) throws IllegalArgumentException {
        return getDistance(new ArrayRealVector(v,false));
    }",0,[0]
10045,bugs-dot-jar_FLINK-2707_3e233a38,"@SuppressWarnings(""unchecked"")
	@Override
	public <S, C extends Serializable> OperatorState<S> getOperatorState(String name,
			S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {
		if (defaultState == null) {
			throw new RuntimeException(""Cannot set default state to null."");
		}
		StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);
		state.setDefaultState(defaultState);
		state.setCheckpointer(checkpointer);

		return (OperatorState<S>) state;
	}","@SuppressWarnings(""unchecked"")
	@Override
	public <S, C extends Serializable> OperatorState<S> getOperatorState(String name,
			S defaultState, boolean partitioned, StateCheckpointer<S, C> checkpointer) throws IOException {
		if (defaultState == null) {
			throw new RuntimeException(""Cannot set default state to null."");
		}
		StreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);
		state.setCheckpointer(checkpointer);
		state.setDefaultState(defaultState);

		return (OperatorState<S>) state;
	}",1,[8]
18566,bugs-dot-jar_OAK-395_4ed7bc8e,"@Override
    public void orderBefore(final String srcChildRelPath, final String destChildRelPath) throws RepositoryException {
        checkStatus();

        sessionDelegate.perform(new SessionOperation<Void>() {
            @Override
            public Void perform() throws RepositoryException {
                String oakSrcChildRelPath =
                        sessionDelegate.getOakPathOrThrowNotFound(srcChildRelPath);
                String oakDestChildRelPath = null;
                if (destChildRelPath != null) {
                    oakDestChildRelPath =
                            sessionDelegate.getOakPathOrThrowNotFound(destChildRelPath);
                }
                dlg.orderBefore(oakSrcChildRelPath, oakDestChildRelPath);
                return null;
            }
        });
    }","@Override
    public void orderBefore(final String srcChildRelPath, final String destChildRelPath) throws RepositoryException {
        checkStatus();

        sessionDelegate.perform(new SessionOperation<Void>() {
            @Override
            public Void perform() throws RepositoryException {
                String oakSrcChildRelPath =
                        sessionDelegate.getOakPathOrThrowNotFound(srcChildRelPath);
                String oakDestChildRelPath = null;
                if (destChildRelPath != null) {
                    oakDestChildRelPath =
                            sessionDelegate.getOakPathOrThrowNotFound(destChildRelPath);
                }
                dlg.orderBefore(oakSrcChildRelPath, oakDestChildRelPath);
                return null;
            }
        });
    }",0,[0]
4101,bugs-dot-jar_WICKET-3620_1a2bc1bc,"@Override
	public void setContentType(String mimeType)
	{
		actions.add(new SetContentTypeAction(mimeType));
	}","@Override
	public void setContentType(String mimeType)
	{
		actions.add(new SetContentTypeAction(mimeType));
	}",0,[0]
345,Bears-15,"@Override
    public List<NamedType> findSubtypes(Annotated a)
    {
        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);
        if (t == null) return null;
        JsonSubTypes.Type[] types = t.value();
        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);
        for (JsonSubTypes.Type type : types) {
            result.add(new NamedType(type.value(), type.name()));
        }
        return result;
    }","@Override
    public List<NamedType> findSubtypes(Annotated a)
    {
        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);
        if (t == null) return null;
        JsonSubTypes.Type[] types = t.value();
        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);
        for (JsonSubTypes.Type type : types) {
            result.add(new NamedType(type.value(), type.name()));
        }
        return result;
    }",0,[0]
566,bugs-dot-jar_MATH-1300_1d635088,"@Override
    public boolean nextBoolean() {
        return nextDouble() <= 0.5;
    }","@Override
    public boolean nextBoolean() {
        return nextDouble() <= 0.5;
    }",0,[0]
5441,bugs-dot-jar_OAK-1186_52372042,"@Nonnull
    @Override
    public NodeState merge(@Nonnull NodeBuilder builder,
                           @Nonnull CommitHook commitHook,
                           @Nullable CommitInfo info)
            throws CommitFailedException {
        return asMongoRootBuilder(builder).merge(commitHook, info);
    }","@Nonnull
    @Override
    public NodeState merge(@Nonnull NodeBuilder builder,
                           @Nonnull CommitHook commitHook,
                           @Nullable CommitInfo info)
            throws CommitFailedException {
        return asMongoRootBuilder(builder).merge(commitHook, info);
    }",0,[0]
16611,bugs-dot-jar_FLINK-1848_7164b2b6,"@Override
	public BlockLocation[] getFileBlockLocations(final FileStatus file, final long start, final long len)
			throws IOException {

		final BlockLocation[] blockLocations = new BlockLocation[1];
		blockLocations[0] = new LocalBlockLocation(this.hostName, file.getLen());

		return blockLocations;
	}","@Override
	public BlockLocation[] getFileBlockLocations(final FileStatus file, final long start, final long len)
			throws IOException {

		final BlockLocation[] blockLocations = new BlockLocation[1];
		blockLocations[0] = new LocalBlockLocation(this.hostName, file.getLen());

		return blockLocations;
	}",0,[0]
107,Bears-6,"public AnnotatedMember getAnyGetter()
    {
        if (!_collected) {
            collectAll();
        }
        if (_anyGetters != null) {
            if (_anyGetters.size() > 1) {
                reportProblem(""Multiple 'any-getters' defined (""+_anyGetters.get(0)+"" vs ""
                        +_anyGetters.get(1)+"")"");
            }
            return _anyGetters.getFirst();
        }        
        return null;
    }","public AnnotatedMember getAnyGetter()
    {
        if (!_collected) {
            collectAll();
        }
        if (_anyGetters != null) {
            if (_anyGetters.size() > 1) {
                reportProblem(""Multiple 'any-getters' defined (""+_anyGetters.get(0)+"" vs ""
                        +_anyGetters.get(1)+"")"");
            }
            return _anyGetters.getFirst();
        }        
        return null;
    }",0,[0]
15379,bugs-dot-jar_MNG-1895_806eaeb0,"public Object getKey()
    {
        return artifact.getDependencyConflictId();
    }","public Object getKey()
    {
        return artifact.getDependencyConflictId();
    }",0,[0]
19946,bugs-dot-jar_FLINK-3052_8dc70f2e,"public OptimizerNode getInitialSolutionSetPredecessorNode() {
		return getFirstPredecessorNode();
	}","public OptimizerNode getInitialSolutionSetPredecessorNode() {
		return getFirstPredecessorNode();
	}",0,[0]
1763,bugs-dot-jar_MATH-482_6d6649ef,"private static void splitMult(double a[], double b[], double ans[]) {
        ans[0] = a[0] * b[0];
        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];

        /* Resplit */
        resplit(ans);
    }","private static void splitMult(double a[], double b[], double ans[]) {
        ans[0] = a[0] * b[0];
        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];

        /* Resplit */
        resplit(ans);
    }",0,[0]
5389,bugs-dot-jar_FLINK-3534_734ba01d,"private boolean transitionState(JobStatus current, JobStatus newState, Throwable error) {
		if (STATE_UPDATER.compareAndSet(this, current, newState)) {
			if (LOG.isDebugEnabled()) {
				LOG.debug(""{} switched from {} to {}."", this.getJobName(), current, newState);
			}

			stateTimestamps[newState.ordinal()] = System.currentTimeMillis();
			notifyJobStatusChange(newState, error);
			return true;
		}
		else {
			return false;
		}
	}","private boolean transitionState(JobStatus current, JobStatus newState, Throwable error) {
		if (STATE_UPDATER.compareAndSet(this, current, newState)) {
			if (LOG.isDebugEnabled()) {
				LOG.debug(""{} switched from {} to {}."", this.getJobName(), current, newState);
			}

			stateTimestamps[newState.ordinal()] = System.currentTimeMillis();
			notifyJobStatusChange(newState, error);
			return true;
		}
		else {
			return false;
		}
	}",0,[0]
35530,bugs-dot-jar_OAK-3930_b939aa6e,"private static String getAttribute(Attributes attributes, String namespaceUri, String localName) {
        return attributes.getValue(namespaceUri, localName);
    }","private static String getAttribute(Attributes attributes, String namespaceUri, String localName) {
        return attributes.getValue(namespaceUri, localName);
    }",0,[0]
24221,bugs-dot-jar_WICKET-2839_15477252,"@Override
	public String getContentType()
	{
		testContentType();
		return contentType;
	}","@Override
	public String getContentType()
	{
		testContentType();
		return contentType;
	}",0,[0]
21949,bugs-dot-jar_MATH-370_495f04bc,"public static double[] normalizeArray(double[] values, double normalizedSum)
       throws ArithmeticException, IllegalArgumentException {
         if (Double.isInfinite(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     LocalizedFormats.NORMALIZE_INFINITE);
         }
         if (Double.isNaN(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     LocalizedFormats.NORMALIZE_NAN);
         }
         double sum = 0d;
         final int len = values.length;
         double[] out = new double[len];
         for (int i = 0; i < len; i++) {
             if (Double.isInfinite(values[i])) {
                 throw MathRuntimeException.createArithmeticException(
                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
             }
             if (!Double.isNaN(values[i])) {
                 sum += values[i];
             }
         }
         if (sum == 0) {
             throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
         }
         for (int i = 0; i < len; i++) {
             if (Double.isNaN(values[i])) {
                 out[i] = Double.NaN;
             } else {
                 out[i] = values[i] * normalizedSum / sum;
             }
         }
         return out;
     }","public static double[] normalizeArray(double[] values, double normalizedSum)
       throws ArithmeticException, IllegalArgumentException {
         if (Double.isInfinite(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     LocalizedFormats.NORMALIZE_INFINITE);
         }
         if (Double.isNaN(normalizedSum)) {
             throw MathRuntimeException.createIllegalArgumentException(
                     LocalizedFormats.NORMALIZE_NAN);
         }
         double sum = 0d;
         final int len = values.length;
         double[] out = new double[len];
         for (int i = 0; i < len; i++) {
             if (Double.isInfinite(values[i])) {
                 throw MathRuntimeException.createArithmeticException(
                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);
             }
             if (!Double.isNaN(values[i])) {
                 sum += values[i];
             }
         }
         if (sum == 0) {
             throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);
         }
         for (int i = 0; i < len; i++) {
             if (Double.isNaN(values[i])) {
                 out[i] = Double.NaN;
             } else {
                 out[i] = values[i] * normalizedSum / sum;
             }
         }
         return out;
     }",0,[0]
34917,bugs-dot-jar_CAMEL-5570_a57830ed,"@Deprecated
    public OnExceptionDefinition useOriginalBody() {
        setUseOriginalMessagePolicy(Boolean.TRUE);
        return this;
    }","@Deprecated
    public OnExceptionDefinition useOriginalBody() {
        setUseOriginalMessagePolicy(Boolean.TRUE);
        return this;
    }",0,[0]
22446,bugs-dot-jar_CAMEL-7611_e30f1c53,"@Override
    public String toString() {
        return key + "" -> "" + value;
    }","@Override
    public String toString() {
        return key + "" -> "" + value;
    }",0,[0]
10298,bugs-dot-jar_OAK-3897_94c6c575,"private String diffImpl(DocumentNodeState from, DocumentNodeState to)
            throws DocumentStoreException {
        JsopWriter w = new JsopStream();
        // TODO this does not work well for large child node lists
        // use a document store index instead
        int max = MANY_CHILDREN_THRESHOLD;

        final boolean debug = LOG.isDebugEnabled();
        final long start = debug ? now() : 0;

        DocumentNodeState.Children fromChildren, toChildren;
        fromChildren = getChildren(from, null, max);
        toChildren = getChildren(to, null, max);

        final long getChildrenDoneIn = debug ? now() : 0;

        String diffAlgo;
        RevisionVector fromRev = from.getLastRevision();
        RevisionVector toRev = to.getLastRevision();
        if (!fromChildren.hasMore && !toChildren.hasMore) {
            diffAlgo = ""diffFewChildren"";
            diffFewChildren(w, from.getPath(), fromChildren,
                    fromRev, toChildren, toRev);
        } else {
            if (FAST_DIFF) {
                diffAlgo = ""diffManyChildren"";
                fromRev = from.getRootRevision();
                toRev = to.getRootRevision();
                diffManyChildren(w, from.getPath(), fromRev, toRev);
            } else {
                diffAlgo = ""diffAllChildren"";
                max = Integer.MAX_VALUE;
                fromChildren = getChildren(from, null, max);
                toChildren = getChildren(to, null, max);
                diffFewChildren(w, from.getPath(), fromChildren,
                        fromRev, toChildren, toRev);
            }
        }

        String diff = w.toString();
        if (debug) {
            long end = now();
            LOG.debug(""Diff performed via '{}' at [{}] between revisions [{}] => [{}] took {} ms ({} ms), diff '{}'"",
                    diffAlgo, from.getPath(), fromRev, toRev,
                    end - start, getChildrenDoneIn - start, diff);
        }
        return diff;
    }","private String diffImpl(DocumentNodeState from, DocumentNodeState to)
            throws DocumentStoreException {
        JsopWriter w = new JsopStream();
        // TODO this does not work well for large child node lists
        // use a document store index instead
        int max = MANY_CHILDREN_THRESHOLD;

        final boolean debug = LOG.isDebugEnabled();
        final long start = debug ? now() : 0;

        DocumentNodeState.Children fromChildren, toChildren;
        fromChildren = getChildren(from, null, max);
        toChildren = getChildren(to, null, max);

        final long getChildrenDoneIn = debug ? now() : 0;

        String diffAlgo;
        RevisionVector fromRev = from.getLastRevision();
        RevisionVector toRev = to.getLastRevision();
        if (!fromChildren.hasMore && !toChildren.hasMore) {
            diffAlgo = ""diffFewChildren"";
            diffFewChildren(w, from.getPath(), fromChildren,
                    fromRev, toChildren, toRev);
        } else {
            if (FAST_DIFF) {
                diffAlgo = ""diffManyChildren"";
                fromRev = from.getRootRevision();
                toRev = to.getRootRevision();
                diffManyChildren(w, from.getPath(), fromRev, toRev);
            } else {
                diffAlgo = ""diffAllChildren"";
                max = Integer.MAX_VALUE;
                fromChildren = getChildren(from, null, max);
                toChildren = getChildren(to, null, max);
                diffFewChildren(w, from.getPath(), fromChildren,
                        fromRev, toChildren, toRev);
            }
        }

        String diff = w.toString();
        if (debug) {
            long end = now();
            LOG.debug(""Diff performed via '{}' at [{}] between revisions [{}] => [{}] took {} ms ({} ms), diff '{}'"",
                    diffAlgo, from.getPath(), fromRev, toRev,
                    end - start, getChildrenDoneIn - start, diff);
        }
        return diff;
    }",0,[0]
11268,bugs-dot-jar_CAMEL-7130_cc192f87,"public ErrorListener getErrorListener() {
        return errorListener;
    }","public ErrorListener getErrorListener() {
        return errorListener;
    }",0,[0]
1809,Bears-202,"public List<ModuleRef> getModules() {
        try {
            try (AutoCloseableExecutorService executorService = new AutoCloseableExecutorService(
                    DEFAULT_NUM_WORKER_THREADS)) {
                scanSpec.performScan = false;
                try (ScanResult scanResult = executorService.submit( //
                        new Scanner(scanSpec, executorService, DEFAULT_NUM_WORKER_THREADS,
                                /* scanResultProcessor = */ null, /* failureHandler = */ null, topLevelLog))
                        .get()) {
                    return scanResult.getModules();
                }
            }
        } catch (final InterruptedException e) {
            if (topLevelLog != null) {
                topLevelLog.log(""Thread interrupted while getting modules"");
            }
            throw new IllegalArgumentException(""Scan interrupted"", e);
        } catch (final ExecutionException e) {
            if (topLevelLog != null) {
                topLevelLog.log(""Exception while getting modules"", e);
            }
            final Throwable cause = e.getCause();
            throw new RuntimeException(cause == null ? e : cause);
        } finally {
            if (topLevelLog != null) {
                topLevelLog.flush();
            }
        }
    }","public List<ModuleRef> getModules() {
        try {
            try (AutoCloseableExecutorService executorService = new AutoCloseableExecutorService(
                    DEFAULT_NUM_WORKER_THREADS)) {
                scanSpec.performScan = false;
                try (ScanResult scanResult = executorService.submit( //
                        new Scanner(scanSpec, executorService, DEFAULT_NUM_WORKER_THREADS,
                                /* scanResultProcessor = */ null, /* failureHandler = */ null, topLevelLog))
                        .get()) {
                    return scanResult.getModules();
                }
            }
        } catch (final InterruptedException e) {
            if (topLevelLog != null) {
                topLevelLog.log(""Thread interrupted while getting modules"");
            }
            throw new IllegalArgumentException(""Scan interrupted"", e);
        } catch (final ExecutionException e) {
            if (topLevelLog != null) {
                topLevelLog.log(""Exception while getting modules"", e);
            }
            final Throwable cause = e.getCause();
            throw new RuntimeException(cause == null ? e : cause);
        } finally {
            if (topLevelLog != null) {
                topLevelLog.flush();
            }
        }
    }",0,[0]
4608,bugs-dot-jar_MATH-950_424cbd20,"public int getEvaluations() {
        return evaluations.getCount();
    }","public int getEvaluations() {
        return evaluations.getCount();
    }",0,[0]
22647,bugs-dot-jar_WICKET-5204_9e6efa61,"protected void configure(Map<String, Object> widgetProperties)
	{
	}","protected void configure(Map<String, Object> widgetProperties)
	{
	}",0,[0]
1833,Bears-211,"@Override
    public CBORParser createParser(byte[] data) throws IOException {
        return _createParser(data, 0, data.length, _createContext(data, true));
    }","@Override
    public CBORParser createParser(byte[] data) throws IOException {
        return createParser(data, 0, data.length);
    }",1,[2]
20853,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Converter
    public static String toString(InputStream in, Exchange exchange) throws IOException {
        return toString(toReader(in, exchange));
    }","@Converter
    public static String toString(InputStream in, Exchange exchange) throws IOException {
        return toString(toReader(in, exchange));
    }",0,[0]
9722,bugs-dot-jar_OAK-614_6feacf6b,"@Override
    public Iterable<? extends PropertyState> getProperties() {
        return read().getProperties();
    }","@Override
    public Iterable<? extends PropertyState> getProperties() {
        return read().getProperties();
    }",0,[0]
37779,bugs-dot-jar_WICKET-3647_1b57b51c,"public final String getAjaxRegionMarkupId()
	{
		String markupId = null;
		for (Behavior behavior : getBehaviors())
		{
			if (behavior instanceof IAjaxRegionMarkupIdProvider)
			{
				markupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(this);
			}
		}
		if (markupId == null)
		{
			if (this instanceof IAjaxRegionMarkupIdProvider)
			{
				markupId = ((IAjaxRegionMarkupIdProvider)this).getAjaxRegionMarkupId(this);
			}
		}
		if (markupId == null)
		{
			markupId = getMarkupId();
		}
		return markupId;
	}","public final String getAjaxRegionMarkupId()
	{
		String markupId = null;
		for (Behavior behavior : getBehaviors())
		{
			if (behavior instanceof IAjaxRegionMarkupIdProvider)
			{
				markupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(this);
			}
		}
		if (markupId == null)
		{
			if (this instanceof IAjaxRegionMarkupIdProvider)
			{
				markupId = ((IAjaxRegionMarkupIdProvider)this).getAjaxRegionMarkupId(this);
			}
		}
		if (markupId == null)
		{
			markupId = getMarkupId();
		}
		return markupId;
	}",0,[0]
4654,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapCos() {
        return copy().mapCosToSelf();
    }","public RealVector mapCos() {
        return copy().mapCosToSelf();
    }",0,[0]
17784,bugs-dot-jar_OAK-740_35a7f014,"public void remove(String path) {
        Preconditions.checkArgument(path.startsWith(this.path));
        remove.add(path.substring(this.path.length()));
    }","public void remove(String path) {
        Preconditions.checkArgument(path.startsWith(this.path));
        remove.add(path.substring(this.path.length()));
    }",0,[0]
7538,bugs-dot-jar_WICKET-2624_ef880545,"private static Field findField(Class<?> clz, String expression)
	{
		Field field = null;
		try
		{
			field = clz.getField(expression);
		}
		catch (Exception e)
		{
			Class<?> tmp = clz;
			while (tmp != null && tmp != Object.class)
			{
				Field[] fields = tmp.getDeclaredFields();
				for (int i = 0; i < fields.length; i++)
				{
					if (fields[i].getName().equals(expression))
					{
						fields[i].setAccessible(true);
						return fields[i];
					}
				}
				tmp = tmp.getSuperclass();
			}
			log.debug(""Cannot find field "" + clz + ""."" + expression);
		}
		return field;
	}","private static Field findField(Class<?> clz, String expression)
	{
		Field field = null;
		try
		{
			field = clz.getField(expression);
		}
		catch (Exception e)
		{
			Class<?> tmp = clz;
			while (tmp != null && tmp != Object.class)
			{
				Field[] fields = tmp.getDeclaredFields();
				for (int i = 0; i < fields.length; i++)
				{
					if (fields[i].getName().equals(expression))
					{
						fields[i].setAccessible(true);
						return fields[i];
					}
				}
				tmp = tmp.getSuperclass();
			}
			log.debug(""Cannot find field "" + clz + ""."" + expression);
		}
		return field;
	}",0,[0]
7097,bugs-dot-jar_LOG4J2-763_97203de8,"protected void setId(final StructuredDataId id) {
        this.id = id;
    }","protected void setId(final StructuredDataId id) {
        this.id = id;
    }",0,[0]
33574,bugs-dot-jar_WICKET-4520_b91154ea,"public final void setApplicationSettings(final IApplicationSettings applicationSettings)
	{
		this.applicationSettings = applicationSettings;
	}","public final void setApplicationSettings(final IApplicationSettings applicationSettings)
	{
		this.applicationSettings = applicationSettings;
	}",0,[0]
20785,bugs-dot-jar_CAMEL-5215_033eb6fe,"public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {
        ObjectHelper.notNull(endpoint, ""endpoint"");

        // always create endpoint defined directory
        if (endpoint.isAutoCreate() && !endpoint.getFile().exists()) {
            LOG.trace(""Building starting directory: {}"", endpoint.getFile());
            endpoint.getFile().mkdirs();
        }

        if (ObjectHelper.isEmpty(directory)) {
            // no directory to build so return true to indicate ok
            return true;
        }

        File endpointPath = endpoint.getFile();
        File target = new File(directory);

        File path;
        if (absolute) {
            // absolute path
            path = target;
        } else if (endpointPath.equals(target)) {
            // its just the root of the endpoint path
            path = endpointPath;
        } else {
            // relative after the endpoint path
            String afterRoot = ObjectHelper.after(directory, endpointPath.getPath() + File.separator);
            if (ObjectHelper.isNotEmpty(afterRoot)) {
                // dir is under the root path
                path = new File(endpoint.getFile(), afterRoot);
            } else {
                // dir is relative to the root path
                path = new File(endpoint.getFile(), directory);
            }
        }

        // We need to make sure that this is thread-safe and only one thread tries to create the path directory at the same time.
        synchronized (this) {
            if (path.isDirectory() && path.exists()) {
                // the directory already exists
                return true;
            } else {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Building directory: {}"", path);
                }
                return path.mkdirs();
            }
        }
    }","public boolean buildDirectory(String directory, boolean absolute) throws GenericFileOperationFailedException {
        ObjectHelper.notNull(endpoint, ""endpoint"");

        // always create endpoint defined directory
        if (endpoint.isAutoCreate() && !endpoint.getFile().exists()) {
            LOG.trace(""Building starting directory: {}"", endpoint.getFile());
            endpoint.getFile().mkdirs();
        }

        if (ObjectHelper.isEmpty(directory)) {
            // no directory to build so return true to indicate ok
            return true;
        }

        File endpointPath = endpoint.getFile();
        File target = new File(directory);

        File path;
        if (absolute) {
            // absolute path
            path = target;
        } else if (endpointPath.equals(target)) {
            // its just the root of the endpoint path
            path = endpointPath;
        } else {
            // relative after the endpoint path
            String afterRoot = ObjectHelper.after(directory, endpointPath.getPath() + File.separator);
            if (ObjectHelper.isNotEmpty(afterRoot)) {
                // dir is under the root path
                path = new File(endpoint.getFile(), afterRoot);
            } else {
                // dir is relative to the root path
                path = new File(endpoint.getFile(), directory);
            }
        }

        // We need to make sure that this is thread-safe and only one thread tries to create the path directory at the same time.
        synchronized (this) {
            if (path.isDirectory() && path.exists()) {
                // the directory already exists
                return true;
            } else {
                if (LOG.isTraceEnabled()) {
                    LOG.trace(""Building directory: {}"", path);
                }
                return path.mkdirs();
            }
        }
    }",0,[0]
17341,bugs-dot-jar_FLINK-1951_adb321d6,"private AbstractJobVertex createDualInputVertex(DualInputPlanNode node) throws CompilerException {
		final String taskName = node.getNodeName();
		final DriverStrategy ds = node.getDriverStrategy();
		final AbstractJobVertex vertex = new AbstractJobVertex(taskName);
		final TaskConfig config = new TaskConfig(vertex.getConfiguration());
		vertex.setInvokableClass( (this.currentIteration != null && node.isOnDynamicPath()) ? IterationIntermediatePactTask.class : RegularPactTask.class);
		
		// set user code
		config.setStubWrapper(node.getProgramOperator().getUserCodeWrapper());
		config.setStubParameters(node.getProgramOperator().getParameters());
		
		// set the driver strategy
		config.setDriver(ds.getDriverClass());
		config.setDriverStrategy(ds);
		if (node.getComparator1() != null) {
			config.setDriverComparator(node.getComparator1(), 0);
		}
		if (node.getComparator2() != null) {
			config.setDriverComparator(node.getComparator2(), 1);
		}
		if (node.getPairComparator() != null) {
			config.setDriverPairComparator(node.getPairComparator());
		}
		
		// assign memory, file-handles, etc.
		assignDriverResources(node, config);
		return vertex;
	}","private AbstractJobVertex createDualInputVertex(DualInputPlanNode node) throws CompilerException {
		final String taskName = node.getNodeName();
		final DriverStrategy ds = node.getDriverStrategy();
		final AbstractJobVertex vertex = new AbstractJobVertex(taskName);
		final TaskConfig config = new TaskConfig(vertex.getConfiguration());
		vertex.setInvokableClass( (this.currentIteration != null && node.isOnDynamicPath()) ? IterationIntermediatePactTask.class : RegularPactTask.class);
		
		// set user code
		config.setStubWrapper(node.getProgramOperator().getUserCodeWrapper());
		config.setStubParameters(node.getProgramOperator().getParameters());
		
		// set the driver strategy
		config.setDriver(ds.getDriverClass());
		config.setDriverStrategy(ds);
		if (node.getComparator1() != null) {
			config.setDriverComparator(node.getComparator1(), 0);
		}
		if (node.getComparator2() != null) {
			config.setDriverComparator(node.getComparator2(), 1);
		}
		if (node.getPairComparator() != null) {
			config.setDriverPairComparator(node.getPairComparator());
		}
		
		// assign memory, file-handles, etc.
		assignDriverResources(node, config);
		return vertex;
	}",0,[0]
40710,bugs-dot-jar_WICKET-442_246d53c5,"public String toString()
	{
		StringBuffer buf = new StringBuffer(getClass().getName()).append(""@"").append(hashCode())
				.append(getPage().toString()).append(""->"").append(getTarget().getId()).append(""->"")
				.append(getRequestListenerInterface().getMethod().getDeclaringClass()).append(""."")
				.append(getRequestListenerInterface().getName());

		if (requestParameters != null)
		{
			buf.append("" (request paramaters: "").append(requestParameters.toString()).append("")"");
		}
		return buf.toString();
	}","public String toString()
	{
		StringBuffer buf = new StringBuffer(getClass().getName()).append(""@"").append(hashCode())
				.append(getPage().toString()).append(""->"").append(getTarget().getId()).append(""->"")
				.append(getRequestListenerInterface().getMethod().getDeclaringClass()).append(""."")
				.append(getRequestListenerInterface().getName());

		if (requestParameters != null)
		{
			buf.append("" (request paramaters: "").append(requestParameters.toString()).append("")"");
		}
		return buf.toString();
	}",0,[0]
8986,bugs-dot-jar_ACCUMULO-1051_25cf3ccd,"@Override
  public Iterator<byte[]> iterator() {
    return immutableList.iterator();
  }","@Override
  public Iterator<byte[]> iterator() {
    return immutableList.iterator();
  }",0,[0]
930,Bears-123,"public static <T extends BaseReport> Collection<T> detectTripsAndStops(Collection<Position> positionCollection,
            TripsConfig tripsConfig, boolean ignoreOdometer, double speedThreshold, Class<T> reportClass) {
        Collection<T> result = new ArrayList<>();

        ArrayList<Position> positions = new ArrayList<>(positionCollection);
        if (positions != null && !positions.isEmpty()) {
            boolean trips = reportClass.equals(TripReport.class);
            MotionEventHandler  motionHandler = new MotionEventHandler(tripsConfig);
            DeviceState deviceState = new DeviceState();
            deviceState.setMotionState(isMoving(positions, 0, tripsConfig, speedThreshold));
            int startEventIndex = trips == deviceState.getMotionState() ? 0 : -1;
            int startNoEventIndex = -1;
            for (int i = 0; i < positions.size(); i++) {
                Map<Event, Position> event = motionHandler.updateMotionState(deviceState, positions.get(i),
                        isMoving(positions, i, tripsConfig, speedThreshold));
                if (deviceState.getMotionPosition() != null && startEventIndex == -1
                        && trips != deviceState.getMotionState()) {
                    startEventIndex = i;
                    startNoEventIndex = -1;
                }
                if (trips == deviceState.getMotionState()) {
                    if (startNoEventIndex == -1) {
                        startNoEventIndex = i;
                    } else if (deviceState.getMotionPosition() == null) {
                        startNoEventIndex = -1;
                    }
                }
                if (startEventIndex != -1 && startNoEventIndex != -1 && event != null
                        && trips != deviceState.getMotionState()) {
                    result.add(calculateTripOrStop(positions, startEventIndex, startNoEventIndex,
                            ignoreOdometer, reportClass));
                    startEventIndex = -1;
                }
            }
            if (startEventIndex != -1 && (startNoEventIndex != -1 || !trips)) {
                result.add(calculateTripOrStop(positions, startEventIndex,
                            startNoEventIndex != -1 ? startNoEventIndex : positions.size() - 1,
                            ignoreOdometer, reportClass));
            }
        }
        return result;
    }","public static <T extends BaseReport> Collection<T> detectTripsAndStops(Collection<Position> positionCollection,
            TripsConfig tripsConfig, boolean ignoreOdometer, double speedThreshold, Class<T> reportClass) {
        Collection<T> result = new ArrayList<>();

        ArrayList<Position> positions = new ArrayList<>(positionCollection);
        if (positions != null && !positions.isEmpty()) {
            boolean trips = reportClass.equals(TripReport.class);
            MotionEventHandler  motionHandler = new MotionEventHandler(tripsConfig);
            DeviceState deviceState = new DeviceState();
            deviceState.setMotionState(isMoving(positions, 0, tripsConfig, speedThreshold));
            int startEventIndex = trips == deviceState.getMotionState() ? 0 : -1;
            int startNoEventIndex = -1;
            for (int i = 0; i < positions.size(); i++) {
                Map<Event, Position> event = motionHandler.updateMotionState(deviceState, positions.get(i),
                        isMoving(positions, i, tripsConfig, speedThreshold));
                if (startEventIndex == -1
                        && (trips != deviceState.getMotionState() && deviceState.getMotionPosition() != null
                        || trips == deviceState.getMotionState() && event != null)) {
                    startEventIndex = i;
                    startNoEventIndex = -1;
                } else if (trips != deviceState.getMotionState() && startEventIndex != -1
                        && deviceState.getMotionPosition() == null && event == null) {
                    startEventIndex = -1;
                }
                if (startNoEventIndex == -1
                        && (trips == deviceState.getMotionState() && deviceState.getMotionPosition() != null
                        || trips != deviceState.getMotionState() && event != null)) {
                    startNoEventIndex = i;
                } else if (startNoEventIndex != -1 && deviceState.getMotionPosition() == null && event == null) {
                    startNoEventIndex = -1;
                }
                if (startEventIndex != -1 && startNoEventIndex != -1 && event != null
                        && trips != deviceState.getMotionState()) {
                    result.add(calculateTripOrStop(positions, startEventIndex, startNoEventIndex,
                            ignoreOdometer, reportClass));
                    startEventIndex = -1;
                }
            }
            if (startEventIndex != -1 && (startNoEventIndex != -1 || !trips)) {
                result.add(calculateTripOrStop(positions, startEventIndex,
                            startNoEventIndex != -1 ? startNoEventIndex : positions.size() - 1,
                            ignoreOdometer, reportClass));
            }
        }
        return result;
    }",1,"[15, 16, 20, 21, 22, 23, 24, 25]"
38516,bugs-dot-jar_CAMEL-9124_9da2c05a,"public void setAsyncDelayedRedelivery(String asyncDelayedRedelivery) {
        this.asyncDelayedRedelivery = asyncDelayedRedelivery;
    }","public void setAsyncDelayedRedelivery(String asyncDelayedRedelivery) {
        this.asyncDelayedRedelivery = asyncDelayedRedelivery;
    }",0,[0]
18015,bugs-dot-jar_LOG4J2-676_3b2e880e,"private NoSQLObject<W> buildMarkerEntity(Marker marker) {
        final NoSQLObject<W> entity = this.connection.createObject();
        entity.set(""name"", marker.getName());

        final Marker[] parents = marker.getParents();
        if (parents != null) {
            @SuppressWarnings(""unchecked"")
            final NoSQLObject<W>[] parentEntities = new NoSQLObject[parents.length];
            for (int i = 0; i < parents.length; i++) {
                parentEntities[i] = buildMarkerEntity(parents[i]);
            }
            entity.set(""parents"", parentEntities);
        }
        return entity;
    }","private NoSQLObject<W> buildMarkerEntity(Marker marker) {
        final NoSQLObject<W> entity = this.connection.createObject();
        entity.set(""name"", marker.getName());

        final Marker[] parents = marker.getParents();
        if (parents != null) {
            @SuppressWarnings(""unchecked"")
            final NoSQLObject<W>[] parentEntities = new NoSQLObject[parents.length];
            for (int i = 0; i < parents.length; i++) {
                parentEntities[i] = buildMarkerEntity(parents[i]);
            }
            entity.set(""parents"", parentEntities);
        }
        return entity;
    }",0,[0]
24865,bugs-dot-jar_CAMEL-5187_8cadc344,"protected void createJmxConnector(String host) throws IOException {
        ObjectHelper.notEmpty(serviceUrlPath, ""serviceUrlPath"");
        ObjectHelper.notNull(registryPort, ""registryPort"");

        try {
            LocateRegistry.createRegistry(registryPort);
            LOG.debug(""Created JMXConnector RMI registry on port {}"", registryPort);
        } catch (RemoteException ex) {
            // The registry may had been created, we could get the registry instead
        }

        // must start with leading slash
        String path = serviceUrlPath.startsWith(""/"") ? serviceUrlPath : ""/"" + serviceUrlPath;
        // Create an RMI connector and start it
        final JMXServiceURL url;
        if (connectorPort > 0) {
            url = new JMXServiceURL(""service:jmx:rmi://"" + host + "":"" + connectorPort + ""/jndi/rmi://"" + host
                                    + "":"" + registryPort + path);
        } else {
            url = new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://"" + host + "":"" + registryPort + path);
        }

        cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);

        if (executorService == null) {
            // we only need a single thread for the JMX connector
            executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, ""JMXConnector: "" + url);
        }

        // execute the JMX connector
        executorService.execute(new Runnable() {
            public void run() {
                try {
                    cs.start();
                } catch (IOException ioe) {
                    LOG.warn(""Could not start JMXConnector thread."", ioe);
                }
            }
        });

        LOG.info(""JMX Connector thread started and listening at: "" + url);
    }","protected void createJmxConnector(String host) throws IOException {
        ObjectHelper.notEmpty(serviceUrlPath, ""serviceUrlPath"");
        ObjectHelper.notNull(registryPort, ""registryPort"");

        try {
            LocateRegistry.createRegistry(registryPort);
            LOG.debug(""Created JMXConnector RMI registry on port {}"", registryPort);
        } catch (RemoteException ex) {
            // The registry may had been created, we could get the registry instead
        }

        // must start with leading slash
        String path = serviceUrlPath.startsWith(""/"") ? serviceUrlPath : ""/"" + serviceUrlPath;
        // Create an RMI connector and start it
        final JMXServiceURL url;
        if (connectorPort > 0) {
            url = new JMXServiceURL(""service:jmx:rmi://"" + host + "":"" + connectorPort + ""/jndi/rmi://"" + host
                                    + "":"" + registryPort + path);
        } else {
            url = new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://"" + host + "":"" + registryPort + path);
        }

        cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);

        if (executorService == null) {
            // we only need a single thread for the JMX connector
            executorService = camelContext.getExecutorServiceManager().newSingleThreadExecutor(this, ""JMXConnector: "" + url);
        }

        // execute the JMX connector
        executorService.execute(new Runnable() {
            public void run() {
                try {
                    cs.start();
                } catch (IOException ioe) {
                    LOG.warn(""Could not start JMXConnector thread."", ioe);
                }
            }
        });

        LOG.info(""JMX Connector thread started and listening at: "" + url);
    }",0,[0]
1801,Bears-202,"public void scanAsync(final ExecutorService executorService, final int numParallelTasks,
            final ScanResultProcessor scanResultProcessor, final FailureHandler failureHandler) {
        if (scanResultProcessor == null) {
            // If scanResultProcessor is null, the scan won't do anything after completion, and the ScanResult will
            // simply be lost.
            throw new IllegalArgumentException(""scanResultProcessor cannot be null"");
        }
        if (failureHandler == null) {
            // The result of the Future<ScanObject> object returned by launchAsyncScan is discarded below, so we
            // force the addition of a FailureHandler so that exceptions are not silently swallowed.
            throw new IllegalArgumentException(""failureHandler cannot be null"");
        }
        // Drop the returned Future<ScanResult>, a ScanResultProcessor is used instead
        executorService.submit(new Scanner(scanSpec, executorService, numParallelTasks, scanResultProcessor,
                failureHandler, topLevelLog));
    }","public void scanAsync(final ExecutorService executorService, final int numParallelTasks,
            final ScanResultProcessor scanResultProcessor, final FailureHandler failureHandler) {
        if (scanResultProcessor == null) {
            // If scanResultProcessor is null, the scan won't do anything after completion, and the ScanResult will
            // simply be lost.
            throw new IllegalArgumentException(""scanResultProcessor cannot be null"");
        }
        if (failureHandler == null) {
            // The result of the Future<ScanObject> object returned by launchAsyncScan is discarded below, so we
            // force the addition of a FailureHandler so that exceptions are not silently swallowed.
            throw new IllegalArgumentException(""failureHandler cannot be null"");
        }
        // Drop the returned Future<ScanResult>, a ScanResultProcessor is used instead
        executorService.submit(new Scanner(scanSpec, executorService, numParallelTasks, scanResultProcessor,
                failureHandler, topLevelLog));
    }",0,[0]
38751,bugs-dot-jar_OAK-276_1bf5c550,"public StoredNode getNode(Id id) throws NotFoundException, Exception {
        verifyInitialized();

        StoredNode node = (StoredNode) cache.get(id);
        if (node != null) {
            return node;
        }

        node = new StoredNode(id, this);
        pm.readNode(node);

        cache.put(id, node);

        return node;
    }","public StoredNode getNode(Id id) throws NotFoundException, Exception {
        verifyInitialized();

        StoredNode node = (StoredNode) cache.get(id);
        if (node != null) {
            return node;
        }

        node = new StoredNode(id, this);
        pm.readNode(node);

        cache.put(id, node);

        return node;
    }",0,[0]
24788,bugs-dot-jar_FLINK-1930_4dbf030a,"private Buffer requestBuffer(boolean isBlocking) throws InterruptedException, IOException {
		synchronized (availableMemorySegments) {
			returnExcessMemorySegments();

			boolean askToRecycle = owner != null;

			while (availableMemorySegments.isEmpty()) {
				if (isDestroyed) {
					return null;
				}

				if (numberOfRequestedMemorySegments < currentPoolSize) {
					final MemorySegment segment = networkBufferPool.requestMemorySegment();

					if (segment != null) {
						numberOfRequestedMemorySegments++;
						availableMemorySegments.add(segment);

						continue;
					}
				}

				if (askToRecycle) {
					owner.releaseMemory(1);
				}

				if (isBlocking) {
					availableMemorySegments.wait(2000);
				}
				else {
					return null;
				}
			}

			return new Buffer(availableMemorySegments.poll(), this);
		}
	}","private Buffer requestBuffer(boolean isBlocking) throws InterruptedException, IOException {
		synchronized (availableMemorySegments) {
			returnExcessMemorySegments();

			boolean askToRecycle = owner != null;

			while (availableMemorySegments.isEmpty()) {
				if (isDestroyed) {
					throw new IllegalStateException(""Buffer pool is destroyed."");
				}

				if (numberOfRequestedMemorySegments < currentPoolSize) {
					final MemorySegment segment = networkBufferPool.requestMemorySegment();

					if (segment != null) {
						numberOfRequestedMemorySegments++;
						availableMemorySegments.add(segment);

						continue;
					}
				}

				if (askToRecycle) {
					owner.releaseMemory(1);
				}

				if (isBlocking) {
					availableMemorySegments.wait(2000);
				}
				else {
					return null;
				}
			}

			return new Buffer(availableMemorySegments.poll(), this);
		}
	}",1,[8]
8846,bugs-dot-jar_CAMEL-7275_44cad623,"@Override
    protected void doShutdown() throws Exception {
        ServiceHelper.stopAndShutdownServices(processors, errorHandlers, aggregationStrategy);
        // only clear error handlers when shutting down
        errorHandlers.clear();

        if (shutdownExecutorService && executorService != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(executorService);
        }
        if (aggregateExecutorService != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(aggregateExecutorService);
        }
    }","@Override
    protected void doShutdown() throws Exception {
        ServiceHelper.stopAndShutdownServices(processors, errorHandlers, aggregationStrategy);
        // only clear error handlers when shutting down
        errorHandlers.clear();

        if (shutdownExecutorService && executorService != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(executorService);
        }
        if (aggregateExecutorService != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(aggregateExecutorService);
        }
    }",0,[0]
3012,bugs-dot-jar_MATH-358_061f5017,"@Override
    public double integrate(final FirstOrderDifferentialEquations equations,
                            final double t0, final double[] y0,
                            final double t, final double[] y)
        throws DerivativeException, IntegratorException {

        final int n = y0.length;
        sanityChecks(equations, t0, y0, t, y);
        setEquations(equations);
        resetEvaluations();
        final boolean forward = t > t0;

        // initialize working arrays
        if (y != y0) {
            System.arraycopy(y0, 0, y, 0, n);
        }
        final double[] yDot = new double[y0.length];
        final double[] yTmp = new double[y0.length];

        // set up two interpolators sharing the integrator arrays
        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();
        interpolator.reinitialize(y, forward);
        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();
        interpolatorTmp.reinitialize(yTmp, forward);

        // set up integration control objects
        for (StepHandler handler : stepHandlers) {
            handler.reset();
        }
        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);


        // compute the initial Nordsieck vector using the configured starter integrator
        start(t0, y, t);
        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
        interpolator.storeTime(stepStart);

        double hNew = stepSize;
        interpolator.rescale(hNew);

        boolean lastStep = false;
        while (!lastStep) {

            // shift all data
            interpolator.shift();

            double error = 0;
            for (boolean loop = true; loop;) {

                stepSize = hNew;

                // predict a first estimate of the state at step end (P in the PECE sequence)
                final double stepEnd = stepStart + stepSize;
                interpolator.setInterpolatedTime(stepEnd);
                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);

                // evaluate a first estimate of the derivative (first E in the PECE sequence)
                computeDerivatives(stepEnd, yTmp, yDot);

                // update Nordsieck vector
                final double[] predictedScaled = new double[y0.length];
                for (int j = 0; j < y0.length; ++j) {
                    predictedScaled[j] = stepSize * yDot[j];
                }
                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);
                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);

                // apply correction (C in the PECE sequence)
                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));

                if (error <= 1.0) {

                    // evaluate a final estimate of the derivative (second E in the PECE sequence)
                    computeDerivatives(stepEnd, yTmp, yDot);

                    // update Nordsieck vector
                    final double[] correctedScaled = new double[y0.length];
                    for (int j = 0; j < y0.length; ++j) {
                        correctedScaled[j] = stepSize * yDot[j];
                    }
                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);

                    // discrete events handling
                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);
                    interpolatorTmp.storeTime(stepStart);
                    interpolatorTmp.shift();
                    interpolatorTmp.storeTime(stepEnd);
                    if (manager.evaluateStep(interpolatorTmp)) {
                        final double dt = manager.getEventTime() - stepStart;
                        if (Math.abs(dt) <= Math.ulp(stepStart)) {
                            // rejecting the step would lead to a too small next step, we accept it
                            loop = false;
                        } else {
                            // reject the step to match exactly the next switch time
                            hNew = dt;
                            interpolator.rescale(hNew);
                        }
                    } else {
                        // accept the step
                        scaled    = correctedScaled;
                        nordsieck = nordsieckTmp;
                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);
                        loop = false;
                    }

                } else {
                    // reject the step and attempt to reduce error by stepsize control
                    final double factor = computeStepGrowShrinkFactor(error);
                    hNew = filterStep(stepSize * factor, forward, false);
                    interpolator.rescale(hNew);
                }

            }

            // the step has been accepted (may have been truncated)
            final double nextStep = stepStart + stepSize;
            System.arraycopy(yTmp, 0, y, 0, n);
            interpolator.storeTime(nextStep);
            manager.stepAccepted(nextStep, y);
            lastStep = manager.stop();

            // provide the step data to the step handler
            for (StepHandler handler : stepHandlers) {
                interpolator.setInterpolatedTime(nextStep);
                handler.handleStep(interpolator, lastStep);
            }
            stepStart = nextStep;

            if (!lastStep && manager.reset(stepStart, y)) {

                // some events handler has triggered changes that
                // invalidate the derivatives, we need to restart from scratch
                start(stepStart, y, t);
                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);

            }

            if (! lastStep) {
                // in some rare cases we may get here with stepSize = 0, for example
                // when an event occurs at integration start, reducing the first step
                // to zero; we have to reset the step to some safe non zero value
                stepSize = filterStep(stepSize, forward, true);

                // stepsize control for next step
                final double  factor     = computeStepGrowShrinkFactor(error);
                final double  scaledH    = stepSize * factor;
                final double  nextT      = stepStart + scaledH;
                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
                hNew = filterStep(scaledH, forward, nextIsLast);
                interpolator.rescale(hNew);
            }

        }

        final double stopTime  = stepStart;
        stepStart = Double.NaN;
        stepSize  = Double.NaN;
        return stopTime;

    }","@Override
    public double integrate(final FirstOrderDifferentialEquations equations,
                            final double t0, final double[] y0,
                            final double t, final double[] y)
        throws DerivativeException, IntegratorException {

        final int n = y0.length;
        sanityChecks(equations, t0, y0, t, y);
        setEquations(equations);
        resetEvaluations();
        final boolean forward = t > t0;

        // initialize working arrays
        if (y != y0) {
            System.arraycopy(y0, 0, y, 0, n);
        }
        final double[] yDot = new double[y0.length];
        final double[] yTmp = new double[y0.length];

        // set up two interpolators sharing the integrator arrays
        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();
        interpolator.reinitialize(y, forward);
        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();
        interpolatorTmp.reinitialize(yTmp, forward);

        // set up integration control objects
        for (StepHandler handler : stepHandlers) {
            handler.reset();
        }
        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);


        // compute the initial Nordsieck vector using the configured starter integrator
        start(t0, y, t);
        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);
        interpolator.storeTime(stepStart);

        double hNew = stepSize;
        interpolator.rescale(hNew);

        boolean lastStep = false;
        while (!lastStep) {

            // shift all data
            interpolator.shift();

            double error = 0;
            for (boolean loop = true; loop;) {

                stepSize = hNew;

                // predict a first estimate of the state at step end (P in the PECE sequence)
                final double stepEnd = stepStart + stepSize;
                interpolator.setInterpolatedTime(stepEnd);
                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);

                // evaluate a first estimate of the derivative (first E in the PECE sequence)
                computeDerivatives(stepEnd, yTmp, yDot);

                // update Nordsieck vector
                final double[] predictedScaled = new double[y0.length];
                for (int j = 0; j < y0.length; ++j) {
                    predictedScaled[j] = stepSize * yDot[j];
                }
                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);
                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);

                // apply correction (C in the PECE sequence)
                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));

                if (error <= 1.0) {

                    // evaluate a final estimate of the derivative (second E in the PECE sequence)
                    computeDerivatives(stepEnd, yTmp, yDot);

                    // update Nordsieck vector
                    final double[] correctedScaled = new double[y0.length];
                    for (int j = 0; j < y0.length; ++j) {
                        correctedScaled[j] = stepSize * yDot[j];
                    }
                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);

                    // discrete events handling
                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);
                    interpolatorTmp.storeTime(stepStart);
                    interpolatorTmp.shift();
                    interpolatorTmp.storeTime(stepEnd);
                    if (manager.evaluateStep(interpolatorTmp)) {
                        final double dt = manager.getEventTime() - stepStart;
                        if (Math.abs(dt) <= Math.ulp(stepStart)) {
                            // we cannot simply truncate the step, reject the current computation
                            // and let the loop compute another state with the truncated step.
                            // it is so small (much probably exactly 0 due to limited accuracy)
                            // that the code above would fail handling it.
                            // So we set up an artificial 0 size step by copying states
                            interpolator.storeTime(stepStart);
                            System.arraycopy(y, 0, yTmp, 0, y0.length);
                            hNew     = 0;
                            stepSize = 0;
                            loop     = false;
                        } else {
                            // reject the step to match exactly the next switch time
                            hNew = dt;
                            interpolator.rescale(hNew);
                        }
                    } else {
                        // accept the step
                        scaled    = correctedScaled;
                        nordsieck = nordsieckTmp;
                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);
                        loop = false;
                    }

                } else {
                    // reject the step and attempt to reduce error by stepsize control
                    final double factor = computeStepGrowShrinkFactor(error);
                    hNew = filterStep(stepSize * factor, forward, false);
                    interpolator.rescale(hNew);
                }

            }

            // the step has been accepted (may have been truncated)
            final double nextStep = stepStart + stepSize;
            System.arraycopy(yTmp, 0, y, 0, n);
            interpolator.storeTime(nextStep);
            manager.stepAccepted(nextStep, y);
            lastStep = manager.stop();

            // provide the step data to the step handler
            for (StepHandler handler : stepHandlers) {
                interpolator.setInterpolatedTime(nextStep);
                handler.handleStep(interpolator, lastStep);
            }
            stepStart = nextStep;

            if (!lastStep && manager.reset(stepStart, y)) {

                // some events handler has triggered changes that
                // invalidate the derivatives, we need to restart from scratch
                start(stepStart, y, t);
                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);

            }

            if (! lastStep) {
                // in some rare cases we may get here with stepSize = 0, for example
                // when an event occurs at integration start, reducing the first step
                // to zero; we have to reset the step to some safe non zero value
                stepSize = filterStep(stepSize, forward, true);

                // stepsize control for next step
                final double  factor     = computeStepGrowShrinkFactor(error);
                final double  scaledH    = stepSize * factor;
                final double  nextT      = stepStart + scaledH;
                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
                hNew = filterStep(scaledH, forward, nextIsLast);
                interpolator.rescale(hNew);
            }

        }

        final double stopTime  = stepStart;
        stepStart = Double.NaN;
        stepSize  = Double.NaN;
        return stopTime;

    }",1,"[90, 91]"
34270,bugs-dot-jar_WICKET-4184_a0150366,"public AppendingStringBuffer append(final int i)
	{
		return append(String.valueOf(i));
	}","public AppendingStringBuffer append(final int i)
	{
		return append(String.valueOf(i));
	}",0,[0]
23580,bugs-dot-jar_FLINK-1290_45fb6d82,"@Override
	protected List<GlobalPropertiesPair> createPossibleGlobalProperties() {
		ArrayList<GlobalPropertiesPair> pairs = new ArrayList<GlobalPropertiesPair>();
		
		if (repartitionAllowed) {
			// partition both (hash or custom)
			RequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();
			if (customPartitioner == null) {
				partitioned1.setAnyPartitioning(this.keys1);
			} else {
				partitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);
			}
			
			RequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();
			if (customPartitioner == null) {
				partitioned2.setAnyPartitioning(this.keys2);
			} else {
				partitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);
			}
			
			pairs.add(new GlobalPropertiesPair(partitioned1, partitioned2));
		}
		
		if (broadcastSecondAllowed) {
			// replicate second
			RequestedGlobalProperties any1 = new RequestedGlobalProperties();
			RequestedGlobalProperties replicated2 = new RequestedGlobalProperties();
			replicated2.setFullyReplicated();
			pairs.add(new GlobalPropertiesPair(any1, replicated2));
		}
		
		if (broadcastFirstAllowed) {
			// replicate first
			RequestedGlobalProperties replicated1 = new RequestedGlobalProperties();
			replicated1.setFullyReplicated();
			RequestedGlobalProperties any2 = new RequestedGlobalProperties();
			pairs.add(new GlobalPropertiesPair(replicated1, any2));
		}
		return pairs;
	}","@Override
	protected List<GlobalPropertiesPair> createPossibleGlobalProperties() {
		ArrayList<GlobalPropertiesPair> pairs = new ArrayList<GlobalPropertiesPair>();
		
		if (repartitionAllowed) {
			// partition both (hash or custom)
			if (this.customPartitioner == null) {
				
				// we accept compatible partitionings of any type
				RequestedGlobalProperties partitioned_left_any = new RequestedGlobalProperties();
				RequestedGlobalProperties partitioned_right_any = new RequestedGlobalProperties();
				partitioned_left_any.setAnyPartitioning(this.keys1);
				partitioned_right_any.setAnyPartitioning(this.keys2);
				pairs.add(new GlobalPropertiesPair(partitioned_left_any, partitioned_right_any));
				
				// we also explicitly add hash partitioning, as a fallback, if the any-pairs do not match
				RequestedGlobalProperties partitioned_left_hash = new RequestedGlobalProperties();
				RequestedGlobalProperties partitioned_right_hash = new RequestedGlobalProperties();
				partitioned_left_hash.setHashPartitioned(this.keys1);
				partitioned_right_hash.setHashPartitioned(this.keys2);
				pairs.add(new GlobalPropertiesPair(partitioned_left_hash, partitioned_right_hash));
			}
			else {
				RequestedGlobalProperties partitioned_left = new RequestedGlobalProperties();
				partitioned_left.setCustomPartitioned(this.keys1, this.customPartitioner);
				
				RequestedGlobalProperties partitioned_right = new RequestedGlobalProperties();
				partitioned_right.setCustomPartitioned(this.keys2, this.customPartitioner);
				
				return Collections.singletonList(new GlobalPropertiesPair(partitioned_left, partitioned_right));
			}
			
			
			RequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();
			if (customPartitioner == null) {
				partitioned1.setAnyPartitioning(this.keys1);
			} else {
				partitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);
			}
			
			RequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();
			if (customPartitioner == null) {
				partitioned2.setAnyPartitioning(this.keys2);
			} else {
				partitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);
			}
			
			pairs.add(new GlobalPropertiesPair(partitioned1, partitioned2));
		}
		
		if (broadcastSecondAllowed) {
			// replicate second
			RequestedGlobalProperties any1 = new RequestedGlobalProperties();
			RequestedGlobalProperties replicated2 = new RequestedGlobalProperties();
			replicated2.setFullyReplicated();
			pairs.add(new GlobalPropertiesPair(any1, replicated2));
		}
		
		if (broadcastFirstAllowed) {
			// replicate first
			RequestedGlobalProperties replicated1 = new RequestedGlobalProperties();
			replicated1.setFullyReplicated();
			RequestedGlobalProperties any2 = new RequestedGlobalProperties();
			pairs.add(new GlobalPropertiesPair(replicated1, any2));
		}
		return pairs;
	}",1,[]
481,Bears-16,"public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen)
        throws IOException
    {
        gen.writeFieldName(fieldName);
        if (value == null) {
            /* Note: can't easily check for suppression at this point
             * any more; caller must check it.
             */
            if (_stdNullValueSerializer) { // minor perf optimization
                gen.writeNull();
            } else {
                _nullValueSerializer.serialize(null, gen, this);
            }
        } else {
            Class<?> cls = value.getClass();
            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
        }
    }","public final void defaultSerializeField(String fieldName, Object value, JsonGenerator gen)
        throws IOException
    {
        gen.writeFieldName(fieldName);
        if (value == null) {
            /* Note: can't easily check for suppression at this point
             * any more; caller must check it.
             */
            if (_stdNullValueSerializer) { // minor perf optimization
                gen.writeNull();
            } else {
                _nullValueSerializer.serialize(null, gen, this);
            }
        } else {
            Class<?> cls = value.getClass();
            findTypedValueSerializer(cls, true, null).serialize(value, gen, this);
        }
    }",0,[0]
12721,bugs-dot-jar_WICKET-4121_8967eb2b,"public boolean isPreviousAvailable()
	{
		return !history.isEmpty();
	}","public boolean isPreviousAvailable()
	{
		return !history.isEmpty();
	}",0,[0]
14937,bugs-dot-jar_CAMEL-5683_0c3c7d1b,"public void resetCacheStatistics() {
        if (consumers instanceof LRUCache) {
            LRUCache<String, PollingConsumer> cache = (LRUCache<String, PollingConsumer>)consumers;
            cache.resetStatistics();
        }
    }","public void resetCacheStatistics() {
        if (consumers instanceof LRUCache) {
            LRUCache<String, PollingConsumer> cache = (LRUCache<String, PollingConsumer>)consumers;
            cache.resetStatistics();
        }
    }",0,[0]
4362,bugs-dot-jar_CAMEL-4682_1e54865c,"public void setInflightRepository(InflightRepository repository) {
        this.inflightRepository = repository;
    }","public void setInflightRepository(InflightRepository repository) {
        this.inflightRepository = repository;
    }",0,[0]
16557,bugs-dot-jar_ACCUMULO-4138_4d23d784,"public static OptionGroup addListDeleteGroup(final String name) {
    final Option addOpt = new Option(AdlOpt.ADD.opt, ""add"", false, ""add "" + name);
    final Option deleteOpt = new Option(AdlOpt.DELETE.opt, ""delete"", false, ""delete "" + name);
    final Option listOpt = new Option(AdlOpt.LIST.opt, ""list"", false, ""list "" + name + ""(s)"");
    final OptionGroup og = new OptionGroup();
    og.addOption(addOpt);
    og.addOption(deleteOpt);
    og.addOption(listOpt);
    og.setRequired(true);
    return og;
  }","public static OptionGroup addListDeleteGroup(final String name) {
    final Option addOpt = new Option(AdlOpt.ADD.opt, ""add"", false, ""add "" + name);
    final Option deleteOpt = new Option(AdlOpt.DELETE.opt, ""delete"", false, ""delete "" + name);
    final Option listOpt = new Option(AdlOpt.LIST.opt, ""list"", false, ""list "" + name + ""(s)"");
    final OptionGroup og = new OptionGroup();
    og.addOption(addOpt);
    og.addOption(deleteOpt);
    og.addOption(listOpt);
    og.setRequired(true);
    return og;
  }",0,[0]
34929,bugs-dot-jar_CAMEL-5570_a57830ed,"public RedeliveryPolicyDefinition getRedeliveryPolicy() {
        return redeliveryPolicy;
    }","public RedeliveryPolicyDefinition getRedeliveryPolicy() {
        return redeliveryPolicy;
    }",0,[0]
1195,Bears-152,"@Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
            throws BeansException {
        if (annotationPackage == null || annotationPackage.length() == 0) {
            return;
        }
        if (beanFactory instanceof BeanDefinitionRegistry) {
            try {
                // init scanner
                Class<?> scannerClass = ReflectUtils.forName(""org.springframework.context.annotation.ClassPathBeanDefinitionScanner"");
                Object scanner = scannerClass.getConstructor(new Class<?>[]{BeanDefinitionRegistry.class, boolean.class}).newInstance(new Object[]{(BeanDefinitionRegistry) beanFactory, true});
                // add filter
                Class<?> filterClass = ReflectUtils.forName(""org.springframework.core.type.filter.AnnotationTypeFilter"");
                Object filter = filterClass.getConstructor(Class.class).newInstance(Service.class);
                Method addIncludeFilter = scannerClass.getMethod(""addIncludeFilter"", ReflectUtils.forName(""org.springframework.core.type.filter.TypeFilter""));
                addIncludeFilter.invoke(scanner, filter);
                // scan packages
                String[] packages = Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);
                Method scan = scannerClass.getMethod(""scan"", new Class<?>[]{String[].class});
                scan.invoke(scanner, new Object[]{packages});
            } catch (Throwable e) {
                // spring 2.0
            }
        }
    }","@Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
            throws BeansException {
        if (annotationPackage == null || annotationPackage.length() == 0) {
            return;
        }
        if (beanFactory instanceof BeanDefinitionRegistry) {
            try {
                // init scanner
                Class<?> scannerClass = ReflectUtils.forName(""org.springframework.context.annotation.ClassPathBeanDefinitionScanner"");
                Object scanner = scannerClass.getConstructor(new Class<?>[]{BeanDefinitionRegistry.class, boolean.class}).newInstance(new Object[]{(BeanDefinitionRegistry) beanFactory, true});
                // add filter
                Class<?> filterClass = ReflectUtils.forName(""org.springframework.core.type.filter.AnnotationTypeFilter"");
                Object filter = filterClass.getConstructor(Class.class).newInstance(Service.class);
                Method addIncludeFilter = scannerClass.getMethod(""addIncludeFilter"", ReflectUtils.forName(""org.springframework.core.type.filter.TypeFilter""));
                addIncludeFilter.invoke(scanner, filter);
                // scan packages
                String[] packages = Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);
                Method scan = scannerClass.getMethod(""scan"", new Class<?>[]{String[].class});
                scan.invoke(scanner, new Object[]{packages});
            } catch (Throwable e) {
                // spring 2.0
            }
        }
    }",0,[0]
25584,bugs-dot-jar_ACCUMULO-2974_5eceb10e,"private void sendSplitRequest(MergeInfo info, TabletState state, TabletLocationState tls) {
    // Already split?
    if (!info.getState().equals(MergeState.SPLITTING))
      return;
    // Merges don't split
    if (!info.isDelete())
      return;
    // Online and ready to split?
    if (!state.equals(TabletState.HOSTED))
      return;
    // Does this extent cover the end points of the delete?
    KeyExtent range = info.getExtent();
    if (tls.extent.overlaps(range)) {
      for (Text splitPoint : new Text[] {range.getPrevEndRow(), range.getEndRow()}) {
        if (splitPoint == null)
          continue;
        if (!tls.extent.contains(splitPoint))
          continue;
        if (splitPoint.equals(tls.extent.getEndRow()))
          continue;
        if (splitPoint.equals(tls.extent.getPrevEndRow()))
          continue;
        try {
          TServerConnection conn;
          conn = this.master.tserverSet.getConnection(tls.current);
          if (conn != null) {
            Master.log.info(""Asking "" + tls.current + "" to split "" + tls.extent + "" at "" + splitPoint);
            conn.splitTablet(this.master.masterLock, tls.extent, splitPoint);
          } else {
            Master.log.warn(""Not connected to server "" + tls.current);
          }
        } catch (NotServingTabletException e) {
          Master.log.debug(""Error asking tablet server to split a tablet: "" + e);
        } catch (Exception e) {
          Master.log.warn(""Error asking tablet server to split a tablet: "" + e);
        }
      }
    }
  }","private void sendSplitRequest(MergeInfo info, TabletState state, TabletLocationState tls) {
    // Already split?
    if (!info.getState().equals(MergeState.SPLITTING))
      return;
    // Merges don't split
    if (!info.isDelete())
      return;
    // Online and ready to split?
    if (!state.equals(TabletState.HOSTED))
      return;
    // Does this extent cover the end points of the delete?
    KeyExtent range = info.getExtent();
    if (tls.extent.overlaps(range)) {
      for (Text splitPoint : new Text[] {range.getPrevEndRow(), range.getEndRow()}) {
        if (splitPoint == null)
          continue;
        if (!tls.extent.contains(splitPoint))
          continue;
        if (splitPoint.equals(tls.extent.getEndRow()))
          continue;
        if (splitPoint.equals(tls.extent.getPrevEndRow()))
          continue;
        try {
          TServerConnection conn;
          conn = this.master.tserverSet.getConnection(tls.current);
          if (conn != null) {
            Master.log.info(""Asking "" + tls.current + "" to split "" + tls.extent + "" at "" + splitPoint);
            conn.splitTablet(this.master.masterLock, tls.extent, splitPoint);
          } else {
            Master.log.warn(""Not connected to server "" + tls.current);
          }
        } catch (NotServingTabletException e) {
          Master.log.debug(""Error asking tablet server to split a tablet: "" + e);
        } catch (Exception e) {
          Master.log.warn(""Error asking tablet server to split a tablet: "" + e);
        }
      }
    }
  }",0,[0]
23377,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public String peek() {
        if (list.isEmpty()) {
            return null;
        }
        final int last = list.size() - 1;
        return list.get(last);
    }","@Override
    public String peek() {
        if (list.isEmpty()) {
            return null;
        }
        final int last = list.size() - 1;
        return list.get(last);
    }",0,[0]
6438,bugs-dot-jar_FLINK-1133_27e40205,"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
		
		// check if type is a subclass of tuple
		if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t))
				|| (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {
			
			Type curT = t;
			
			// do not allow usage of Tuple as type
			if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {
				throw new InvalidTypesException(
						""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
			}
			
			// go up the hierarchy until we reach immediate child of Tuple (with or without generics)
			// collect the types while moving up for a later top-down 
			while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(
					Tuple.class))
					&& !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {
				typeHierarchy.add(curT);
				
				// parameterized type
				if (curT instanceof ParameterizedType) {
					curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();
				}
				// class
				else {
					curT = ((Class<?>) curT).getGenericSuperclass();
				}
			}
			
			// check if immediate child of Tuple has generics
			if (curT instanceof Class<?>) {
				throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
			}
			
			ParameterizedType tupleChild = (ParameterizedType) curT;
			
			Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
			
			// materialize possible type variables
			for (int i = 0; i < subtypes.length; i++) {
				// materialize immediate TypeVariables
				if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
					subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
				}
				// class or parameterized type
				else {
					subtypes[i] = tupleChild.getActualTypeArguments()[i];
				}
			}
			
			TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
			for (int i = 0; i < subtypes.length; i++) {
				// sub type could not be determined with materializing
				// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
				if (subtypes[i] instanceof TypeVariable<?>) {
					tupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
					
					// variable could not be determined
					if (tupleSubTypes[i] == null) {
						throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '""
								+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()
								+ ""' could not be determined. This is most likely a type erasure problem. ""
								+ ""The type extraction currently supports types with generic variables only in cases where ""
								+ ""all variables in the return type can be deduced from the input type(s)."");
					}
				} else {
					tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
				}
			}
			
			// TODO: Check that type that extends Tuple does not have additional fields.
			// Right now, these fields are not be serialized by the TupleSerializer. 
			// We might want to add an ExtendedTupleSerializer for that. 
			
			if (t instanceof Class<?>) {
				return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);
			} else if (t instanceof ParameterizedType) {
				return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);
			}
		}
		// type depends on another type
		// e.g. class MyMapper<E> extends MapFunction<String, E>
		else if (t instanceof TypeVariable) {
			Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
			
			if (!(typeVar instanceof TypeVariable)) {
				return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
			}
			// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
			else {
				TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
				if (typeInfo != null) {
					return typeInfo;
				} else {
					throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '""
							+ ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. ""
							+ ""The type extraction currently supports types with generic variables only in cases where ""
							+ ""all variables in the return type can be deduced from the input type(s)."");
				}
			}
		}
		// arrays with generics 
		else if (t instanceof GenericArrayType) {
			GenericArrayType genericArray = (GenericArrayType) t;
			
			Type componentType = genericArray.getGenericComponentType();
			
			// due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class
			if (componentType instanceof Class) {
				
				Class<?> componentClass = (Class<?>) componentType;
				String className;
				// for int[], double[] etc.
				if(componentClass.isPrimitive()) {
					className = encodePrimitiveClass(componentClass);
				}
				// for String[], Integer[] etc.
				else {
					className = ""L"" + componentClass.getName() + "";"";
				}
				
				Class<OUT> classArray = null;
				try {
					classArray = (Class<OUT>) Class.forName(""["" + className);
				} catch (ClassNotFoundException e) {
					throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
				}
				return getForClass(classArray);
			}
			
			TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(),
					in1Type, in2Type);
			return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
		}
		// objects with generics are treated as raw type
		else if (t instanceof ParameterizedType) {
			return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());
		}
		// no tuple, no TypeVariable, no generic type
		else if (t instanceof Class) {
			return privateGetForClass((Class<OUT>) t);
		}
		
		throw new InvalidTypesException(""Type Information could not be created."");
	}","@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfoWithTypeHierarchy(ArrayList<Type> typeHierarchy, Type t,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
		
		// check if type is a subclass of tuple
		if ((t instanceof Class<?> && Tuple.class.isAssignableFrom((Class<?>) t))
				|| (t instanceof ParameterizedType && Tuple.class.isAssignableFrom((Class<?>) ((ParameterizedType) t).getRawType()))) {
			
			Type curT = t;
			
			// do not allow usage of Tuple as type
			if (curT instanceof Class<?> && ((Class<?>) curT).equals(Tuple.class)) {
				throw new InvalidTypesException(
						""Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead."");
			}
			
			// go up the hierarchy until we reach immediate child of Tuple (with or without generics)
			// collect the types while moving up for a later top-down 
			while (!(curT instanceof ParameterizedType && ((Class<?>) ((ParameterizedType) curT).getRawType()).getSuperclass().equals(
					Tuple.class))
					&& !(curT instanceof Class<?> && ((Class<?>) curT).getSuperclass().equals(Tuple.class))) {
				typeHierarchy.add(curT);
				
				// parameterized type
				if (curT instanceof ParameterizedType) {
					curT = ((Class<?>) ((ParameterizedType) curT).getRawType()).getGenericSuperclass();
				}
				// class
				else {
					curT = ((Class<?>) curT).getGenericSuperclass();
				}
			}
			
			// check if immediate child of Tuple has generics
			if (curT instanceof Class<?>) {
				throw new InvalidTypesException(""Tuple needs to be parameterized by using generics."");
			}
			
			ParameterizedType tupleChild = (ParameterizedType) curT;
			
			Type[] subtypes = new Type[tupleChild.getActualTypeArguments().length];
			
			// materialize possible type variables
			for (int i = 0; i < subtypes.length; i++) {
				// materialize immediate TypeVariables
				if (tupleChild.getActualTypeArguments()[i] instanceof TypeVariable<?>) {
					subtypes[i] = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) tupleChild.getActualTypeArguments()[i]);
				}
				// class or parameterized type
				else {
					subtypes[i] = tupleChild.getActualTypeArguments()[i];
				}
			}
			
			TypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];
			for (int i = 0; i < subtypes.length; i++) {
				// sub type could not be determined with materializing
				// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
				if (subtypes[i] instanceof TypeVariable<?>) {
					tupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);
					
					// variable could not be determined
					if (tupleSubTypes[i] == null) {
						throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) subtypes[i]).getName() + ""' in '""
								+ ((TypeVariable<?>) subtypes[i]).getGenericDeclaration()
								+ ""' could not be determined. This is most likely a type erasure problem. ""
								+ ""The type extraction currently supports types with generic variables only in cases where ""
								+ ""all variables in the return type can be deduced from the input type(s)."");
					}
				} else {
					tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);
				}
			}
			
			// TODO: Check that type that extends Tuple does not have additional fields.
			// Right now, these fields are not be serialized by the TupleSerializer. 
			// We might want to add an ExtendedTupleSerializer for that. 
			
			if (t instanceof Class<?>) {
				return new TupleTypeInfo(((Class<? extends Tuple>) t), tupleSubTypes);
			} else if (t instanceof ParameterizedType) {
				return new TupleTypeInfo(((Class<? extends Tuple>) ((ParameterizedType) t).getRawType()), tupleSubTypes);
			}
		}
		// type depends on another type
		// e.g. class MyMapper<E> extends MapFunction<String, E>
		else if (t instanceof TypeVariable) {
			Type typeVar = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) t);
			
			if (!(typeVar instanceof TypeVariable)) {
				return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);
			}
			// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt
			else {
				TypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);
				if (typeInfo != null) {
					return typeInfo;
				} else {
					throw new InvalidTypesException(""Type of TypeVariable '"" + ((TypeVariable<?>) t).getName() + ""' in '""
							+ ((TypeVariable<?>) t).getGenericDeclaration() + ""' could not be determined. This is most likely a type erasure problem. ""
							+ ""The type extraction currently supports types with generic variables only in cases where ""
							+ ""all variables in the return type can be deduced from the input type(s)."");
				}
			}
		}
		// arrays with generics 
		else if (t instanceof GenericArrayType) {
			GenericArrayType genericArray = (GenericArrayType) t;
			
			Type componentType = genericArray.getGenericComponentType();
			
			// due to a Java 6 bug, it is possible that the JVM classifies e.g. String[] or int[] as GenericArrayType instead of Class
			if (componentType instanceof Class) {
				
				Class<?> componentClass = (Class<?>) componentType;
				String className;
				// for int[], double[] etc.
				if(componentClass.isPrimitive()) {
					className = encodePrimitiveClass(componentClass);
				}
				// for String[], Integer[] etc.
				else {
					className = ""L"" + componentClass.getName() + "";"";
				}
				
				Class<OUT> classArray = null;
				try {
					classArray = (Class<OUT>) Class.forName(""["" + className);
				} catch (ClassNotFoundException e) {
					throw new InvalidTypesException(""Could not convert GenericArrayType to Class."");
				}
				return getForClass(classArray);
			}
			
			TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(),
					in1Type, in2Type);
			return ObjectArrayTypeInfo.getInfoFor(t, componentInfo);
		}
		// objects with generics are treated as raw type
		else if (t instanceof ParameterizedType) {
			return privateGetForClass((Class<OUT>) ((ParameterizedType) t).getRawType());
		}
		// no tuple, no TypeVariable, no generic type
		else if (t instanceof Class) {
			return privateGetForClass((Class<OUT>) t);
		}
		
		throw new InvalidTypesException(""Type Information could not be created."");
	}",1,"[59, 94]"
39444,bugs-dot-jar_FLINK-3760_494212b3,"public void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {
		if (serializer == null) {
			if (typeInfo != null) {
				serializer = typeInfo.createSerializer(executionConfig);
			} else {
				throw new IllegalStateException(
						""Cannot initialize serializer after TypeInformation was dropped during serialization"");
			}
		}
	}","public void initializeSerializerUnlessSet(ExecutionConfig executionConfig) {
		if (serializer == null) {
			if (typeInfo != null) {
				serializer = typeInfo.createSerializer(executionConfig);
			} else {
				throw new IllegalStateException(
						""Cannot initialize serializer after TypeInformation was dropped during serialization"");
			}
		}
	}",0,[0]
18432,bugs-dot-jar_OAK-1877_716e1237,"private IndexUpdate(IndexUpdate parent, String name) {
        this.parent = checkNotNull(parent);
        this.name = name;
        this.provider = parent.provider;
        this.async = parent.async;
        this.root = parent.root;
        this.builder = parent.builder.child(checkNotNull(name));
        this.updateCallback = parent.updateCallback;
    }","private IndexUpdate(IndexUpdate parent, String name) {
        this.parent = checkNotNull(parent);
        this.name = name;
        this.provider = parent.provider;
        this.async = parent.async;
        this.root = parent.root;
        this.builder = parent.builder.getChildNode(checkNotNull(name));
        this.updateCallback = parent.updateCallback;
    }",1,[6]
141,Bears-6,"@Override
    public POJOPropertyBuilder withSimpleName(String newSimpleName)
    {
        PropertyName newName = _name.withSimpleName(newSimpleName);
        return (newName == _name) ? this : new POJOPropertyBuilder(this, newName);
    }","@Override
    public POJOPropertyBuilder withSimpleName(String newSimpleName)
    {
        PropertyName newName = _name.withSimpleName(newSimpleName);
        return (newName == _name) ? this : new POJOPropertyBuilder(this, newName);
    }",0,[0]
23211,bugs-dot-jar_OAK-1020_83427028,"@Nonnull
    public PropertyDelegate getProperty(String relPath) throws RepositoryException {
        Tree parent = getTree(PathUtils.getParentPath(relPath));
        String name = PathUtils.getName(relPath);
        return new PropertyDelegate(sessionDelegate, parent, name);
    }","@Nonnull
    public PropertyDelegate getProperty(String relPath) throws RepositoryException {
        Tree parent = getTree(PathUtils.getParentPath(relPath));
        String name = PathUtils.getName(relPath);
        return new PropertyDelegate(sessionDelegate, parent, name);
    }",0,[0]
20319,bugs-dot-jar_WICKET-3885_beb9086d,"private String getAbsoluteURL(String url)
	{
		if (url.startsWith(""http://"") || url.startsWith(""https://""))
		{
			return url;
		}
		else if (url.startsWith(""/""))
		{
			return getAbsolutePrefix() + url;
		}
		else
		{
			HttpServletRequest httpServletRequest = webRequest.getContainerRequest();
			Charset charset = RequestUtils.getCharset(httpServletRequest);

			final Url current = webRequest.getClientUrl();

			Url append = Url.parse(url, charset);
			current.concatSegments(append.getSegments());
			Url result = new Url(current.getSegments(), append.getQueryParameters());

			String path = result.toString();

			// replace redirect to empty path with '/'
			if (Strings.isEmpty(path))
			{
				path = ""/"";
			}

			return Strings.join(""/"", getAbsolutePrefix(), httpServletRequest.getContextPath(),
				webRequest.getFilterPrefix(), path);
		}
	}","private String getAbsoluteURL(String url)
	{
		if (url.startsWith(""http://"") || url.startsWith(""https://""))
		{
			return url;
		}
		else if (url.startsWith(""/""))
		{
			return getAbsolutePrefix() + url;
		}
		else
		{
			HttpServletRequest httpServletRequest = webRequest.getContainerRequest();
			Charset charset = RequestUtils.getCharset(httpServletRequest);

			final Url current = webRequest.getClientUrl();

			Url append = Url.parse(url, charset);
			current.concatSegments(append.getSegments());
			Url result = new Url(current.getSegments(), append.getQueryParameters());

			String path = result.toString();

			// replace redirect to empty path with '/'
			if (Strings.isEmpty(path))
			{
				path = ""/"";
			}

			return Strings.join(""/"", getAbsolutePrefix(), httpServletRequest.getContextPath(),
				webRequest.getFilterPrefix(), path);
		}
	}",0,[0]
23360,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public ThreadContextStack copy() {
        List<String> result = null;
        if (!useStack || (result = stack.get()) == null) {
            return new MutableThreadContextStack(new ArrayList<String>());
        }
        return new MutableThreadContextStack(result);
    }","@Override
    public ThreadContextStack copy() {
        List<String> result = null;
        if (!useStack || (result = stack.get()) == null) {
            return new MutableThreadContextStack(new ArrayList<String>());
        }
        return new MutableThreadContextStack(result);
    }",0,[0]
2926,bugs-dot-jar_WICKET-3455_f30bd1cb,"protected final void renderAll(final MarkupStream markupStream, final ComponentTag openTag)
	{
		while (markupStream.hasMore())
		{
			// In case of Page we need to render the whole file. For all other components just what
			// is in between the open and the close tag.
			if ((openTag != null) && markupStream.get().closes(openTag))
			{
				break;
			}

			// Remember where we are
			final int index = markupStream.getCurrentIndex();

			// Render the markup element
			renderNext(markupStream);

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);
			MarkupElement elem = markupStream.get();
			if (elem instanceof RawMarkup)
			{
				markupStream.next();
			}
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
			}
			else
			{
				throw new WicketRuntimeException(""Ups. This should never happen. "" +
					markupStream.toString());
			}
		}
	}","protected final void renderAll(final MarkupStream markupStream, final ComponentTag openTag)
	{
		while (markupStream.hasMore())
		{
			// In case of Page we need to render the whole file. For all other components just what
			// is in between the open and the close tag.
			if ((openTag != null) && markupStream.get().closes(openTag))
			{
				break;
			}

			// Remember where we are
			final int index = markupStream.getCurrentIndex();

			// Render the markup element
			renderNext(markupStream);

			// Go back to where we were and move the markup stream forward to whatever the next
			// element is.
			markupStream.setCurrentIndex(index);
			MarkupElement elem = markupStream.get();
			if (elem instanceof RawMarkup)
			{
				markupStream.next();
			}
			else if (!markupStream.getTag().isClose())
			{
				markupStream.skipComponent();
			}
			else
			{
				throw new WicketRuntimeException(""Ups. This should never happen. "" +
					markupStream.toString());
			}
		}
	}",0,[0]
35303,bugs-dot-jar_WICKET-4276_32c76c4a,"boolean isSelected(final SelectOption<?> option)
	{
		Args.notNull(option, ""option"");

		// if the raw input is specified use that, otherwise use model
		if (hasRawInput())
		{
			String[] paths = getInputAsArray();
			if ((paths != null) && (paths.length > 0))
			{
				for (String path : paths)
				{
					if (path.equals(option.getPath()))
					{
						return true;
					}
				}
				return false;
			}
		}

		return compareModels(getDefaultModelObject(), option.getDefaultModelObject());
	}","boolean isSelected(final SelectOption<?> option)
	{
		Args.notNull(option, ""option"");

		// if the raw input is specified use that, otherwise use model
		if (hasRawInput())
		{
			String[] values = getInputAsArray();
			if (values != null && values.length > 0)
			{
				for (int i = 0; i < values.length; i++)
				{
					String value = values[i];
					if (value.equals(option.getValue()))
					{
						return true;
					}
				}
				return false;
			}
		}

		return compareModels(getDefaultModelObject(), option.getDefaultModelObject());
	}",1,"[7, 8, 10, 12]"
36429,bugs-dot-jar_MATH-705_645d642b,"@Override
    protected StepInterpolator doCopy() {
        return new ClassicalRungeKuttaStepInterpolator(this);
    }","@Override
    protected StepInterpolator doCopy() {
        return new ClassicalRungeKuttaStepInterpolator(this);
    }",0,[0]
1441,bugs-dot-jar_OAK-185_7fe28a0e,"@Override
    @Nonnull
    public Item getPrimaryItem() throws RepositoryException {
        checkStatus();
        String name = getPrimaryNodeType().getPrimaryItemName();
        if (name == null) {
            throw new ItemNotFoundException(""No primary item present on node "" + this);
        }
        if (hasProperty(name)) {
            return getProperty(name);
        } else if (hasNode(name)) {
            return getNode(name);
        } else {
            throw new ItemNotFoundException(""Primary item "" + name + "" does not exist on node "" + this);
        }
    }","@Override
    @Nonnull
    public Item getPrimaryItem() throws RepositoryException {
        checkStatus();
        String name = getPrimaryNodeType().getPrimaryItemName();
        if (name == null) {
            throw new ItemNotFoundException(""No primary item present on node "" + this);
        }
        if (hasProperty(name)) {
            return getProperty(name);
        } else if (hasNode(name)) {
            return getNode(name);
        } else {
            throw new ItemNotFoundException(""Primary item "" + name + "" does not exist on node "" + this);
        }
    }",0,[0]
2582,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void offlineTable(ByteBuffer login, String tableName) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException, TException {
    try {
      getConnector(login).tableOperations().offline(tableName);
    } catch (Exception e) {
      handleExceptionTNF(e);
    }
  }","@Override
  public void offlineTable(ByteBuffer login, String tableName) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException, TException {
    try {
      getConnector(login).tableOperations().offline(tableName);
    } catch (Exception e) {
      handleExceptionTNF(e);
    }
  }",0,[0]
26065,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"public void overrideCurrentTime(long ts) {
    this.currentTime = ts;
  }","public void overrideCurrentTime(long ts) {
    this.currentTime = ts;
  }",0,[0]
943,bugs-dot-jar_WICKET-2033_420ac965,"public final String getEvent()
	{
		return event;
	}","public final String getEvent()
	{
		return event;
	}",0,[0]
35728,bugs-dot-jar_FLINK-1978_0078c44e,"@Override
	public void copy(DataInputView source, DataOutputView target) throws IOException {
		// copy the flags
		int flags = source.readByte();
		target.writeByte(flags);

		if ((flags & IS_NULL) != 0) {
			// is a null value, nothing further to copy
			return;
		}

		TypeSerializer<?> subclassSerializer = null;
		if ((flags & IS_SUBCLASS) != 0) {
			String className = source.readUTF();
			target.writeUTF(className);
			try {
				Class<?> subclass = Class.forName(className, true, Thread.currentThread()
						.getContextClassLoader());
				subclassSerializer = getSubclassSerializer(subclass);
			} catch (ClassNotFoundException e) {
				throw new RuntimeException(""Cannot instantiate class."", e);
			}
		} else if ((flags & IS_TAGGED_SUBCLASS) != 0) {
			int subclassTag = source.readByte();
			target.writeByte(subclassTag);
			subclassSerializer = registeredSerializers[subclassTag];
		}

		if ((flags & NO_SUBCLASS) != 0) {
			for (int i = 0; i < numFields; i++) {
				boolean isNull = source.readBoolean();
				target.writeBoolean(isNull);
				if (!isNull) {
					fieldSerializers[i].copy(source, target);
				}
			}
		} else {
			if (subclassSerializer != null) {
				subclassSerializer.copy(source, target);
			}
		}
	}","@Override
	public void copy(DataInputView source, DataOutputView target) throws IOException {
		// copy the flags
		int flags = source.readByte();
		target.writeByte(flags);

		if ((flags & IS_NULL) != 0) {
			// is a null value, nothing further to copy
			return;
		}

		TypeSerializer<?> subclassSerializer = null;
		if ((flags & IS_SUBCLASS) != 0) {
			String className = source.readUTF();
			target.writeUTF(className);
			try {
				Class<?> subclass = Class.forName(className, true, Thread.currentThread()
						.getContextClassLoader());
				subclassSerializer = getSubclassSerializer(subclass);
			} catch (ClassNotFoundException e) {
				throw new RuntimeException(""Cannot instantiate class."", e);
			}
		} else if ((flags & IS_TAGGED_SUBCLASS) != 0) {
			int subclassTag = source.readByte();
			target.writeByte(subclassTag);
			subclassSerializer = registeredSerializers[subclassTag];
		}

		if ((flags & NO_SUBCLASS) != 0) {
			for (int i = 0; i < numFields; i++) {
				boolean isNull = source.readBoolean();
				target.writeBoolean(isNull);
				if (!isNull) {
					fieldSerializers[i].copy(source, target);
				}
			}
		} else {
			if (subclassSerializer != null) {
				subclassSerializer.copy(source, target);
			}
		}
	}",0,[0]
22570,bugs-dot-jar_FLINK-1820_39d526e6,"@Override
	public FloatValue createValue() {
		return new FloatValue();
	}","@Override
	public FloatValue createValue() {
		return new FloatValue();
	}",0,[0]
10342,bugs-dot-jar_OAK-3897_94c6c575,"@Override
    public boolean childNodeChanged(String name,
                                    NodeState before,
                                    NodeState after) {
        String p = PathUtils.concat(path, name);
        return after.compareAgainstBaseState(before,
                new ResetDiff(revision, p, operations));
    }","@Override
    public boolean childNodeChanged(String name,
                                    NodeState before,
                                    NodeState after) {
        String p = PathUtils.concat(path, name);
        return after.compareAgainstBaseState(before,
                new ResetDiff(revision, p, operations));
    }",0,[0]
358,bugs-dot-jar_OAK-888_6d82cb64,"@Nonnull
    public static Iterable<String> elements(final String path) {
        assert isValid(path);

        final Iterator<String> it = new Iterator<String>() {
            int pos = PathUtils.isAbsolute(path) ? 1 : 0;
            String next;

            @Override
            public boolean hasNext() {
                if (next == null) {
                    if (pos >= path.length()) {
                        return false;
                    }
                    int i = path.indexOf('/', pos);
                    if (i < 0) {
                        next = path.substring(pos);
                        pos = path.length();
                    } else {
                        next = path.substring(pos, i);
                        pos = i + 1;
                    }
                }
                return true;
            }

            @Override
            public String next() {
                if (hasNext()) {
                    String next = this.next;
                    this.next = null;
                    return next;
                }
                throw new NoSuchElementException();
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException(""remove"");
            }
        };

        return new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
                return it;
            }
        };
    }","@Nonnull
    public static Iterable<String> elements(final String path) {
        assert isValid(path);

        final Iterator<String> it = new Iterator<String>() {
            int pos = PathUtils.isAbsolute(path) ? 1 : 0;
            String next;

            @Override
            public boolean hasNext() {
                if (next == null) {
                    if (pos >= path.length()) {
                        return false;
                    }
                    int i = path.indexOf('/', pos);
                    if (i < 0) {
                        next = path.substring(pos);
                        pos = path.length();
                    } else {
                        next = path.substring(pos, i);
                        pos = i + 1;
                    }
                }
                return true;
            }

            @Override
            public String next() {
                if (hasNext()) {
                    String next = this.next;
                    this.next = null;
                    return next;
                }
                throw new NoSuchElementException();
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException(""remove"");
            }
        };

        return new Iterable<String>() {
            @Override
            public Iterator<String> iterator() {
                return it;
            }
        };
    }",0,[0]
40417,bugs-dot-jar_WICKET-442_246d53c5,"public final void render(final MarkupStream markupStream)
	{
		setMarkupStream(markupStream);
		setFlag(FLAG_IS_RENDERED_ONCE, true);

		// Determine if component is visible using it's authorization status
		// and the isVisible property.
		if (isRenderAllowed() && isVisible())
		{
			// Rendering is beginning
			if (log.isDebugEnabled())
			{
				log.debug(""Begin render "" + this);
			}

			try
			{
				// Call implementation to render component
				onBeforeRender();
				try
				{
					onRender(markupStream);
				}
				finally
				{
					onAfterRender();
				}

				// Component has been rendered
				rendered();
			}
			catch (RuntimeException ex)
			{
				// Call each behaviors onException() to allow the
				// behavior to clean up
				if (behaviors != null)
				{
					for (Iterator i = behaviors.iterator(); i.hasNext();)
					{
						IBehavior behavior = (IBehavior)i.next();
						if (isBehaviorAccepted(behavior))
						{
							try
							{
								behavior.exception(this, ex);
							}
							catch (Throwable ex2)
							{
								log.error(""Error while cleaning up after exception"", ex2);
							}
						}
					}
				}

				// Re-throw the exception
				throw ex;
			}

			if (log.isDebugEnabled())
			{
				log.debug(""End render "" + this);
			}
		}
		else
		{
			if (getFlag(FLAG_PLACEHOLDER))
			{
				// write out a placeholder tag into the markup
				final ComponentTag tag = markupStream.getTag();

				getResponse().write(""<"");
				getResponse().write(tag.getName());
				getResponse().write("" id=\"""");
				getResponse().write(getMarkupId());
				getResponse().write(""\"" style=\""display:none\""></"");
				getResponse().write(tag.getName());
				getResponse().write("">"");
			}
			markupStream.skipComponent();
		}
	}","public final void render(final MarkupStream markupStream)
	{
		setMarkupStream(markupStream);
		setFlag(FLAG_IS_RENDERED_ONCE, true);

		// Determine if component is visible using it's authorization status
		// and the isVisible property.
		if (isRenderAllowed() && isVisible())
		{
			// Rendering is beginning
			if (log.isDebugEnabled())
			{
				log.debug(""Begin render "" + this);
			}

			try
			{
				// Call implementation to render component
				onBeforeRender();
				try
				{
					onRender(markupStream);
				}
				finally
				{
					onAfterRender();
				}

				// Component has been rendered
				rendered();
			}
			catch (RuntimeException ex)
			{
				// Call each behaviors onException() to allow the
				// behavior to clean up
				if (behaviors != null)
				{
					for (Iterator i = behaviors.iterator(); i.hasNext();)
					{
						IBehavior behavior = (IBehavior)i.next();
						if (isBehaviorAccepted(behavior))
						{
							try
							{
								behavior.exception(this, ex);
							}
							catch (Throwable ex2)
							{
								log.error(""Error while cleaning up after exception"", ex2);
							}
						}
					}
				}

				// Re-throw the exception
				throw ex;
			}

			if (log.isDebugEnabled())
			{
				log.debug(""End render "" + this);
			}
		}
		else
		{
			if (getFlag(FLAG_PLACEHOLDER))
			{
				// write out a placeholder tag into the markup
				final ComponentTag tag = markupStream.getTag();

				getResponse().write(""<"");
				getResponse().write(tag.getName());
				getResponse().write("" id=\"""");
				getResponse().write(getMarkupId());
				getResponse().write(""\"" style=\""display:none\""></"");
				getResponse().write(tag.getName());
				getResponse().write("">"");
			}
			markupStream.skipComponent();
		}
	}",0,[0]
2647,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public ByteBuffer login(String principal, Map<String,String> loginProperties) throws org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      AuthenticationToken token = getToken(principal, loginProperties);
      TCredentials credential = CredentialHelper.create(principal, token, instance.getInstanceID());
      ByteBuffer login = ByteBuffer.wrap(CredentialHelper.asByteArray(credential));
      getConnector(login); // check to make sure user exists
      return login;
    } catch (AccumuloSecurityException e) {
      throw new org.apache.accumulo.proxy.thrift.AccumuloSecurityException(e.toString());
    } catch (Exception e) {
      throw new TException(e);
    }
  }","@Override
  public ByteBuffer login(String principal, Map<String,String> loginProperties) throws org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      AuthenticationToken token = getToken(principal, loginProperties);
      TCredentials credential = CredentialHelper.create(principal, token, instance.getInstanceID());
      ByteBuffer login = ByteBuffer.wrap(CredentialHelper.asByteArray(credential));
      getConnector(login); // check to make sure user exists
      return login;
    } catch (AccumuloSecurityException e) {
      throw new org.apache.accumulo.proxy.thrift.AccumuloSecurityException(e.toString());
    } catch (Exception e) {
      throw new TException(e);
    }
  }",0,[0]
39724,bugs-dot-jar_OAK-2021_004db804,"public Statement optimize() {
        if (explain || measure || orderList.size() > 0) {
            return this;
        }
        if (where == null) {
            return this;
        }
        ArrayList<Expression> unionList = new ArrayList<Expression>();
        addToUnionList(where, unionList);
        if (unionList.size() == 1) {
            return this;
        }
        Statement union = null;
        for (int i = 0; i < unionList.size(); i++) {
            Expression e = unionList.get(i);
            Statement s = new Statement();
            s.columnSelector = columnSelector;
            s.selectors = selectors;
            s.columnList = columnList;
            s.where = e;
            if (i == unionList.size() - 1) {
                s.xpathQuery = xpathQuery;
            }
            if (union == null) {
                union = s;
            } else {
                union = new UnionStatement(union.optimize(), s.optimize());
            }
        }
        return union;
    }","public Statement optimize() {
        if (explain || measure) {
            return this;
        }
        if (where == null) {
            return this;
        }
        where = where.optimize();
        ArrayList<Expression> unionList = new ArrayList<Expression>();
        addToUnionList(where, unionList);
        if (unionList.size() == 1) {
            return this;
        }
        Statement union = null;
        for (int i = 0; i < unionList.size(); i++) {
            Expression e = unionList.get(i);
            Statement s = new Statement();
            s.columnSelector = columnSelector;
            s.selectors = selectors;
            s.columnList = columnList;
            s.where = e;
            if (union == null) {
                union = s;
            } else {
                union = new UnionStatement(union.optimize(), s.optimize());
            }
        }
        union.orderList = orderList;
        union.xpathQuery = xpathQuery;
        return union;
    }",1,"[1, 20, 21, 22]"
22663,bugs-dot-jar_WICKET-5204_9e6efa61,"protected DatePicker newDatePicker()
	{
		return new DatePicker()
		{
			private static final long serialVersionUID = 1L;

			@Override
			protected void configure(final Map<String, Object> widgetProperties,
				final IHeaderResponse response, final Map<String, Object> initVariables)
			{
				super.configure(widgetProperties, response, initVariables);

				DateTimeField.this.configure(widgetProperties);
			}
		};
	}","protected DatePicker newDatePicker()
	{
		return new DatePicker()
		{
			private static final long serialVersionUID = 1L;

			@Override
			protected void configure(final Map<String, Object> widgetProperties,
				final IHeaderResponse response, final Map<String, Object> initVariables)
			{
				super.configure(widgetProperties, response, initVariables);

				DateTimeField.this.configure(widgetProperties);
			}
		};
	}",0,[0]
6939,bugs-dot-jar_OAK-3411_978c77ff,"@Nonnull
    NavigableMap<Revision, Range> getPreviousRanges(boolean includeStale) {
        if (includeStale) {
            return createPreviousRanges(true);
        } else {
            if (previous == null) {
                previous = createPreviousRanges(false);
            }
            return previous;
        }
    }","@Nonnull
    NavigableMap<Revision, Range> getPreviousRanges(boolean includeStale) {
        if (includeStale) {
            return createPreviousRanges(true);
        } else {
            if (previous == null) {
                previous = createPreviousRanges(false);
            }
            return previous;
        }
    }",0,[0]
11674,bugs-dot-jar_CAMEL-5796_de6dd425,"public WireTapDefinition<Type> wireTap(String uri) {
        WireTapDefinition<Type> answer = new WireTapDefinition<Type>();
        answer.setUri(uri);
        addOutput(answer);
        return answer;
    }","public WireTapDefinition<Type> wireTap(String uri) {
        WireTapDefinition<Type> answer = new WireTapDefinition<Type>();
        answer.setUri(uri);
        addOutput(answer);
        return answer;
    }",0,[0]
32939,bugs-dot-jar_OAK-43_668f08f2,"public MutableCommit() {
    }","public MutableCommit() {
    }",0,[0]
26055,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"@Override
  public boolean accept(Key k, Value v) {
    if (currentTime - k.getTimestamp() > threshold)
      return false;
    return true;
  }","@Override
  public boolean accept(Key k, Value v) {
    if (currentTime - k.getTimestamp() > threshold)
      return false;
    return true;
  }",0,[0]
12793,bugs-dot-jar_MATH-1208_ce2badf0,"public EmpiricalDistribution(RandomGenerator generator) {
        this(DEFAULT_BIN_COUNT, generator);
    }","public EmpiricalDistribution(RandomGenerator generator) {
        this(DEFAULT_BIN_COUNT, generator);
    }",0,[0]
18484,bugs-dot-jar_CAMEL-7359_9cb09d14,"private Expression createSimpleExpression(String function, boolean strict) {
        // return the function directly if we can create function without analyzing the prefix
        Expression answer = createSimpleExpressionDirectly(function);
        if (answer != null) {
            return answer;
        }

        // body and headers first
        answer = createSimpleExpressionBodyOrHeader(function, strict);
        if (answer != null) {
            return answer;
        }

        // camelContext OGNL
        String remainder = ifStartsWithReturnRemainder(""camelContext"", function);
        if (remainder != null) {
            boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
            if (invalid) {
                throw new SimpleParserException(""Valid syntax: ${camelContext.OGNL} was: "" + function, token.getIndex());
            }
            return ExpressionBuilder.camelContextOgnlExpression(remainder);
        }

        // Exception OGNL
        remainder = ifStartsWithReturnRemainder(""exception"", function);
        if (remainder != null) {
            boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
            if (invalid) {
                throw new SimpleParserException(""Valid syntax: ${exception.OGNL} was: "" + function, token.getIndex());
            }
            return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);
        }

        // property
        remainder = ifStartsWithReturnRemainder(""property"", function);
        if (remainder != null) {
            // remove leading character (dot or ?)
            if (remainder.startsWith(""."") || remainder.startsWith(""?"")) {
                remainder = remainder.substring(1);
            }
            // remove starting and ending brackets
            if (remainder.startsWith(""["") && remainder.endsWith(""]"")) {
                remainder = remainder.substring(1, remainder.length() - 1);
            }

            // validate syntax
            boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
            if (invalid) {
                throw new SimpleParserException(""Valid syntax: ${property.OGNL} was: "" + function, token.getIndex());
            }

            if (OgnlHelper.isValidOgnlExpression(remainder)) {
                // ognl based property
                return ExpressionBuilder.propertyOgnlExpression(remainder);
            } else {
                // regular property
                return ExpressionBuilder.propertyExpression(remainder);
            }
        }

        // system property
        remainder = ifStartsWithReturnRemainder(""sys."", function);
        if (remainder != null) {
            return ExpressionBuilder.systemPropertyExpression(remainder);
        }
        remainder = ifStartsWithReturnRemainder(""sysenv."", function);
        if (remainder != null) {
            return ExpressionBuilder.systemEnvironmentExpression(remainder);
        }

        // file: prefix
        remainder = ifStartsWithReturnRemainder(""file:"", function);
        if (remainder != null) {
            Expression fileExpression = createSimpleFileExpression(remainder);
            if (function != null) {
                return fileExpression;
            }
        }

        // date: prefix
        remainder = ifStartsWithReturnRemainder(""date:"", function);
        if (remainder != null) {
            String[] parts = remainder.split("":"");
            if (parts.length < 2) {
                throw new SimpleParserException(""Valid syntax: ${date:command:pattern} was: "" + function, token.getIndex());
            }
            String command = ObjectHelper.before(remainder, "":"");
            String pattern = ObjectHelper.after(remainder, "":"");
            return ExpressionBuilder.dateExpression(command, pattern);
        }

        // bean: prefix
        remainder = ifStartsWithReturnRemainder(""bean:"", function);
        if (remainder != null) {
            return ExpressionBuilder.beanExpression(remainder);
        }

        // properties: prefix
        remainder = ifStartsWithReturnRemainder(""properties:"", function);
        if (remainder != null) {
            String[] parts = remainder.split("":"");
            if (parts.length > 2) {
                throw new SimpleParserException(""Valid syntax: ${properties:[locations]:key} was: "" + function, token.getIndex());
            }

            String locations = null;
            String key = remainder;
            if (parts.length == 2) {
                locations = ObjectHelper.before(remainder, "":"");
                key = ObjectHelper.after(remainder, "":"");
            }
            return ExpressionBuilder.propertiesComponentExpression(key, locations);
        }

        // ref: prefix
        remainder = ifStartsWithReturnRemainder(""ref:"", function);
        if (remainder != null) {
            return ExpressionBuilder.refExpression(remainder);
        }

        // const: prefix
        remainder = ifStartsWithReturnRemainder(""type:"", function);
        if (remainder != null) {
            Expression exp = ExpressionBuilder.typeExpression(remainder);
            // we want to cache this expression so we wont re-evaluate it as the type/constant wont change
            return ExpressionBuilder.cacheExpression(exp);
        }

        if (strict) {
            throw new SimpleParserException(""Unknown function: "" + function, token.getIndex());
        } else {
            return null;
        }
    }","private Expression createSimpleExpression(String function, boolean strict) {
        // return the function directly if we can create function without analyzing the prefix
        Expression answer = createSimpleExpressionDirectly(function);
        if (answer != null) {
            return answer;
        }

        // body and headers first
        answer = createSimpleExpressionBodyOrHeader(function, strict);
        if (answer != null) {
            return answer;
        }

        // camelContext OGNL
        String remainder = ifStartsWithReturnRemainder(""camelContext"", function);
        if (remainder != null) {
            boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
            if (invalid) {
                throw new SimpleParserException(""Valid syntax: ${camelContext.OGNL} was: "" + function, token.getIndex());
            }
            return ExpressionBuilder.camelContextOgnlExpression(remainder);
        }

        // Exception OGNL
        remainder = ifStartsWithReturnRemainder(""exception"", function);
        if (remainder != null) {
            boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
            if (invalid) {
                throw new SimpleParserException(""Valid syntax: ${exception.OGNL} was: "" + function, token.getIndex());
            }
            return ExpressionBuilder.exchangeExceptionOgnlExpression(remainder);
        }

        // property
        remainder = ifStartsWithReturnRemainder(""property"", function);
        if (remainder != null) {
            // remove leading character (dot or ?)
            if (remainder.startsWith(""."") || remainder.startsWith(""?"")) {
                remainder = remainder.substring(1);
            }
            // remove starting and ending brackets
            if (remainder.startsWith(""["") && remainder.endsWith(""]"")) {
                remainder = remainder.substring(1, remainder.length() - 1);
            }

            // validate syntax
            boolean invalid = OgnlHelper.isInvalidValidOgnlExpression(remainder);
            if (invalid) {
                throw new SimpleParserException(""Valid syntax: ${property.OGNL} was: "" + function, token.getIndex());
            }

            if (OgnlHelper.isValidOgnlExpression(remainder)) {
                // ognl based property
                return ExpressionBuilder.propertyOgnlExpression(remainder);
            } else {
                // regular property
                return ExpressionBuilder.propertyExpression(remainder);
            }
        }

        // system property
        remainder = ifStartsWithReturnRemainder(""sys."", function);
        if (remainder != null) {
            return ExpressionBuilder.systemPropertyExpression(remainder);
        }
        remainder = ifStartsWithReturnRemainder(""sysenv."", function);
        if (remainder != null) {
            return ExpressionBuilder.systemEnvironmentExpression(remainder);
        }

        // file: prefix
        remainder = ifStartsWithReturnRemainder(""file:"", function);
        if (remainder != null) {
            Expression fileExpression = createSimpleFileExpression(remainder);
            if (function != null) {
                return fileExpression;
            }
        }

        // date: prefix
        remainder = ifStartsWithReturnRemainder(""date:"", function);
        if (remainder != null) {
            String[] parts = remainder.split("":"");
            if (parts.length < 2) {
                throw new SimpleParserException(""Valid syntax: ${date:command:pattern} was: "" + function, token.getIndex());
            }
            String command = ObjectHelper.before(remainder, "":"");
            String pattern = ObjectHelper.after(remainder, "":"");
            return ExpressionBuilder.dateExpression(command, pattern);
        }

        // bean: prefix
        remainder = ifStartsWithReturnRemainder(""bean:"", function);
        if (remainder != null) {
            return ExpressionBuilder.beanExpression(remainder);
        }

        // properties: prefix
        remainder = ifStartsWithReturnRemainder(""properties:"", function);
        if (remainder != null) {
            String[] parts = remainder.split("":"");
            if (parts.length > 2) {
                throw new SimpleParserException(""Valid syntax: ${properties:[locations]:key} was: "" + function, token.getIndex());
            }

            String locations = null;
            String key = remainder;
            if (parts.length == 2) {
                locations = ObjectHelper.before(remainder, "":"");
                key = ObjectHelper.after(remainder, "":"");
            }
            return ExpressionBuilder.propertiesComponentExpression(key, locations);
        }

        // ref: prefix
        remainder = ifStartsWithReturnRemainder(""ref:"", function);
        if (remainder != null) {
            return ExpressionBuilder.refExpression(remainder);
        }

        // const: prefix
        remainder = ifStartsWithReturnRemainder(""type:"", function);
        if (remainder != null) {
            Expression exp = ExpressionBuilder.typeExpression(remainder);
            // we want to cache this expression so we wont re-evaluate it as the type/constant wont change
            return ExpressionBuilder.cacheExpression(exp);
        }

        if (strict) {
            throw new SimpleParserException(""Unknown function: "" + function, token.getIndex());
        } else {
            return null;
        }
    }",0,[0]
22938,bugs-dot-jar_CAMEL-3428_320545cd,"public Collection<Endpoint> removeEndpoints(String uri) throws Exception {
        Collection<Endpoint> answer = new ArrayList<Endpoint>();
        Endpoint oldEndpoint = endpoints.remove(uri);
        if (oldEndpoint != null) {
            answer.add(oldEndpoint);
            stopServices(oldEndpoint);
        } else {
            for (Map.Entry entry : endpoints.entrySet()) {
                oldEndpoint = (Endpoint)entry.getValue();
                if (EndpointHelper.matchEndpoint(oldEndpoint.getEndpointUri(), uri)) {
                    answer.add(oldEndpoint);
                    stopServices(oldEndpoint);
                }
            }
            for (Endpoint endpoint : answer) {
                endpoints.remove(endpoint.getEndpointUri());
            }
        }

        // notify lifecycle its being removed
        for (Endpoint endpoint : answer) {
            for (LifecycleStrategy strategy : lifecycleStrategies) {
                strategy.onEndpointRemove(endpoint);
            }
        }

        return answer;
    }","public Collection<Endpoint> removeEndpoints(String uri) throws Exception {
        Collection<Endpoint> answer = new ArrayList<Endpoint>();
        Endpoint oldEndpoint = endpoints.remove(uri);
        if (oldEndpoint != null) {
            answer.add(oldEndpoint);
            stopServices(oldEndpoint);
        } else {
            for (Map.Entry entry : endpoints.entrySet()) {
                oldEndpoint = (Endpoint)entry.getValue();
                if (EndpointHelper.matchEndpoint(oldEndpoint.getEndpointUri(), uri)) {
                    answer.add(oldEndpoint);
                    stopServices(oldEndpoint);
                }
            }
            for (Endpoint endpoint : answer) {
                endpoints.remove(endpoint.getEndpointUri());
            }
        }

        // notify lifecycle its being removed
        for (Endpoint endpoint : answer) {
            for (LifecycleStrategy strategy : lifecycleStrategies) {
                strategy.onEndpointRemove(endpoint);
            }
        }

        return answer;
    }",0,[0]
27136,bugs-dot-jar_MATH-395_962315ba,"public void resetMaximalIterationCount() {
        maximalIterationCount = defaultMaximalIterationCount;
    }","public void resetMaximalIterationCount() {
        maximalIterationCount = defaultMaximalIterationCount;
    }",0,[0]
31798,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"public Mutation(Mutation m) {
    m.serialize();
    this.row = m.row;
    this.data = m.data;
    this.entries = m.entries;
    this.values = m.values;
  }","public Mutation(Mutation m) {
    m.serialize();
    this.row = m.row;
    this.data = m.data;
    this.entries = m.entries;
    this.values = m.values;
  }",0,[0]
19049,bugs-dot-jar_WICKET-4594_5e1bf8d8,"protected final PageInfo getPageInfo(IPageRequestHandler handler)
	{
		Args.notNull(handler, ""handler"");

		Integer pageId = null;
		if (handler.isPageInstanceCreated())
		{
			IRequestablePage page = handler.getPage();

			if (page.isPageStateless() == false)
			{
				pageId = page.getPageId();
			}
		}

		return new PageInfo(pageId);
	}","protected final PageInfo getPageInfo(IPageRequestHandler handler)
	{
		Args.notNull(handler, ""handler"");

		Integer pageId = null;
		if (handler.isPageInstanceCreated())
		{
			IRequestablePage page = handler.getPage();

			if (page.isPageStateless() == false)
			{
				pageId = page.getPageId();
			}
		}

		return new PageInfo(pageId);
	}",0,[0]
16273,bugs-dot-jar_FLINK-3189_a5b05566,"public static void printHelpForRun() {
		HelpFormatter formatter = new HelpFormatter();
		formatter.setLeftPadding(5);
		formatter.setWidth(80);

		System.out.println(""\nAction \""run\"" compiles and runs a program."");
		System.out.println(""\n  Syntax: run [OPTIONS] <jar-file> <arguments>"");
		formatter.setSyntaxPrefix(""  \""run\"" action options:"");
		formatter.printHelp("" "", getRunOptionsWithoutDeprecatedOptions(new Options()));
		formatter.setSyntaxPrefix(""  Additional arguments if -m "" + CliFrontend.YARN_DEPLOY_JOBMANAGER + "" is set:"");
		Options yarnOpts = new Options();
		yarnSessionCLi.getYARNSessionCLIOptions(yarnOpts);
		formatter.printHelp("" "", yarnOpts);
		System.out.println();
	}","public static void printHelpForRun() {
		HelpFormatter formatter = new HelpFormatter();
		formatter.setLeftPadding(5);
		formatter.setWidth(80);

		System.out.println(""\nAction \""run\"" compiles and runs a program."");
		System.out.println(""\n  Syntax: run [OPTIONS] <jar-file> <arguments>"");
		formatter.setSyntaxPrefix(""  \""run\"" action options:"");
		formatter.printHelp("" "", getRunOptionsWithoutDeprecatedOptions(new Options()));
		formatter.setSyntaxPrefix(""  Additional arguments if -m "" + CliFrontend.YARN_DEPLOY_JOBMANAGER + "" is set:"");
		Options yarnOpts = new Options();
		yarnSessionCLi.getYARNSessionCLIOptions(yarnOpts);
		formatter.printHelp("" "", yarnOpts);
		System.out.println();
	}",0,[0]
38777,bugs-dot-jar_FLINK-2567_948b6e05,"public int getNumberOfNonNullFields() {
		return this.fieldTypes.length;
	}","public int getNumberOfNonNullFields() {
		return this.fieldTypes.length;
	}",0,[0]
1728,bugs-dot-jar_MATH-1005_91d280b7,"public static <T> T[] buildArray(final Field<T> field, final int length) {
         @SuppressWarnings(""unchecked"") // OK because field must be correct class
         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
         Arrays.fill(array, field.getZero());
         return array;
     }","public static <T> T[] buildArray(final Field<T> field, final int length) {
         @SuppressWarnings(""unchecked"") // OK because field must be correct class
         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);
         Arrays.fill(array, field.getZero());
         return array;
     }",0,[0]
9328,bugs-dot-jar_OAK-1122_5286861d,"protected void init(String homeDir) throws MicroKernelException {
        try {
            rep = new Repository(homeDir);
            rep.init();
            // initialize commit gate with current head
            gate.commit(rep.getHeadRevision().toString());
        } catch (Exception e) {
            throw new MicroKernelException(e);
        }
    }","protected void init(String homeDir) throws MicroKernelException {
        try {
            rep = new Repository(homeDir);
            rep.init();
            // initialize commit gate with current head
            gate.commit(rep.getHeadRevision().toString());
        } catch (Exception e) {
            throw new MicroKernelException(e);
        }
    }",0,[0]
23268,bugs-dot-jar_FLINK-1496_0a4c7694,"public BufferReader(RuntimeEnvironment environment, NetworkEnvironment networkEnvironment, IntermediateDataSetID consumedResultId, int numberOfInputChannels, int queueToRequest) {

		this.consumedResultId = checkNotNull(consumedResultId);
		// Note: the environment is not fully initialized yet
		this.environment = checkNotNull(environment);

		this.networkEnvironment = networkEnvironment;

		checkArgument(numberOfInputChannels >= 0);
		this.totalNumberOfInputChannels = numberOfInputChannels;

		checkArgument(queueToRequest >= 0);
		this.queueToRequest = queueToRequest;

		this.inputChannels = Maps.newHashMapWithExpectedSize(numberOfInputChannels);
	}","public BufferReader(RuntimeEnvironment environment, NetworkEnvironment networkEnvironment, IntermediateDataSetID consumedResultId, int numberOfInputChannels, int queueToRequest) {

		this.consumedResultId = checkNotNull(consumedResultId);
		// Note: the environment is not fully initialized yet
		this.environment = checkNotNull(environment);

		this.networkEnvironment = networkEnvironment;

		checkArgument(numberOfInputChannels >= 0);
		this.totalNumberOfInputChannels = numberOfInputChannels;

		checkArgument(queueToRequest >= 0);
		this.queueToRequest = queueToRequest;

		this.inputChannels = Maps.newHashMapWithExpectedSize(numberOfInputChannels);
	}",0,[0]
8104,bugs-dot-jar_FLINK-1640_8f321c72,"@Override
	public int hashCode() {
		return uri.hashCode();
	}","@Override
	public int hashCode() {
		return uri.hashCode();
	}",0,[0]
14231,bugs-dot-jar_LOG4J2-392_731c84b5,"protected static byte[] toByteArray(final InputStream is) throws IOException {
        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();

        int nRead;
        final byte[] data = new byte[BUF_SIZE];

        while ((nRead = is.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, nRead);
        }

        return buffer.toByteArray();
    }","protected static byte[] toByteArray(final InputStream is) throws IOException {
        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();

        int nRead;
        final byte[] data = new byte[BUF_SIZE];

        while ((nRead = is.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, nRead);
        }

        return buffer.toByteArray();
    }",0,[0]
21864,bugs-dot-jar_MNG-2174_778f044e,"private List<DomainModel> getDomainModelParentsFromLocalPath( PomClassicDomainModel domainModel,
                                                                  PomArtifactResolver artifactResolver,
                                                                  File projectDirectory,
                                                                  List<InterpolatorProperty> properties,
                                                                  Collection<String> activeProfileIds)
        throws IOException
    {
        List<DomainModel> domainModels = new ArrayList<DomainModel>();

        Parent parent = domainModel.getModel().getParent();

        if ( parent == null )
        {
            return domainModels;
        }

        Model model = domainModel.getModel();

        File parentFile = new File( projectDirectory, model.getParent().getRelativePath() ).getCanonicalFile();
        if ( parentFile.isDirectory() )
        {
            parentFile = new File( parentFile.getAbsolutePath(), ""pom.xml"" );
        }

        if ( !parentFile.isFile() )
        {
            throw new IOException( ""File does not exist: File = "" + parentFile.getAbsolutePath() );
        }

        PomClassicDomainModel parentDomainModel = new PomClassicDomainModel( parentFile );
        parentDomainModel.setProjectDirectory( parentFile.getParentFile() );
         ProfileContext profileContext = new ProfileContext(new DefaultModelDataSource(parentDomainModel.getModelProperties(),
                PomTransformer.MODEL_CONTAINER_FACTORIES), activeProfileIds, properties);
        Collection<ModelContainer> profileContainers = profileContext.getActiveProfiles();

        for(ModelContainer mc : profileContainers)
        {
            List<ModelProperty> transformed = new ArrayList<ModelProperty>();
            transformed.add(new ModelProperty(ProjectUri.xUri, null));
            for(ModelProperty mp : mc.getProperties())
            {
                if(mp.getUri().startsWith(ProjectUri.Profiles.Profile.xUri) && !mp.getUri().equals(ProjectUri.Profiles.Profile.id)
                    && !mp.getUri().startsWith(ProjectUri.Profiles.Profile.Activation.xUri))
                {
                    transformed.add(new ModelProperty(mp.getUri().replace(ProjectUri.Profiles.Profile.xUri, ProjectUri.xUri),
                            mp.getResolvedValue()));
                }
            }
            domainModels.add(new PomClassicDomainModel(transformed));
        }

        if ( !parentDomainModel.matchesParent( domainModel.getModel().getParent() ) )
        {
            logger.debug( ""Parent pom ids do not match: Parent File = "" + parentFile.getAbsolutePath() + "", Parent ID = ""
                    + parentDomainModel.getId() + "", Child ID = "" + domainModel.getId() + "", Expected Parent ID = ""
                    + domainModel.getModel().getParent().getId() );
            
            List<DomainModel> parentDomainModels = getDomainModelParentsFromRepository( domainModel, artifactResolver, properties, activeProfileIds );
            
            if(parentDomainModels.size() == 0)
            {
                throw new IOException(""Unable to find parent pom on local path or repo: ""
                        + domainModel.getModel().getParent().getId());
            }
            
            domainModels.addAll( parentDomainModels );
            return domainModels;
        }

        domainModels.add( parentDomainModel );
        if ( parentDomainModel.getModel().getParent() != null )
        {
            if ( isParentLocal( parentDomainModel.getModel().getParent(), parentFile.getParentFile() ) )
            {
                domainModels.addAll( getDomainModelParentsFromLocalPath( parentDomainModel, artifactResolver,
                                                                         parentFile.getParentFile(), properties, activeProfileIds ) );
            }
            else
            {
                domainModels.addAll( getDomainModelParentsFromRepository( parentDomainModel, artifactResolver, properties, activeProfileIds ) );
            }
        }

        return domainModels;
    }","private List<DomainModel> getDomainModelParentsFromLocalPath( PomClassicDomainModel domainModel,
                                                                  PomArtifactResolver artifactResolver,
                                                                  File projectDirectory,
                                                                  List<InterpolatorProperty> properties,
                                                                  Collection<String> activeProfileIds)
        throws IOException
    {
        List<DomainModel> domainModels = new ArrayList<DomainModel>();

        Parent parent = domainModel.getModel().getParent();

        if ( parent == null )
        {
            return domainModels;
        }

        Model model = domainModel.getModel();

        File parentFile = new File( projectDirectory, model.getParent().getRelativePath() ).getCanonicalFile();
        if ( parentFile.isDirectory() )
        {
            parentFile = new File( parentFile.getAbsolutePath(), ""pom.xml"" );
        }

        if ( !parentFile.isFile() )
        {
            throw new IOException( ""File does not exist: File = "" + parentFile.getAbsolutePath() );
        }

        PomClassicDomainModel parentDomainModel = new PomClassicDomainModel( parentFile );
        parentDomainModel.setProjectDirectory( parentFile.getParentFile() );
         ProfileContext profileContext = new ProfileContext(new DefaultModelDataSource(parentDomainModel.getModelProperties(),
                PomTransformer.MODEL_CONTAINER_FACTORIES), activeProfileIds, properties);
        Collection<ModelContainer> profileContainers = profileContext.getActiveProfiles();

        for(ModelContainer mc : profileContainers)
        {
            List<ModelProperty> transformed = new ArrayList<ModelProperty>();
            transformed.add(new ModelProperty(ProjectUri.xUri, null));
            for(ModelProperty mp : mc.getProperties())
            {
                if(mp.getUri().startsWith(ProjectUri.Profiles.Profile.xUri) && !mp.getUri().equals(ProjectUri.Profiles.Profile.id)
                    && !mp.getUri().startsWith(ProjectUri.Profiles.Profile.Activation.xUri))
                {
                    transformed.add(new ModelProperty(mp.getUri().replace(ProjectUri.Profiles.Profile.xUri, ProjectUri.xUri),
                            mp.getResolvedValue()));
                }
            }
            domainModels.add(new PomClassicDomainModel(transformed));
        }

        if ( !parentDomainModel.matchesParent( domainModel.getModel().getParent() ) )
        {
            logger.debug( ""Parent pom ids do not match: Parent File = "" + parentFile.getAbsolutePath() + "", Parent ID = ""
                    + parentDomainModel.getId() + "", Child ID = "" + domainModel.getId() + "", Expected Parent ID = ""
                    + domainModel.getModel().getParent().getId() );
            
            List<DomainModel> parentDomainModels = getDomainModelParentsFromRepository( domainModel, artifactResolver, properties, activeProfileIds );
            
            if(parentDomainModels.size() == 0)
            {
                throw new IOException(""Unable to find parent pom on local path or repo: ""
                        + domainModel.getModel().getParent().getId());
            }
            
            domainModels.addAll( parentDomainModels );
            return domainModels;
        }

        domainModels.add( parentDomainModel );
        if ( parentDomainModel.getModel().getParent() != null )
        {
            if ( isParentLocal( parentDomainModel.getModel().getParent(), parentFile.getParentFile() ) )
            {
                domainModels.addAll( getDomainModelParentsFromLocalPath( parentDomainModel, artifactResolver,
                                                                         parentFile.getParentFile(), properties, activeProfileIds ) );
            }
            else
            {
                domainModels.addAll( getDomainModelParentsFromRepository( parentDomainModel, artifactResolver, properties, activeProfileIds ) );
            }
        }

        return domainModels;
    }",0,[0]
27126,bugs-dot-jar_WICKET-4020_081cdeb2,"protected void addCachingDecoration(Url url, PageParameters parameters)
	{
		final List<String> segments = url.getSegments();
		final int lastSegmentAt = segments.size() - 1;
		final String filename = segments.get(lastSegmentAt);

		if (Strings.isEmpty(filename) == false)
		{
			// TODO is calling getResource() a potential performance bottleneck?
			final IResource resource = resourceReference.getResource();

			if (resource instanceof IStaticCacheableResource)
			{
				final IStaticCacheableResource cacheable = (IStaticCacheableResource)resource;
				final ResourceUrl cacheUrl = new ResourceUrl(filename, parameters);

				getCachingStrategy().decorateUrl(cacheUrl, cacheable);

				if (Strings.isEmpty(cacheUrl.getFileName()))
				{
					throw new IllegalStateException(""caching strategy returned empty name for "" + resource);
				}
				segments.set(lastSegmentAt, cacheUrl.getFileName());
			}
		}
	}","protected void addCachingDecoration(Url url, PageParameters parameters)
	{
		final List<String> segments = url.getSegments();
		final int lastSegmentAt = segments.size() - 1;
		final String filename = segments.get(lastSegmentAt);

		if (Strings.isEmpty(filename) == false)
		{
			// TODO is calling getResource() a potential performance bottleneck?
			final IResource resource = resourceReference.getResource();

			if (resource instanceof IStaticCacheableResource)
			{
				final IStaticCacheableResource cacheable = (IStaticCacheableResource)resource;
				final ResourceUrl cacheUrl = new ResourceUrl(filename, parameters);

				getCachingStrategy().decorateUrl(cacheUrl, cacheable);

				if (Strings.isEmpty(cacheUrl.getFileName()))
				{
					throw new IllegalStateException(""caching strategy returned empty name for "" + resource);
				}
				segments.set(lastSegmentAt, cacheUrl.getFileName());
			}
		}
	}",0,[0]
16628,bugs-dot-jar_WICKET-5689_2ac29d30,"public static WebApplication get()
	{
		Application application = Application.get();

		if (application instanceof WebApplication == false)
		{
			throw new WicketRuntimeException(
				""The application attached to the current thread is not a "" +
					WebApplication.class.getSimpleName());
		}

		return (WebApplication)application;
	}","public static WebApplication get()
	{
		Application application = Application.get();

		if (application instanceof WebApplication == false)
		{
			throw new WicketRuntimeException(
				""The application attached to the current thread is not a "" +
					WebApplication.class.getSimpleName());
		}

		return (WebApplication)application;
	}",0,[0]
21053,bugs-dot-jar_OAK-846_7acb091a,"@Override
    public synchronized String getNodes(String path, String revisionId, int depth,
            long offset, int maxChildNodes, String filter)
            throws MicroKernelException {
        if (depth != 0) {
            throw new MicroKernelException(""Only depth 0 is supported, depth is "" + depth);
        }
        revisionId = revisionId != null ? revisionId : headRevision.toString();
        if (revisionId.startsWith(""b"")) {
            // reading from the branch is reading from the trunk currently
            revisionId = stripBranchRevMarker(revisionId);
        }
        Revision rev = Revision.fromString(revisionId);
        Node n = getNode(path, rev);
        if (n == null) {
            return null;
            // throw new MicroKernelException(""Node not found at path "" + path);
        }
        JsopStream json = new JsopStream();
        boolean includeId = filter != null && filter.contains("":id"");
        includeId |= filter != null && filter.contains("":hash"");
        json.object();
        n.append(json, includeId);
        if (maxChildNodes == -1) {
            maxChildNodes = Integer.MAX_VALUE;
        }
        // FIXME: must not read all children!
        Children c = getChildren(path, rev, Integer.MAX_VALUE);
        for (long i = offset; i < c.children.size(); i++) {
            if (maxChildNodes-- <= 0) {
                break;
            }
            String name = PathUtils.getName(c.children.get((int) i));
            json.key(name).object().endObject();
        }
        json.key("":childNodeCount"").value(c.children.size());
        json.endObject();
        String result = json.toString();
        // if (filter != null && filter.contains("":hash"")) {
        //     result = result.replaceAll(""\"":id\"""", ""\"":hash\"""");
        // }
        return result;
    }","@Override
    public synchronized String getNodes(String path, String revisionId, int depth,
            long offset, int maxChildNodes, String filter)
            throws MicroKernelException {
        if (depth != 0) {
            throw new MicroKernelException(""Only depth 0 is supported, depth is "" + depth);
        }
        revisionId = revisionId != null ? revisionId : headRevision.toString();
        if (revisionId.startsWith(""b"")) {
            // reading from the branch is reading from the trunk currently
            revisionId = stripBranchRevMarker(revisionId);
        }
        Revision rev = Revision.fromString(revisionId);
        Node n = getNode(path, rev);
        if (n == null) {
            return null;
            // throw new MicroKernelException(""Node not found at path "" + path);
        }
        JsopStream json = new JsopStream();
        boolean includeId = filter != null && filter.contains("":id"");
        includeId |= filter != null && filter.contains("":hash"");
        json.object();
        n.append(json, includeId);
        if (maxChildNodes == -1) {
            maxChildNodes = Integer.MAX_VALUE;
        }
        // FIXME: must not read all children!
        Children c = getChildren(path, rev, Integer.MAX_VALUE);
        for (long i = offset; i < c.children.size(); i++) {
            if (maxChildNodes-- <= 0) {
                break;
            }
            String name = PathUtils.getName(c.children.get((int) i));
            json.key(name).object().endObject();
        }
        json.key("":childNodeCount"").value(c.children.size());
        json.endObject();
        String result = json.toString();
        // if (filter != null && filter.contains("":hash"")) {
        //     result = result.replaceAll(""\"":id\"""", ""\"":hash\"""");
        // }
        return result;
    }",0,[0]
1338,Bears-160,"protected void parseCreateTable(Marker start) {
        tokens.canConsume(""TEMPORARY"");
        tokens.consume(""TABLE"");
        boolean onlyIfNotExists = tokens.canConsume(""IF"", ""NOT"", ""EXISTS"");
        TableId tableId = parseQualifiedTableName(start);
        if (tokens.canConsume(""LIKE"")) {
            TableId originalId = parseQualifiedTableName(start);
            Table original = databaseTables.forTable(originalId);
            if (original != null) {
                databaseTables.overwriteTable(tableId, original.columns(), original.primaryKeyColumnNames(), original.defaultCharsetName());
            }
            consumeRemainingStatement(start);
            signalCreateTable(tableId, start);
            debugParsed(start);
            return;
        }
        if (onlyIfNotExists && databaseTables.forTable(tableId) != null) {
            // The table does exist, so we should do nothing ...
            consumeRemainingStatement(start);
            signalCreateTable(tableId, start);
            debugParsed(start);
            return;
        }
        TableEditor table = databaseTables.editOrCreateTable(tableId);

        // create_definition ...
        if (tokens.matches('(')) parseCreateDefinitionList(start, table);
        // table_options ...
        parseTableOptions(start, table);
        // partition_options ...
        if (tokens.matches(""PARTITION"")) {
            parsePartitionOptions(start, table);
        }
        // select_statement
        if (tokens.canConsume(""AS"") || tokens.canConsume(""IGNORE"", ""AS"") || tokens.canConsume(""REPLACE"", ""AS"")) {
            parseAsSelectStatement(start, table);
        }

        // Make sure that the table's character set has been set ...
        if (!table.hasDefaultCharsetName()) {
            table.setDefaultCharsetName(currentDatabaseCharset());
        }

        // Update the table definition ...
        databaseTables.overwriteTable(table.create());
        signalCreateTable(tableId, start);
        debugParsed(start);
    }","protected void parseCreateTable(Marker start) {
        tokens.canConsume(""TEMPORARY"");
        tokens.consume(""TABLE"");
        boolean onlyIfNotExists = tokens.canConsume(""IF"", ""NOT"", ""EXISTS"");
        TableId tableId = parseQualifiedTableName(start);
        if (tokens.canConsume(""LIKE"")) {
            TableId originalId = parseQualifiedTableName(start);
            Table original = databaseTables.forTable(originalId);
            if (original != null) {
                databaseTables.overwriteTable(tableId, original.columns(), original.primaryKeyColumnNames(), original.defaultCharsetName());
            }
            consumeRemainingStatement(start);
            signalCreateTable(tableId, start);
            debugParsed(start);
            return;
        }
        if (onlyIfNotExists && databaseTables.forTable(tableId) != null) {
            // The table does exist, so we should do nothing ...
            consumeRemainingStatement(start);
            signalCreateTable(tableId, start);
            debugParsed(start);
            return;
        }
        TableEditor table = databaseTables.editOrCreateTable(tableId);

        // create_definition ...
        if (tokens.matches('(')) parseCreateDefinitionList(start, table);
        // table_options ...
        parseTableOptions(start, table);
        // partition_options ...
        if (tokens.matches(""PARTITION"")) {
            parsePartitionOptions(start, table);
        }
        // select_statement
        if (tokens.canConsume(""AS"") || tokens.canConsume(""IGNORE"", ""AS"") || tokens.canConsume(""REPLACE"", ""AS"")) {
            parseAsSelectStatement(start, table);
        }

        // Make sure that the table's character set has been set ...
        if (!table.hasDefaultCharsetName()) {
            table.setDefaultCharsetName(currentDatabaseCharset());
        }

        // Update the table definition ...
        databaseTables.overwriteTable(table.create());
        signalCreateTable(tableId, start);
        debugParsed(start);
    }",0,[0]
33642,bugs-dot-jar_WICKET-3845_afc7034d,"public void addHeader(String name, String value)
	{
		// be lenient and strip leading / trailing blanks
		value = Args.notEmpty(value, ""value"").trim();

		internalAdd(name, value);
	}","public void addHeader(String name, String value)
	{
		// be lenient and strip leading / trailing blanks
		value = Args.notNull(value, ""value"").trim();

		internalAdd(name, value);
	}",1,[3]
27802,bugs-dot-jar_CAMEL-8053_cac72b14,"public void configure(RouteContext routeContext, ErrorHandler handler) {
        if (handler instanceof ErrorHandlerSupport) {
            ErrorHandlerSupport handlerSupport = (ErrorHandlerSupport) handler;

            List<OnExceptionDefinition> list = onExceptions.get(routeContext);
            if (list != null) {
                for (OnExceptionDefinition exception : list) {
                    handlerSupport.addExceptionPolicy(routeContext, exception);
                }
            }
        }
    }","public void configure(RouteContext routeContext, ErrorHandler handler) {
        if (handler instanceof ErrorHandlerSupport) {
            ErrorHandlerSupport handlerSupport = (ErrorHandlerSupport) handler;

            List<OnExceptionDefinition> list = onExceptions.get(routeContext);
            if (list != null) {
                for (OnExceptionDefinition exception : list) {
                    handlerSupport.addExceptionPolicy(routeContext, exception);
                }
            }
        }
    }",0,[0]
23273,bugs-dot-jar_FLINK-1496_0a4c7694,"public TaskEventDispatcher getTaskEventDispatcher() {
		return networkEnvironment.getTaskEventDispatcher();
	}","public TaskEventDispatcher getTaskEventDispatcher() {
		return networkEnvironment.getTaskEventDispatcher();
	}",0,[0]
26709,bugs-dot-jar_WICKET-3989_6a8fc1cc,"public void renderHead(final Component component, HtmlHeaderContainer container)
	{
	}","public void renderHead(final Component component, HtmlHeaderContainer container)
	{
	}",0,[0]
2001,Bears-245,"public static ParameterSpec get(VariableElement element) {
    TypeName type = TypeName.get(element.asType());
    String name = element.getSimpleName().toString();
    return ParameterSpec.builder(type, name)
        .addModifiers(element.getModifiers())
        .build();
  }","public static ParameterSpec get(VariableElement element) {
    TypeName type = TypeName.get(element.asType());
    String name = element.getSimpleName().toString();
    return ParameterSpec.builder(type, name)
        .addModifiers(element.getModifiers())
        .build();
  }",0,[0]
19589,bugs-dot-jar_WICKET-2569_9ced53a5,"@Override
	public String locationAsString()
	{
		/*
		 * Uses both resource locations so that if the child does not have a style and the parent
		 * does, the location is unique to this combination (or vice versa) SEE WICKET-1507 (Jeremy
		 * Thomerson)
		 */
		return getMarkupResourceStream().getBaseMarkup().locationAsString() + "":"" +
			getMarkupResourceStream().locationAsString();
	}","@Override
	public String locationAsString()
	{
		/*
		 * Uses both resource locations so that if the child does not have a style and the parent
		 * does, the location is unique to this combination (or vice versa) SEE WICKET-1507 (Jeremy
		 * Thomerson)
		 */
		return getMarkupResourceStream().getBaseMarkup().locationAsString() + "":"" +
			getMarkupResourceStream().locationAsString();
	}",0,[0]
16608,bugs-dot-jar_FLINK-1848_7164b2b6,"@Override
	public void read(DataInputView in) throws IOException {

		final boolean isNotNull = in.readBoolean();
		if (isNotNull) {
			final String scheme = StringUtils.readNullableString(in);
			final String userInfo = StringUtils.readNullableString(in);
			final String host = StringUtils.readNullableString(in);
			final int port = in.readInt();
			final String path = StringUtils.readNullableString(in);
			final String query = StringUtils.readNullableString(in);
			final String fragment = StringUtils.readNullableString(in);

			try {
				uri = new URI(scheme, userInfo, host, port, path, query, fragment);
			} catch (URISyntaxException e) {
				throw new IOException(""Error reconstructing URI"", e);
			}
		}
	}","@Override
	public void read(DataInputView in) throws IOException {

		final boolean isNotNull = in.readBoolean();
		if (isNotNull) {
			final String scheme = StringUtils.readNullableString(in);
			final String userInfo = StringUtils.readNullableString(in);
			final String host = StringUtils.readNullableString(in);
			final int port = in.readInt();
			final String path = StringUtils.readNullableString(in);
			final String query = StringUtils.readNullableString(in);
			final String fragment = StringUtils.readNullableString(in);

			try {
				uri = new URI(scheme, userInfo, host, port, path, query, fragment);
			} catch (URISyntaxException e) {
				throw new IOException(""Error reconstructing URI"", e);
			}
		}
	}",0,[0]
6376,bugs-dot-jar_ACCUMULO-3015_f848178e,"public Authorizations getAuths() {
    return auths;
  }","public Authorizations getAuths() {
    return auths;
  }",0,[0]
13786,bugs-dot-jar_LOG4J2-619_3b4b370e,"static DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        enableXInclude(factory);
        return factory.newDocumentBuilder();
    }","static DocumentBuilder newDocumentBuilder() throws ParserConfigurationException {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        enableXInclude(factory);
        return factory.newDocumentBuilder();
    }",0,[0]
21164,bugs-dot-jar_WICKET-5442_a382917f,"public int getMinute(final Calendar calendar)
	{
		return get(calendar, Calendar.MINUTE);
	}","public int getMinute(final Calendar calendar)
	{
		return get(calendar, Calendar.MINUTE);
	}",0,[0]
20720,bugs-dot-jar_OAK-3817_2a02a138,"private void init(AbstractAnalysisFactory o, NodeState state) {
        if (o instanceof ResourceLoaderAware) {
            try {
                ((ResourceLoaderAware) o).inform(new NodeStateResourceLoader(state, defaultLoader));
            } catch (IOException e) {
                throw new IllegalArgumentException(""Error occurred while initializing type "" + o.getClass(), e);
            }
        }

        if (state.hasProperty(LuceneIndexConstants.ANL_LUCENE_MATCH_VERSION)){
            o.setExplicitLuceneMatchVersion(true);
        }
    }","private void init(AbstractAnalysisFactory o, NodeState state) {
        if (o instanceof ResourceLoaderAware) {
            try {
                ((ResourceLoaderAware) o).inform(new NodeStateResourceLoader(state, defaultLoader));
            } catch (IOException e) {
                throw new IllegalArgumentException(""Error occurred while initializing type "" + o.getClass(), e);
            }
        }

        if (state.hasProperty(LuceneIndexConstants.ANL_LUCENE_MATCH_VERSION)){
            o.setExplicitLuceneMatchVersion(true);
        }
    }",0,[0]
951,bugs-dot-jar_WICKET-2033_420ac965,protected abstract void onSubmit(AjaxRequestTarget target);,protected abstract void onSubmit(AjaxRequestTarget target);,0,[0]
7802,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public ArrayRealVector add(RealVector v) {
        if (v instanceof ArrayRealVector) {
            final double[] vData = ((ArrayRealVector) v).data;
            final int dim = vData.length;
            checkVectorDimensions(dim);
            ArrayRealVector result = new ArrayRealVector(dim);
            double[] resultData = result.data;
            for (int i = 0; i < dim; i++) {
                resultData[i] = data[i] + vData[i];
            }
            return result;
        } else {
            checkVectorDimensions(v);
            double[] out = data.clone();
            Iterator<Entry> it = v.sparseIterator();
            while (it.hasNext()) {
                final Entry e = it.next();
                out[e.getIndex()] += e.getValue();
            }
            return new ArrayRealVector(out, false);
        }
    }","@Override
    public ArrayRealVector add(RealVector v) {
        if (v instanceof ArrayRealVector) {
            final double[] vData = ((ArrayRealVector) v).data;
            final int dim = vData.length;
            checkVectorDimensions(dim);
            ArrayRealVector result = new ArrayRealVector(dim);
            double[] resultData = result.data;
            for (int i = 0; i < dim; i++) {
                resultData[i] = data[i] + vData[i];
            }
            return result;
        } else {
            checkVectorDimensions(v);
            double[] out = data.clone();
            Iterator<Entry> it = v.sparseIterator();
            while (it.hasNext()) {
                final Entry e = it.next();
                out[e.getIndex()] += e.getValue();
            }
            return new ArrayRealVector(out, false);
        }
    }",0,[0]
34880,bugs-dot-jar_CAMEL-5570_a57830ed,"public OnExceptionDefinition handled(Expression handled) {
        setHandledPolicy(ExpressionToPredicateAdapter.toPredicate(handled));
        return this;
    }","public OnExceptionDefinition handled(Expression handled) {
        setHandledPolicy(ExpressionToPredicateAdapter.toPredicate(handled));
        return this;
    }",0,[0]
34498,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"long getFlushID() throws NoNodeException {
    try {
      String zTablePath = Constants.ZROOT + ""/"" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + ""/"" + extent.getTableId()
          + Constants.ZTABLE_FLUSH_ID;
      return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null), Constants.UTF8));
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    } catch (NumberFormatException nfe) {
      throw new RuntimeException(nfe);
    } catch (KeeperException ke) {
      if (ke instanceof NoNodeException) {
        throw (NoNodeException) ke;
      } else {
        throw new RuntimeException(ke);
      }
    }
  }","long getFlushID() throws NoNodeException {
    try {
      String zTablePath = Constants.ZROOT + ""/"" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + ""/"" + extent.getTableId()
          + Constants.ZTABLE_FLUSH_ID;
      return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null), Constants.UTF8));
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    } catch (NumberFormatException nfe) {
      throw new RuntimeException(nfe);
    } catch (KeeperException ke) {
      if (ke instanceof NoNodeException) {
        throw (NoNodeException) ke;
      } else {
        throw new RuntimeException(ke);
      }
    }
  }",0,[0]
973,Bears-127,"private Position decodeNew(DeviceSession deviceSession, ChannelBuffer buf, int index) {

        Position position = new Position();
        position.setDeviceId(deviceSession.getDeviceId());
        position.setProtocol(getProtocolName());

        position.set(Position.KEY_INDEX, index);

        position.setTime(new Date(buf.readUnsignedInt() * 1000));

        int flags = buf.readUnsignedByte();

        if (BitUtil.check(flags, 0)) {
            position.setLatitude(buf.readInt() / 1800000.0);
            position.setLongitude(buf.readInt() / 1800000.0);
            position.setAltitude(buf.readShort());
            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));
            position.setCourse(buf.readUnsignedShort());
            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());
        }

        if (BitUtil.check(flags, 1)) {
            position.setNetwork(new Network(CellTower.from(
                    buf.readUnsignedShort(), buf.readUnsignedShort(),
                    buf.readUnsignedShort(), buf.readUnsignedInt(), buf.readUnsignedByte())));
        }

        if (BitUtil.check(flags, 2)) {
            buf.skipBytes(7); // bsid1
        }

        if (BitUtil.check(flags, 3)) {
            buf.skipBytes(7); // bsid2
        }

        if (BitUtil.check(flags, 4)) {
            buf.skipBytes(7); // bss0
        }

        if (BitUtil.check(flags, 5)) {
            buf.skipBytes(7); // bss1
        }

        if (BitUtil.check(flags, 6)) {
            buf.skipBytes(7); // bss2
        }

        return position;
    }","private Position decodeNew(DeviceSession deviceSession, ChannelBuffer buf, int index) {

        Position position = new Position();
        position.setDeviceId(deviceSession.getDeviceId());
        position.setProtocol(getProtocolName());

        position.set(Position.KEY_INDEX, index);

        position.setTime(new Date(buf.readUnsignedInt() * 1000));

        int flags = buf.readUnsignedByte();

        if (BitUtil.check(flags, 0)) {
            position.setLatitude(buf.readInt() / 1800000.0);
            position.setLongitude(buf.readInt() / 1800000.0);
            position.setAltitude(buf.readShort());
            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));
            position.setCourse(buf.readUnsignedShort());
            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());
        }

        if (BitUtil.check(flags, 1)) {
            position.setNetwork(new Network(CellTower.from(
                    buf.readUnsignedShort(), buf.readUnsignedShort(),
                    buf.readUnsignedShort(), buf.readUnsignedInt(), buf.readUnsignedByte())));
        }

        if (BitUtil.check(flags, 2)) {
            buf.skipBytes(7); // bsid1
        }

        if (BitUtil.check(flags, 3)) {
            buf.skipBytes(7); // bsid2
        }

        if (BitUtil.check(flags, 4)) {
            buf.skipBytes(7); // bss0
        }

        if (BitUtil.check(flags, 5)) {
            buf.skipBytes(7); // bss1
        }

        if (BitUtil.check(flags, 6)) {
            buf.skipBytes(7); // bss2
        }

        return position;
    }",0,[0]
12677,bugs-dot-jar_FLINK-1985_495a5c3c,"private void setVertexConfig(Integer vertexID, StreamConfig config,
			List<StreamEdge> chainableOutputs, List<StreamEdge> nonChainableOutputs) {

		StreamNode vertex = streamGraph.getStreamNode(vertexID);

		config.setVertexID(vertexID);
		config.setBufferTimeout(vertex.getBufferTimeout());

		config.setTypeSerializerIn1(vertex.getTypeSerializerIn1());
		config.setTypeSerializerIn2(vertex.getTypeSerializerIn2());
		config.setTypeSerializerOut1(vertex.getTypeSerializerOut());

		config.setStreamOperator(vertex.getOperator());
		config.setOutputSelectorWrapper(vertex.getOutputSelectorWrapper());

		config.setNumberOfOutputs(nonChainableOutputs.size());
		config.setNonChainedOutputs(nonChainableOutputs);
		config.setChainedOutputs(chainableOutputs);
		config.setStateMonitoring(streamGraph.isCheckpointingEnabled());
		config.setStateHandleProvider(streamGraph.getStateHandleProvider());

		Class<? extends AbstractInvokable> vertexClass = vertex.getJobVertexClass();

		if (vertexClass.equals(StreamIterationHead.class)
				|| vertexClass.equals(StreamIterationTail.class)) {
			config.setIterationId(streamGraph.getLoopID(vertexID));
			config.setIterationWaitTime(streamGraph.getLoopTimeout(vertexID));
		}

		List<StreamEdge> allOutputs = new ArrayList<StreamEdge>(chainableOutputs);
		allOutputs.addAll(nonChainableOutputs);

		for (StreamEdge output : allOutputs) {
			config.setSelectedNames(output.getTargetID(),
					streamGraph.getEdge(vertexID, output.getTargetID()).getSelectedNames());
		}

		vertexConfigs.put(vertexID, config);
	}","private void setVertexConfig(Integer vertexID, StreamConfig config,
			List<StreamEdge> chainableOutputs, List<StreamEdge> nonChainableOutputs) {

		StreamNode vertex = streamGraph.getStreamNode(vertexID);

		config.setVertexID(vertexID);
		config.setBufferTimeout(vertex.getBufferTimeout());

		config.setTypeSerializerIn1(vertex.getTypeSerializerIn1());
		config.setTypeSerializerIn2(vertex.getTypeSerializerIn2());
		config.setTypeSerializerOut1(vertex.getTypeSerializerOut());

		config.setStreamOperator(vertex.getOperator());
		config.setOutputSelectorWrapper(vertex.getOutputSelectorWrapper());

		config.setNumberOfOutputs(nonChainableOutputs.size());
		config.setNonChainedOutputs(nonChainableOutputs);
		config.setChainedOutputs(chainableOutputs);
		config.setStateMonitoring(streamGraph.isCheckpointingEnabled());
		config.setStateHandleProvider(streamGraph.getStateHandleProvider());

		Class<? extends AbstractInvokable> vertexClass = vertex.getJobVertexClass();

		if (vertexClass.equals(StreamIterationHead.class)
				|| vertexClass.equals(StreamIterationTail.class)) {
			config.setIterationId(streamGraph.getLoopID(vertexID));
			config.setIterationWaitTime(streamGraph.getLoopTimeout(vertexID));
		}

		List<StreamEdge> allOutputs = new ArrayList<StreamEdge>(chainableOutputs);
		allOutputs.addAll(nonChainableOutputs);

		for (StreamEdge output : allOutputs) {
			config.setSelectedNames(output.getTargetID(),
					streamGraph.getEdge(vertexID, output.getTargetID()).getSelectedNames());
		}

		vertexConfigs.put(vertexID, config);
	}",0,[0]
2182,bugs-dot-jar_MNG-4918_691a03a7,"@Deprecated
    public MavenProject( MavenProject project )
    {
        deepCopy( project );
    }","@Deprecated
    public MavenProject( MavenProject project )
    {
        deepCopy( project );
    }",0,[0]
340,Bears-15,"@Override
    public Class<?>[] findViews(Annotated a)
    {
        JsonView ann = _findAnnotation(a, JsonView.class);
        return (ann == null) ? null : ann.value();
    }","@Override
    public Class<?>[] findViews(Annotated a)
    {
        JsonView ann = _findAnnotation(a, JsonView.class);
        return (ann == null) ? null : ann.value();
    }",0,[0]
7282,bugs-dot-jar_LOG4J2-581_bb02fa15,"public PatternProcessor getPatternProcessor() {
        return patternProcessor;
    }","public PatternProcessor getPatternProcessor() {
        return patternProcessor;
    }",0,[0]
8204,bugs-dot-jar_MATH-294_2c8a114f,"private void shuffle(int[] list, int end) {
        int target = 0;
        for (int i = list.length - 1; i >= end; i--) {
            if (i == 0) {
                target = 0;
            } else {
                target = nextInt(0, i);
            }
            int temp = list[target];
            list[target] = list[i];
            list[i] = temp;
        }
    }","private void shuffle(int[] list, int end) {
        int target = 0;
        for (int i = list.length - 1; i >= end; i--) {
            if (i == 0) {
                target = 0;
            } else {
                target = nextInt(0, i);
            }
            int temp = list[target];
            list[target] = list[i];
            list[i] = temp;
        }
    }",0,[0]
11521,bugs-dot-jar_ACCUMULO-1800_8ec4cb84,"@Override
  public void importTable(ByteBuffer login, String tableName, String importDir) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableExistsException, TException {
    
    try {
      getConnector(login).tableOperations().importTable(tableName, importDir);
    } catch (TableExistsException e) {
      throw new org.apache.accumulo.proxy.thrift.TableExistsException(e.toString());
    } catch (Exception e) {
      handleException(e);
    }
  }","@Override
  public void importTable(ByteBuffer login, String tableName, String importDir) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableExistsException, TException {
    
    try {
      getConnector(login).tableOperations().importTable(tableName, importDir);
    } catch (TableExistsException e) {
      throw new org.apache.accumulo.proxy.thrift.TableExistsException(e.toString());
    } catch (Exception e) {
      handleException(e);
    }
  }",0,[0]
24886,bugs-dot-jar_CAMEL-7100_00a9b02b,"public static String newStringFromBytes(byte[] bytes, int start, int length) {
        try {
            return new String(bytes, start, length, UTF8_CHARSET.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(""Impossible failure: Charset.forName(\""UTF-8\"") returns invalid name."", e);
        }
    }","public static String newStringFromBytes(byte[] bytes, int start, int length) {
        try {
            return new String(bytes, start, length, UTF8_CHARSET.name());
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(""Impossible failure: Charset.forName(\""UTF-8\"") returns invalid name."", e);
        }
    }",0,[0]
18103,bugs-dot-jar_WICKET-5147_184e51e9,"@Override
	protected void onBeforeRender()
	{
		// Make sure it is really empty
		renderedComponents = null;

		// if the page is stateless, reset the flag so that it is tested again
		if (Boolean.TRUE.equals(stateless))
		{
			stateless = null;
		}

		super.onBeforeRender();

		// If any of the components on page is not stateless, we need to bind the session
		// before we start rendering components, as then jsessionid won't be appended
		// for links rendered before first stateful component
		if (getSession().isTemporary() && !peekPageStateless())
		{
			getSession().bind();
		}
	}","@Override
	protected void onBeforeRender()
	{
		// Make sure it is really empty
		renderedComponents = null;

		// if the page is stateless, reset the flag so that it is tested again
		if (Boolean.TRUE.equals(stateless))
		{
			stateless = null;
		}

		super.onBeforeRender();

		// If any of the components on page is not stateless, we need to bind the session
		// before we start rendering components, as then jsessionid won't be appended
		// for links rendered before first stateful component
		if (getSession().isTemporary() && !peekPageStateless())
		{
			getSession().bind();
		}
	}",0,[0]
7946,bugs-dot-jar_MATH-812_6eb46555,"public RealVector combine(double a, double b, RealVector y) {
        return copy().combineToSelf(a, b, y);
    }","public RealVector combine(double a, double b, RealVector y) {
        return copy().combineToSelf(a, b, y);
    }",0,[0]
23924,bugs-dot-jar_ACCUMULO-3077_17654199,"public int minorCompactionStarted(final CommitSession commitSession, final int seq, final String fullyQualifiedFileName) throws IOException {
    if (!enabled(commitSession))
      return -1;
    write(commitSession, false, new Writer() {
      @Override
      public LoggerOperation write(DfsLogger logger, int ignored) throws Exception {
        logger.minorCompactionStarted(seq, commitSession.getLogId(), fullyQualifiedFileName).await();
        return null;
      }
    });
    return seq;
  }","public int minorCompactionStarted(final CommitSession commitSession, final int seq, final String fullyQualifiedFileName) throws IOException {
    if (!enabled(commitSession))
      return -1;
    write(commitSession, false, new Writer() {
      @Override
      public LoggerOperation write(DfsLogger logger, int ignored) throws Exception {
        logger.minorCompactionStarted(seq, commitSession.getLogId(), fullyQualifiedFileName).await();
        return null;
      }
    });
    return seq;
  }",0,[0]
40356,bugs-dot-jar_WICKET-442_246d53c5,"public Component(final String id)
	{
		setId(id);
		getApplication().notifyComponentInstantiationListeners(this);
	}","public Component(final String id)
	{
		setId(id);
		getApplication().notifyComponentInstantiationListeners(this);
	}",0,[0]
13847,bugs-dot-jar_CAMEL-4011_cbffff59,"@Converter
    public static Short toShort(Object value) {
        if (value instanceof Short) {
            return (Short) value;
        } else if (value instanceof Number) {
            Number number = (Number) value;
            return number.shortValue();
        } else if (value instanceof String) {
            return Short.valueOf((String) value);
        } else {
            return null;
        }
    }","@Converter
    public static Short toShort(Object value) {
        if (value instanceof Short) {
            return (Short) value;
        } else if (value instanceof Number) {
            if (value.equals(Double.NaN)) {
                return null;
            }
            Number number = (Number) value;
            return number.shortValue();
        } else if (value instanceof String) {
            return Short.valueOf((String) value);
        } else {
            return null;
        }
    }",1,[]
26683,bugs-dot-jar_MATH-471_a4b1948b,"public static long subAndCheck(long a, long b) {
        long ret;
        String msg = ""overflow: subtract"";
        if (b == Long.MIN_VALUE) {
            if (a < 0) {
                ret = a - b;
            } else {
                throw new MathArithmeticException(msg);
            }
        } else {
            // use additive inverse
            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);
        }
        return ret;
    }","public static long subAndCheck(long a, long b) {
        long ret;
        String msg = ""overflow: subtract"";
        if (b == Long.MIN_VALUE) {
            if (a < 0) {
                ret = a - b;
            } else {
                throw new MathArithmeticException(msg);
            }
        } else {
            // use additive inverse
            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);
        }
        return ret;
    }",0,[0]
18848,bugs-dot-jar_MATH-935_48dde378,"public void tanh(final double[] operand, final int operandOffset,
                     final double[] result, final int resultOffset) {

        // create the function value and derivatives
        final double[] function = new double[1 + order];
        final double t = FastMath.tanh(operand[operandOffset]);
        function[0] = t;

        if (order > 0) {

            // the nth order derivative of tanh has the form:
            // dn(tanh(x)/dxn = P_n(tanh(x))
            // where P_n(t) is a degree n+1 polynomial with same parity as n+1
            // P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ...
            // the general recurrence relation for P_n is:
            // P_n(x) = (1-t^2) P_(n-1)'(t)
            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
            final double[] p = new double[order + 2];
            p[1] = 1;
            final double t2 = t * t;
            for (int n = 1; n <= order; ++n) {

                // update and evaluate polynomial P_n(t)
                double v = 0;
                p[n + 1] = -n * p[n];
                for (int k = n + 1; k >= 0; k -= 2) {
                    v = v * t2 + p[k];
                    if (k > 2) {
                        p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];
                    } else if (k == 2) {
                        p[0] = p[1];
                    }
                }
                if ((n & 0x1) == 0) {
                    v *= t;
                }

                function[n] = v;

            }
        }

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }","public void tanh(final double[] operand, final int operandOffset,
                     final double[] result, final int resultOffset) {

        // create the function value and derivatives
        final double[] function = new double[1 + order];
        final double t = FastMath.tanh(operand[operandOffset]);
        function[0] = t;

        if (order > 0) {

            // the nth order derivative of tanh has the form:
            // dn(tanh(x)/dxn = P_n(tanh(x))
            // where P_n(t) is a degree n+1 polynomial with same parity as n+1
            // P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ...
            // the general recurrence relation for P_n is:
            // P_n(x) = (1-t^2) P_(n-1)'(t)
            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
            final double[] p = new double[order + 2];
            p[1] = 1;
            final double t2 = t * t;
            for (int n = 1; n <= order; ++n) {

                // update and evaluate polynomial P_n(t)
                double v = 0;
                p[n + 1] = -n * p[n];
                for (int k = n + 1; k >= 0; k -= 2) {
                    v = v * t2 + p[k];
                    if (k > 2) {
                        p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];
                    } else if (k == 2) {
                        p[0] = p[1];
                    }
                }
                if ((n & 0x1) == 0) {
                    v *= t;
                }

                function[n] = v;

            }
        }

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }",0,[0]
2823,bugs-dot-jar_WICKET-5056_56169634,"@Override
	public int getCompatibilityScore(Request request)
	{
		if (urlStartsWith(request.getUrl(), mountSegments))
		{
			return mountSegments.length;
		}
		else
		{
			return 0;
		}
	}","@Override
	public int getCompatibilityScore(Request request)
	{
		if (urlStartsWith(request.getUrl(), mountSegments))
		{
			/* see WICKET-5056 - alter score with pathSegment type */
			int countOptional = 0;
			int fixedSegments = 0;
			for (MountPathSegment pathSegment : pathSegments)
			{
				fixedSegments += pathSegment.getFixedPartSize();
				countOptional += pathSegment.getOptionalParameters();
			}
			return mountSegments.length - countOptional + fixedSegments;
		}
		else
		{
			return 0;
		}
	}",1,[5]
26365,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    public boolean holdsLock() throws RepositoryException {
        return getLockManager().holdsLock(getPath());
    }","@Override
    public boolean holdsLock() throws RepositoryException {
        return getLockManager().holdsLock(getPath());
    }",0,[0]
1681,Bears-197,"public static String urlEncode(final String value) {
        try {
            return URLEncoder.encode(value, ""UTF-8"");
        } catch (final UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }","public static String urlEncode(final String value) {
        try {
            return URLEncoder.encode(value, ""UTF-8"");
        } catch (final UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }",0,[0]
33607,bugs-dot-jar_WICKET-4520_b91154ea,"public SharedResources getSharedResources()
	{
		return sharedResources;
	}","public SharedResources getSharedResources()
	{
		return sharedResources;
	}",0,[0]
35263,bugs-dot-jar_ACCUMULO-1732_941e3cb1,"@Deprecated
  protected static String getTokenClass(JobConf job) {
    return getAuthenticationToken(job).getClass().getName();
  }","@Deprecated
  protected static String getTokenClass(JobConf job) {
    return getAuthenticationToken(job).getClass().getName();
  }",0,[0]
10081,bugs-dot-jar_WICKET-4292_9cb617ae,"@Override
	public String encodeURL(final String url)
	{
		return url;
	}","@Override
	public String encodeURL(final String url)
	{
		return url;
	}",0,[0]
21154,bugs-dot-jar_WICKET-5442_a382917f,"public Time add(final Duration duration)
	{
		return millis(getMilliseconds() + duration.getMilliseconds());
	}","public Time add(final Duration duration)
	{
		return millis(getMilliseconds() + duration.getMilliseconds());
	}",0,[0]
39934,bugs-dot-jar_WICKET-2621_c849f986,"public MultiFileUploadField(String id, IModel<Collection<FileUpload>> model)
	{
		this(id, model, UNLIMITED);
	}","public MultiFileUploadField(String id, IModel<Collection<FileUpload>> model)
	{
		this(id, model, UNLIMITED);
	}",0,[0]
11054,bugs-dot-jar_LOG4J2-478_11763dee,"@PluginFactory
    public static JSONLayout createLayout(
            @PluginAttribute(""locationInfo"") final String locationInfo,
            @PluginAttribute(""properties"") final String properties, 
            @PluginAttribute(""complete"") final String completeStr,
            @PluginAttribute(""compact"") final String compactStr, 
            @PluginAttribute(""charset"") final String charsetName) {
        final Charset charset = Charsets.getSupportedCharset(charsetName, Charsets.UTF_8);
        final boolean info = Boolean.parseBoolean(locationInfo);
        final boolean props = Boolean.parseBoolean(properties);
        final boolean complete = Boolean.parseBoolean(completeStr);
        final boolean compact = Boolean.parseBoolean(compactStr);
        return new JSONLayout(info, props, complete, compact, charset);
    }","@PluginFactory
    public static JSONLayout createLayout(
            @PluginAttribute(""locationInfo"") final String locationInfo,
            @PluginAttribute(""properties"") final String properties, 
            @PluginAttribute(""complete"") final String completeStr,
            @PluginAttribute(""compact"") final String compactStr, 
            @PluginAttribute(""charset"") final String charsetName) {
        final Charset charset = Charsets.getSupportedCharset(charsetName, Charsets.UTF_8);
        final boolean info = Boolean.parseBoolean(locationInfo);
        final boolean props = Boolean.parseBoolean(properties);
        final boolean complete = Boolean.parseBoolean(completeStr);
        final boolean compact = Boolean.parseBoolean(compactStr);
        return new JSONLayout(info, props, complete, compact, charset);
    }",0,[0]
7398,bugs-dot-jar_OAK-1369_ce0b0955,"private Expression parseCondition() throws ParseException {
        Expression a;
        if (readIf(""fn:not"") || readIf(""not"")) {
            read(""("");
            a = parseConstraint();
            if (a instanceof Expression.Condition && ((Expression.Condition) a).operator.equals(""is not null"")) {
                // not(@property) -> @property is null
                Expression.Condition c = (Expression.Condition) a;
                c = new Expression.Condition(c.left, ""is null"", null, Expression.PRECEDENCE_CONDITION);
                a = c;
            } else {
                Expression.Function f = new Expression.Function(""not"");
                f.params.add(a);
                a = f;
            }
            read("")"");
        } else if (readIf(""("")) {
            a = parseConstraint();
            read("")"");
        } else {
            Expression e = parseExpression();
            if (e.isCondition()) {
                return e;
            }
            a = parseCondition(e);
        }
        return a;
    }","private Expression parseCondition() throws ParseException {
        Expression a;
        if (readIf(""fn:not"") || readIf(""not"")) {
            read(""("");
            a = parseConstraint();
            if (a instanceof Expression.Condition && ((Expression.Condition) a).operator.equals(""is not null"")) {
                // not(@property) -> @property is null
                Expression.Condition c = (Expression.Condition) a;
                c = new Expression.Condition(c.left, ""is null"", null, Expression.PRECEDENCE_CONDITION);
                a = c;
            } else {
                Expression.Function f = new Expression.Function(""not"");
                f.params.add(a);
                a = f;
            }
            read("")"");
        } else if (readIf(""("")) {
            a = parseConstraint();
            read("")"");
        } else {
            Expression e = parseExpression();
            if (e.isCondition()) {
                return e;
            }
            a = parseCondition(e);
        }
        return a;
    }",0,[0]
10054,bugs-dot-jar_MATH-1127_ba62c59d,"public static boolean equals(float x, float y) {
        return equals(x, y, 1);
    }","public static boolean equals(float x, float y) {
        return equals(x, y, 1);
    }",0,[0]
1206,Bears-152,"@Override
    public void close(final int timeout) {
        startClose();
        if (timeout > 0) {
            final long max = (long) timeout;
            final long start = System.currentTimeMillis();
            if (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, true)) {
                sendChannelReadOnlyEvent();
            }
            while (HeaderExchangeServer.this.isRunning()
                    && System.currentTimeMillis() - start < max) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }
        doClose();
        server.close(timeout);
    }","@Override
    public void close(final int timeout) {
        startClose();
        if (timeout > 0) {
            final long max = (long) timeout;
            final long start = System.currentTimeMillis();
            if (getUrl().getParameter(Constants.CHANNEL_SEND_READONLYEVENT_KEY, true)) {
                sendChannelReadOnlyEvent();
            }
            while (HeaderExchangeServer.this.isRunning()
                    && System.currentTimeMillis() - start < max) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }
        doClose();
        server.close(timeout);
    }",0,[0]
21472,bugs-dot-jar_LOG4J2-1046_11960820,"private ThrowableProxy[] toSuppressedProxies(final Throwable thrown, Set<Throwable> suppressedVisited) {
        try {
            final Throwable[] suppressed = Throwables.getSuppressed(thrown);
            if (suppressed == null) {
                return EMPTY_THROWABLE_PROXY_ARRAY;
            }
            final List<ThrowableProxy> proxies = new ArrayList<>(suppressed.length);
            if (suppressedVisited == null) {
                suppressedVisited = new HashSet<>(proxies.size());
            }
            for (int i = 0; i < suppressed.length; i++) {
                final Throwable candidate = suppressed[i];
                if (!suppressedVisited.contains(candidate)) {
                    suppressedVisited.add(candidate);
                    proxies.add(new ThrowableProxy(candidate, suppressedVisited));
                }
            }
            return proxies.toArray(new ThrowableProxy[proxies.size()]);
        } catch (final Exception e) {
            StatusLogger.getLogger().error(e);
        }
        return null;
    }","private ThrowableProxy[] toSuppressedProxies(final Throwable thrown, Set<Throwable> suppressedVisited) {
        try {
            final Throwable[] suppressed = Throwables.getSuppressed(thrown);
            if (suppressed == null) {
                return EMPTY_THROWABLE_PROXY_ARRAY;
            }
            final List<ThrowableProxy> proxies = new ArrayList<>(suppressed.length);
            if (suppressedVisited == null) {
                suppressedVisited = new HashSet<>(proxies.size());
            }
            for (int i = 0; i < suppressed.length; i++) {
                final Throwable candidate = suppressed[i];
                if (!suppressedVisited.contains(candidate)) {
                    suppressedVisited.add(candidate);
                    proxies.add(new ThrowableProxy(candidate, suppressedVisited));
                }
            }
            return proxies.toArray(new ThrowableProxy[proxies.size()]);
        } catch (final Exception e) {
            StatusLogger.getLogger().error(e);
        }
        return null;
    }",0,[0]
98,bugs-dot-jar_OAK-1822_3e83a4c1,"public void increment(@Nonnull String property, long value) {
        Operation op = new Operation();
        op.type = Operation.Type.INCREMENT;
        op.value = value;
        changes.put(new Key(property, null), op);
    }","public void increment(@Nonnull String property, long value) {
        Operation op = new Operation(Operation.Type.INCREMENT, value);
        changes.put(new Key(property, null), op);
    }",1,"[1, 2, 3]"
34574,bugs-dot-jar_CAMEL-8964_ea8ee025,"public DefaultCamelContext() {
        this.executorServiceManager = new DefaultExecutorServiceManager(this);

        // create endpoint registry at first since end users may access endpoints before CamelContext is started
        this.endpoints = new DefaultEndpointRegistry(this);

        // add the derfer service startup listener
        this.startupListeners.add(deferStartupListener);

        // use WebSphere specific resolver if running on WebSphere
        if (WebSpherePackageScanClassResolver.isWebSphereClassLoader(this.getClass().getClassLoader())) {
            log.info(""Using WebSphere specific PackageScanClassResolver"");
            packageScanClassResolver = new WebSpherePackageScanClassResolver(""META-INF/services/org/apache/camel/TypeConverter"");
        } else {
            packageScanClassResolver = new DefaultPackageScanClassResolver();
        }

        // setup management strategy first since end users may use it to add event notifiers
        // using the management strategy before the CamelContext has been started
        this.managementStrategy = createManagementStrategy();
        this.managementMBeanAssembler = createManagementMBeanAssembler();

        // Call all registered trackers with this context
        // Note, this may use a partially constructed object
        CamelContextTrackerRegistry.INSTANCE.contextCreated(this);

        // [TODO] Remove in 3.0
        Container.Instance.manage(this);
    }","public DefaultCamelContext() {
        this.executorServiceManager = new DefaultExecutorServiceManager(this);

        // create endpoint registry at first since end users may access endpoints before CamelContext is started
        this.endpoints = new DefaultEndpointRegistry(this);

        // add the derfer service startup listener
        this.startupListeners.add(deferStartupListener);

        // use WebSphere specific resolver if running on WebSphere
        if (WebSpherePackageScanClassResolver.isWebSphereClassLoader(this.getClass().getClassLoader())) {
            log.info(""Using WebSphere specific PackageScanClassResolver"");
            packageScanClassResolver = new WebSpherePackageScanClassResolver(""META-INF/services/org/apache/camel/TypeConverter"");
        } else {
            packageScanClassResolver = new DefaultPackageScanClassResolver();
        }

        // setup management strategy first since end users may use it to add event notifiers
        // using the management strategy before the CamelContext has been started
        this.managementStrategy = createManagementStrategy();
        this.managementMBeanAssembler = createManagementMBeanAssembler();

        // Call all registered trackers with this context
        // Note, this may use a partially constructed object
        CamelContextTrackerRegistry.INSTANCE.contextCreated(this);

        // [TODO] Remove in 3.0
        Container.Instance.manage(this);
    }",0,[0]
272,Bears-12,"public BuilderBasedDeserializer(BuilderBasedDeserializer src, Set<String> ignorableProps) {
        super(src, ignorableProps);
        _buildMethod = src._buildMethod;
    }","public BuilderBasedDeserializer(BuilderBasedDeserializer src, Set<String> ignorableProps) {
        super(src, ignorableProps);
        _buildMethod = src._buildMethod;
    }",0,[0]
29739,bugs-dot-jar_FLINK-2763_af477563,"protected boolean processProbeIter() throws IOException{
		final ProbeIterator<PT> probeIter = this.probeIterator;
		final TypeComparator<PT> probeAccessors = this.probeSideComparator;
		
		PT next;
		while ((next = probeIter.next()) != null) {
			final int hash = hash(probeAccessors.hash(next), this.currentRecursionDepth);
			final int posHashCode = hash % this.numBuckets;
			
			// get the bucket for the given hash code
			final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits;
			final int bucketInSegmentOffset = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
			final MemorySegment bucket = this.buckets[bucketArrayPos];
			
			// get the basic characteristics of the bucket
			final int partitionNumber = bucket.get(bucketInSegmentOffset + HEADER_PARTITION_OFFSET);
			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber);
			
			// for an in-memory partition, process set the return iterators, else spill the probe records
			if (p.isInMemory()) {
				this.recordComparator.setReference(next);
				this.bucketIterator.set(bucket, p.overflowSegments, p, hash, bucketInSegmentOffset);
				return true;
			} else {
				byte status = bucket.get(bucketInSegmentOffset + HEADER_STATUS_OFFSET);
				if (status == BUCKET_STATUS_IN_FILTER) {
					this.bloomFilter.setBitsLocation(bucket, bucketInSegmentOffset + BUCKET_HEADER_LENGTH);
					// Use BloomFilter to filter out all the probe records which would not match any key in spilled build table buckets.
					if (this.bloomFilter.testHash(hash)) {
						p.insertIntoProbeBuffer(next);
					}
				} else {
					p.insertIntoProbeBuffer(next);
				}
			}
		}
		// -------------- partition done ---------------
		
		return false;
	}","protected boolean processProbeIter() throws IOException{
		final ProbeIterator<PT> probeIter = this.probeIterator;
		final TypeComparator<PT> probeAccessors = this.probeSideComparator;
		
		PT next;
		while ((next = probeIter.next()) != null) {
			final int hash = hash(probeAccessors.hash(next), this.currentRecursionDepth);
			final int posHashCode = hash % this.numBuckets;
			
			// get the bucket for the given hash code
			final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits;
			final int bucketInSegmentOffset = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
			final MemorySegment bucket = this.buckets[bucketArrayPos];
			
			// get the basic characteristics of the bucket
			final int partitionNumber = bucket.get(bucketInSegmentOffset + HEADER_PARTITION_OFFSET);
			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber);
			
			// for an in-memory partition, process set the return iterators, else spill the probe records
			if (p.isInMemory()) {
				this.recordComparator.setReference(next);
				this.bucketIterator.set(bucket, p.overflowSegments, p, hash, bucketInSegmentOffset);
				return true;
			} else {
				byte status = bucket.get(bucketInSegmentOffset + HEADER_STATUS_OFFSET);
				if (status == BUCKET_STATUS_IN_FILTER) {
					this.bloomFilter.setBitsLocation(bucket, bucketInSegmentOffset + BUCKET_HEADER_LENGTH);
					// Use BloomFilter to filter out all the probe records which would not match any key in spilled build table buckets.
					if (this.bloomFilter.testHash(hash)) {
						p.insertIntoProbeBuffer(next);
					}
				} else {
					p.insertIntoProbeBuffer(next);
				}
			}
		}
		// -------------- partition done ---------------
		
		return false;
	}",0,[0]
23359,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public void trim(final int depth) {
        if (depth < 0) {
            throw new IllegalArgumentException(
                    ""Maximum stack depth cannot be negative"");
        }
        final List<String> list = stack.get();
        if (list == null) {
            return;
        }
        final List<String> copy = new ArrayList<String>();
        final int count = Math.min(depth, list.size());
        for (int i = 0; i < count; i++) {
            copy.add(list.get(i));
        }
        stack.set(copy);
    }","@Override
    public void trim(final int depth) {
        if (depth < 0) {
            throw new IllegalArgumentException(
                    ""Maximum stack depth cannot be negative"");
        }
        final List<String> list = stack.get();
        if (list == null) {
            return;
        }
        final List<String> copy = new ArrayList<String>();
        final int count = Math.min(depth, list.size());
        for (int i = 0; i < count; i++) {
            copy.add(list.get(i));
        }
        stack.set(copy);
    }",0,[0]
3775,bugs-dot-jar_FLINK-2460_a17d4e82,"boolean registerListener(NotificationListener listener) {
		synchronized (buffers) {
			if (!buffers.isEmpty() || isReleased) {
				return false;
			}

			if (registeredListener == null) {
				registeredListener = listener;

				return true;
			}

			throw new IllegalStateException(""Already registered listener."");
		}
	}","boolean registerListener(NotificationListener listener) {
		synchronized (buffers) {
			if (!buffers.isEmpty() || isReleased) {
				return false;
			}

			if (registeredListener == null) {
				registeredListener = listener;

				return true;
			}

			throw new IllegalStateException(""Already registered listener."");
		}
	}",0,[0]
2265,bugs-dot-jar_MNG-4918_691a03a7,"@Deprecated
    public void setReporting( Reporting reporting )
    {
        getModel().setReporting( reporting );
    }","@Deprecated
    public void setReporting( Reporting reporting )
    {
        getModel().setReporting( reporting );
    }",0,[0]
9860,bugs-dot-jar_OAK-3634_90ad50da,"private static String indexTypeAsString(int type) {
        switch (type) {
            case DatabaseMetaData.tableIndexClustered:
                return ""clustered"";
            case DatabaseMetaData.tableIndexHashed:
                return ""hashed"";
            case DatabaseMetaData.tableIndexStatistic:
                return ""statistic"";
            case DatabaseMetaData.tableIndexOther:
                return ""other"";
            default:
                return ""indexType="" + type;
        }
    }","private static String indexTypeAsString(int type) {
        switch (type) {
            case DatabaseMetaData.tableIndexClustered:
                return ""clustered"";
            case DatabaseMetaData.tableIndexHashed:
                return ""hashed"";
            case DatabaseMetaData.tableIndexStatistic:
                return ""statistic"";
            case DatabaseMetaData.tableIndexOther:
                return ""other"";
            default:
                return ""indexType="" + type;
        }
    }",0,[0]
33830,bugs-dot-jar_ACCUMULO-1986_adee0f12,"private void put(byte b[]) {
    buffer.add(b.length);
    buffer.add(b);
  }","private void put(byte b[]) {
    buffer.add(b.length);
    buffer.add(b);
  }",0,[0]
7943,bugs-dot-jar_MATH-812_6eb46555,"public Iterator<Entry> iterator() {
        final int dim = getDimension();
        return new Iterator<Entry>() {

            /** Current index. */
            private int i = 0;

            /** Current entry. */
            private Entry e = new Entry();

            /** {@inheritDoc} */
            public boolean hasNext() {
                return i < dim;
            }

            /** {@inheritDoc} */
            public Entry next() {
                if (i < dim) {
                    e.setIndex(i++);
                    return e;
                } else {
                    throw new NoSuchElementException();
                }
            }

            /** {@inheritDoc} */
            public void remove() {
                throw new MathUnsupportedOperationException();
            }
        };
    }","public Iterator<Entry> iterator() {
        final int dim = getDimension();
        return new Iterator<Entry>() {

            /** Current index. */
            private int i = 0;

            /** Current entry. */
            private Entry e = new Entry();

            /** {@inheritDoc} */
            public boolean hasNext() {
                return i < dim;
            }

            /** {@inheritDoc} */
            public Entry next() {
                if (i < dim) {
                    e.setIndex(i++);
                    return e;
                } else {
                    throw new NoSuchElementException();
                }
            }

            /** {@inheritDoc} */
            public void remove() {
                throw new MathUnsupportedOperationException();
            }
        };
    }",0,[0]
769,bugs-dot-jar_FLINK-3762_dc78a747,"@Override
	public boolean isImmutableType() {
		return false;
	}","@Override
	public boolean isImmutableType() {
		return false;
	}",0,[0]
9689,bugs-dot-jar_CAMEL-4542_c408c3ed,"public void setInstance(Object instance) {
        this.instance = instance;
    }","public void setInstance(Object instance) {
        this.instance = instance;
    }",0,[0]
25053,bugs-dot-jar_OAK-1227_117b0a3d,"@Override
    @Nonnull
    public PropertyIterator getReferences() throws RepositoryException {
        return internalGetReferences(null, false);
    }","@Override
    @Nonnull
    public PropertyIterator getReferences() throws RepositoryException {
        return internalGetReferences(null, false);
    }",0,[0]
26803,bugs-dot-jar_OAK-3020_147515ae,"@Override
    public void markDirty() {
        propertiesChanged = true;
    }","@Override
    public void markDirty() {
        propertiesChanged = true;
    }",0,[0]
25100,bugs-dot-jar_OAK-1227_117b0a3d,"private static List<Value> compact(Value[] values) {
        List<Value> list = Lists.newArrayListWithCapacity(values.length);
        for (Value value : values) {
            if (value != null) {
                list.add(value);
            }
        }
        return list;
    }","private static List<Value> compact(Value[] values) {
        List<Value> list = Lists.newArrayListWithCapacity(values.length);
        for (Value value : values) {
            if (value != null) {
                list.add(value);
            }
        }
        return list;
    }",0,[0]
9325,bugs-dot-jar_OAK-1122_5286861d,"public MicroKernelImpl(String homeDir) throws MicroKernelException {
        init(homeDir);
    }","public MicroKernelImpl(String homeDir) throws MicroKernelException {
        init(homeDir);
    }",0,[0]
17780,bugs-dot-jar_MATH-344_a0b4b4b7,"public double solve(final UnivariateRealFunction f,
                        final double min, final double max)
        throws MaxIterationsExceededException,
        FunctionEvaluationException {

        clearResult();
        verifyInterval(min, max);

        double ret = Double.NaN;

        double yMin = f.value(min);
        double yMax = f.value(max);

        // Verify bracketing
        double sign = yMin * yMax;
        if (sign > 0) {
            // check if either value is close to a zero
            if (Math.abs(yMin) <= functionValueAccuracy) {
                setResult(min, 0);
                ret = min;
            } else if (Math.abs(yMax) <= functionValueAccuracy) {
                setResult(max, 0);
                ret = max;
            } else {
                // neither value is close to zero and min and max do not bracket root.
                throw MathRuntimeException.createIllegalArgumentException(
                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
            }
        } else if (sign < 0){
            // solve using only the first endpoint as initial guess
            ret = solve(f, min, yMin, max, yMax, min, yMin);
        } else {
            // either min or max is a root
            if (yMin == 0.0) {
                ret = min;
            } else {
                ret = max;
            }
        }

        return ret;
    }","public double solve(final UnivariateRealFunction f,
                        final double min, final double max)
        throws MaxIterationsExceededException,
        FunctionEvaluationException {

        clearResult();
        verifyInterval(min, max);

        double ret = Double.NaN;

        double yMin = f.value(min);
        double yMax = f.value(max);

        // Verify bracketing
        double sign = yMin * yMax;
        if (sign > 0) {
            // check if either value is close to a zero
            if (Math.abs(yMin) <= functionValueAccuracy) {
                setResult(min, 0);
                ret = min;
            } else if (Math.abs(yMax) <= functionValueAccuracy) {
                setResult(max, 0);
                ret = max;
            } else {
                // neither value is close to zero and min and max do not bracket root.
                throw MathRuntimeException.createIllegalArgumentException(
                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
            }
        } else if (sign < 0){
            // solve using only the first endpoint as initial guess
            ret = solve(f, min, yMin, max, yMax, min, yMin);
        } else {
            // either min or max is a root
            if (yMin == 0.0) {
                ret = min;
            } else {
                ret = max;
            }
        }

        return ret;
    }",0,[0]
22703,bugs-dot-jar_CAMEL-8584_dd0f74c0,"public String getTraceLabel() {
        return ""circuitbreaker"";
    }","public String getTraceLabel() {
        return ""circuitbreaker"";
    }",0,[0]
1178,bugs-dot-jar_WICKET-5546_f1af9e03,"public Component replaceWith(Component replacement)
	{
		Args.notNull(replacement, ""replacement"");

		if (!getId().equals(replacement.getId()))
		{
			throw new IllegalArgumentException(
				""Replacement component must have the same id as the component it will replace. Replacement id [["" +
					replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null)
		{
			throw new IllegalStateException(
				""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
		return replacement;
	}","public Component replaceWith(Component replacement)
	{
		Args.notNull(replacement, ""replacement"");

		if (!getId().equals(replacement.getId()))
		{
			throw new IllegalArgumentException(
				""Replacement component must have the same id as the component it will replace. Replacement id [["" +
					replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null)
		{
			throw new IllegalStateException(
				""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
		return replacement;
	}",0,[0]
3756,bugs-dot-jar_ACCUMULO-209_76d727f0,"@Override
  public boolean validateOptions(Map<String,String> options) {
    super.validateOptions(options);
    if (options.containsKey(ROW_REGEX))
      Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    
    if (options.containsKey(COLF_REGEX))
      Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    
    if (options.containsKey(COLQ_REGEX))
      Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    
    if (options.containsKey(VALUE_REGEX))
      Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    
    return true;
  }","@Override
  public boolean validateOptions(Map<String,String> options) {
    super.validateOptions(options);
    if (options.containsKey(ROW_REGEX))
      Pattern.compile(options.get(ROW_REGEX)).matcher("""");
    
    if (options.containsKey(COLF_REGEX))
      Pattern.compile(options.get(COLF_REGEX)).matcher("""");
    
    if (options.containsKey(COLQ_REGEX))
      Pattern.compile(options.get(COLQ_REGEX)).matcher("""");
    
    if (options.containsKey(VALUE_REGEX))
      Pattern.compile(options.get(VALUE_REGEX)).matcher("""");
    
    if (options.containsKey(ENCODING)) {
      try {
        this.encoding = options.get(ENCODING);
        @SuppressWarnings(""unused"")
        String test = new String(""test"".getBytes(), encoding);
      } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
        return false;
      }
    }
    
    return true;
  }",1,[]
724,bugs-dot-jar_LOG4J2-385_7c2ce5cf,"public PatternProcessor(final String pattern) {
        final PatternParser parser = createPatternParser();
        final List<PatternConverter> converters = new ArrayList<PatternConverter>();
        final List<FormattingInfo> fields = new ArrayList<FormattingInfo>();
        parser.parse(pattern, converters, fields, false);
        final FormattingInfo[] infoArray = new FormattingInfo[fields.size()];
        patternFields = fields.toArray(infoArray);
        final ArrayPatternConverter[] converterArray = new ArrayPatternConverter[converters.size()];
        patternConverters = converters.toArray(converterArray);

        for (final ArrayPatternConverter converter : patternConverters) {
            if (converter instanceof DatePatternConverter) {
                final DatePatternConverter dateConverter = (DatePatternConverter) converter;
                frequency = calculateFrequency(dateConverter.getPattern());
            }
        }
    }","public PatternProcessor(final String pattern) {
        final PatternParser parser = createPatternParser();
        final List<PatternConverter> converters = new ArrayList<PatternConverter>();
        final List<FormattingInfo> fields = new ArrayList<FormattingInfo>();
        parser.parse(pattern, converters, fields, false);
        final FormattingInfo[] infoArray = new FormattingInfo[fields.size()];
        patternFields = fields.toArray(infoArray);
        final ArrayPatternConverter[] converterArray = new ArrayPatternConverter[converters.size()];
        patternConverters = converters.toArray(converterArray);

        for (final ArrayPatternConverter converter : patternConverters) {
            if (converter instanceof DatePatternConverter) {
                final DatePatternConverter dateConverter = (DatePatternConverter) converter;
                frequency = calculateFrequency(dateConverter.getPattern());
            }
        }
    }",0,[0]
24551,bugs-dot-jar_CAMEL-6593_7f8a295a,"public String getExpression() {
        return expression;
    }","public String getExpression() {
        return expression;
    }",0,[0]
256,Bears-9,"@SuppressWarnings(""resource"")
    protected Object _deserializeTypedForId(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
    {
        String typeId = p.getText();
        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);
        if (_typeIdVisible) { // need to merge id back in JSON input?
            if (tb == null) {
                tb = new TokenBuffer(p, ctxt);
            }
            tb.writeFieldName(p.getCurrentName());
            tb.writeString(typeId);
        }
        if (tb != null) { // need to put back skipped properties?
            // 02-Jul-2016, tatu: Depending on for JsonParserSequence is initialized it may
            //   try to access current token; ensure there isn't one
            p.clearCurrentToken();
            p = JsonParserSequence.createFlattened(false, tb.asParser(p), p);
        }
        // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:
        p.nextToken(); // to skip past String value
        // deserializer should take care of closing END_OBJECT as well
        return deser.deserialize(p, ctxt);
    }","@SuppressWarnings(""resource"")
    protected Object _deserializeTypedForId(JsonParser p, DeserializationContext ctxt, TokenBuffer tb) throws IOException
    {
        String typeId = p.getText();
        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);
        if (_typeIdVisible) { // need to merge id back in JSON input?
            if (tb == null) {
                tb = new TokenBuffer(p, ctxt);
            }
            tb.writeFieldName(p.getCurrentName());
            tb.writeString(typeId);
        }
        if (tb != null) { // need to put back skipped properties?
            // 02-Jul-2016, tatu: Depending on for JsonParserSequence is initialized it may
            //   try to access current token; ensure there isn't one
            p.clearCurrentToken();
            p = JsonParserSequence.createFlattened(false, tb.asParser(p), p);
        }
        // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:
        p.nextToken(); // to skip past String value
        // deserializer should take care of closing END_OBJECT as well
        return deser.deserialize(p, ctxt);
    }",0,[0]
22134,bugs-dot-jar_WICKET-1677_01a3dd66,"protected void onSelectionChanged(Object newSelection)
	{
	}","protected void onSelectionChanged(Object newSelection)
	{
	}",0,[0]
26974,bugs-dot-jar_LOG4J2-793_73400bfb,"@Override
    public void trace(final Marker marker, final String s, final Object o) {
        logger.logIfEnabled(FQCN, Level.TRACE, getMarker(marker), s, o);
    }","@Override
    public void trace(final Marker marker, final String s, final Object o) {
        logger.logIfEnabled(FQCN, Level.TRACE, getMarker(marker), s, o);
    }",0,[0]
3223,bugs-dot-jar_WICKET-3767_84c3baac,"private void reportValidationError(ConversionException e, ValidationError error)
	{
		final Locale locale = e.getLocale();
		if (locale != null)
		{
			error.setVariable(""locale"", locale);
		}
		error.setVariable(""exception"", e);
		Format format = e.getFormat();
		if (format instanceof SimpleDateFormat)
		{
			error.setVariable(""format"", ((SimpleDateFormat)format).toLocalizedPattern());
		}

		Map<String, Object> variables = e.getVariables();
		if (variables != null)
		{
			error.getVariables().putAll(variables);
		}

		error(error);
	}","private void reportValidationError(ConversionException e, ValidationError error)
	{
		final Locale locale = e.getLocale();
		if (locale != null)
		{
			error.setVariable(""locale"", locale);
		}
		error.setVariable(""exception"", e);
		Format format = e.getFormat();
		if (format instanceof SimpleDateFormat)
		{
			error.setVariable(""format"", ((SimpleDateFormat)format).toLocalizedPattern());
		}

		Map<String, Object> variables = e.getVariables();
		if (variables != null)
		{
			error.getVariables().putAll(variables);
		}

		error(error);
	}",0,[0]
12413,bugs-dot-jar_OAK-1225_3535afe2,"@CheckForNull
    public Node getNodeOrNull(final String absPath) throws RepositoryException {
        return perform(new ReadOperation<Node>() {
            @Override
            public Node perform() throws RepositoryException {
                return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);
            }
        });
    }","@CheckForNull
    public Node getNodeOrNull(final String absPath) throws RepositoryException {
        return perform(new ReadOperation<Node>() {
            @Override
            public Node perform() throws RepositoryException {
                try {
                    return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);
                } catch (PathNotFoundException e) {
                    return null;
                }
            }
        });
    }",1,[5]
11330,bugs-dot-jar_OAK-395_e6c31270,"@Override
    @Nonnull
    public NodeDefinition getDefinition() throws RepositoryException {
        if (getDepth() == 0) {
            return dlg.sessionDelegate.getDefinitionProvider().getRootDefinition();
        } else {
            return dlg.sessionDelegate.getDefinitionProvider().getDefinition(getParent(), this);
        }
    }","@Override
    @Nonnull
    public NodeDefinition getDefinition() throws RepositoryException {
        if (getDepth() == 0) {
            return dlg.sessionDelegate.getDefinitionProvider().getRootDefinition();
        } else {
            return dlg.sessionDelegate.getDefinitionProvider().getDefinition(getParent(), this);
        }
    }",0,[0]
25974,bugs-dot-jar_MATH-1117_f4c926ea,"public PolygonsSet(final BSPTree<Euclidean2D> tree, final double tolerance) {
        super(tree, tolerance);
    }","public PolygonsSet(final BSPTree<Euclidean2D> tree, final double tolerance) {
        super(tree, tolerance);
    }",0,[0]
36268,bugs-dot-jar_CAMEL-9444_baece126,"public RecipientListDefinition<Type> onPrepareRef(String onPrepareRef) {
        setOnPrepareRef(onPrepareRef);
        return this;
    }","public RecipientListDefinition<Type> onPrepareRef(String onPrepareRef) {
        setOnPrepareRef(onPrepareRef);
        return this;
    }",0,[0]
33646,bugs-dot-jar_WICKET-3845_afc7034d,"private String valueToString(Object value)
	{
		if (value instanceof Time)
		{
			return ((Time)value).toRfc1123TimestampString();
		}
		else
		{
			return value.toString();
		}
	}","private String valueToString(Object value)
	{
		if (value instanceof Time)
		{
			return ((Time)value).toRfc1123TimestampString();
		}
		else
		{
			return value.toString();
		}
	}",0,[0]
20420,bugs-dot-jar_WICKET-3076_d3dc9a50,"private UrlUtils()
	{

	}","private UrlUtils()
	{

	}",0,[0]
23502,bugs-dot-jar_LOG4J2-127_029e79da,"public void warn(Object message) {
        if (isEnabled(Level.WARN, null, message, null)) {
            log(null, FQCN, Level.WARN, new ObjectMessage(message), null);
        }
    }","public void warn(Object message) {
        if (isEnabled(Level.WARN, null, message, null)) {
            log(null, FQCN, Level.WARN, new ObjectMessage(message), null);
        }
    }",0,[0]
28677,bugs-dot-jar_FLINK-2734_8b40bb7a,"public boolean isForceCheckpointing() {
		return forceCheckpointing;
	}","public boolean isForceCheckpointing() {
		return forceCheckpointing;
	}",0,[0]
697,Bears-22,"@Override
    public boolean isContainerType() {
        return false;
    }","@Override
    public boolean isContainerType() {
        return false;
    }",0,[0]
22123,bugs-dot-jar_WICKET-1677_01a3dd66,"public RadioChoice(final String id)
	{
		super(id);
	}","public RadioChoice(final String id)
	{
		super(id);
	}",0,[0]
10166,bugs-dot-jar_MNG-4915_1c3abfba,"private void validateEffectivePluginDependencies( ModelProblemCollector problems, Plugin plugin,
                                                      ModelBuildingRequest request )
    {
        List<Dependency> dependencies = plugin.getDependencies();

        if ( !dependencies.isEmpty() )
        {
            String prefix = ""build.plugins.plugin["" + plugin.getKey() + ""].dependencies.dependency."";

            Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

            for ( Dependency d : dependencies )
            {
                validateEffectiveDependency( problems, d, false, prefix, request );

                validateVersion( prefix + ""version"", problems, errOn30, d.getVersion(), d.getManagementKey(), d );

                validateEnum( prefix + ""scope"", problems, errOn30, d.getScope(), d.getManagementKey(), d, ""compile"",
                              ""runtime"", ""system"" );
            }
        }
    }","private void validateEffectivePluginDependencies( ModelProblemCollector problems, Plugin plugin,
                                                      ModelBuildingRequest request )
    {
        List<Dependency> dependencies = plugin.getDependencies();

        if ( !dependencies.isEmpty() )
        {
            String prefix = ""build.plugins.plugin["" + plugin.getKey() + ""].dependencies.dependency."";

            Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );

            for ( Dependency d : dependencies )
            {
                validateEffectiveDependency( problems, d, false, prefix, request );

                validateVersion( prefix + ""version"", problems, errOn30, d.getVersion(), d.getManagementKey(), d );

                validateEnum( prefix + ""scope"", problems, errOn30, d.getScope(), d.getManagementKey(), d, ""compile"",
                              ""runtime"", ""system"" );
            }
        }
    }",0,[0]
37634,bugs-dot-jar_CAMEL-7160_095fa2b4,"protected long calculateDelay(Exchange exchange) {
        // evaluate as Object first to see if we get any result at all
        Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);
        if (result == null) {
            throw new RuntimeExchangeException(""The max requests per period expression was evaluated as null: "" + maxRequestsPerPeriodExpression, exchange);
        }

        // then must convert value to long
        Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);
        if (longValue != null) {
            // log if we changed max period after initial setting
            if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {
                log.debug(""Throttler changed maximum requests per period from {} to {}"", maximumRequestsPerPeriod, longValue);
            }
            maximumRequestsPerPeriod = longValue;
        }

        if (maximumRequestsPerPeriod <= 0) {
            throw new IllegalStateException(""The maximumRequestsPerPeriod must be a positive number, was: "" + maximumRequestsPerPeriod);
        }

        TimeSlot slot = nextSlot();
        if (!slot.isActive()) {
            long delay = slot.startTime - currentSystemTime();
            return delay;
        } else {
            return 0;
        }
    }","protected long calculateDelay(Exchange exchange) {
        // evaluate as Object first to see if we get any result at all
        Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);
        if (result == null) {
            throw new RuntimeExchangeException(""The max requests per period expression was evaluated as null: "" + maxRequestsPerPeriodExpression, exchange);
        }

        // then must convert value to long
        Long longValue = exchange.getContext().getTypeConverter().convertTo(Long.class, result);
        if (longValue != null) {
            // log if we changed max period after initial setting
            if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {
                log.debug(""Throttler changed maximum requests per period from {} to {}"", maximumRequestsPerPeriod, longValue);
            }
            if (maximumRequestsPerPeriod > longValue) {
                slot.capacity = 0;
            }
            maximumRequestsPerPeriod = longValue;
        }

        if (maximumRequestsPerPeriod <= 0) {
            throw new IllegalStateException(""The maximumRequestsPerPeriod must be a positive number, was: "" + maximumRequestsPerPeriod);
        }

        TimeSlot slot = nextSlot();
        if (!slot.isActive()) {
            long delay = slot.startTime - currentSystemTime();
            return delay;
        } else {
            return 0;
        }
    }",1,[]
1944,Bears-232,"public static long packLong(byte[] a, byte pad) {
        return pack(a, pad, 8);
    }","public static long packLong(byte[] a, byte pad) {
        return pack(a, pad, 8);
    }",0,[0]
21031,bugs-dot-jar_OAK-846_7acb091a,"void runBackgroundOperations() {
        if (isDisposed.get()) {
            return;
        }
        backgroundRenewClusterIdLease();
        if (simpleRevisionCounter != null) {
            // only when using timestamp
            return;
        }
        if (!ENABLE_BACKGROUND_OPS || stopBackground) {
            return;
        }
        synchronized (this) {
            try {
                backgroundWrite();
                backgroundRead();
            } catch (RuntimeException e) {
                if (isDisposed.get()) {
                    return;
                }
                LOG.warn(""Background operation failed: "" + e.toString(), e);
            }
        }
    }","void runBackgroundOperations() {
        if (isDisposed.get()) {
            return;
        }
        backgroundRenewClusterIdLease();
        if (simpleRevisionCounter != null) {
            // only when using timestamp
            return;
        }
        if (!ENABLE_BACKGROUND_OPS || stopBackground) {
            return;
        }
        synchronized (this) {
            try {
                backgroundWrite();
                backgroundRead();
            } catch (RuntimeException e) {
                if (isDisposed.get()) {
                    return;
                }
                LOG.warn(""Background operation failed: "" + e.toString(), e);
            }
        }
    }",0,[0]
1738,Bears-197,"public String getUserInfo() {
        return this.userInfo;
    }","public String getUserInfo() {
        return this.userInfo;
    }",0,[0]
11599,bugs-dot-jar_CAMEL-5796_de6dd425,"public Type inOut(Endpoint... endpoints) {
        return to(ExchangePattern.InOut, endpoints);
    }","public Type inOut(Endpoint... endpoints) {
        return to(ExchangePattern.InOut, endpoints);
    }",0,[0]
2146,bugs-dot-jar_WICKET-2961_3d8c9d75,"protected void onComponentTag(final ComponentTag tag)
	{
		// We can't try to get the ID from markup. This could be different than
		// id returned from getMarkupId() prior first rendering the component
		// (due to transparent resolvers and borders which break the 1:1
		// component <-> markup relation)
		if (getFlag(FLAG_OUTPUT_MARKUP_ID))
		{
			tag.put(MARKUP_ID_ATTR_NAME, getMarkupId());
		}

		if (getApplication().getDebugSettings().isOutputComponentPath())
		{
			String path = getPageRelativePath();
			path = path.replace(""_"", ""__"");
			path = path.replace("":"", ""_"");
			tag.put(""wicketpath"", path);
		}
	}","protected void onComponentTag(final ComponentTag tag)
	{
		// We can't try to get the ID from markup. This could be different than
		// id returned from getMarkupId() prior first rendering the component
		// (due to transparent resolvers and borders which break the 1:1
		// component <-> markup relation)
		if (getFlag(FLAG_OUTPUT_MARKUP_ID))
		{
			tag.put(MARKUP_ID_ATTR_NAME, getMarkupId());
		}

		if (getApplication().getDebugSettings().isOutputComponentPath())
		{
			String path = getPageRelativePath();
			path = path.replace(""_"", ""__"");
			path = path.replace("":"", ""_"");
			tag.put(""wicketpath"", path);
		}
	}",0,[0]
18194,bugs-dot-jar_MATH-554_fbbb96eb,"public boolean isInfinite() {
      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));
  }","public boolean isInfinite() {
      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));
  }",0,[0]
3307,bugs-dot-jar_LOG4J2-492_61ccbb95,"public static void registerMBeans() throws JMException {
        final ContextSelector selector = getContextSelector();
        registerMBeans(selector);
    }","public static void registerMBeans() throws JMException {
        final ContextSelector selector = getContextSelector();
        registerMBeans(selector);
    }",0,[0]
9720,bugs-dot-jar_OAK-614_6feacf6b,"@Override @Nonnull
    public NodeBuilder removeNode(String name) {
        write();

        if (writeState.base.getChildNode(name) != null) {
            writeState.nodes.put(name, null);
        } else {
            writeState.nodes.remove(name);
        }

        updated();
        return this;
    }","@Override @Nonnull
    public NodeBuilder removeNode(String name) {
        write();

        if (writeState.base.getChildNode(name) != null) {
            writeState.nodes.put(name, null);
        } else {
            writeState.nodes.remove(name);
        }

        updated();
        return this;
    }",0,[0]
8693,bugs-dot-jar_WICKET-5883_cd3b9234,"public void remove(final IFormValidator validator)
	{
		Args.notNull(validator, ""validator"");

		Behavior match = null;
		for (Behavior behavior : getBehaviors())
		{
			if (behavior.equals(validator))
			{
				match = behavior;
				break;
			}
			else if (behavior instanceof FormValidatorAdapter)
			{
				if (((FormValidatorAdapter)behavior).getValidator().equals(validator))
				{
					match = behavior;
					break;
				}
			}
		}

		if (match != null)
		{
			remove(match);
		}
		else
		{

			throw new IllegalStateException(
				""Tried to remove form validator that was not previously added. ""
					+ ""Make sure your validator's equals() implementation is sufficient"");
		}
	}","public void remove(final IFormValidator validator)
	{
		Args.notNull(validator, ""validator"");

		Behavior match = null;
		for (Behavior behavior : getBehaviors())
		{
			if (behavior.equals(validator))
			{
				match = behavior;
				break;
			}
			else if (behavior instanceof FormValidatorAdapter)
			{
				if (((FormValidatorAdapter)behavior).getValidator().equals(validator))
				{
					match = behavior;
					break;
				}
			}
		}

		if (match != null)
		{
			remove(match);
		}
		else
		{

			throw new IllegalStateException(
				""Tried to remove form validator that was not previously added. ""
					+ ""Make sure your validator's equals() implementation is sufficient"");
		}
	}",0,[0]
39931,bugs-dot-jar_WICKET-2621_c849f986,"protected void registerJavascriptNamespaces(IHeaderResponse response)
	{
		response.renderJavascript(
			""if (Wicket==undefined) { Wicket={}; } if (Wicket.Forms==undefined) { Wicket.Forms={}; }"",
			Form.class.getName());
	}","protected void registerJavascriptNamespaces(IHeaderResponse response)
	{
		response.renderJavascript(
			""if (Wicket==undefined) { Wicket={}; } if (Wicket.Forms==undefined) { Wicket.Forms={}; }"",
			Form.class.getName());
	}",0,[0]
29755,bugs-dot-jar_FLINK-2763_af477563,"protected void createPartitions(int numPartitions, int recursionLevel) {
		// sanity check
		ensureNumBuffersReturned(numPartitions);

		this.currentEnumerator = this.ioManager.createChannelEnumerator();
		
		this.partitionsBeingBuilt.clear();
		for (int i = 0; i < numPartitions; i++) {
			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel);
			this.partitionsBeingBuilt.add(p);
		}
	}","protected void createPartitions(int numPartitions, int recursionLevel) {
		// sanity check
		ensureNumBuffersReturned(numPartitions);

		this.currentEnumerator = this.ioManager.createChannelEnumerator();
		
		this.partitionsBeingBuilt.clear();
		for (int i = 0; i < numPartitions; i++) {
			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel);
			this.partitionsBeingBuilt.add(p);
		}
	}",0,[0]
29745,bugs-dot-jar_FLINK-2763_af477563,"public void close() {
		// make sure that we close only once
		if (!this.closed.compareAndSet(false, true)) {
			return;
		}
		
		// clear the iterators, so the next call to next() will notice
		this.bucketIterator = null;
		this.probeIterator = null;
		
		// release the table structure
		releaseTable();
		
		// clear the memory in the partitions
		clearPartitions();
		
		// clear the current probe side channel, if there is one
		if (this.currentSpilledProbeSide != null) {
			try {
				this.currentSpilledProbeSide.closeAndDelete();
			}
			catch (Throwable t) {
				LOG.warn(""Could not close and delete the temp file for the current spilled partition probe side."", t);
			}
		}
		
		// clear the partitions that are still to be done (that have files on disk)
		for (int i = 0; i < this.partitionsPending.size(); i++) {
			final HashPartition<BT, PT> p = this.partitionsPending.get(i);
			p.clearAllMemory(this.availableMemory);
		}
		
		// return the write-behind buffers
		for (int i = 0; i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable; i++) {
			try {
				this.availableMemory.add(this.writeBehindBuffers.take());
			}
			catch (InterruptedException iex) {
				throw new RuntimeException(""Hashtable closing was interrupted"");
			}
		}
		this.writeBehindBuffersAvailable = 0;
	}","public void close() {
		// make sure that we close only once
		if (!this.closed.compareAndSet(false, true)) {
			return;
		}
		
		// clear the iterators, so the next call to next() will notice
		this.bucketIterator = null;
		this.probeIterator = null;
		
		// release the table structure
		releaseTable();
		
		// clear the memory in the partitions
		clearPartitions();
		
		// clear the current probe side channel, if there is one
		if (this.currentSpilledProbeSide != null) {
			try {
				this.currentSpilledProbeSide.closeAndDelete();
			}
			catch (Throwable t) {
				LOG.warn(""Could not close and delete the temp file for the current spilled partition probe side."", t);
			}
		}
		
		// clear the partitions that are still to be done (that have files on disk)
		for (int i = 0; i < this.partitionsPending.size(); i++) {
			final HashPartition<BT, PT> p = this.partitionsPending.get(i);
			p.clearAllMemory(this.availableMemory);
		}
		
		// return the write-behind buffers
		for (int i = 0; i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable; i++) {
			try {
				this.availableMemory.add(this.writeBehindBuffers.take());
			}
			catch (InterruptedException iex) {
				throw new RuntimeException(""Hashtable closing was interrupted"");
			}
		}
		this.writeBehindBuffersAvailable = 0;
	}",0,[0]
12562,bugs-dot-jar_MATH-864_abe53a53,"public List<Double> getStatisticsFitnessHistory() {
        return statisticsFitnessHistory;
    }","public List<Double> getStatisticsFitnessHistory() {
        return statisticsFitnessHistory;
    }",0,[0]
23388,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public Object[] toArray() {
        return list.toArray();
    }","@Override
    public Object[] toArray() {
        return list.toArray();
    }",0,[0]
15990,bugs-dot-jar_FLINK-3684_e3759a5e,"@Override
	public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
		StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);

		final AbstractStateBackend.CheckpointStateOutputStream os = this.getStateBackend().createCheckpointStateOutputStream(
			checkpointId,
			timestamp);

		final ObjectOutputStream oos = new ObjectOutputStream(os);
		final AbstractStateBackend.CheckpointStateOutputView ov = new AbstractStateBackend.CheckpointStateOutputView(os);

		oos.writeObject(nfa);

		ov.writeInt(priorityQueue.size());

		for (StreamRecord<IN> streamRecord: priorityQueue) {
			streamRecordSerializer.serialize(streamRecord, ov);
		}

		taskState.setOperatorState(os.closeAndGetHandle());

		return taskState;
	}","@Override
	public StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {
		StreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);

		final AbstractStateBackend.CheckpointStateOutputStream os = this.getStateBackend().createCheckpointStateOutputStream(
			checkpointId,
			timestamp);

		final ObjectOutputStream oos = new ObjectOutputStream(os);
		final AbstractStateBackend.CheckpointStateOutputView ov = new AbstractStateBackend.CheckpointStateOutputView(os);

		oos.writeObject(nfa);

		ov.writeInt(priorityQueue.size());

		for (StreamRecord<IN> streamRecord: priorityQueue) {
			streamRecordSerializer.serialize(streamRecord, ov);
		}

		taskState.setOperatorState(os.closeAndGetHandle());

		return taskState;
	}",0,[0]
28668,bugs-dot-jar_FLINK-2734_8b40bb7a,"public StreamExecutionEnvironment setBufferTimeout(long timeoutMillis) {
		if (timeoutMillis < -1) {
			throw new IllegalArgumentException(""Timeout of buffer must be non-negative or -1"");
		}

		this.bufferTimeout = timeoutMillis;
		return this;
	}","public StreamExecutionEnvironment setBufferTimeout(long timeoutMillis) {
		if (timeoutMillis < -1) {
			throw new IllegalArgumentException(""Timeout of buffer must be non-negative or -1"");
		}

		this.bufferTimeout = timeoutMillis;
		return this;
	}",0,[0]
10695,bugs-dot-jar_MNG-1797_5d99b35c,"public void addProfiles( List profiles )
    {
        for ( Iterator it = profiles.iterator(); it.hasNext(); )
        {
            Profile profile = (Profile) it.next();

            addProfile( profile );
        }
    }","public void addProfiles( List profiles )
    {
        for ( Iterator it = profiles.iterator(); it.hasNext(); )
        {
            Profile profile = (Profile) it.next();

            addProfile( profile );
        }
    }",0,[0]
921,Bears-123,"public static double calculateFuel(Position firstPosition, Position lastPosition) {

        if (firstPosition.getAttributes().get(Position.KEY_FUEL_LEVEL) != null
                && lastPosition.getAttributes().get(Position.KEY_FUEL_LEVEL) != null) {

            BigDecimal value = new BigDecimal(firstPosition.getDouble(Position.KEY_FUEL_LEVEL)
                    - lastPosition.getDouble(Position.KEY_FUEL_LEVEL));
            return value.setScale(1, RoundingMode.HALF_EVEN).doubleValue();
        }
        return 0;
    }","public static double calculateFuel(Position firstPosition, Position lastPosition) {

        if (firstPosition.getAttributes().get(Position.KEY_FUEL_LEVEL) != null
                && lastPosition.getAttributes().get(Position.KEY_FUEL_LEVEL) != null) {

            BigDecimal value = new BigDecimal(firstPosition.getDouble(Position.KEY_FUEL_LEVEL)
                    - lastPosition.getDouble(Position.KEY_FUEL_LEVEL));
            return value.setScale(1, RoundingMode.HALF_EVEN).doubleValue();
        }
        return 0;
    }",0,[0]
12357,bugs-dot-jar_OAK-2465_60186813,"@Nonnull
    public Collection<PermissionEntry> getEntries(@Nonnull Tree accessControlledTree) {
        if (existingNames.isEmpty()) {
            return Collections.emptyList();
        } else if (pathEntryMap != null) {
            Collection<PermissionEntry> entries = pathEntryMap.get(accessControlledTree.getPath());
            return (entries != null) ? entries : Collections.<PermissionEntry>emptyList();
        } else {
            return (accessControlledTree.hasChild(AccessControlConstants.REP_POLICY)) ?
                    loadEntries(accessControlledTree.getPath()) :
                    Collections.<PermissionEntry>emptyList();
        }
    }","@Nonnull
    public Collection<PermissionEntry> getEntries(@Nonnull Tree accessControlledTree) {
        if (existingNames.isEmpty()) {
            return Collections.emptyList();
        } else if (pathEntryMap != null) {
            Collection<PermissionEntry> entries = pathEntryMap.get(accessControlledTree.getPath());
            return (entries != null) ? entries : Collections.<PermissionEntry>emptyList();
        } else {
            return (accessControlledTree.hasChild(AccessControlConstants.REP_POLICY)) ?
                    loadEntries(accessControlledTree.getPath()) :
                    Collections.<PermissionEntry>emptyList();
        }
    }",0,[0]
9498,bugs-dot-jar_MNG-5655_96337372,"public <T> void seed( Class<T> clazz, final T value )
    {
        getScopeState().seeded.put( Key.get( clazz ), Providers.of( value ) );
    }","public <T> void seed( Class<T> clazz, final T value )
    {
        getScopeState().seeded.put( Key.get( clazz ), Providers.of( value ) );
    }",0,[0]
18051,bugs-dot-jar_OAK-3249_64712735,"private String copyWorkspace(NodeState sourceState, NodeBuilder builder, String workspaceName)
            throws RepositoryException {
        final Set<String> includes = calculateEffectiveIncludePaths(includePaths, sourceState);
        final Set<String> excludes = union(copyOf(this.excludePaths), of(""/jcr:system/jcr:versionStorage""));
        final Set<String> merges = union(copyOf(this.mergePaths), of(""/jcr:system""));

        logger.info(""Copying workspace {} [i: {}, e: {}, m: {}]"", workspaceName, includes, excludes, merges);

        NodeStateCopier.builder()
                .include(includes)
                .exclude(excludes)
                .merge(merges)
                .copy(sourceState, builder);

        return workspaceName;
    }","private String copyWorkspace(NodeState sourceState, NodeBuilder builder, String workspaceName)
            throws RepositoryException {
        final Set<String> includes = calculateEffectiveIncludePaths(includePaths, sourceState);
        final Set<String> excludes = union(copyOf(this.excludePaths), of(""/jcr:system/jcr:versionStorage""));
        final Set<String> merges = union(copyOf(this.mergePaths), of(""/jcr:system""));

        logger.info(""Copying workspace {} [i: {}, e: {}, m: {}]"", workspaceName, includes, excludes, merges);

        NodeStateCopier.builder()
                .include(includes)
                .exclude(excludes)
                .merge(merges)
                .copy(sourceState, builder);

        return workspaceName;
    }",0,[0]
385,bugs-dot-jar_FLINK-2874_17e7b423,"public static <IN1, IN2, OUT> TypeInformation<OUT> getCrossReturnTypes(CrossFunction<IN1, IN2, OUT> crossInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type)
	{
		return getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);
	}","public static <IN1, IN2, OUT> TypeInformation<OUT> getCrossReturnTypes(CrossFunction<IN1, IN2, OUT> crossInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type)
	{
		return getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);
	}",0,[0]
15485,bugs-dot-jar_MATH-555_328513f3,"public static void checkOrder(double[] val, OrderDirection dir,
                                  boolean strict) {
        checkOrder(val, dir, strict, true);
    }","public static void checkOrder(double[] val, OrderDirection dir,
                                  boolean strict) {
        checkOrder(val, dir, strict, true);
    }",0,[0]
8037,bugs-dot-jar_OAK-2147_a1556c30,"public Iterable<String> query(final Filter filter, final String indexName,
            final NodeState indexMeta, final PropertyRestriction pr) {
        return query(filter, indexName, indexMeta, pr, """");
    }","public Iterable<String> query(final Filter filter, final String indexName,
            final NodeState indexMeta, final PropertyRestriction pr) {
        return query(filter, indexName, indexMeta, pr, """");
    }",0,[0]
29204,bugs-dot-jar_WICKET-3884_b772ff87,"@Deprecated
	public AttributeAppender(String attribute, boolean addAttributeIfNotPresent,
		IModel<?> appendModel, String separator)
	{
		this(attribute, appendModel, separator);
	}","@Deprecated
	public AttributeAppender(String attribute, boolean addAttributeIfNotPresent,
		IModel<?> appendModel, String separator)
	{
		this(attribute, appendModel, separator);
	}",0,[0]
31385,bugs-dot-jar_CAMEL-9340_1cab39f6,"public FileIdempotentRepository() {
        // default use a 1st level cache 
        this.cache = new LRUCache<String, Object>(1000);
    }","public FileIdempotentRepository() {
        // default use a 1st level cache 
        this.cache = new LRUCache<String, Object>(1000);
    }",0,[0]
40411,bugs-dot-jar_WICKET-442_246d53c5,"public final void modelChanging()
	{
		// Call user code
		onModelChanging();

		// Tell the page that our model changed
		final Page page = findPage();
		if (page != null)
		{
			page.componentModelChanging(this);
		}
	}","public final void modelChanging()
	{
		// Call user code
		onModelChanging();

		// Tell the page that our model changed
		final Page page = findPage();
		if (page != null)
		{
			page.componentModelChanging(this);
		}
	}",0,[0]
135,Bears-6,"private PropertyNamingStrategy _findNamingStrategy()
    {
        Object namingDef = (_annotationIntrospector == null)? null
                : _annotationIntrospector.findNamingStrategy(_classDef);
        if (namingDef == null) {
            return _config.getPropertyNamingStrategy();
        }
        if (namingDef instanceof PropertyNamingStrategy) {
            return (PropertyNamingStrategy) namingDef;
        }
        /* Alas, there's no way to force return type of ""either class
         * X or Y"" -- need to throw an exception after the fact
         */
        if (!(namingDef instanceof Class)) {
            throw new IllegalStateException(""AnnotationIntrospector returned PropertyNamingStrategy definition of type ""
                    +namingDef.getClass().getName()+""; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"");
        }
        Class<?> namingClass = (Class<?>)namingDef;
        // 09-Nov-2015, tatu: Need to consider pseudo-value of STD, which means ""use default""
        if (namingClass == PropertyNamingStrategy.class) {
            return null;
        }
        
        if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) {
            throw new IllegalStateException(""AnnotationIntrospector returned Class ""
                    +namingClass.getName()+""; expected Class<PropertyNamingStrategy>"");
        }
        HandlerInstantiator hi = _config.getHandlerInstantiator();
        if (hi != null) {
            PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass);
            if (pns != null) {
                return pns;
            }
        }
        return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass,
                    _config.canOverrideAccessModifiers());
    }","private PropertyNamingStrategy _findNamingStrategy()
    {
        Object namingDef = (_annotationIntrospector == null)? null
                : _annotationIntrospector.findNamingStrategy(_classDef);
        if (namingDef == null) {
            return _config.getPropertyNamingStrategy();
        }
        if (namingDef instanceof PropertyNamingStrategy) {
            return (PropertyNamingStrategy) namingDef;
        }
        /* Alas, there's no way to force return type of ""either class
         * X or Y"" -- need to throw an exception after the fact
         */
        if (!(namingDef instanceof Class)) {
            throw new IllegalStateException(""AnnotationIntrospector returned PropertyNamingStrategy definition of type ""
                    +namingDef.getClass().getName()+""; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"");
        }
        Class<?> namingClass = (Class<?>)namingDef;
        // 09-Nov-2015, tatu: Need to consider pseudo-value of STD, which means ""use default""
        if (namingClass == PropertyNamingStrategy.class) {
            return null;
        }
        
        if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) {
            throw new IllegalStateException(""AnnotationIntrospector returned Class ""
                    +namingClass.getName()+""; expected Class<PropertyNamingStrategy>"");
        }
        HandlerInstantiator hi = _config.getHandlerInstantiator();
        if (hi != null) {
            PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass);
            if (pns != null) {
                return pns;
            }
        }
        return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass,
                    _config.canOverrideAccessModifiers());
    }",0,[0]
478,Bears-16,"public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser,
            BeanProperty property)
        throws JsonMappingException
    {
        if (ser != null) {
            if (ser instanceof ContextualSerializer) {
                ser = ((ContextualSerializer) ser).createContextual(this, property);
            }
        }
        return ser;
    }","public JsonSerializer<?> handlePrimaryContextualization(JsonSerializer<?> ser,
            BeanProperty property)
        throws JsonMappingException
    {
        if (ser != null) {
            if (ser instanceof ContextualSerializer) {
                ser = ((ContextualSerializer) ser).createContextual(this, property);
            }
        }
        return ser;
    }",0,[0]
5399,bugs-dot-jar_FLINK-3534_734ba01d,"public void registerExecutionListener(ActorGateway listener) {
		if (listener != null) {
			this.executionListenerActors.add(listener);
		}
	}","public void registerExecutionListener(ActorGateway listener) {
		if (listener != null) {
			this.executionListenerActors.add(listener);
		}
	}",0,[0]
8531,bugs-dot-jar_FLINK-2442_30761572,"public <X> TypeInformation<X> getTypeAt(String fieldExpression) {

		Matcher matcher = PATTERN_NESTED_FIELDS.matcher(fieldExpression);
		if(!matcher.matches()) {
			if (fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR) || fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR_SCALA)) {
				throw new InvalidFieldReferenceException(""Wildcard expressions are not allowed here."");
			} else {
				throw new InvalidFieldReferenceException(""Invalid format of tuple field expression \""""+fieldExpression+""\""."");
			}
		}

		String fieldStr = matcher.group(1);
		Matcher fieldMatcher = PATTERN_FIELD.matcher(fieldStr);
		if(!fieldMatcher.matches()) {
			throw new RuntimeException(""Invalid matcher pattern"");
		}
		String field = fieldMatcher.group(2);
		int fieldPos = Integer.valueOf(field);

		if(fieldPos >= this.getArity()) {
			throw new InvalidFieldReferenceException(""Tuple field expression \""""+fieldStr+""\"" out of bounds of ""+this.toString()+""."");
		}
		TypeInformation<X> fieldType = this.getTypeAt(fieldPos);
		String tail = matcher.group(5);
		if(tail == null) {
			// we found the type
			return fieldType;
		} else {
			if(fieldType instanceof CompositeType<?>) {
				return ((CompositeType<?>) fieldType).getTypeAt(tail);
			} else {
				throw new InvalidFieldReferenceException(""Nested field expression \""""+tail+""\"" not possible on atomic type ""+fieldType+""."");
			}
		}
	}","public <X> TypeInformation<X> getTypeAt(String fieldExpression) {

		Matcher matcher = PATTERN_NESTED_FIELDS.matcher(fieldExpression);
		if(!matcher.matches()) {
			if (fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR) || fieldExpression.equals(ExpressionKeys.SELECT_ALL_CHAR_SCALA)) {
				throw new InvalidFieldReferenceException(""Wildcard expressions are not allowed here."");
			} else {
				throw new InvalidFieldReferenceException(""Invalid format of tuple field expression \""""+fieldExpression+""\""."");
			}
		}

		String fieldStr = matcher.group(1);
		Matcher fieldMatcher = PATTERN_FIELD.matcher(fieldStr);
		if(!fieldMatcher.matches()) {
			throw new RuntimeException(""Invalid matcher pattern"");
		}
		String field = fieldMatcher.group(2);
		int fieldPos = Integer.valueOf(field);

		if(fieldPos >= this.getArity()) {
			throw new InvalidFieldReferenceException(""Tuple field expression \""""+fieldStr+""\"" out of bounds of ""+this.toString()+""."");
		}
		TypeInformation<X> fieldType = this.getTypeAt(fieldPos);
		String tail = matcher.group(5);
		if(tail == null) {
			// we found the type
			return fieldType;
		} else {
			if(fieldType instanceof CompositeType<?>) {
				return ((CompositeType<?>) fieldType).getTypeAt(tail);
			} else {
				throw new InvalidFieldReferenceException(""Nested field expression \""""+tail+""\"" not possible on atomic type ""+fieldType+""."");
			}
		}
	}",0,[0]
11574,bugs-dot-jar_CAMEL-5796_de6dd425,"protected void configureChild(ProcessorDefinition<?> output) {
        // noop
    }","protected void configureChild(ProcessorDefinition<?> output) {
        // noop
    }",0,[0]
598,Bears-18,"@SuppressWarnings(""deprecation"")
    private JsonInclude.Value _refinePropertyInclusion(Annotated a, JsonInclude.Value value) {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        if (ann != null) {
            switch (ann.include()) {
            case ALWAYS:
                return value.withValueInclusion(JsonInclude.Include.ALWAYS);
            case NON_NULL:
                return value.withValueInclusion(JsonInclude.Include.NON_NULL);
            case NON_DEFAULT:
                return value.withValueInclusion(JsonInclude.Include.NON_DEFAULT);
            case NON_EMPTY:
                return value.withValueInclusion(JsonInclude.Include.NON_EMPTY);
            case DEFAULT_INCLUSION:
            default:
            }
        }
        return value;
    }","@SuppressWarnings(""deprecation"")
    private JsonInclude.Value _refinePropertyInclusion(Annotated a, JsonInclude.Value value) {
        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);
        if (ann != null) {
            switch (ann.include()) {
            case ALWAYS:
                return value.withValueInclusion(JsonInclude.Include.ALWAYS);
            case NON_NULL:
                return value.withValueInclusion(JsonInclude.Include.NON_NULL);
            case NON_DEFAULT:
                return value.withValueInclusion(JsonInclude.Include.NON_DEFAULT);
            case NON_EMPTY:
                return value.withValueInclusion(JsonInclude.Include.NON_EMPTY);
            case DEFAULT_INCLUSION:
            default:
            }
        }
        return value;
    }",0,[0]
35711,bugs-dot-jar_MATH-631_ebc61de9,"protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    if (x == x1) {
                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
                                                          atol);
                        // Update formula cannot make any progress: Update the
                        // search interval.
                        x0 = 0.5 * (x0 + x1 - delta);
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }","protected final double doSolve() {
        // Get initial solution
        double x0 = getMin();
        double x1 = getMax();
        double f0 = computeObjectiveValue(x0);
        double f1 = computeObjectiveValue(x1);

        // If one of the bounds is the exact root, return it. Since these are
        // not under-approximations or over-approximations, we can return them
        // regardless of the allowed solutions.
        if (f0 == 0.0) {
            return x0;
        }
        if (f1 == 0.0) {
            return x1;
        }

        // Verify bracketing of initial solution.
        verifyBracketing(x0, x1);

        // Get accuracies.
        final double ftol = getFunctionValueAccuracy();
        final double atol = getAbsoluteAccuracy();
        final double rtol = getRelativeAccuracy();

        // Keep track of inverted intervals, meaning that the left bound is
        // larger than the right bound.
        boolean inverted = false;

        // Keep finding better approximations.
        while (true) {
            // Calculate the next approximation.
            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
            final double fx = computeObjectiveValue(x);

            // If the new approximation is the exact root, return it. Since
            // this is not an under-approximation or an over-approximation,
            // we can return it regardless of the allowed solutions.
            if (fx == 0.0) {
                return x;
            }

            // Update the bounds with the new approximation.
            if (f1 * fx < 0) {
                // The value of x1 has switched to the other bound, thus inverting
                // the interval.
                x0 = x1;
                f0 = f1;
                inverted = !inverted;
            } else {
                switch (method) {
                case ILLINOIS:
                    f0 *= 0.5;
                    break;
                case PEGASUS:
                    f0 *= f1 / (f1 + fx);
                    break;
                case REGULA_FALSI:
                    // Nothing.
                    break;
                default:
                    // Should never happen.
                    throw new MathInternalError();
                }
            }
            // Update from [x0, x1] to [x0, x].
            x1 = x;
            f1 = fx;

            // If the function value of the last approximation is too small,
            // given the function value accuracy, then we can't get closer to
            // the root than we already are.
            if (FastMath.abs(f1) <= ftol) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    if (inverted) {
                        return x1;
                    }
                    break;
                case RIGHT_SIDE:
                    if (!inverted) {
                        return x1;
                    }
                    break;
                case BELOW_SIDE:
                    if (f1 <= 0) {
                        return x1;
                    }
                    break;
                case ABOVE_SIDE:
                    if (f1 >= 0) {
                        return x1;
                    }
                    break;
                default:
                    throw new MathInternalError();
                }
            }

            // If the current interval is within the given accuracies, we
            // are satisfied with the current approximation.
            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
                                                     atol)) {
                switch (allowed) {
                case ANY_SIDE:
                    return x1;
                case LEFT_SIDE:
                    return inverted ? x1 : x0;
                case RIGHT_SIDE:
                    return inverted ? x0 : x1;
                case BELOW_SIDE:
                    return (f1 <= 0) ? x1 : x0;
                case ABOVE_SIDE:
                    return (f1 >= 0) ? x1 : x0;
                default:
                    throw new MathInternalError();
                }
            }
        }
    }",1,"[58, 59, 60, 61, 62, 63, 64, 65]"
1603,bugs-dot-jar_WICKET-5345_3fc7234e,"public void removeLeadingSegments(final int count)
	{
		Args.withinRange(0, segments.size(), count, ""count"");
		for (int i = 0; i < count; i++)
		{
			segments.remove(0);
		}
	}","public void removeLeadingSegments(final int count)
	{
		Args.withinRange(0, segments.size(), count, ""count"");
		for (int i = 0; i < count; i++)
		{
			segments.remove(0);
		}
	}",0,[0]
511,Bears-16,"public void setTypeId(AnnotatedMember idProp) {
        // Not legal to use multiple ones...
        if (_typeId != null) {
            throw new IllegalArgumentException(""Multiple type ids specified with ""+_typeId+"" and ""+idProp);
        }
        _typeId = idProp;
    }","public void setTypeId(AnnotatedMember idProp) {
        // Not legal to use multiple ones...
        if (_typeId != null) {
            throw new IllegalArgumentException(""Multiple type ids specified with ""+_typeId+"" and ""+idProp);
        }
        _typeId = idProp;
    }",0,[0]
29470,bugs-dot-jar_WICKET-4323_e24874da,"private String getString(Component component)
	{

		final Localizer localizer = getLocalizer();
		final Locale locale;
		if (component != null)
		{
			locale = component.getLocale();
		}
		else
		{
			locale = Session.exists() ? Session.get().getLocale() : Locale.getDefault();
		}

		String value;

		// Substitute any parameters if necessary
		Object[] parameters = getParameters();
		if (parameters == null || parameters.length == 0)
		{
			// Get the string resource, doing any property substitutions as part
			// of the get operation
			value = localizer.getString(getResourceKey(), component, model, defaultValue);
			if (value == null)
			{
				value = defaultValue;
			}
		}
		else
		{
			// Get the string resource, doing not any property substitutions
			// that has to be done later after MessageFormat
			value = localizer.getString(getResourceKey(), component, null, defaultValue);
			if (value == null)
			{
				value = defaultValue;
			}
			if (value != null)
			{
				// Build the real parameters
				Object[] realParams = new Object[parameters.length];
				for (int i = 0; i < parameters.length; i++)
				{
					if (parameters[i] instanceof IModel<?>)
					{
						realParams[i] = ((IModel<?>)parameters[i]).getObject();
					}
					else if (model != null && parameters[i] instanceof String)
					{
						realParams[i] = PropertyVariableInterpolator.interpolate(
							(String)parameters[i], model.getObject());
					}
					else
					{
						realParams[i] = parameters[i];
					}
				}

				// Escape all single quotes outside {..}
				if (value.indexOf('\'') != -1)
				{
					value = escapeQuotes(value);
				}

				if (model != null)
				{
					// First escape all substitute properties so that message format doesn't try to
					// parse that.
					value = Strings.replaceAll(value, ""${"", ""$'{'"").toString();
				}

				// Apply the parameters
				final MessageFormat format = new MessageFormat(value, locale);
				value = format.format(realParams);

				if (model != null)
				{
					// un escape the substitute properties
					value = Strings.replaceAll(value, ""$'{'"", ""${"").toString();
					// now substitute the properties
					value = localizer.substitutePropertyExpressions(component, value, model);
				}
			}
		}

		// Return the string resource
		return value;
	}","private String getString(Component component)
	{

		final Localizer localizer = getLocalizer();
		final Locale locale;
		if (component != null)
		{
			locale = component.getLocale();
		}
		else
		{
			locale = Session.exists() ? Session.get().getLocale() : Locale.getDefault();
		}

		String value;

		// Substitute any parameters if necessary
		Object[] parameters = getParameters();
		if (parameters == null || parameters.length == 0)
		{
			// Get the string resource, doing any property substitutions as part
			// of the get operation
			value = localizer.getString(getResourceKey(), component, model, defaultValue);
			if (value == null)
			{
				value = defaultValue;
			}
		}
		else
		{
			// Get the string resource, doing not any property substitutions
			// that has to be done later after MessageFormat
			value = localizer.getString(getResourceKey(), component, null, defaultValue);
			if (value == null)
			{
				value = defaultValue;
			}
			if (value != null)
			{
				// Build the real parameters
				Object[] realParams = new Object[parameters.length];
				for (int i = 0; i < parameters.length; i++)
				{
					if (parameters[i] instanceof IModel<?>)
					{
						realParams[i] = ((IModel<?>)parameters[i]).getObject();
					}
					else if (model != null && parameters[i] instanceof String)
					{
						realParams[i] = PropertyVariableInterpolator.interpolate(
							(String)parameters[i], model.getObject());
					}
					else
					{
						realParams[i] = parameters[i];
					}
				}

				// Escape all single quotes outside {..}
				if (value.indexOf('\'') != -1)
				{
					value = escapeQuotes(value);
				}

				if (model != null)
				{
					// First escape all substitute properties so that message format doesn't try to
					// parse that.
					value = Strings.replaceAll(value, ""${"", ""$'{'"").toString();
				}

				// Apply the parameters
				final MessageFormat format = new MessageFormat(value, locale);
				value = format.format(realParams);

				if (model != null)
				{
					// un escape the substitute properties
					value = Strings.replaceAll(value, ""$'{'"", ""${"").toString();
					// now substitute the properties
					value = localizer.substitutePropertyExpressions(component, value, model);
				}
			}
		}

		// Return the string resource
		return value;
	}",0,[0]
1123,bugs-dot-jar_WICKET-5546_f1af9e03,"public final <M extends Serializable> M getMetaData(final MetaDataKey<M> key)
	{
		return key.get(getMetaData());
	}","public final <M extends Serializable> M getMetaData(final MetaDataKey<M> key)
	{
		return key.get(getMetaData());
	}",0,[0]
15978,bugs-dot-jar_MATH-1058_4ebd967c,"public static double regularizedBeta(double x,
                                         final double a, final double b,
                                         double epsilon, int maxIterations) {
        double ret;

        if (Double.isNaN(x) ||
            Double.isNaN(a) ||
            Double.isNaN(b) ||
            x < 0 ||
            x > 1 ||
            a <= 0.0 ||
            b <= 0.0) {
            ret = Double.NaN;
        } else if (x > (a + 1.0) / (a + b + 2.0)) {
            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
        } else {
            ContinuedFraction fraction = new ContinuedFraction() {

                @Override
                protected double getB(int n, double x) {
                    double ret;
                    double m;
                    if (n % 2 == 0) { // even
                        m = n / 2.0;
                        ret = (m * (b - m) * x) /
                            ((a + (2 * m) - 1) * (a + (2 * m)));
                    } else {
                        m = (n - 1.0) / 2.0;
                        ret = -((a + m) * (a + b + m) * x) /
                                ((a + (2 * m)) * (a + (2 * m) + 1.0));
                    }
                    return ret;
                }

                @Override
                protected double getA(int n, double x) {
                    return 1.0;
                }
            };
            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -
                FastMath.log(a) - logBeta(a, b)) *
                1.0 / fraction.evaluate(x, epsilon, maxIterations);
        }

        return ret;
    }","public static double regularizedBeta(double x,
                                         final double a, final double b,
                                         double epsilon, int maxIterations) {
        double ret;

        if (Double.isNaN(x) ||
            Double.isNaN(a) ||
            Double.isNaN(b) ||
            x < 0 ||
            x > 1 ||
            a <= 0.0 ||
            b <= 0.0) {
            ret = Double.NaN;
        } else if (x > (a + 1.0) / (a + b + 2.0)) {
            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);
        } else {
            ContinuedFraction fraction = new ContinuedFraction() {

                @Override
                protected double getB(int n, double x) {
                    double ret;
                    double m;
                    if (n % 2 == 0) { // even
                        m = n / 2.0;
                        ret = (m * (b - m) * x) /
                            ((a + (2 * m) - 1) * (a + (2 * m)));
                    } else {
                        m = (n - 1.0) / 2.0;
                        ret = -((a + m) * (a + b + m) * x) /
                                ((a + (2 * m)) * (a + (2 * m) + 1.0));
                    }
                    return ret;
                }

                @Override
                protected double getA(int n, double x) {
                    return 1.0;
                }
            };
            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) -
                FastMath.log(a) - logBeta(a, b)) *
                1.0 / fraction.evaluate(x, epsilon, maxIterations);
        }

        return ret;
    }",1,[39]
222,bugs-dot-jar_WICKET-2368_fae1601b,"@Deprecated
	protected final IPageVersionManager newVersionManager()
	{
		return null;
	}","@Deprecated
	protected final IPageVersionManager newVersionManager()
	{
		return null;
	}",0,[0]
19729,bugs-dot-jar_WICKET-5359_61122bab,"public final Duration toDuration(final Duration defaultValue)
	{
		if (text != null)
		{
			try
			{
				return toDuration();
			}
			catch (Exception x)
			{
				if (LOG.isDebugEnabled())
				{
					LOG.debug(String.format(
						""An error occurred while converting '%s' to a Duration: %s"", text, x.getMessage()), x);
				}
			}
		}
		return defaultValue;
	}","public final Duration toDuration(final Duration defaultValue)
	{
		if (text != null)
		{
			try
			{
				return toDuration();
			}
			catch (Exception x)
			{
				if (LOG.isDebugEnabled())
				{
					LOG.debug(String.format(
						""An error occurred while converting '%s' to a Duration: %s"", text,
						x.getMessage()), x);
				}
			}
		}
		return defaultValue;
	}",1,[13]
13113,bugs-dot-jar_LOG4J2-234_2d7d6311,"@Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(""useRaw="").append(useRawMessage);
        sb.append("", pattern="").append(pattern.toString());
        return sb.toString();
    }","@Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append(""useRaw="").append(useRawMessage);
        sb.append("", pattern="").append(pattern.toString());
        return sb.toString();
    }",0,[0]
30141,bugs-dot-jar_MATH-801_118e94b5,"public Rotation(double q0, double q1, double q2, double q3,
                  boolean needsNormalization) {

    if (needsNormalization) {
      // normalization preprocessing
      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
      q0 *= inv;
      q1 *= inv;
      q2 *= inv;
      q3 *= inv;
    }

    this.q0 = q0;
    this.q1 = q1;
    this.q2 = q2;
    this.q3 = q3;

  }","public Rotation(double q0, double q1, double q2, double q3,
                  boolean needsNormalization) {

    if (needsNormalization) {
      // normalization preprocessing
      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
      q0 *= inv;
      q1 *= inv;
      q2 *= inv;
      q3 *= inv;
    }

    this.q0 = q0;
    this.q1 = q1;
    this.q2 = q2;
    this.q3 = q3;

  }",0,[0]
2540,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static Expression fileSizeExpression() {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return exchange.getIn().getHeader(""CamelFileLength"", Long.class);
            }

            @Override
            public String toString() {
                return ""file:length"";
            }
        };
    }","public static Expression fileSizeExpression() {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return exchange.getIn().getHeader(""CamelFileLength"", Long.class);
            }

            @Override
            public String toString() {
                return ""file:length"";
            }
        };
    }",0,[0]
29769,bugs-dot-jar_FLINK-2763_af477563,"public static byte assignPartition(int bucket, byte numPartitions) {
		return (byte) (bucket % numPartitions);
	}","public static byte assignPartition(int bucket, byte numPartitions) {
		return (byte) (bucket % numPartitions);
	}",0,[0]
1837,Bears-211,"@Override
    protected CBORParser _createParser(InputStream in, IOContext ctxt) throws IOException
    {
        return new CBORParserBootstrapper(ctxt, in).constructParser(_factoryFeatures,
                _parserFeatures, _formatParserFeatures,
                _objectCodec, _byteSymbolCanonicalizer);
    }","@Override
    protected CBORParser _createParser(InputStream in, IOContext ctxt) throws IOException
    {
        return new CBORParserBootstrapper(ctxt, in).constructParser(_factoryFeatures,
                _parserFeatures, _formatParserFeatures,
                _objectCodec, _byteSymbolCanonicalizer);
    }",0,[0]
23275,bugs-dot-jar_FLINK-1496_0a4c7694,"public BufferProvider getBufferProvider() {
		return bufferPool;
	}","public BufferProvider getBufferProvider() {
		return bufferPool;
	}",0,[0]
4935,bugs-dot-jar_WICKET-3563_c62b66c1,"protected void onMarkupAttached()
	{
		if (log.isDebugEnabled())
		{
			log.debug(""Markup available "" + toString());
		}

		// move the component to its real parent if necessary
		// moveComponentToItsRealParent();
	}","protected void onMarkupAttached()
	{
		if (log.isDebugEnabled())
		{
			log.debug(""Markup available "" + toString());
		}

		// move the component to its real parent if necessary
		// moveComponentToItsRealParent();
	}",0,[0]
1350,Bears-160,"protected void parseColumnDefinition(Marker start, String columnName, TokenStream tokens, TableEditor table, ColumnEditor column,
                                         AtomicBoolean isPrimaryKey) {
        // Parse the data type, which must be at this location ...
        List<ParsingException> errors = new ArrayList<>();
        Marker dataTypeStart = tokens.mark();
        DataType dataType = dataTypeParser.parse(tokens, errors::addAll);
        if (dataType == null) {
            String dataTypeName = parseDomainName(start);
            if (dataTypeName != null) dataType = DataType.userDefinedType(dataTypeName);
        }
        if (dataType == null) {
            // No data type was found
            parsingFailed(dataTypeStart.position(), errors, ""Unable to read the data type"");
            return;
        }
        column.jdbcType(dataType.jdbcType());
        column.type(dataType.name(), dataType.expression());
        if (""ENUM"".equals(dataType.name())) {
            column.length(1);
        } else if (""SET"".equals(dataType.name())) {
            List<String> options = parseSetAndEnumOptions(dataType.expression());
            // After DBZ-132, it will always be comma seperated
            column.length(Math.max(0, options.size() * 2 - 1)); // number of options + number of commas
        } else {
            if (dataType.length() > -1) column.length((int) dataType.length());
            if (dataType.scale() > -1) column.scale(dataType.scale());
        }

        if (Types.NCHAR == dataType.jdbcType() || Types.NVARCHAR == dataType.jdbcType()) {
            // NCHAR and NVARCHAR columns always uses utf8 as charset
            column.charsetName(""utf8"");
        }

        if (tokens.canConsume(""CHARSET"") || tokens.canConsume(""CHARACTER"", ""SET"")) {
            String charsetName = tokens.consume();
            if (!""DEFAULT"".equalsIgnoreCase(charsetName)) {
                // Only record it if not inheriting the character set from the table
                column.charsetName(charsetName);
            }
        }
        if (tokens.canConsume(""COLLATE"")) {
            tokens.consume(); // name of collation
        }

        if (tokens.canConsume(""AS"") || tokens.canConsume(""GENERATED"", ""ALWAYS"", ""AS"")) {
            consumeExpression(start);
            tokens.canConsumeAnyOf(""VIRTUAL"", ""STORED"");
            if (tokens.canConsume(""UNIQUE"")) {
                tokens.canConsume(""KEY"");
            }
            if (tokens.canConsume(""COMMENT"")) {
                consumeQuotedString();
            }
            tokens.canConsume(""NOT"", ""NULL"");
            tokens.canConsume(""NULL"");
            tokens.canConsume(""PRIMARY"", ""KEY"");
            tokens.canConsume(""KEY"");
        } else {
            while (tokens.matchesAnyOf(""NOT"", ""NULL"", ""DEFAULT"", ""AUTO_INCREMENT"", ""UNIQUE"", ""PRIMARY"", ""KEY"", ""COMMENT"",
                                       ""REFERENCES"", ""COLUMN_FORMAT"", ""ON"", ""COLLATE"")) {
                // Nullability ...
                if (tokens.canConsume(""NOT"", ""NULL"")) {
                    column.optional(false);
                } else if (tokens.canConsume(""NULL"")) {
                    column.optional(true);
                }
                // Default value ...
                if (tokens.matches(""DEFAULT"")) {
                    parseDefaultClause(start);
                }
                if (tokens.matches(""ON"", ""UPDATE"") || tokens.matches(""ON"", ""DELETE"")) {
                    parseOnUpdateOrDelete(tokens.mark());
                    column.autoIncremented(true);
                }
                // Other options ...
                if (tokens.canConsume(""AUTO_INCREMENT"")) {
                    column.autoIncremented(true);
                    column.generated(true);
                }
                if (tokens.canConsume(""UNIQUE"", ""KEY"") || tokens.canConsume(""UNIQUE"")) {
                    if (table.primaryKeyColumnNames().isEmpty() && !column.isOptional()) {
                        // The table has no primary key (yet) but this is a non-null column and therefore will have all unique
                        // values (MySQL allows UNIQUE indexes with some nullable columns, but in that case allows duplicate
                        // rows),
                        // so go ahead and set it to this column as it's a unique key
                        isPrimaryKey.set(true);
                    }
                }
                if (tokens.canConsume(""PRIMARY"", ""KEY"") || tokens.canConsume(""KEY"")) {
                    // Always set this column as the primary key
                    column.optional(false); // MySQL primary key columns may not be null
                    isPrimaryKey.set(true);
                }
                if (tokens.canConsume(""COMMENT"")) {
                    consumeQuotedString();
                }
                if (tokens.canConsume(""COLUMN_FORMAT"")) {
                    tokens.consumeAnyOf(""FIXED"", ""DYNAMIC"", ""DEFAULT"");
                }
                if (tokens.matches(""REFERENCES"")) {
                    parseReferenceDefinition(start);
                }
                if (tokens.canConsume(""COLLATE"")) {
                    tokens.consume(); // name of collation
                }
            }
        }
    }","protected void parseColumnDefinition(Marker start, String columnName, TokenStream tokens, TableEditor table, ColumnEditor column,
                                         AtomicBoolean isPrimaryKey) {
        // Parse the data type, which must be at this location ...
        List<ParsingException> errors = new ArrayList<>();
        Marker dataTypeStart = tokens.mark();
        DataType dataType = dataTypeParser.parse(tokens, errors::addAll);
        if (dataType == null) {
            String dataTypeName = parseDomainName(start);
            if (dataTypeName != null) dataType = DataType.userDefinedType(dataTypeName);
        }
        if (dataType == null) {
            // No data type was found
            parsingFailed(dataTypeStart.position(), errors, ""Unable to read the data type"");
            return;
        }
        column.jdbcType(dataType.jdbcType());
        column.type(dataType.name(), dataType.expression());
        if (""ENUM"".equals(dataType.name())) {
            column.length(1);
        } else if (""SET"".equals(dataType.name())) {
            List<String> options = parseSetAndEnumOptions(dataType.expression());
            // After DBZ-132, it will always be comma seperated
            column.length(Math.max(0, options.size() * 2 - 1)); // number of options + number of commas
        } else {
            if (dataType.length() > -1) column.length((int) dataType.length());
            if (dataType.scale() > -1) column.scale(dataType.scale());
        }

        if (Types.NCHAR == dataType.jdbcType() || Types.NVARCHAR == dataType.jdbcType()) {
            // NCHAR and NVARCHAR columns always uses utf8 as charset
            column.charsetName(""utf8"");
        }

        if (tokens.canConsume(""CHARSET"") || tokens.canConsume(""CHARACTER"", ""SET"")) {
            String charsetName = tokens.consume();
            if (!""DEFAULT"".equalsIgnoreCase(charsetName)) {
                // Only record it if not inheriting the character set from the table
                column.charsetName(charsetName);
            }
        }
        if (tokens.canConsume(""COLLATE"")) {
            tokens.consume(); // name of collation
        }

        if (tokens.canConsume(""AS"") || tokens.canConsume(""GENERATED"", ""ALWAYS"", ""AS"")) {
            consumeExpression(start);
            tokens.canConsumeAnyOf(""VIRTUAL"", ""STORED"");
            if (tokens.canConsume(""UNIQUE"")) {
                tokens.canConsume(""KEY"");
            }
            if (tokens.canConsume(""COMMENT"")) {
                consumeQuotedString();
            }
            tokens.canConsume(""NOT"", ""NULL"");
            tokens.canConsume(""NULL"");
            tokens.canConsume(""PRIMARY"", ""KEY"");
            tokens.canConsume(""KEY"");
        } else {
            while (tokens.matchesAnyOf(""NOT"", ""NULL"", ""DEFAULT"", ""AUTO_INCREMENT"", ""UNIQUE"", ""PRIMARY"", ""KEY"", ""COMMENT"",
                                       ""REFERENCES"", ""COLUMN_FORMAT"", ""ON"", ""COLLATE"")) {
                // Nullability ...
                if (tokens.canConsume(""NOT"", ""NULL"")) {
                    column.optional(false);
                } else if (tokens.canConsume(""NULL"")) {
                    column.optional(true);
                }
                // Default value ...
                if (tokens.matches(""DEFAULT"")) {
                    parseDefaultClause(start);
                }
                if (tokens.matches(""ON"", ""UPDATE"") || tokens.matches(""ON"", ""DELETE"")) {
                    parseOnUpdateOrDelete(tokens.mark());
                    column.autoIncremented(true);
                }
                // Other options ...
                if (tokens.canConsume(""AUTO_INCREMENT"")) {
                    column.autoIncremented(true);
                    column.generated(true);
                }
                if (tokens.canConsume(""UNIQUE"", ""KEY"") || tokens.canConsume(""UNIQUE"")) {
                    if (table.primaryKeyColumnNames().isEmpty() && !column.isOptional()) {
                        // The table has no primary key (yet) but this is a non-null column and therefore will have all unique
                        // values (MySQL allows UNIQUE indexes with some nullable columns, but in that case allows duplicate
                        // rows),
                        // so go ahead and set it to this column as it's a unique key
                        isPrimaryKey.set(true);
                    }
                }
                if (tokens.canConsume(""PRIMARY"", ""KEY"") || tokens.canConsume(""KEY"")) {
                    // Always set this column as the primary key
                    column.optional(false); // MySQL primary key columns may not be null
                    isPrimaryKey.set(true);
                }
                if (tokens.canConsume(""COMMENT"")) {
                    consumeQuotedString();
                }
                if (tokens.canConsume(""COLUMN_FORMAT"")) {
                    tokens.consumeAnyOf(""FIXED"", ""DYNAMIC"", ""DEFAULT"");
                }
                if (tokens.matches(""REFERENCES"")) {
                    parseReferenceDefinition(start);
                }
                if (tokens.canConsume(""COLLATE"")) {
                    tokens.consume(); // name of collation
                }
            }
        }
    }",0,[0]
25589,bugs-dot-jar_ACCUMULO-2974_5eceb10e,"private void deleteTablets(MergeInfo info, Range scanRange, BatchWriter bw, Connector conn) throws TableNotFoundException, MutationsRejectedException {
    Scanner scanner;
    Mutation m;
    // Delete everything in the other tablets
    // group all deletes into tablet into one mutation, this makes tablets
    // either disappear entirely or not all.. this is important for the case
    // where the process terminates in the loop below...
    scanner = conn.createScanner(info.getExtent().isMeta() ? RootTable.NAME : MetadataTable.NAME, Authorizations.EMPTY);
    Master.log.debug(""Deleting range "" + scanRange);
    scanner.setRange(scanRange);
    RowIterator rowIter = new RowIterator(scanner);
    while (rowIter.hasNext()) {
      Iterator<Entry<Key,Value>> row = rowIter.next();
      m = null;
      while (row.hasNext()) {
        Entry<Key,Value> entry = row.next();
        Key key = entry.getKey();
        
        if (m == null)
          m = new Mutation(key.getRow());
        
        m.putDelete(key.getColumnFamily(), key.getColumnQualifier());
        Master.log.debug(""deleting entry "" + key);
      }
      bw.addMutation(m);
    }
    
    bw.flush();
  }","private void deleteTablets(MergeInfo info, Range scanRange, BatchWriter bw, Connector conn) throws TableNotFoundException, MutationsRejectedException {
    Scanner scanner;
    Mutation m;
    // Delete everything in the other tablets
    // group all deletes into tablet into one mutation, this makes tablets
    // either disappear entirely or not all.. this is important for the case
    // where the process terminates in the loop below...
    scanner = conn.createScanner(info.getExtent().isMeta() ? RootTable.NAME : MetadataTable.NAME, Authorizations.EMPTY);
    Master.log.debug(""Deleting range "" + scanRange);
    scanner.setRange(scanRange);
    RowIterator rowIter = new RowIterator(scanner);
    while (rowIter.hasNext()) {
      Iterator<Entry<Key,Value>> row = rowIter.next();
      m = null;
      while (row.hasNext()) {
        Entry<Key,Value> entry = row.next();
        Key key = entry.getKey();
        
        if (m == null)
          m = new Mutation(key.getRow());
        
        m.putDelete(key.getColumnFamily(), key.getColumnQualifier());
        Master.log.debug(""deleting entry "" + key);
      }
      bw.addMutation(m);
    }
    
    bw.flush();
  }",0,[0]
8842,bugs-dot-jar_CAMEL-7275_44cad623,"protected void prepareSharedUnitOfWork(Exchange childExchange, Exchange parentExchange) {
        childExchange.setProperty(Exchange.PARENT_UNIT_OF_WORK, parentExchange.getUnitOfWork());
    }","protected void prepareSharedUnitOfWork(Exchange childExchange, Exchange parentExchange) {
        childExchange.setProperty(Exchange.PARENT_UNIT_OF_WORK, parentExchange.getUnitOfWork());
    }",0,[0]
6370,bugs-dot-jar_ACCUMULO-3015_f848178e,"public void setOffline(Boolean offline) {
    this.offline = offline;
  }","public void setOffline(Boolean offline) {
    this.offline = offline;
  }",0,[0]
18516,bugs-dot-jar_CAMEL-9666_da035952,"public Object getProperty(String name, Object defaultValue) {
        Object answer = getProperty(name);
        return answer != null ? answer : defaultValue;
    }","public Object getProperty(String name, Object defaultValue) {
        Object answer = getProperty(name);
        return answer != null ? answer : defaultValue;
    }",0,[0]
7331,bugs-dot-jar_WICKET-5466_c1c1f794,"@Override
	public IRequestableComponent getComponent()
	{
		return pageComponentProvider.getComponent();
	}","@Override
	public IRequestableComponent getComponent()
	{
		return pageComponentProvider.getComponent();
	}",0,[0]
784,Bears-99,"private Position decodeBinary(ChannelBuffer buf, Channel channel, SocketAddress remoteAddress) {

        Position position = new Position();
        position.setProtocol(getProtocolName());

        buf.readByte(); // marker

        DeviceSession deviceSession = getDeviceSession(
                channel, remoteAddress, ChannelBuffers.hexDump(buf.readBytes(5)));
        if (deviceSession == null) {
            return null;
        }
        position.setDeviceId(deviceSession.getDeviceId());

        DateBuilder dateBuilder = new DateBuilder()
                .setHour(BcdUtil.readInteger(buf, 2))
                .setMinute(BcdUtil.readInteger(buf, 2))
                .setSecond(BcdUtil.readInteger(buf, 2))
                .setDay(BcdUtil.readInteger(buf, 2))
                .setMonth(BcdUtil.readInteger(buf, 2))
                .setYear(BcdUtil.readInteger(buf, 2));
        position.setTime(dateBuilder.getDate());

        double latitude = readCoordinate(buf, false);
        position.set(Position.KEY_BATTERY, decodeBattery(buf.readUnsignedByte()));
        double longitude = readCoordinate(buf, true);

        int flags = buf.readUnsignedByte() & 0x0f;
        position.setValid((flags & 0x02) != 0);
        if ((flags & 0x04) == 0) {
            latitude = -latitude;
        }
        if ((flags & 0x08) == 0) {
            longitude = -longitude;
        }

        position.setLatitude(latitude);
        position.setLongitude(longitude);

        position.setSpeed(BcdUtil.readInteger(buf, 3));
        position.setCourse((buf.readUnsignedByte() & 0x0f) * 100.0 + BcdUtil.readInteger(buf, 2));

        processStatus(position, buf.readUnsignedInt());
        return position;
    }","private Position decodeBinary(ChannelBuffer buf, Channel channel, SocketAddress remoteAddress) {

        Position position = new Position();
        position.setProtocol(getProtocolName());

        buf.readByte(); // marker

        DeviceSession deviceSession = getDeviceSession(
                channel, remoteAddress, ChannelBuffers.hexDump(buf.readBytes(5)));
        if (deviceSession == null) {
            return null;
        }
        position.setDeviceId(deviceSession.getDeviceId());

        DateBuilder dateBuilder = new DateBuilder()
                .setHour(BcdUtil.readInteger(buf, 2))
                .setMinute(BcdUtil.readInteger(buf, 2))
                .setSecond(BcdUtil.readInteger(buf, 2))
                .setDay(BcdUtil.readInteger(buf, 2))
                .setMonth(BcdUtil.readInteger(buf, 2))
                .setYear(BcdUtil.readInteger(buf, 2));
        position.setTime(dateBuilder.getDate());

        double latitude = readCoordinate(buf, false);
        position.set(Position.KEY_BATTERY, decodeBattery(buf.readUnsignedByte()));
        double longitude = readCoordinate(buf, true);

        int flags = buf.readUnsignedByte() & 0x0f;
        position.setValid((flags & 0x02) != 0);
        if ((flags & 0x04) == 0) {
            latitude = -latitude;
        }
        if ((flags & 0x08) == 0) {
            longitude = -longitude;
        }

        position.setLatitude(latitude);
        position.setLongitude(longitude);

        position.setSpeed(BcdUtil.readInteger(buf, 3));
        position.setCourse((buf.readUnsignedByte() & 0x0f) * 100.0 + BcdUtil.readInteger(buf, 2));

        processStatus(position, buf.readUnsignedInt());
        return position;
    }",0,[0]
7520,bugs-dot-jar_WICKET-4030_5f69685d,"@Override
	public String getFilterPath()
	{
		return UrlUtils.normalizePath(filterPath);
	}","@Override
	public String getFilterPath()
	{
		return UrlUtils.normalizePath(filterPath);
	}",0,[0]
204,bugs-dot-jar_WICKET-2368_fae1601b,"public final Page rollbackPage(int numberOfVersions)
	{
		Page page = this;
		if (versionManager != null)
		{
			page = versionManager.rollbackPage(numberOfVersions);
		}
		getSession().touch(page);
		return page;
	}","public final Page rollbackPage(int numberOfVersions)
	{
		Page page = this;
		if (versionManager != null)
		{
			page = versionManager.rollbackPage(numberOfVersions);
		}
		getSession().touch(page);
		return page;
	}",0,[0]
26528,bugs-dot-jar_OAK-3021_494da6de,"@Override
    public void propertyDeleted(PropertyState before) throws CommitFailedException {
        // nothing to do: mandatory properties will be enforced by node type validator
    }","@Override
    public void propertyDeleted(PropertyState before) throws CommitFailedException {
        // nothing to do: mandatory properties will be enforced by node type validator
    }",0,[0]
32113,bugs-dot-jar_MATH-724_9c8bb934,"public double nextChiSquare(double df) {
        return nextInversionDeviate(new ChiSquaredDistribution(df));
    }","public double nextChiSquare(double df) {
        return nextInversionDeviate(new ChiSquaredDistribution(df));
    }",0,[0]
17153,bugs-dot-jar_MATH-949_f83bbc1d,"public LevenbergMarquardtOptimizer(double initialStepBoundFactor,
                                       double costRelativeTolerance,
                                       double parRelativeTolerance,
                                       double orthoTolerance,
                                       double threshold) {
        super(null); // No custom convergence criterion.
        this.initialStepBoundFactor = initialStepBoundFactor;
        this.costRelativeTolerance = costRelativeTolerance;
        this.parRelativeTolerance = parRelativeTolerance;
        this.orthoTolerance = orthoTolerance;
        this.qrRankingThreshold = threshold;
    }","public LevenbergMarquardtOptimizer(double initialStepBoundFactor,
                                       double costRelativeTolerance,
                                       double parRelativeTolerance,
                                       double orthoTolerance,
                                       double threshold) {
        super(null); // No custom convergence criterion.
        this.initialStepBoundFactor = initialStepBoundFactor;
        this.costRelativeTolerance = costRelativeTolerance;
        this.parRelativeTolerance = parRelativeTolerance;
        this.orthoTolerance = orthoTolerance;
        this.qrRankingThreshold = threshold;
    }",0,[0]
25669,bugs-dot-jar_CAMEL-7973_799b45df,"public boolean process(final Exchange exchange, final AsyncCallback callback) {

        // can we still run
        if (!isRunAllowed()) {
            log.trace(""Run not allowed, will reject executing exchange: {}"", exchange);
            if (exchange.getException() == null) {
                exchange.setException(new RejectedExecutionException(""Run is not allowed""));
            }
            callback.done(true);
            return true;
        }

        if (failures.get() >= threshold && System.currentTimeMillis() - lastFailure < halfOpenAfter) {
            exchange.setException(new RejectedExecutionException(""CircuitBreaker Open: failures: "" + failures + "", lastFailure: "" + lastFailure));
        }
        Processor processor = getProcessors().get(0);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process CircuitBreaker"");
        }

        AsyncProcessor albp = AsyncProcessorConverterHelper.convert(processor);
        boolean sync = albp.process(exchange, callback);

        boolean failed = hasFailed(exchange);

        if (!failed) {
            failures.set(0);
        } else {
            failures.incrementAndGet();
            lastFailure = System.currentTimeMillis();
        }

        if (!sync) {
            log.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            return false;
        }

        log.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
        callback.done(true);
        return true;
    }","public boolean process(final Exchange exchange, final AsyncCallback callback) {

        // can we still run
        if (!isRunAllowed()) {
            log.trace(""Run not allowed, will reject executing exchange: {}"", exchange);
            if (exchange.getException() == null) {
                exchange.setException(new RejectedExecutionException(""Run is not allowed""));
            }
            callback.done(true);
            return true;
        }

        if (failures.get() >= threshold && System.currentTimeMillis() - lastFailure < halfOpenAfter) {
            exchange.setException(new RejectedExecutionException(""CircuitBreaker Open: failures: "" + failures + "", lastFailure: "" + lastFailure));
            /*
             * If the circuit opens, we have to prevent the execution of any processor.
             * The failures count can be set to 0.
             */
            failures.set(0);
            callback.done(true);
            return true;
        }
        Processor processor = getProcessors().get(0);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process CircuitBreaker"");
        }

        AsyncProcessor albp = AsyncProcessorConverterHelper.convert(processor);
        // Added a callback for processing the exchange in the callback
        boolean sync = albp.process(exchange, new CircuitBreakerCallback(exchange, callback));
        
        // We need to check the exception here as albp is use sync call  
        if (sync) {
            boolean failed = hasFailed(exchange);
            if (!failed) {
                failures.set(0);
            } else {
                failures.incrementAndGet();
                lastFailure = System.currentTimeMillis();
            }
        } else {
            // CircuitBreakerCallback can take care of failure check of the exchange
            log.trace(""Processing exchangeId: {} is continued being processed asynchronously"", exchange.getExchangeId());
            return false;
        }

        log.trace(""Processing exchangeId: {} is continued being processed synchronously"", exchange.getExchangeId());
        callback.done(true);
        return true;
    }",1,"[21, 23, 25, 26, 28, 29, 30, 32]"
3833,bugs-dot-jar_ACCUMULO-1544_0cf2ff72,"public void killProcess(ServerType type, ProcessReference proc) throws ProcessNotFoundException, InterruptedException {
    boolean found = false;
    switch (type) {
      case MASTER:
        if (proc.equals(masterProcess)) {
          masterProcess.destroy();
          masterProcess = null;
          found = true;
        }
        break;
      case TABLET_SERVER:
        for (Process tserver : tabletServerProcesses) {
          if (proc.equals(tserver)) {
            tabletServerProcesses.remove(tserver);
            tserver.destroy();
            found = true;
            break;
          }
        }
        break;
      case ZOOKEEPER:
        if (proc.equals(zooKeeperProcess)) {
          zooKeeperProcess.destroy();
          zooKeeperProcess = null;
          found = true;
        }
        break;
    }
    if (!found)
      throw new ProcessNotFoundException();
  }","public void killProcess(ServerType type, ProcessReference proc) throws ProcessNotFoundException, InterruptedException {
    boolean found = false;
    switch (type) {
      case MASTER:
        if (proc.equals(masterProcess)) {
          masterProcess.destroy();
          masterProcess = null;
          found = true;
        }
        break;
      case TABLET_SERVER:
        for (Process tserver : tabletServerProcesses) {
          if (proc.equals(tserver)) {
            tabletServerProcesses.remove(tserver);
            tserver.destroy();
            found = true;
            break;
          }
        }
        break;
      case ZOOKEEPER:
        if (proc.equals(zooKeeperProcess)) {
          zooKeeperProcess.destroy();
          zooKeeperProcess = null;
          found = true;
        }
        break;
    }
    if (!found)
      throw new ProcessNotFoundException();
  }",0,[0]
173,Bears-6,"protected Integer _findIndex() {
        return fromMemberAnnotations(new WithMember<Integer>() {
            @Override
            public Integer withMember(AnnotatedMember member) {
                return _annotationIntrospector.findPropertyIndex(member);
            }
        });
    }","protected Integer _findIndex() {
        return fromMemberAnnotations(new WithMember<Integer>() {
            @Override
            public Integer withMember(AnnotatedMember member) {
                return _annotationIntrospector.findPropertyIndex(member);
            }
        });
    }",0,[0]
21647,bugs-dot-jar_MATH-371_bb005b56,"public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {
        int nVars = matrix.getColumnDimension();
        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < i; j++) {
              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));
              outMatrix.setEntry(i, j, corr);
              outMatrix.setEntry(j, i, corr);
            }
            outMatrix.setEntry(i, i, 1d);
        }
        return outMatrix;
    }","public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {
        int nVars = matrix.getColumnDimension();
        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);
        for (int i = 0; i < nVars; i++) {
            for (int j = 0; j < i; j++) {
              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));
              outMatrix.setEntry(i, j, corr);
              outMatrix.setEntry(j, i, corr);
            }
            outMatrix.setEntry(i, i, 1d);
        }
        return outMatrix;
    }",0,[0]
12961,bugs-dot-jar_OAK-2345_a0dc4c89,"public void applyChanges(Revision rev, String path,
                             boolean isNew, List<String> added,
                             List<String> removed, List<String> changed,
                             DiffCache.Entry cacheEntry) {
        if (isNew) {
            DocumentNodeState.Children c = new DocumentNodeState.Children();
            Set<String> set = Sets.newTreeSet();
            for (String p : added) {
                set.add(Utils.unshareString(PathUtils.getName(p)));
            }
            c.children.addAll(set);
            PathRev key = childNodeCacheKey(path, rev, null);
            nodeChildrenCache.put(key, c);
        }

        // update diff cache
        JsopWriter w = new JsopStream();
        for (String p : added) {
            w.tag('+').key(PathUtils.getName(p)).object().endObject().newline();
        }
        for (String p : removed) {
            w.tag('-').value(PathUtils.getName(p)).newline();
        }
        for (String p : changed) {
            w.tag('^').key(PathUtils.getName(p)).object().endObject().newline();
        }
        cacheEntry.append(path, w.toString());

        // update docChildrenCache
        if (!added.isEmpty()) {
            StringValue docChildrenKey = new StringValue(path);
            NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);
            if (docChildren != null) {
                int currentSize = docChildren.childNames.size();
                NavigableSet<String> names = Sets.newTreeSet(docChildren.childNames);
                // incomplete cache entries must not be updated with
                // names at the end of the list because there might be
                // a next name in DocumentStore smaller than the one added
                if (!docChildren.isComplete) {
                    for (String childPath : added) {
                        String name = PathUtils.getName(childPath);
                        if (names.higher(name) != null) {
                            names.add(Utils.unshareString(name));
                        }
                    }
                } else {
                    // add all
                    for (String childPath : added) {
                        names.add(Utils.unshareString(PathUtils.getName(childPath)));
                    }
                }
                // any changes?
                if (names.size() != currentSize) {
                    // create new cache entry with updated names
                    boolean complete = docChildren.isComplete;
                    docChildren = new NodeDocument.Children();
                    docChildren.isComplete = complete;
                    docChildren.childNames.addAll(names);
                    docChildrenCache.put(docChildrenKey, docChildren);
                }
            }
        }
    }","public void applyChanges(Revision rev, String path,
                             boolean isNew, List<String> added,
                             List<String> removed, List<String> changed,
                             DiffCache.Entry cacheEntry) {
        if (isNew) {
            DocumentNodeState.Children c = new DocumentNodeState.Children();
            Set<String> set = Sets.newTreeSet();
            for (String p : added) {
                set.add(Utils.unshareString(PathUtils.getName(p)));
            }
            c.children.addAll(set);
            PathRev key = childNodeCacheKey(path, rev, null);
            nodeChildrenCache.put(key, c);
        }

        // update diff cache
        JsopWriter w = new JsopStream();
        for (String p : added) {
            w.tag('+').key(PathUtils.getName(p)).object().endObject().newline();
        }
        for (String p : removed) {
            w.tag('-').value(PathUtils.getName(p)).newline();
        }
        for (String p : changed) {
            w.tag('^').key(PathUtils.getName(p)).object().endObject().newline();
        }
        cacheEntry.append(path, w.toString());

        // update docChildrenCache
        if (!added.isEmpty()) {
            StringValue docChildrenKey = new StringValue(path);
            NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);
            if (docChildren != null) {
                int currentSize = docChildren.childNames.size();
                NavigableSet<String> names = Sets.newTreeSet(docChildren.childNames);
                // incomplete cache entries must not be updated with
                // names at the end of the list because there might be
                // a next name in DocumentStore smaller than the one added
                if (!docChildren.isComplete) {
                    for (String childPath : added) {
                        String name = PathUtils.getName(childPath);
                        if (names.higher(name) != null) {
                            names.add(Utils.unshareString(name));
                        }
                    }
                } else {
                    // add all
                    for (String childPath : added) {
                        names.add(Utils.unshareString(PathUtils.getName(childPath)));
                    }
                }
                // any changes?
                if (names.size() != currentSize) {
                    // create new cache entry with updated names
                    boolean complete = docChildren.isComplete;
                    docChildren = new NodeDocument.Children();
                    docChildren.isComplete = complete;
                    docChildren.childNames.addAll(names);
                    docChildrenCache.put(docChildrenKey, docChildren);
                }
            }
        }
    }",0,[0]
11322,bugs-dot-jar_OAK-395_e6c31270,"@Override
    public boolean hasProperties() throws RepositoryException {
        checkStatus();

        return sessionDelegate.perform(new SessionOperation<Boolean>() {
            @Override
            public Boolean perform() throws RepositoryException {
                return dlg.getPropertyCount() != 0;
            }
        });
    }","@Override
    public boolean hasProperties() throws RepositoryException {
        checkStatus();

        return sessionDelegate.perform(new SessionOperation<Boolean>() {
            @Override
            public Boolean perform() throws RepositoryException {
                return dlg.getPropertyCount() != 0;
            }
        });
    }",0,[0]
30581,bugs-dot-jar_CAMEL-3531_41e4b5b9,"private ObjectHelper() {
    }","private ObjectHelper() {
    }",0,[0]
16662,bugs-dot-jar_WICKET-5689_2ac29d30,"public BufferedWebResponse getAndRemoveBufferedResponse(String sessionId, Url url)
	{
		String key = sessionId + url.toString();
		return storedResponses.remove(key);
	}","public BufferedWebResponse getAndRemoveBufferedResponse(String sessionId, Url url)
	{
		String key = sessionId + url.toString();
		return storedResponses.remove(key);
	}",0,[0]
4841,bugs-dot-jar_MATH-326_ce185345,"public double getEntry(int index) throws MatrixIndexException {
        checkIndex(index);
        return entries.get(index);
    }","public double getEntry(int index) throws MatrixIndexException {
        checkIndex(index);
        return entries.get(index);
    }",0,[0]
19865,bugs-dot-jar_WICKET-1718_bb7f9cf5,"@Override
	public final void dirty(boolean isInitialization)
	{
		Request request = getRequest();
		if (isInitialization == false && request instanceof WebRequest &&
			((WebRequest)request).isAjax())
		{
			return;
		}
		super.dirty(isInitialization);
	}","@Override
	public final void dirty(boolean isInitialization)
	{
		Request request = getRequest();
		if (isInitialization == false && request instanceof WebRequest &&
			((WebRequest)request).isAjax())
		{
			return;
		}
		super.dirty(isInitialization);
	}",0,[0]
3031,bugs-dot-jar_FLINK-2754_68912126,"@Override
	public long getOccupancy() {
		return this.sortBufferBytes;
	}","@Override
	public long getOccupancy() {
		return this.sortBufferBytes;
	}",0,[0]
24816,bugs-dot-jar_FLINK-1437_fb7ce0e3,"@Override
	public T deserialize(DataInputView source) throws IOException {
		boolean isNull = source.readBoolean();
		if(isNull) {
			return null;
		}
		T target;
		try {
			target = clazz.newInstance();
		}
		catch (Throwable t) {
			throw new RuntimeException(""Cannot instantiate class."", t);
		}
		
		try {
			for (int i = 0; i < numFields; i++) {
				isNull = source.readBoolean();
				if(isNull) {
					fields[i].set(target, null);
				} else {
					Object field = fieldSerializers[i].deserialize(source);
					fields[i].set(target, field);
				}
			}
		} catch (IllegalAccessException e) {
			throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields"" +
					""before."");
		}
		return target;
	}","@Override
	public T deserialize(DataInputView source) throws IOException {
		boolean isNull = source.readBoolean();
		if(isNull) {
			return null;
		}
		T target;
		try {
			target = clazz.newInstance();
		}
		catch (Throwable t) {
			throw new RuntimeException(""Cannot instantiate class."", t);
		}
		
		try {
			for (int i = 0; i < numFields; i++) {
				isNull = source.readBoolean();
				if(isNull) {
					fields[i].set(target, null);
				} else {
					Object field = fieldSerializers[i].deserialize(source);
					fields[i].set(target, field);
				}
			}
		} catch (IllegalAccessException e) {
			throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields"" +
					""before."");
		}
		return target;
	}",0,[0]
40324,bugs-dot-jar_LOG4J2-219_ed951c76,"@Override
    public Object getComponent(final String name) {
        return componentMap.get(name);
    }","@Override
    public Object getComponent(final String name) {
        return componentMap.get(name);
    }",0,[0]
39286,bugs-dot-jar_OAK-4353_b0014b7d,"private boolean hasGraph() {
        if (!hasGraph) {
            try {
                loadGraph();
            } catch (IOException ignore) { }
        }
        return hasGraph;
    }","private boolean hasGraph() {
        if (!hasGraph) {
            try {
                loadGraph();
            } catch (IOException ignore) { }
        }
        return hasGraph;
    }",0,[0]
39160,bugs-dot-jar_OAK-3920_99996c25,"public OakDirectory(NodeBuilder builder, IndexDefinition definition, boolean readOnly) {
        this(builder, INDEX_DATA_CHILD_NAME, definition, readOnly);
    }","public OakDirectory(NodeBuilder builder, IndexDefinition definition, boolean readOnly) {
        this(builder, INDEX_DATA_CHILD_NAME, definition, readOnly);
    }",0,[0]
7051,bugs-dot-jar_LOG4J2-763_97203de8,"public MapMessage newInstance(final Map<String, String> map) {
        return new MapMessage(map);
    }","public MapMessage newInstance(final Map<String, String> map) {
        return new MapMessage(map);
    }",0,[0]
38474,bugs-dot-jar_CAMEL-9124_9da2c05a,"public RedeliveryPolicyDefinition asyncDelayedRedelivery() {
        setAsyncDelayedRedelivery(""true"");
        return this;
    }","public RedeliveryPolicyDefinition asyncDelayedRedelivery() {
        setAsyncDelayedRedelivery(""true"");
        return this;
    }",0,[0]
33188,bugs-dot-jar_WICKET-2202_24ac1a35,"private void markFormsSubmitted()
	{
		setFlag(FLAG_SUBMITTED, true);

		visitChildren(Form.class, new IVisitor<Component>()
		{
			public Object component(Component component)
			{
				Form<?> form = (Form<?>)component;
				if (form.isEnabledInHierarchy() && isVisibleInHierarchy())
				{
					form.setFlag(FLAG_SUBMITTED, true);
					return IVisitor.CONTINUE_TRAVERSAL;
				}
				return IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		});
	}","private void markFormsSubmitted()
	{
		setFlag(FLAG_SUBMITTED, true);

		visitChildren(Form.class, new IVisitor<Component>()
		{
			public Object component(Component component)
			{
				Form<?> form = (Form<?>)component;
				if (form.isEnabledInHierarchy() && isVisibleInHierarchy())
				{
					form.setFlag(FLAG_SUBMITTED, true);
					return IVisitor.CONTINUE_TRAVERSAL;
				}
				return IVisitor.CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
			}
		});
	}",0,[0]
35333,bugs-dot-jar_WICKET-5447_2abc18f1,"@Override
	public void onComponentTag(Component component, ComponentTag tag)
	{
		tag.append(""class"", ""tree-node"", "" "");
	}","@Override
	public void onComponentTag(Component component, ComponentTag tag)
	{
		tag.append(""class"", ""tree-node"", "" "");
	}",0,[0]
23877,bugs-dot-jar_ACCUMULO-3077_17654199,"static void setZooReaderWriter(IZooReaderWriter izoo) {
    zoo = izoo;
  }","static void setZooReaderWriter(IZooReaderWriter izoo) {
    zoo = izoo;
  }",0,[0]
14125,bugs-dot-jar_WICKET-4016_f1c9cef2,"public MarkupContainer removeAll()
	{
		if (children != null)
		{
			addStateChange();

			// Loop through child components
			int size = children_size();
			for (int i = 0; i < size; i++)
			{
				Object childObject = children_get(i, false);
				if (childObject instanceof Component)
				{
					// Get next child
					final Component child = (Component)childObject;

					// Do not call remove() because the state change would than be
					// recorded twice.
					child.internalOnRemove();
					child.detach();
					child.setParent(null);
				}
			}

			children = null;
		}

		return this;
	}","public MarkupContainer removeAll()
	{
		if (children != null)
		{
			addStateChange();

			// Loop through child components
			int size = children_size();
			for (int i = 0; i < size; i++)
			{
				Object childObject = children_get(i, false);
				if (childObject instanceof Component)
				{
					// Get next child
					final Component child = (Component)childObject;

					// Do not call remove() because the state change would than be
					// recorded twice.
					child.internalOnRemove();
					child.detach();
					child.setParent(null);
				}
			}

			children = null;
		}

		return this;
	}",0,[0]
119,bugs-dot-jar_OAK-1822_3e83a4c1,"@CheckForNull
    @Override
    public <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
            throws MicroKernelException {
        log(""createOrUpdate"", update);
        T doc = findAndModify(collection, update, true, false);
        log(""createOrUpdate returns "", doc);
        return doc;
    }","@CheckForNull
    @Override
    public <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
            throws MicroKernelException {
        log(""createOrUpdate"", update);
        T doc = findAndModify(collection, update, true, false);
        log(""createOrUpdate returns "", doc);
        return doc;
    }",0,[0]
2119,bugs-dot-jar_WICKET-2961_3d8c9d75,"public final void warn(final String message)
	{
		Session.get().getFeedbackMessages().warn(this, message);
		Session.get().dirty();
	}","public final void warn(final String message)
	{
		Session.get().getFeedbackMessages().warn(this, message);
		Session.get().dirty();
	}",0,[0]
40721,bugs-dot-jar_ACCUMULO-821_a450ac2f,"@Override
  public void setBatchSize(int size) {
    this.batchSize = size;
  }","@Override
  public void setBatchSize(int size) {
    this.batchSize = size;
  }",0,[0]
12347,bugs-dot-jar_MATH-691_118f0cc0,"public StorelessUnivariateStatistic getVarianceImpl() {
        return varianceImpl;
    }","public StorelessUnivariateStatistic getVarianceImpl() {
        return varianceImpl;
    }",0,[0]
39320,bugs-dot-jar_OAK-429_c02ecef8,"@Override
    public boolean hasValue(Object value) {
        return values.contains(value);
    }","@Override
    public boolean hasValue(Object value) {
        return values.contains(value);
    }",0,[0]
7111,bugs-dot-jar_LOG4J2-763_97203de8,"@Override
    public MapMessage newInstance(final Map<String, String> map) {
        return new StructuredDataMessage(this, map);
    }","@Override
    public MapMessage newInstance(final Map<String, String> map) {
        return new StructuredDataMessage(this, map);
    }",0,[0]
35618,bugs-dot-jar_WICKET-16_6c5083b4,"public final RequestParameters decode(final Request request)
	{
		final RequestParameters parameters = new RequestParameters();
		final String pathInfo = getRequestPath(request);
		parameters.setPath(pathInfo);
		parameters.setPageMapName(request.getParameter(PAGEMAP));
		addInterfaceParameters(request, parameters);
		addBookmarkablePageParameters(request, parameters);
		addResourceParameters(request, parameters);
		parameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));
		if (request.getParameter(IGNORE_IF_NOT_ACTIVE_PARAMETER_NAME) != null)
		{
			parameters.setOnlyProcessIfPathActive(true);
		}

		Map map = request.getParameterMap();
		Iterator iterator = map.keySet().iterator();
		while (iterator.hasNext())
		{
			String key = (String)iterator.next();
			if (key.startsWith(NAME_SPACE))
			{
				iterator.remove();
			}
		}
		parameters.setParameters(map);
		return parameters;
	}","public final RequestParameters decode(final Request request)
	{
		final RequestParameters parameters = new RequestParameters();
		final String pathInfo = getRequestPath(request);
		parameters.setPath(pathInfo);
		parameters.setPageMapName(request.getParameter(PAGEMAP));
		addInterfaceParameters(request, parameters);
		addBookmarkablePageParameters(request, parameters);
		addResourceParameters(request, parameters);
		parameters.setBehaviorId(request.getParameter(BEHAVIOR_ID_PARAMETER_NAME));
		if (request.getParameter(IGNORE_IF_NOT_ACTIVE_PARAMETER_NAME) != null)
		{
			parameters.setOnlyProcessIfPathActive(true);
		}

		Map map = request.getParameterMap();
		Iterator iterator = map.keySet().iterator();
		while (iterator.hasNext())
		{
			String key = (String)iterator.next();
			if (key.startsWith(NAME_SPACE))
			{
				iterator.remove();
			}
		}
		parameters.setParameters(map);
		return parameters;
	}",0,[0]
13018,bugs-dot-jar_OAK-1235_1beb2a50,"public void copy() throws RepositoryException {
        logger.info(
                ""Copying repository content from {} to Oak"",
                source.getRepositoryConfig().getHomeDir());
        try {
            NodeBuilder builder = target.getRoot().builder();

            Map<Integer, String> idxToPrefix = copyNamespaces(builder);
            copyNodeTypes(builder);
            copyVersionStore(builder, idxToPrefix);
            copyWorkspaces(builder, idxToPrefix);

            // TODO: default hooks?
            CommitHook hook = new CompositeHook(
                    new EditorHook(new RegistrationEditorProvider()),
                    new EditorHook(new ReferenceEditorProvider()),
                    new EditorHook(new GroupEditorProvider())
            );
            target.merge(builder, hook, null);
        } catch (Exception e) {
            throw new RepositoryException(""Failed to copy content"", e);
        }
    }","public void copy() throws RepositoryException {
        logger.info(
                ""Copying repository content from {} to Oak"",
                source.getRepositoryConfig().getHomeDir());
        try {
            NodeBuilder builder = target.getRoot().builder();

            // init target repository first
            new InitialContent().initialize(builder);

            Map<Integer, String> idxToPrefix = copyNamespaces(builder);
            copyNodeTypes(builder);
            copyVersionStore(builder, idxToPrefix);
            copyWorkspaces(builder, idxToPrefix);

            // TODO: default hooks?
            CommitHook hook = new CompositeHook(
                    new EditorHook(new RegistrationEditorProvider()),
                    new EditorHook(new ReferenceEditorProvider()),
                    new EditorHook(new GroupEditorProvider())
            );
            target.merge(builder, hook, null);
        } catch (Exception e) {
            throw new RepositoryException(""Failed to copy content"", e);
        }
    }",1,[]
39885,bugs-dot-jar_WICKET-2621_c849f986,"private void dispatchEvent(final Page page, final String url)
	{
		RequestCycle rc = RequestCycle.get();
		IRequestCycleProcessor processor = rc.getProcessor();
		final ObsoleteRequestParameters requestParameters = processor.getRequestCodingStrategy()
			.decode(new FormDispatchRequest(rc.getRequest(), Url.parse(url)));
		IRequestTarget rt = processor.resolve(rc, requestParameters);
		if (rt instanceof IListenerInterfaceRequestTarget)
		{
			IListenerInterfaceRequestTarget interfaceTarget = ((IListenerInterfaceRequestTarget)rt);
			interfaceTarget.getRequestListenerInterface().invoke(page, interfaceTarget.getTarget());
		}
		else
		{
			throw new WicketRuntimeException(
				""Attempt to access unknown request listener interface "" +
					requestParameters.getInterfaceName());
		}
	}","private void dispatchEvent(final Page page, final String url)
	{
		RequestCycle rc = RequestCycle.get();
		IRequestCycleProcessor processor = rc.getProcessor();
		final ObsoleteRequestParameters requestParameters = processor.getRequestCodingStrategy()
			.decode(new FormDispatchRequest(rc.getRequest(), Url.parse(url)));
		IRequestTarget rt = processor.resolve(rc, requestParameters);
		if (rt instanceof IListenerInterfaceRequestTarget)
		{
			IListenerInterfaceRequestTarget interfaceTarget = ((IListenerInterfaceRequestTarget)rt);
			interfaceTarget.getRequestListenerInterface().invoke(page, interfaceTarget.getTarget());
		}
		else
		{
			throw new WicketRuntimeException(
				""Attempt to access unknown request listener interface "" +
					requestParameters.getInterfaceName());
		}
	}",0,[0]
7998,bugs-dot-jar_ACCUMULO-3242_15e83709,"@Deprecated
  public static synchronized ZooCache getInstance(String zooKeepers, int sessionTimeout) {
    return zcf.getZooCache(zooKeepers, sessionTimeout);
  }","@Deprecated
  public static synchronized ZooCache getInstance(String zooKeepers, int sessionTimeout) {
    return zcf.getZooCache(zooKeepers, sessionTimeout);
  }",0,[0]
19917,bugs-dot-jar_FLINK-3052_8dc70f2e,"public void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerNode terminationCriterion) {
		
		// check if the root of the step function has the same parallelism as the iteration
		// or if the step function has any operator at all
		if (nextPartialSolution.getParallelism() != getParallelism() ||
			nextPartialSolution == partialSolution || nextPartialSolution instanceof BinaryUnionNode)
		{
			// add a no-op to the root to express the re-partitioning
			NoOpNode noop = new NoOpNode();
			noop.setParallelism(getParallelism());

			DagConnection noOpConn = new DagConnection(nextPartialSolution, noop, ExecutionMode.PIPELINED);
			noop.setIncomingConnection(noOpConn);
			nextPartialSolution.addOutgoingConnection(noOpConn);
			
			nextPartialSolution = noop;
		}
		
		this.nextPartialSolution = nextPartialSolution;
		this.terminationCriterion = terminationCriterion;
		
		if (terminationCriterion == null) {
			this.singleRoot = nextPartialSolution;
			this.rootConnection = new DagConnection(nextPartialSolution, ExecutionMode.PIPELINED);
		}
		else {
			// we have a termination criterion
			SingleRootJoiner singleRootJoiner = new SingleRootJoiner();
			this.rootConnection = new DagConnection(nextPartialSolution, singleRootJoiner, ExecutionMode.PIPELINED);
			this.terminationCriterionRootConnection = new DagConnection(terminationCriterion, singleRootJoiner,
																		ExecutionMode.PIPELINED);

			singleRootJoiner.setInputs(this.rootConnection, this.terminationCriterionRootConnection);
			
			this.singleRoot = singleRootJoiner;
			
			// add connection to terminationCriterion for interesting properties visitor
			terminationCriterion.addOutgoingConnection(terminationCriterionRootConnection);
		
		}
		
		nextPartialSolution.addOutgoingConnection(rootConnection);
	}","public void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerNode terminationCriterion) {
		
		// check if the root of the step function has the same parallelism as the iteration
		// or if the step function has any operator at all
		if (nextPartialSolution.getParallelism() != getParallelism() ||
			nextPartialSolution == partialSolution || nextPartialSolution instanceof BinaryUnionNode)
		{
			// add a no-op to the root to express the re-partitioning
			NoOpNode noop = new NoOpNode();
			noop.setParallelism(getParallelism());

			DagConnection noOpConn = new DagConnection(nextPartialSolution, noop, ExecutionMode.PIPELINED);
			noop.setIncomingConnection(noOpConn);
			nextPartialSolution.addOutgoingConnection(noOpConn);
			
			nextPartialSolution = noop;
		}
		
		this.nextPartialSolution = nextPartialSolution;
		this.terminationCriterion = terminationCriterion;
		
		if (terminationCriterion == null) {
			this.singleRoot = nextPartialSolution;
			this.rootConnection = new DagConnection(nextPartialSolution, ExecutionMode.PIPELINED);
		}
		else {
			// we have a termination criterion
			SingleRootJoiner singleRootJoiner = new SingleRootJoiner();
			this.rootConnection = new DagConnection(nextPartialSolution, singleRootJoiner, ExecutionMode.PIPELINED);
			this.terminationCriterionRootConnection = new DagConnection(terminationCriterion, singleRootJoiner,
																		ExecutionMode.PIPELINED);

			singleRootJoiner.setInputs(this.rootConnection, this.terminationCriterionRootConnection);
			
			this.singleRoot = singleRootJoiner;
			
			// add connection to terminationCriterion for interesting properties visitor
			terminationCriterion.addOutgoingConnection(terminationCriterionRootConnection);
		
		}
		
		nextPartialSolution.addOutgoingConnection(rootConnection);
	}",0,[0]
792,Bears-101,"private Object decodeVer(Channel channel, SocketAddress remoteAddress, String sentence) {
        Parser parser = new Parser(PATTERN_VER, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());
        position.setDeviceId(deviceSession.getDeviceId());

        position.set(""deviceType"", parser.next());
        position.set(""firmwareVersion"", parser.nextInt(16));
        position.set(""hardwareVersion"", parser.nextInt(16));

        DateBuilder dateBuilder = new DateBuilder()
                .setDate(parser.nextInt(), parser.nextInt(), parser.nextInt())
                .setTime(parser.nextInt(), parser.nextInt(), parser.nextInt());

        getLastLocation(position, dateBuilder.getDate());

        return position;
    }","private Object decodeVer(Channel channel, SocketAddress remoteAddress, String sentence) {
        Parser parser = new Parser(PATTERN_VER, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());
        position.setDeviceId(deviceSession.getDeviceId());

        position.set(""deviceType"", parser.next());
        position.set(""firmwareVersion"", parser.nextInt(16));
        position.set(""hardwareVersion"", parser.nextInt(16));

        DateBuilder dateBuilder = new DateBuilder()
                .setDate(parser.nextInt(), parser.nextInt(), parser.nextInt())
                .setTime(parser.nextInt(), parser.nextInt(), parser.nextInt());

        getLastLocation(position, dateBuilder.getDate());

        return position;
    }",0,[0]
2296,bugs-dot-jar_MNG-4918_691a03a7,"public List<RemoteRepository> getRemotePluginRepositories()
    {
        return remotePluginRepositories;
    }","public List<RemoteRepository> getRemotePluginRepositories()
    {
        return remotePluginRepositories;
    }",0,[0]
81,Bears-5,"@Override
    public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {
        return new BeanDeserializer(this, ignorableProps);
    }","@Override
    public BeanDeserializer withIgnorableProperties(HashSet<String> ignorableProps) {
        return new BeanDeserializer(this, ignorableProps);
    }",0,[0]
22936,bugs-dot-jar_CAMEL-3428_320545cd,"public Endpoint hasEndpoint(String uri) {
        // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
        try {
            uri = URISupport.normalizeUri(uri);
        } catch (Exception e) {
            throw new ResolveEndpointFailedException(uri, e);
        }
        synchronized (endpoints) {
            return endpoints.get(uri);
        }
    }","public Endpoint hasEndpoint(String uri) {
        // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
        try {
            uri = URISupport.normalizeUri(uri);
        } catch (Exception e) {
            throw new ResolveEndpointFailedException(uri, e);
        }
        synchronized (endpoints) {
            return endpoints.get(uri);
        }
    }",0,[0]
2507,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static <T> Expression faultBodyExpression(final Class<T> type) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return exchange.getOut().isFault() ? exchange.getOut().getBody(type) : null;
            }

            @Override
            public String toString() {
                return ""faultBodyAs["" + type.getName() + ""]"";
            }
        };
    }","public static <T> Expression faultBodyExpression(final Class<T> type) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return exchange.getOut().isFault() ? exchange.getOut().getBody(type) : null;
            }

            @Override
            public String toString() {
                return ""faultBodyAs["" + type.getName() + ""]"";
            }
        };
    }",0,[0]
13740,bugs-dot-jar_MATH-318_83f18d52,"private void computeGershgorinCircles() {

        final int m     = main.length;
        final int lowerStart = 4 * m;
        final int upperStart = 5 * m;
        lowerSpectra = Double.POSITIVE_INFINITY;
        upperSpectra = Double.NEGATIVE_INFINITY;
        double eMax = 0;

        double eCurrent = 0;
        for (int i = 0; i < m - 1; ++i) {

            final double dCurrent = main[i];
            final double ePrevious = eCurrent;
            eCurrent = Math.abs(secondary[i]);
            eMax = Math.max(eMax, eCurrent);
            final double radius = ePrevious + eCurrent;

            final double lower = dCurrent - radius;
            work[lowerStart + i] = lower;
            lowerSpectra = Math.min(lowerSpectra, lower);

            final double upper = dCurrent + radius;
            work[upperStart + i] = upper;
            upperSpectra = Math.max(upperSpectra, upper);

        }

        final double dCurrent = main[m - 1];
        final double lower = dCurrent - eCurrent;
        work[lowerStart + m - 1] = lower;
        lowerSpectra = Math.min(lowerSpectra, lower);
        final double upper = dCurrent + eCurrent;
        work[upperStart + m - 1] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);

    }","private void computeGershgorinCircles() {

        final int m     = main.length;
        final int lowerStart = 4 * m;
        final int upperStart = 5 * m;
        lowerSpectra = Double.POSITIVE_INFINITY;
        upperSpectra = Double.NEGATIVE_INFINITY;
        double eMax = 0;

        double eCurrent = 0;
        for (int i = 0; i < m - 1; ++i) {

            final double dCurrent = main[i];
            final double ePrevious = eCurrent;
            eCurrent = Math.abs(secondary[i]);
            eMax = Math.max(eMax, eCurrent);
            final double radius = ePrevious + eCurrent;

            final double lower = dCurrent - radius;
            work[lowerStart + i] = lower;
            lowerSpectra = Math.min(lowerSpectra, lower);

            final double upper = dCurrent + radius;
            work[upperStart + i] = upper;
            upperSpectra = Math.max(upperSpectra, upper);

        }

        final double dCurrent = main[m - 1];
        final double lower = dCurrent - eCurrent;
        work[lowerStart + m - 1] = lower;
        lowerSpectra = Math.min(lowerSpectra, lower);
        final double upper = dCurrent + eCurrent;
        work[upperStart + m - 1] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);

    }",0,[0]
39546,bugs-dot-jar_OAK-278_db19e70f,"@Override
    public void purged() {
        nodeBuilder = null;
    }","@Override
    public void purged() {
        nodeBuilder = null;
    }",0,[0]
23445,bugs-dot-jar_LOG4J2-127_029e79da,"public <T extends Throwable> T throwing(T t) {
        if (isEnabled(Level.ERROR, THROWING_MARKER, (Object) null, null)) {
            log(THROWING_MARKER, FQCN, Level.ERROR, new SimpleMessage(THROWING), t);
        }
        return t;
    }","public <T extends Throwable> T throwing(T t) {
        if (isEnabled(Level.ERROR, THROWING_MARKER, (Object) null, null)) {
            log(THROWING_MARKER, FQCN, Level.ERROR, new SimpleMessage(THROWING), t);
        }
        return t;
    }",0,[0]
1958,Bears-235,"public AccountManager(AccountRepository accountRepository){
        this.accountRepository = accountRepository;
    }","public AccountManager(AccountRepository accountRepository){
        this.accountRepository = accountRepository;
    }",0,[0]
24027,bugs-dot-jar_OAK-579_7d72e6ed,"@Override
    public boolean evaluate() {
        PropertyValue p1 = selector1.currentProperty(property1Name);
        if (p1 == null) {
            return false;
        }
        PropertyValue p2 = selector2.currentProperty(property2Name);
        if (p2 == null) {
            return false;
        }
        if (!p1.isArray() && !p2.isArray()) {
            // both are single valued
            return PropertyValues.match(p1, p2);
        }
        // TODO what is the expected result of an equi join for multi-valued properties?
        if (!p1.isArray() && p2.isArray()) {
            if (p1.getType().tag() != p2.getType().tag()) {
                p1 = PropertyValues.convert(p1, p2.getType().tag(), query.getNamePathMapper());
            }
            if (p1 != null && PropertyValues.match(p1, p2)) {
                return true;
            }
            return false;
        } else if (p1.isArray() && !p2.isArray()) {
            if (p1.getType().tag() != p2.getType().tag()) {
                p2 = PropertyValues.convert(p2, p1.getType().tag(), query.getNamePathMapper());
            }
            if (p2 != null && PropertyValues.match(p1, p2)) {
                return true;
            }
            return false;
        }
        return PropertyValues.match(p1, p2);
    }","@Override
    public boolean evaluate() {
        PropertyValue p1 = selector1.currentProperty(property1Name);
        if (p1 == null) {
            return false;
        }
        PropertyValue p2 = selector2.currentProperty(property2Name);
        if (p2 == null) {
            return false;
        }
        if (!p1.isArray() && !p2.isArray()) {
            // both are single valued
            return PropertyValues.match(p1, p2);
        }
        // TODO what is the expected result of an equi join for multi-valued properties?
        if (!p1.isArray() && p2.isArray()) {
            if (p1.getType().tag() != p2.getType().tag()) {
                p1 = PropertyValues.convert(p1, p2.getType().tag(), query.getNamePathMapper());
            }
            if (p1 != null && PropertyValues.match(p1, p2)) {
                return true;
            }
            return false;
        } else if (p1.isArray() && !p2.isArray()) {
            if (p1.getType().tag() != p2.getType().tag()) {
                p2 = PropertyValues.convert(p2, p1.getType().tag(), query.getNamePathMapper());
            }
            if (p2 != null && PropertyValues.match(p1, p2)) {
                return true;
            }
            return false;
        }
        return PropertyValues.match(p1, p2);
    }",0,[0]
678,Bears-21,protected abstract long _timestamp(T value);,protected abstract long _timestamp(T value);,0,[0]
16430,bugs-dot-jar_CAMEL-7163_5f726d0b,"public void resumeAll() {
        logger.log(""Resume all"");
        // stop single stepping
        singleStepExchangeId = null;

        for (String node : getSuspendedBreakpointNodeIds()) {
            // remember to remove the dumped message as its no longer in need
            suspendedBreakpointMessages.remove(node);
            SuspendedExchange se = suspendedBreakpoints.remove(node);
            if (se != null) {
                se.getLatch().countDown();
            }
        }
    }","public void resumeAll() {
        logger.log(""Resume all"");
        // stop single stepping
        singleStepExchangeId = null;

        for (String node : getSuspendedBreakpointNodeIds()) {
            // remember to remove the dumped message as its no longer in need
            suspendedBreakpointMessages.remove(node);
            SuspendedExchange se = suspendedBreakpoints.remove(node);
            if (se != null) {
                se.getLatch().countDown();
            }
        }
    }",0,[0]
25424,bugs-dot-jar_WICKET-5720_2fc6a395,"public static String[] split(final String s, final char c)
	{
		if (s == null || s.length() == 0)
		{
			return NO_STRINGS;
		}
		final List<String> strings = new ArrayList<>();
		int pos = 0;
		while (true)
		{
			int next = s.indexOf(c, pos);
			if (next == -1)
			{
				strings.add(s.substring(pos));
				break;
			}
			else
			{
				strings.add(s.substring(pos, next));
			}
			pos = next + 1;
		}
		final String[] result = new String[strings.size()];
		strings.toArray(result);
		return result;
	}","public static String[] split(final String s, final char c)
	{
		if (s == null || s.length() == 0)
		{
			return NO_STRINGS;
		}
		final List<String> strings = new ArrayList<>();
		int pos = 0;
		while (true)
		{
			int next = s.indexOf(c, pos);
			if (next == -1)
			{
				strings.add(s.substring(pos));
				break;
			}
			else
			{
				strings.add(s.substring(pos, next));
			}
			pos = next + 1;
		}
		final String[] result = new String[strings.size()];
		strings.toArray(result);
		return result;
	}",0,[0]
1060,bugs-dot-jar_OAK-2528_239de7b8,"private boolean considerSplit() {
        SortedMap<Revision, Range> previous = doc.getPreviousRanges();
        // only consider if there are enough commits,
        // unless document is really big
        return doc.getLocalRevisions().size() + doc.getLocalCommitRoot().size() > NUM_REVS_THRESHOLD
                || doc.getMemory() >= DOC_SIZE_THRESHOLD
                || previous.size() >= PREV_SPLIT_FACTOR
                || !doc.getStalePrev().isEmpty();
    }","private boolean considerSplit() {
        SortedMap<Revision, Range> previous = doc.getPreviousRanges();
        // only consider if there are enough commits,
        // unless document is really big
        return doc.getLocalRevisions().size() + doc.getLocalCommitRoot().size() > NUM_REVS_THRESHOLD
                || doc.getMemory() >= DOC_SIZE_THRESHOLD
                || previous.size() >= PREV_SPLIT_FACTOR
                || !doc.getStalePrev().isEmpty();
    }",0,[0]
30324,bugs-dot-jar_MATH-679_5e638976,"@Override
    public void addToEntry(int row, int column, double increment) {
        MatrixUtils.checkRowIndex(this, row);
        MatrixUtils.checkColumnIndex(this, column);
        final int key = computeKey(row, column);
        final double value = entries.get(key) + increment;
        if (value == 0.0) {
            entries.remove(key);
        } else {
            entries.put(key, value);
        }
    }","@Override
    public void addToEntry(int row, int column, double increment) {
        MatrixUtils.checkRowIndex(this, row);
        MatrixUtils.checkColumnIndex(this, column);
        final int key = computeKey(row, column);
        final double value = entries.get(key) + increment;
        if (value == 0.0) {
            entries.remove(key);
        } else {
            entries.put(key, value);
        }
    }",0,[0]
25684,bugs-dot-jar_WICKET-5484_ecdfc124,"protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl,
		Url targetUrl)
	{
		return neverRedirect(getRedirectPolicy())
			|| (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl
				.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),
				isPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender())
			|| shouldPreserveClientUrl(cycle);
	}","protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl,
		Url targetUrl)
	{
		// WICKET-5484 never render and write for Ajax requests
		if (isAjax(cycle))
		{
			return false;
		}

		return neverRedirect(getRedirectPolicy())
			|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl
				.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),
				isPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())
			|| shouldPreserveClientUrl(cycle);
	}",1,"[4, 6]"
1524,Bears-180,"@Override
	public Resource createRelative(String relativePath) throws IOException {
		int lastSlashIndex = this.location.lastIndexOf(""/"");
		String absolutePath = this.location.substring(0, lastSlashIndex + 1) + relativePath;
		return new GoogleStorageResourceObject(this.storage, absolutePath, this.createBlobIfNotExists);
	}","@Override
	public Resource createRelative(String relativePath) throws IOException {
		int lastSlashIndex = this.location.lastIndexOf(""/"");
		String absolutePath = this.location.substring(0, lastSlashIndex + 1) + relativePath;
		return new GoogleStorageResourceObject(this.storage, absolutePath, this.createBlobIfNotExists);
	}",0,[0]
80,Bears-5,"@Override
    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {
        return new BeanDeserializer(this, oir);
    }","@Override
    public BeanDeserializer withObjectIdReader(ObjectIdReader oir) {
        return new BeanDeserializer(this, oir);
    }",0,[0]
30553,bugs-dot-jar_CAMEL-7795_19b2aa31,"@Override
    public void beginTransactedBy(Object key) {
        MDC.put(MDC_TRANSACTION_KEY, key.toString());
        super.beginTransactedBy(key);
    }","@Override
    public void beginTransactedBy(Object key) {
        MDC.put(MDC_TRANSACTION_KEY, key.toString());
        super.beginTransactedBy(key);
    }",0,[0]
22769,bugs-dot-jar_MATH-778_5b9302d5,"public static Dfp copysign(final Dfp x, final Dfp y) {
        Dfp result = x.newInstance(x);
        result.sign = y.sign;
        return result;
    }","public static Dfp copysign(final Dfp x, final Dfp y) {
        Dfp result = x.newInstance(x);
        result.sign = y.sign;
        return result;
    }",0,[0]
482,Bears-16,"public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen)
        throws IOException
    {
        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {
            gen.writeNumber(timestamp);
        } else {
            gen.writeString(_dateFormat().format(new Date(timestamp)));
        }
    }","public final void defaultSerializeDateValue(long timestamp, JsonGenerator gen)
        throws IOException
    {
        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {
            gen.writeNumber(timestamp);
        } else {
            gen.writeString(_dateFormat().format(new Date(timestamp)));
        }
    }",0,[0]
28689,bugs-dot-jar_FLINK-2734_8b40bb7a,"public DataStreamSource<Long> generateSequence(long from, long to) {
		if (from > to) {
			throw new IllegalArgumentException(""Start of sequence must not be greater than the end"");
		}
		return addSource(new StatefulSequenceSource(from, to), ""Sequence Source"");
	}","public DataStreamSource<Long> generateSequence(long from, long to) {
		if (from > to) {
			throw new IllegalArgumentException(""Start of sequence must not be greater than the end"");
		}
		return addSource(new StatefulSequenceSource(from, to), ""Sequence Source"");
	}",0,[0]
4283,bugs-dot-jar_CAMEL-4682_1e54865c,"public void setStreamCaching(Boolean cache) {
        this.streamCache = cache;
    }","public void setStreamCaching(Boolean cache) {
        this.streamCache = cache;
    }",0,[0]
1133,bugs-dot-jar_WICKET-5546_f1af9e03,"@Override
	public final MarkupContainer getParent()
	{
		return parent;
	}","@Override
	public final MarkupContainer getParent()
	{
		return parent;
	}",0,[0]
22736,bugs-dot-jar_MATH-778_5b9302d5,"public boolean isNaN() {
        return (nans == QNAN) || (nans == SNAN);
    }","public boolean isNaN() {
        return (nans == QNAN) || (nans == SNAN);
    }",0,[0]
9594,bugs-dot-jar_WICKET-2281_6e0b40bc,"public int getServerPort()
	{
		return 80;
	}","public int getServerPort()
	{
		return 80;
	}",0,[0]
7095,bugs-dot-jar_LOG4J2-763_97203de8,"public StructuredDataId getId() {
        return id;
    }","public StructuredDataId getId() {
        return id;
    }",0,[0]
39395,bugs-dot-jar_ACCUMULO-4138_eb0f9b41,"public static Option startRowOpt() {
    final Option o = new Option(START_ROW_OPT, ""begin-row"", true, ""begin row (inclusive)"");
    o.setArgName(""begin-row"");
    return o;
  }","public static Option startRowOpt() {
    final Option o = new Option(START_ROW_OPT, ""begin-row"", true, ""begin row (exclusive)"");
    o.setArgName(""begin-row"");
    return o;
  }",1,[1]
9457,bugs-dot-jar_FLINK-2802_88a97768,"@Override
	protected void run() throws Exception {
		
		final String iterationId = configuration.getIterationId();
		if (iterationId == null || iterationId.length() == 0) {
			throw new Exception(""Missing iteration ID in the task configuration"");
		}
		
		final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId ,
				getEnvironment().getIndexInSubtaskGroup());
		
		final long iterationWaitTime = configuration.getIterationWaitTime();
		final boolean shouldWait = iterationWaitTime > 0;

		final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);

		// offer the queue for the tail
		BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);
		LOG.info(""Iteration head {} added feedback queue under {}"", getName(), brokerID);

		// do the work 
		try {
			@SuppressWarnings(""unchecked"")
			Collection<RecordWriterOutput<OUT>> outputs = 
					(Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();

			while (running) {
				StreamRecord<OUT> nextRecord = shouldWait ?
					dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) :
					dataChannel.take();

				if (nextRecord != null) {
					for (RecordWriterOutput<OUT> output : outputs) {
						output.collect(nextRecord);
					}
				}
				else {
					// done
					break;
				}
			}
		}
		finally {
			// make sure that we remove the queue from the broker, to prevent a resource leak
			BlockingQueueBroker.INSTANCE.remove(brokerID);
			LOG.info(""Iteration head {} removed feedback queue under {}"", getName(), brokerID);
		}
	}","@Override
	protected void run() throws Exception {
		
		final String iterationId = configuration.getIterationId();
		if (iterationId == null || iterationId.length() == 0) {
			throw new Exception(""Missing iteration ID in the task configuration"");
		}
		
		final String brokerID = createBrokerIdString(getEnvironment().getJobID(), iterationId ,
				getEnvironment().getIndexInSubtaskGroup());
		
		final long iterationWaitTime = configuration.getIterationWaitTime();
		final boolean shouldWait = iterationWaitTime > 0;

		final BlockingQueue<StreamRecord<OUT>> dataChannel = new ArrayBlockingQueue<StreamRecord<OUT>>(1);

		// offer the queue for the tail
		BlockingQueueBroker.INSTANCE.handIn(brokerID, dataChannel);
		LOG.info(""Iteration head {} added feedback queue under {}"", getName(), brokerID);

		// do the work 
		try {
			@SuppressWarnings(""unchecked"")
			Collection<RecordWriterOutput<OUT>> outputs = 
					(Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();

			// If timestamps are enabled we make sure to remove cyclic watermark dependencies
			if (getExecutionConfig().areTimestampsEnabled()) {
				for (RecordWriterOutput<OUT> output : outputs) {
					output.emitWatermark(new Watermark(Long.MAX_VALUE));
				}
			}

			while (running) {
				StreamRecord<OUT> nextRecord = shouldWait ?
					dataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) :
					dataChannel.take();

				if (nextRecord != null) {
					for (RecordWriterOutput<OUT> output : outputs) {
						output.collect(nextRecord);
					}
				}
				else {
					// done
					break;
				}
			}
		}
		finally {
			// make sure that we remove the queue from the broker, to prevent a resource leak
			BlockingQueueBroker.INSTANCE.remove(brokerID);
			LOG.info(""Iteration head {} removed feedback queue under {}"", getName(), brokerID);
		}
	}",1,[]
17399,bugs-dot-jar_CAMEL-7018_3244c1e5,"@ManagedAttribute(description = ""Endpoint service state"")
    public String getState() {
        return getStatus().name();
    }","@ManagedAttribute(description = ""Endpoint service state"")
    public String getState() {
        return getStatus().name();
    }",0,[0]
6390,bugs-dot-jar_MATH-1096_19c1c3bb,"private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final int nbExtreme,
                                                final List<P> support) {

        // create a new ball on the prescribed support
        EnclosingBall<S, P> ball = generator.ballOnSupport(support);

        if (ball.getSupportSize() <= ball.getCenter().getSpace().getDimension()) {

            for (int i = 0; i < nbExtreme; ++i) {
                final P pi = extreme.get(i);
                if (!ball.contains(pi, tolerance)) {

                    // we have found an outside point,
                    // enlarge the ball by adding it to the support
                    support.add(pi);
                    ball = moveToFrontBall(extreme, i, support);
                    support.remove(support.size() - 1);

                    // it was an interesting point, move it to the front
                    // according to Welzl's heuristic
                    for (int j = i; j > 0; --j) {
                        extreme.set(j, extreme.get(j - 1));
                    }
                    extreme.set(0, pi);

                }
            }

        }

        return ball;

    }","private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final int nbExtreme,
                                                final List<P> support) {

        // create a new ball on the prescribed support
        EnclosingBall<S, P> ball = generator.ballOnSupport(support);

        if (ball.getSupportSize() <= ball.getCenter().getSpace().getDimension()) {

            for (int i = 0; i < nbExtreme; ++i) {
                final P pi = extreme.get(i);
                if (!ball.contains(pi, tolerance)) {

                    // we have found an outside point,
                    // enlarge the ball by adding it to the support
                    support.add(pi);
                    ball = moveToFrontBall(extreme, i, support);
                    support.remove(support.size() - 1);

                    // it was an interesting point, move it to the front
                    // according to Welzl's heuristic
                    for (int j = i; j > 0; --j) {
                        extreme.set(j, extreme.get(j - 1));
                    }
                    extreme.set(0, pi);

                }
            }

        }

        return ball;

    }",0,[0]
3649,bugs-dot-jar_WICKET-3253_71b6e905,"public Method getPropertySetter()
	{
		String expression = propertyExpression();
		if (Strings.isEmpty(expression) == false)
		{
			Object target = getTarget();
			if (target != null)
			{
				try
				{
					return PropertyResolver.getPropertySetter(expression, target);
				}
				catch (Exception ignore)
				{
				}
			}
		}
		return null;
	}","public Method getPropertySetter()
	{
		String expression = propertyExpression();
		if (Strings.isEmpty(expression) == false)
		{
			Object target = getTarget();
			if (target != null)
			{
				try
				{
					return PropertyResolver.getPropertySetter(expression, target);
				}
				catch (Exception ignore)
				{
				}
			}
		}
		return null;
	}",0,[0]
20802,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Converter
    public static Serializable genericFileToSerializable(GenericFile<?> file, Exchange exchange) throws IOException {
        if (exchange != null) {
            // ensure the body is loaded as we do not want a java.io.File handle returned, but the file content
            file.getBinding().loadContent(exchange, file);
            return exchange.getContext().getTypeConverter().convertTo(Serializable.class, exchange, file.getBody());
        } else {
            // should revert to fallback converter if we don't have an exchange
            return null;
        }
    }","@Converter
    public static Serializable genericFileToSerializable(GenericFile<?> file, Exchange exchange) throws IOException {
        if (exchange != null) {
            // ensure the body is loaded as we do not want a java.io.File handle returned, but the file content
            file.getBinding().loadContent(exchange, file);
            return exchange.getContext().getTypeConverter().convertTo(Serializable.class, exchange, file.getBody());
        } else {
            // should revert to fallback converter if we don't have an exchange
            return null;
        }
    }",0,[0]
11409,bugs-dot-jar_CAMEL-7344_91228815,"public Exchange createExchange() {
        return createExchange(getExchangePattern());
    }","public Exchange createExchange() {
        return createExchange(getExchangePattern());
    }",0,[0]
17079,bugs-dot-jar_MATH-949_f83bbc1d,"public ConvergenceChecker<PAIR> getConvergenceChecker() {
        return checker;
    }","public ConvergenceChecker<PAIR> getConvergenceChecker() {
        return checker;
    }",0,[0]
9708,bugs-dot-jar_OAK-614_6feacf6b,"@Override
    public boolean isNew() {
        return !isRoot() && parent.isNew(name);
    }","@Override
    public boolean isNew() {
        return !isRoot() && parent.isNew(name);
    }",0,[0]
34467,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"private void checkTabletDir(Path tabletDir) throws IOException {

    FileStatus[] files = null;
    try {
      files = fs.listStatus(tabletDir);
    } catch (FileNotFoundException ex) {
      // ignored
    }

    if (files == null) {
      if (tabletDir.getName().startsWith(""c-""))
        log.debug(""Tablet "" + extent + "" had no dir, creating "" + tabletDir); // its a clone dir...
      else
        log.warn(""Tablet "" + extent + "" had no dir, creating "" + tabletDir);

      fs.mkdirs(tabletDir);
    }
  }","private void checkTabletDir(Path tabletDir) throws IOException {

    FileStatus[] files = null;
    try {
      files = fs.listStatus(tabletDir);
    } catch (FileNotFoundException ex) {
      // ignored
    }

    if (files == null) {
      if (tabletDir.getName().startsWith(""c-""))
        log.debug(""Tablet "" + extent + "" had no dir, creating "" + tabletDir); // its a clone dir...
      else
        log.warn(""Tablet "" + extent + "" had no dir, creating "" + tabletDir);

      fs.mkdirs(tabletDir);
    }
  }",0,[0]
8481,bugs-dot-jar_ACCUMULO-366_db4a291f,"private void announceExistence() {
    IZooReaderWriter zoo = ZooReaderWriter.getInstance();
    try {
      String zPath = ZooUtil.getRoot(HdfsZooInstance.getInstance()) + Constants.ZTSERVERS + ""/"" + getClientAddressString();
      
      zoo.putPersistentData(zPath, new byte[] {}, NodeExistsPolicy.SKIP);
      
      tabletServerLock = new ZooLock(zPath);
      
      LockWatcher lw = new LockWatcher() {
        
        @Override
        public void lostLock(final LockLossReason reason) {
          Halt.halt(0, new Runnable() {
            public void run() {
              if (!serverStopRequested)
                log.fatal(""Lost tablet server lock (reason = "" + reason + ""), exiting."");
              logGCInfo();
            }
          });
        }
      };
      
      byte[] lockContent = new ServerServices(getClientAddressString(), Service.TSERV_CLIENT).toString().getBytes();
      for (int i = 0; i < 120 / 5; i++) {
        zoo.putPersistentData(zPath, new byte[0], NodeExistsPolicy.SKIP);
        
        if (tabletServerLock.tryLock(lw, lockContent)) {
          log.debug(""Obtained tablet server lock "" + tabletServerLock.getLockPath());
          return;
        }
        log.info(""Waiting for tablet server lock"");
        UtilWaitThread.sleep(5000);
      }
      String msg = ""Too many retries, exiting."";
      log.info(msg);
      throw new RuntimeException(msg);
    } catch (Exception e) {
      log.info(""Could not obtain tablet server lock, exiting."", e);
      throw new RuntimeException(e);
    }
  }","private void announceExistence() {
    IZooReaderWriter zoo = ZooReaderWriter.getInstance();
    try {
      String zPath = ZooUtil.getRoot(HdfsZooInstance.getInstance()) + Constants.ZTSERVERS + ""/"" + getClientAddressString();
      
      zoo.putPersistentData(zPath, new byte[] {}, NodeExistsPolicy.SKIP);
      
      tabletServerLock = new ZooLock(zPath);
      
      LockWatcher lw = new LockWatcher() {
        
        @Override
        public void lostLock(final LockLossReason reason) {
          Halt.halt(0, new Runnable() {
            public void run() {
              if (!serverStopRequested)
                log.fatal(""Lost tablet server lock (reason = "" + reason + ""), exiting."");
              logGCInfo();
            }
          });
        }
      };
      
      byte[] lockContent = new ServerServices(getClientAddressString(), Service.TSERV_CLIENT).toString().getBytes();
      for (int i = 0; i < 120 / 5; i++) {
        zoo.putPersistentData(zPath, new byte[0], NodeExistsPolicy.SKIP);
        
        if (tabletServerLock.tryLock(lw, lockContent)) {
          log.debug(""Obtained tablet server lock "" + tabletServerLock.getLockPath());
          return;
        }
        log.info(""Waiting for tablet server lock"");
        UtilWaitThread.sleep(5000);
      }
      String msg = ""Too many retries, exiting."";
      log.info(msg);
      throw new RuntimeException(msg);
    } catch (Exception e) {
      log.info(""Could not obtain tablet server lock, exiting."", e);
      throw new RuntimeException(e);
    }
  }",0,[0]
38939,bugs-dot-jar_OAK-1184_f72dd8d1,"public RecordId getEntry(int index) {
        checkElementIndex(index, size);

        if (size == 1) {
            return getRecordId();
        } else {
            int bucketIndex = index / bucketSize;
            int bucketOffset = index % bucketSize;
            Segment segment = getSegment();
            RecordId bucketId = segment.readRecordId(getOffset(0, bucketIndex));
            ListRecord bucket = new ListRecord(segment, bucketId, bucketSize);
            return bucket.getEntry(bucketOffset);
        }
    }","public RecordId getEntry(int index) {
        checkElementIndex(index, size);

        if (size == 1) {
            return getRecordId();
        } else {
            int bucketIndex = index / bucketSize;
            int bucketOffset = index % bucketSize;
            Segment segment = getSegment();
            RecordId bucketId = segment.readRecordId(getOffset(0, bucketIndex));
            ListRecord bucket = new ListRecord(segment, bucketId, bucketSize);
            return bucket.getEntry(bucketOffset);
        }
    }",0,[0]
4193,bugs-dot-jar_ACCUMULO-2659_019edb16,"public static void setLocalIterators(JobConf job, boolean enableFeature) {
    InputConfigurator.setLocalIterators(CLASS, job, enableFeature);
  }","public static void setLocalIterators(JobConf job, boolean enableFeature) {
    InputConfigurator.setLocalIterators(CLASS, job, enableFeature);
  }",0,[0]
448,bugs-dot-jar_WICKET-4927_8c827e33,"@Override
	public void write(byte[] array)
	{
		writeBuffered();
		originalResponse.write(array);
	}","@Override
	public void write(byte[] array)
	{
		stopBuffering();

		originalResponse.write(array);
	}",1,[3]
14,Bears-1,"@Deprecated // since 2.5
    public void addDoubleCreator(AnnotatedWithParams creator) {
        addBooleanCreator(creator, false);
    }","@Deprecated // since 2.5
    public void addDoubleCreator(AnnotatedWithParams creator) {
        addBooleanCreator(creator, false);
    }",0,[0]
33503,bugs-dot-jar_OAK-4066_9a109aa3,"private static TikaConfig getTikaConfig(InputStream configStream, Object source){
        try {
            return new TikaConfig(configStream);
        } catch (Exception e) {
            log.warn(""Tika configuration not available : ""+source, e);
        }
        return TikaConfig.getDefaultConfig();
    }","private static TikaConfig getTikaConfig(InputStream configStream, Object source){
        try {
            return new TikaConfig(configStream);
        } catch (Exception e) {
            log.warn(""Tika configuration not available : ""+source, e);
        }
        return TikaConfig.getDefaultConfig();
    }",0,[0]
4787,bugs-dot-jar_MATH-326_ce185345,"public RealMatrix outerProduct(double[] v)
        throws IllegalArgumentException {
        checkVectorDimensions(v.length);
        final int m = data.length;
        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data.length; j++) {
                out.setEntry(i, j, data[i] * v[j]);
            }
        }
        return out;
    }","public RealMatrix outerProduct(double[] v)
        throws IllegalArgumentException {
        checkVectorDimensions(v.length);
        final int m = data.length;
        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data.length; j++) {
                out.setEntry(i, j, data[i] * v[j]);
            }
        }
        return out;
    }",0,[0]
23369,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public boolean remove(final Object o) {
        if (!useStack) {
            return false;
        }
        final List<String> list = stack.get();
        if (list == null || list.size() == 0) {
            return false;
        }
        final List<String> copy = new ArrayList<String>(list);
        final boolean result = copy.remove(o);
        stack.set(Collections.unmodifiableList(copy));
        return result;
    }","@Override
    public boolean remove(final Object o) {
        if (!useStack) {
            return false;
        }
        final List<String> list = stack.get();
        if (list == null || list.size() == 0) {
            return false;
        }
        final List<String> copy = new ArrayList<String>(list);
        final boolean result = copy.remove(o);
        stack.set(Collections.unmodifiableList(copy));
        return result;
    }",0,[0]
2420,bugs-dot-jar_CAMEL-8137_53b4e90c,"public BeanInfo(CamelContext camelContext, Method explicitMethod) {
        this(camelContext, explicitMethod.getDeclaringClass(), explicitMethod, createParameterMappingStrategy(camelContext));
    }","public BeanInfo(CamelContext camelContext, Method explicitMethod) {
        this(camelContext, explicitMethod.getDeclaringClass(), explicitMethod, createParameterMappingStrategy(camelContext));
    }",0,[0]
4837,bugs-dot-jar_MATH-326_ce185345,"public int getDimension() {
        return virtualSize;
    }","public int getDimension() {
        return virtualSize;
    }",0,[0]
21595,bugs-dot-jar_MATH-1261_4c4b3e2e,"@Override
    public int compareTo(Fraction object) {
        long nOd = ((long) numerator) * object.denominator;
        long dOn = ((long) denominator) * object.numerator;
        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
    }","@Override
    public int compareTo(Fraction object) {
        long nOd = ((long) numerator) * object.denominator;
        long dOn = ((long) denominator) * object.numerator;
        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
    }",0,[0]
13785,bugs-dot-jar_CAMEL-6936_4954d573,"@Override
    protected void doStop() throws Exception {
        prepareOnStartup = false;
        super.doStop();
    }","@Override
    protected void doStop() throws Exception {
        prepareOnStartup = false;
        super.doStop();
    }",0,[0]
11070,bugs-dot-jar_MATH-1269_a94ff90a,"public static double nextDown(final double a) {
        return nextAfter(a, Double.NEGATIVE_INFINITY);
    }","public static double nextDown(final double a) {
        return nextAfter(a, Double.NEGATIVE_INFINITY);
    }",0,[0]
470,Bears-16,"public JsonSerializer<Object> getDefaultNullValueSerializer() {
        return _nullValueSerializer;
    }","public JsonSerializer<Object> getDefaultNullValueSerializer() {
        return _nullValueSerializer;
    }",0,[0]
9180,bugs-dot-jar_MATH-377_c640932d,"public void setMaxIterations(int maxIterations) {
        this.maxIterations = maxIterations;
    }","public void setMaxIterations(int maxIterations) {
        this.maxIterations = maxIterations;
    }",0,[0]
11511,bugs-dot-jar_ACCUMULO-1800_8ec4cb84,"private BatchWriterPlusException getWriter(String writer) throws UnknownWriter {
    UUID uuid = null;
    try {
      uuid = UUID.fromString(writer);
    } catch (IllegalArgumentException iae) {
      throw new UnknownWriter(iae.getMessage());
    }
    
    BatchWriterPlusException bwpe = writerCache.getIfPresent(uuid);
    if (bwpe == null) {
      throw new UnknownWriter(""Writer never existed or no longer exists"");
    }
    return bwpe;
  }","private BatchWriterPlusException getWriter(String writer) throws UnknownWriter {
    UUID uuid = null;
    try {
      uuid = UUID.fromString(writer);
    } catch (IllegalArgumentException iae) {
      throw new UnknownWriter(iae.getMessage());
    }
    
    BatchWriterPlusException bwpe = writerCache.getIfPresent(uuid);
    if (bwpe == null) {
      throw new UnknownWriter(""Writer never existed or no longer exists"");
    }
    return bwpe;
  }",0,[0]
38480,bugs-dot-jar_CAMEL-9124_9da2c05a,"public RedeliveryPolicyDefinition collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        return collisionAvoidanceFactor(Double.toString(collisionAvoidanceFactor));
    }","public RedeliveryPolicyDefinition collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        return collisionAvoidanceFactor(Double.toString(collisionAvoidanceFactor));
    }",0,[0]
19689,bugs-dot-jar_WICKET-4259_1f128536,"protected final Component getLabel()
	{
		if (label == null)
		{
			initLabelAndEditor(getDelegatingParentModel());
		}
		return label;
	}","protected final Component getLabel()
	{
		if (label == null)
		{
			initLabelAndEditor(new WrapperModel());
		}
		return label;
	}",1,[4]
34887,bugs-dot-jar_CAMEL-5570_a57830ed,"public OnExceptionDefinition backOffMultiplier(double backOffMultiplier) {
        getOrCreateRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }","public OnExceptionDefinition backOffMultiplier(double backOffMultiplier) {
        getOrCreateRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }",0,[0]
10671,bugs-dot-jar_MATH-1065_996c0c16,"public double getNumericalMean() {
        double mean = 0;

        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
            mean += sample.getValue() * sample.getKey();
        }

        return mean;
    }","public double getNumericalMean() {
        double mean = 0;

        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
            mean += sample.getValue() * sample.getKey();
        }

        return mean;
    }",0,[0]
2780,bugs-dot-jar_OAK-2174_5931a4a7,"@Nonnull
    public Oak with(@Nonnull EditorProvider provider) {
        editorProviders.add(checkNotNull(provider));
        return this;
    }","@Nonnull
    public Oak with(@Nonnull EditorProvider provider) {
        editorProviders.add(checkNotNull(provider));
        return this;
    }",0,[0]
32479,bugs-dot-jar_OAK-926_e1ae968c,"@Nonnull
    Map<String, String> getLocalCommitRoot() {
        return getLocalMap(COMMIT_ROOT);
    }","@Nonnull
    Map<String, String> getLocalCommitRoot() {
        return getLocalMap(COMMIT_ROOT);
    }",0,[0]
104,bugs-dot-jar_OAK-1822_3e83a4c1,"private static long start() {
        return LOG_TIME ? System.currentTimeMillis() : 0;
    }","private static long start() {
        return LOG_TIME ? System.currentTimeMillis() : 0;
    }",0,[0]
34300,bugs-dot-jar_WICKET-4184_a0150366,"@Override
	public String toString()
	{
		return new String(value, 0, count);
	}","@Override
	public String toString()
	{
		return new String(value, 0, count);
	}",0,[0]
4781,bugs-dot-jar_MATH-326_ce185345,"public void unitize() throws ArithmeticException {
        final double norm = getNorm();
        if (norm == 0) {
            throw MathRuntimeException.createArithmeticException(""cannot normalize a zero norm vector"");
        }
        mapDivideToSelf(norm);
    }","public void unitize() throws ArithmeticException {
        final double norm = getNorm();
        if (norm == 0) {
            throw MathRuntimeException.createArithmeticException(""cannot normalize a zero norm vector"");
        }
        mapDivideToSelf(norm);
    }",0,[0]
10052,bugs-dot-jar_MATH-1127_ba62c59d,"public static int compareTo(double x, double y, double eps) {
        if (equals(x, y, eps)) {
            return 0;
        } else if (x < y) {
            return -1;
        }
        return 1;
    }","public static int compareTo(double x, double y, double eps) {
        if (equals(x, y, eps)) {
            return 0;
        } else if (x < y) {
            return -1;
        }
        return 1;
    }",0,[0]
1987,Bears-241,"private boolean resourceWasNotExisting(String decodedOriginalContent) {

        return decodedOriginalContent == null;
    }","private boolean resourceWasNotExisting(String decodedOriginalContent) {

        return decodedOriginalContent == null;
    }",0,[0]
1658,Bears-194,"private void populateCache(Class<?> clz, String realType) {
 		if (this.cacheReturnTypes.containsKey(realType)) {
			return;
		}
		this.cacheReturnTypes.put(realType, realType);
		Class<?> clazz = clz;
		if (clazz == null) {
			clazz = TypeUtils.INSTANCE.getClassForName(realType);
		}
		if (clazz == null) {
			return;
		}
		
		boolean analizeAnnotations = analizeTypeWithReflectionForAnnotations(clazz); 
		for (Method method : Utils.getMethods(clazz)) {
			Class<?> returnType = method.getReturnType();
			String methodName = method.getName();
			String key = clazz.getCanonicalName() + ""."" + methodName;

			String returnTypeName = UNKNOWN_TYPE;
			if (returnType != null) {
				returnTypeName = returnType.getCanonicalName();
			}
			String old = this.cacheReturnTypes.get(key);
			if (old == null || StringUtils.equals(old, returnTypeName)) {
				this.cacheReturnTypes.put(key, returnTypeName);
			}
			// else {
			// // various return types for same method
			// cacheReturnTypes.put(key, UNKNOWN_TYPE);
			// }

			if (analizeAnnotations) {
				registerAnnotations(key, method.getAnnotations());
			}
		}
		for (Constructor<?> constructor: Utils.getConstructors(clazz)) {
			String methodName = clazz.getSimpleName();
			String key = clazz.getCanonicalName() + ""."" + methodName;
			String retunTypeName = clazz.getCanonicalName();
			this.cacheReturnTypes.put(key, retunTypeName);
			if (analizeAnnotations) {
				registerAnnotations(key, constructor.getAnnotations());
			}
		}
		
	}","private void populateCache(Class<?> clz, String realType) {
 		if (this.cacheReturnTypes.containsKey(realType)) {
			return;
		}
		this.cacheReturnTypes.put(realType, realType);
		Class<?> clazz = clz;
		if (clazz == null) {
			clazz = TypeUtils.INSTANCE.getClassForName(realType);
		}
		if (clazz == null) {
			return;
		}
		
		boolean analizeAnnotations = analizeTypeWithReflectionForAnnotations(clazz); 
		for (Method method : Utils.getMethods(clazz)) {
			Class<?> returnType = method.getReturnType();
			String methodName = method.getName();
			String key = clazz.getCanonicalName() + ""."" + methodName;

			String returnTypeName = UNKNOWN_TYPE;
			if (returnType != null) {
				returnTypeName = returnType.getCanonicalName();
			}
			String old = this.cacheReturnTypes.get(key);
			if (old == null || StringUtils.equals(old, returnTypeName)) {
				this.cacheReturnTypes.put(key, returnTypeName);
			}
			// else {
			// // various return types for same method
			// cacheReturnTypes.put(key, UNKNOWN_TYPE);
			// }

			if (analizeAnnotations) {
				registerAnnotations(key, method.getAnnotations());
			}
		}
		for (Constructor<?> constructor: Utils.getConstructors(clazz)) {
			String methodName = clazz.getSimpleName();
			String key = clazz.getCanonicalName() + ""."" + methodName;
			String retunTypeName = clazz.getCanonicalName();
			this.cacheReturnTypes.put(key, retunTypeName);
			if (analizeAnnotations) {
				registerAnnotations(key, constructor.getAnnotations());
			}
		}
		
	}",0,[0]
8018,bugs-dot-jar_WICKET-4338_9decad35,"public PageParameters decodePageParameters(final Request request)
	{
		PageParameters parameters = new PageParameters();

		int i = 0;
		for (String s : request.getUrl().getSegments())
		{
			parameters.set(i, s);
			++i;
		}

		for (QueryParameter p : request.getUrl().getQueryParameters())
		{
			parameters.add(p.getName(), p.getValue());
		}

		return parameters.isEmpty() ? null : parameters;
	}","public PageParameters decodePageParameters(final Request request)
	{
		PageParameters parameters = new PageParameters();

		int i = 0;
		for (String s : request.getUrl().getSegments())
		{
			parameters.set(i, s);
			++i;
		}
		
		IRequestParameters requestParameters = request.getRequestParameters();
		for (String paramName : requestParameters.getParameterNames())
		{
			List<StringValue> parameterValues = requestParameters.getParameterValues(paramName);
			for (StringValue paramValue : parameterValues)
			{
				parameters.add(paramName, paramValue);
			}
		}

		return parameters.isEmpty() ? null : parameters;
	}",1,"[11, 13]"
5952,bugs-dot-jar_OAK-3110_d10362c0,"@Override
    public String getCopyInProgressSize() {
        return humanReadableByteCount(copyInProgressSize.get());
    }","@Override
    public String getCopyInProgressSize() {
        return humanReadableByteCount(copyInProgressSize.get());
    }",0,[0]
2130,bugs-dot-jar_WICKET-2961_3d8c9d75,"@SuppressWarnings(""unchecked"")
	protected <M extends IBehavior> List<M> getBehaviors(Class<M> type)
	{
		List<IBehavior> behaviors = getBehaviorsRawList();
		if (behaviors == null)
		{
			return Collections.emptyList();
		}

		List<M> subset = new ArrayList<M>(behaviors.size()); // avoid growing
		for (IBehavior behavior : behaviors)
		{
			if (behavior != null)
			{
				if (type == null)
				{
					subset.add((M)behavior);
				}
				else if (type.isAssignableFrom(behavior.getClass()))
				{
					subset.add(type.cast(behavior));
				}
			}
		}
		return Collections.unmodifiableList(subset);
	}","@SuppressWarnings(""unchecked"")
	protected <M extends IBehavior> List<M> getBehaviors(Class<M> type)
	{
		List<IBehavior> behaviors = getBehaviorsRawList();
		if (behaviors == null)
		{
			return Collections.emptyList();
		}

		List<M> subset = new ArrayList<M>(behaviors.size()); // avoid growing
		for (IBehavior behavior : behaviors)
		{
			if (behavior != null)
			{
				if (type == null)
				{
					subset.add((M)behavior);
				}
				else if (type.isAssignableFrom(behavior.getClass()))
				{
					subset.add(type.cast(behavior));
				}
			}
		}
		return Collections.unmodifiableList(subset);
	}",0,[0]
4859,bugs-dot-jar_MATH-326_ce185345,"public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = copy();
        Iterator iter = v.getEntries().iterator();
        while (iter.hasNext()) {
            iter.advance();
            int key = iter.key();
            if (entries.containsKey(key)) {
                res.setEntry(key, entries.get(key) - iter.value());
            } else {
                res.setEntry(key, -iter.value());
            }
        }
        return res;
    }","public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = copy();
        Iterator iter = v.getEntries().iterator();
        while (iter.hasNext()) {
            iter.advance();
            int key = iter.key();
            if (entries.containsKey(key)) {
                res.setEntry(key, entries.get(key) - iter.value());
            } else {
                res.setEntry(key, -iter.value());
            }
        }
        return res;
    }",0,[0]
27849,bugs-dot-jar_CAMEL-8053_cac72b14,"public synchronized void removeRouteDefinition(RouteDefinition routeDefinition) throws Exception {
        String id = routeDefinition.getId();
        if (id != null) {
            // remove existing route
            stopRoute(id);
            removeRoute(id);
        }
        this.routeDefinitions.remove(routeDefinition);
    }","public synchronized void removeRouteDefinition(RouteDefinition routeDefinition) throws Exception {
        String id = routeDefinition.getId();
        if (id != null) {
            // remove existing route
            stopRoute(id);
            removeRoute(id);
        }
        this.routeDefinitions.remove(routeDefinition);
    }",0,[0]
23382,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public ThreadContextStack copy() {
        return new MutableThreadContextStack(this);
    }","@Override
    public ThreadContextStack copy() {
        return new MutableThreadContextStack(this);
    }",0,[0]
17886,bugs-dot-jar_OAK-1075_79467350,"@Nonnull
    public static PropertyValue newDate(String value) {
        return new PropertyStateValue(GenericPropertyState.dateProperty("""", value));
    }","@Nonnull
    public static PropertyValue newDate(String value) {
        return new PropertyStateValue(GenericPropertyState.dateProperty("""", value));
    }",0,[0]
14202,bugs-dot-jar_LOG4J2-392_731c84b5,"@SuppressWarnings(""unchecked"")
    protected void doConfigure() {
        if (rootNode.hasChildren() && rootNode.getChildren().get(0).getName().equalsIgnoreCase(""Properties"")) {
            Node first = rootNode.getChildren().get(0);
            createConfiguration(first, null);
            if (first.getObject() != null) {
                subst.setVariableResolver((StrLookup) first.getObject());
            }
        } else {
            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
            final StrLookup lookup = map == null ? null : new MapLookup(map);
            subst.setVariableResolver(new Interpolator(lookup));
        }

        boolean setLoggers = false;
        boolean setRoot = false;
        for (final Node child : rootNode.getChildren()) {
            if (child.getName().equalsIgnoreCase(""Properties"")) {
                if (tempLookup == subst.getVariableResolver()) {
                    LOGGER.error(""Properties declaration must be the first element in the configuration"");
                }
                continue;
            }
            createConfiguration(child, null);
            if (child.getObject() == null) {
                continue;
            }
            if (child.getName().equalsIgnoreCase(""Appenders"")) {
                appenders = (ConcurrentMap<String, Appender>) child.getObject();
            } else if (child.getObject() instanceof Filter) {
                addFilter((Filter) child.getObject());
            } else if (child.getName().equalsIgnoreCase(""Loggers"")) {
                final Loggers l = (Loggers) child.getObject();
                loggers = l.getMap();
                setLoggers = true;
                if (l.getRoot() != null) {
                    root = l.getRoot();
                    setRoot = true;
                }
            } else {
                LOGGER.error(""Unknown object \""{}\"" of type {} is ignored."", child.getName(),
                        child.getObject().getClass().getName());
            }
        }

        if (!setLoggers) {
            LOGGER.warn(""No Loggers were configured, using default. Is the Loggers element missing?"");
            setToDefault();
            return;
        } else if (!setRoot) {
            LOGGER.warn(""No Root logger was configured, creating default ERROR-level Root logger with Console appender"");
            setToDefault();
            // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers
        }

        for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {
            final LoggerConfig l = entry.getValue();
            for (final AppenderRef ref : l.getAppenderRefs()) {
                final Appender app = appenders.get(ref.getRef());
                if (app != null) {
                    l.addAppender(app, ref.getLevel(), ref.getFilter());
                } else {
                    LOGGER.error(""Unable to locate appender {} for logger {}"", ref.getRef(), l.getName());
                }
            }

        }

        setParents();
    }","@SuppressWarnings(""unchecked"")
    protected void doConfigure() {
        if (rootNode.hasChildren() && rootNode.getChildren().get(0).getName().equalsIgnoreCase(""Properties"")) {
            Node first = rootNode.getChildren().get(0);
            createConfiguration(first, null);
            if (first.getObject() != null) {
                subst.setVariableResolver((StrLookup) first.getObject());
            }
        } else {
            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);
            final StrLookup lookup = map == null ? null : new MapLookup(map);
            subst.setVariableResolver(new Interpolator(lookup));
        }

        boolean setLoggers = false;
        boolean setRoot = false;
        for (final Node child : rootNode.getChildren()) {
            if (child.getName().equalsIgnoreCase(""Properties"")) {
                if (tempLookup == subst.getVariableResolver()) {
                    LOGGER.error(""Properties declaration must be the first element in the configuration"");
                }
                continue;
            }
            createConfiguration(child, null);
            if (child.getObject() == null) {
                continue;
            }
            if (child.getName().equalsIgnoreCase(""Appenders"")) {
                appenders = (ConcurrentMap<String, Appender>) child.getObject();
            } else if (child.getObject() instanceof Filter) {
                addFilter((Filter) child.getObject());
            } else if (child.getName().equalsIgnoreCase(""Loggers"")) {
                final Loggers l = (Loggers) child.getObject();
                loggers = l.getMap();
                setLoggers = true;
                if (l.getRoot() != null) {
                    root = l.getRoot();
                    setRoot = true;
                }
            } else {
                LOGGER.error(""Unknown object \""{}\"" of type {} is ignored."", child.getName(),
                        child.getObject().getClass().getName());
            }
        }

        if (!setLoggers) {
            LOGGER.warn(""No Loggers were configured, using default. Is the Loggers element missing?"");
            setToDefault();
            return;
        } else if (!setRoot) {
            LOGGER.warn(""No Root logger was configured, creating default ERROR-level Root logger with Console appender"");
            setToDefault();
            // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers
        }

        for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {
            final LoggerConfig l = entry.getValue();
            for (final AppenderRef ref : l.getAppenderRefs()) {
                final Appender app = appenders.get(ref.getRef());
                if (app != null) {
                    l.addAppender(app, ref.getLevel(), ref.getFilter());
                } else {
                    LOGGER.error(""Unable to locate appender {} for logger {}"", ref.getRef(), l.getName());
                }
            }

        }

        setParents();
    }",0,[0]
169,bugs-dot-jar_WICKET-2368_fae1601b,"protected Page(final IModel<?> model)
	{
		// A Page's id is not determined until setId is called when the Page is
		// added to a PageMap in the Session.
		super(null, model);
		init();
	}","protected Page(final IModel<?> model)
	{
		// A Page's id is not determined until setId is called when the Page is
		// added to a PageMap in the Session.
		super(null, model);
		init();
	}",0,[0]
8448,bugs-dot-jar_ACCUMULO-366_db4a291f,"public TreeMap<KeyExtent,SplitInfo> split(byte[] sp) throws IOException {
    
    if (sp != null && extent.getEndRow() != null && extent.getEndRow().equals(new Text(sp))) {
      throw new IllegalArgumentException();
    }
    
    if (extent.equals(Constants.ROOT_TABLET_EXTENT)) {
      String msg = ""Cannot split root tablet"";
      log.warn(msg);
      throw new RuntimeException(msg);
    }
    
    try {
      initiateClose(true, false, false);
    } catch (IllegalStateException ise) {
      log.debug(""File "" + extent + "" not splitting : "" + ise.getMessage());
      return null;
    }
    
    // obtain this info outside of synch block since it will involve opening
    // the map files... it is ok if the set of map files changes, because
    // this info is used for optimization... it is ok if map files are missing
    // from the set... can still query and insert into the tablet while this
    // map file operation is happening
    Map<String,org.apache.accumulo.core.file.FileUtil.FileInfo> firstAndLastRowsAbs = FileUtil.tryToGetFirstAndLastRows(fs,
        ServerConfiguration.getSystemConfiguration(), datafileManager.getFiles());
    
    // convert absolute paths to relative paths
    Map<String,org.apache.accumulo.core.file.FileUtil.FileInfo> firstAndLastRows = new HashMap<String,org.apache.accumulo.core.file.FileUtil.FileInfo>();
    
    for (Entry<String,org.apache.accumulo.core.file.FileUtil.FileInfo> entry : firstAndLastRowsAbs.entrySet()) {
      firstAndLastRows.put(datafileManager.abs2rel(new Path(entry.getKey())), entry.getValue());
    }
    
    synchronized (this) {
      // java needs tuples ...
      TreeMap<KeyExtent,SplitInfo> newTablets = new TreeMap<KeyExtent,SplitInfo>();
      
      long t1 = System.currentTimeMillis();
      
      // choose a split point
      SplitRowSpec splitPoint;
      if (sp == null)
        splitPoint = findSplitRow(datafileManager.getFiles());
      else {
        Text tsp = new Text(sp);
        splitPoint = new SplitRowSpec(FileUtil.estimatePercentageLTE(fs, ServerConfiguration.getSystemConfiguration(), extent.getPrevEndRow(),
            extent.getEndRow(), datafileManager.getFiles(), tsp), tsp);
      }
      
      if (splitPoint == null || splitPoint.row == null) {
        log.info(""had to abort split because splitRow was null"");
        closing = false;
        return null;
      }
      
      closed = true;
      completeClose(true, false);
      
      Text midRow = splitPoint.row;
      double splitRatio = splitPoint.splitRatio;
      
      KeyExtent low = new KeyExtent(extent.getTableId(), midRow, extent.getPrevEndRow());
      KeyExtent high = new KeyExtent(extent.getTableId(), extent.getEndRow(), midRow);
      
      String lowDirectory = TabletOperations.createTabletDirectory(fs, location.getParent().toString(), midRow);
      
      // write new tablet information to MetadataTable
      SortedMap<String,DataFileValue> lowDatafileSizes = new TreeMap<String,DataFileValue>();
      SortedMap<String,DataFileValue> highDatafileSizes = new TreeMap<String,DataFileValue>();
      List<String> highDatafilesToRemove = new ArrayList<String>();
      
      MetadataTable.splitDatafiles(extent.getTableId(), midRow, splitRatio, firstAndLastRows, datafileManager.getDatafileSizesRel(), lowDatafileSizes,
          highDatafileSizes, highDatafilesToRemove);
      
      log.debug(""Files for low split "" + low + ""  "" + lowDatafileSizes.keySet());
      log.debug(""Files for high split "" + high + ""  "" + highDatafileSizes.keySet());
      
      String time = tabletTime.getMetadataValue();
      
      // it is possible that some of the bulk loading flags will be deleted after being read below because the bulk load
      // finishes.... therefore split could propogate load flags for a finished bulk load... there is a special iterator
      // on the !METADATA table to clean up this type of garbage
      Map<String,Long> bulkLoadedFiles = MetadataTable.getBulkFilesLoaded(SecurityConstants.getSystemCredentials(), extent);

      MetadataTable.splitTablet(high, extent.getPrevEndRow(), splitRatio, SecurityConstants.getSystemCredentials(), tabletServer.getLock());
      MetadataTable.addNewTablet(low, lowDirectory, tabletServer.getTabletSession(), lowDatafileSizes, bulkLoadedFiles,
          SecurityConstants.getSystemCredentials(), time, lastFlushID, lastCompactID, tabletServer.getLock());
      MetadataTable.finishSplit(high, highDatafileSizes, highDatafilesToRemove, SecurityConstants.getSystemCredentials(), tabletServer.getLock());
      
      log.log(TLevel.TABLET_HIST, extent + "" split "" + low + "" "" + high);
      
      newTablets.put(high, new SplitInfo(tabletDirectory, highDatafileSizes, time, lastFlushID, lastCompactID));
      newTablets.put(low, new SplitInfo(lowDirectory, lowDatafileSizes, time, lastFlushID, lastCompactID));
      
      long t2 = System.currentTimeMillis();
      
      log.debug(String.format(""offline split time : %6.2f secs"", (t2 - t1) / 1000.0));
      
      closeComplete = true;
      
      return newTablets;
    }
  }","public TreeMap<KeyExtent,SplitInfo> split(byte[] sp) throws IOException {
    
    if (sp != null && extent.getEndRow() != null && extent.getEndRow().equals(new Text(sp))) {
      throw new IllegalArgumentException();
    }
    
    if (extent.equals(Constants.ROOT_TABLET_EXTENT)) {
      String msg = ""Cannot split root tablet"";
      log.warn(msg);
      throw new RuntimeException(msg);
    }
    
    try {
      initiateClose(true, false, false);
    } catch (IllegalStateException ise) {
      log.debug(""File "" + extent + "" not splitting : "" + ise.getMessage());
      return null;
    }
    
    // obtain this info outside of synch block since it will involve opening
    // the map files... it is ok if the set of map files changes, because
    // this info is used for optimization... it is ok if map files are missing
    // from the set... can still query and insert into the tablet while this
    // map file operation is happening
    Map<String,org.apache.accumulo.core.file.FileUtil.FileInfo> firstAndLastRowsAbs = FileUtil.tryToGetFirstAndLastRows(fs,
        ServerConfiguration.getSystemConfiguration(), datafileManager.getFiles());
    
    // convert absolute paths to relative paths
    Map<String,org.apache.accumulo.core.file.FileUtil.FileInfo> firstAndLastRows = new HashMap<String,org.apache.accumulo.core.file.FileUtil.FileInfo>();
    
    for (Entry<String,org.apache.accumulo.core.file.FileUtil.FileInfo> entry : firstAndLastRowsAbs.entrySet()) {
      firstAndLastRows.put(datafileManager.abs2rel(new Path(entry.getKey())), entry.getValue());
    }
    
    synchronized (this) {
      // java needs tuples ...
      TreeMap<KeyExtent,SplitInfo> newTablets = new TreeMap<KeyExtent,SplitInfo>();
      
      long t1 = System.currentTimeMillis();
      
      // choose a split point
      SplitRowSpec splitPoint;
      if (sp == null)
        splitPoint = findSplitRow(datafileManager.getFiles());
      else {
        Text tsp = new Text(sp);
        splitPoint = new SplitRowSpec(FileUtil.estimatePercentageLTE(fs, ServerConfiguration.getSystemConfiguration(), extent.getPrevEndRow(),
            extent.getEndRow(), datafileManager.getFiles(), tsp), tsp);
      }
      
      if (splitPoint == null || splitPoint.row == null) {
        log.info(""had to abort split because splitRow was null"");
        closing = false;
        return null;
      }
      
      closed = true;
      completeClose(true, false);
      
      Text midRow = splitPoint.row;
      double splitRatio = splitPoint.splitRatio;
      
      KeyExtent low = new KeyExtent(extent.getTableId(), midRow, extent.getPrevEndRow());
      KeyExtent high = new KeyExtent(extent.getTableId(), extent.getEndRow(), midRow);
      
      String lowDirectory = TabletOperations.createTabletDirectory(fs, location.getParent().toString(), midRow);
      
      // write new tablet information to MetadataTable
      SortedMap<String,DataFileValue> lowDatafileSizes = new TreeMap<String,DataFileValue>();
      SortedMap<String,DataFileValue> highDatafileSizes = new TreeMap<String,DataFileValue>();
      List<String> highDatafilesToRemove = new ArrayList<String>();
      
      MetadataTable.splitDatafiles(extent.getTableId(), midRow, splitRatio, firstAndLastRows, datafileManager.getDatafileSizesRel(), lowDatafileSizes,
          highDatafileSizes, highDatafilesToRemove);
      
      log.debug(""Files for low split "" + low + ""  "" + lowDatafileSizes.keySet());
      log.debug(""Files for high split "" + high + ""  "" + highDatafileSizes.keySet());
      
      String time = tabletTime.getMetadataValue();
      
      // it is possible that some of the bulk loading flags will be deleted after being read below because the bulk load
      // finishes.... therefore split could propogate load flags for a finished bulk load... there is a special iterator
      // on the !METADATA table to clean up this type of garbage
      Map<String,Long> bulkLoadedFiles = MetadataTable.getBulkFilesLoaded(SecurityConstants.getSystemCredentials(), extent);

      MetadataTable.splitTablet(high, extent.getPrevEndRow(), splitRatio, SecurityConstants.getSystemCredentials(), tabletServer.getLock());
      MetadataTable.addNewTablet(low, lowDirectory, tabletServer.getTabletSession(), lowDatafileSizes, bulkLoadedFiles,
          SecurityConstants.getSystemCredentials(), time, lastFlushID, lastCompactID, tabletServer.getLock());
      MetadataTable.finishSplit(high, highDatafileSizes, highDatafilesToRemove, SecurityConstants.getSystemCredentials(), tabletServer.getLock());
      
      log.log(TLevel.TABLET_HIST, extent + "" split "" + low + "" "" + high);
      
      newTablets.put(high, new SplitInfo(tabletDirectory, highDatafileSizes, time, lastFlushID, lastCompactID));
      newTablets.put(low, new SplitInfo(lowDirectory, lowDatafileSizes, time, lastFlushID, lastCompactID));
      
      long t2 = System.currentTimeMillis();
      
      log.debug(String.format(""offline split time : %6.2f secs"", (t2 - t1) / 1000.0));
      
      closeComplete = true;
      
      return newTablets;
    }
  }",0,[0]
31869,bugs-dot-jar_LOG4J2-1406_a523dcd5,"ReusableParameterizedMessage set(String messagePattern, Object p0, Object p1, Object p2) {
        params[0] = p0;
        params[1] = p1;
        params[2] = p2;
        init(messagePattern, 3, params);
        return this;
    }","ReusableParameterizedMessage set(String messagePattern, Object p0, Object p1, Object p2) {
        params[0] = p0;
        params[1] = p1;
        params[2] = p2;
        init(messagePattern, 3, params);
        return this;
    }",0,[0]
8812,bugs-dot-jar_MNG-2712_06090da4,"public void resolve( RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository )
        throws RepositoryMetadataResolutionException
    {
        boolean alreadyResolved = alreadyResolved( metadata );
        if ( !alreadyResolved )
        {
            for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
            {
                ArtifactRepository repository = (ArtifactRepository) i.next();

                ArtifactRepositoryPolicy policy =
                    metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();

                if ( !policy.isEnabled() )
                {
                    getLogger().debug( ""Skipping disabled repository "" + repository.getId() );
                }
                else if ( repository.isBlacklisted() )
                {
                    getLogger().debug( ""Skipping blacklisted repository "" + repository.getId() );
                }
                else
                {
                    File file = new File( localRepository.getBasedir(),
                                          localRepository.pathOfLocalRepositoryMetadata( metadata, repository ) );

                    boolean checkForUpdates =
                        policy.checkOutOfDate( new Date( file.lastModified() ) ) || !file.exists();

                    boolean metadataIsEmpty = true;

                    if ( checkForUpdates )
                    {
                        getLogger().info( metadata.getKey() + "": checking for updates from "" + repository.getId() );

                        try
                        {
                            resolveAlways( metadata, repository, file, policy.getChecksumPolicy(), true );
                            metadataIsEmpty = false;
                        }
                        catch ( TransferFailedException e )
                        {
                            // TODO: [jc; 08-Nov-2005] revisit this for 2.1
                            // suppressing logging to avoid logging this error twice.
                            metadataIsEmpty = true;
                        }
                    }

                    // TODO: should this be inside the above check?
                    // touch file so that this is not checked again until interval has passed
                    if ( file.exists() )
                    {
                        file.setLastModified( System.currentTimeMillis() );
                    }
                    else if ( !metadataIsEmpty )
                    {
                        // this ensures that files are not continuously checked when they don't exist remotely
                        try
                        {
                            metadata.storeInLocalRepository( localRepository, repository );
                        }
                        catch ( RepositoryMetadataStoreException e )
                        {
                            throw new RepositoryMetadataResolutionException(
                                ""Unable to store local copy of metadata: "" + e.getMessage(), e );
                        }
                    }
                }
            }
            cachedMetadata.add( metadata.getKey() );
        }

        try
        {
            mergeMetadata( metadata, remoteRepositories, localRepository );
        }
        catch ( RepositoryMetadataStoreException e )
        {
            throw new RepositoryMetadataResolutionException(
                ""Unable to store local copy of metadata: "" + e.getMessage(), e );
        }
        catch ( RepositoryMetadataReadException e )
        {
            throw new RepositoryMetadataResolutionException( ""Unable to read local copy of metadata: "" + e.getMessage(),
                                                             e );
        }
    }","public void resolve( RepositoryMetadata metadata, List remoteRepositories, ArtifactRepository localRepository )
        throws RepositoryMetadataResolutionException
    {
        boolean alreadyResolved = alreadyResolved( metadata );
        if ( !alreadyResolved )
        {
            for ( Iterator i = remoteRepositories.iterator(); i.hasNext(); )
            {
                ArtifactRepository repository = (ArtifactRepository) i.next();

                ArtifactRepositoryPolicy policy =
                    metadata.isSnapshot() ? repository.getSnapshots() : repository.getReleases();

                if ( !policy.isEnabled() )
                {
                    getLogger().debug( ""Skipping disabled repository "" + repository.getId() );
                }
                else if ( repository.isBlacklisted() )
                {
                    getLogger().debug( ""Skipping blacklisted repository "" + repository.getId() );
                }
                else
                {
                    File file = new File( localRepository.getBasedir(),
                                          localRepository.pathOfLocalRepositoryMetadata( metadata, repository ) );



                    boolean checkForUpdates =
                        policy.checkOutOfDate( new Date( file.lastModified() ) ) || !file.exists();

                    boolean metadataIsEmpty = true;

                    if ( checkForUpdates )
                    {
                        getLogger().info( metadata.getKey() + "": checking for updates from "" + repository.getId() );

                        try
                        {
                            resolveAlways( metadata, repository, file, policy.getChecksumPolicy(), true );
                            metadataIsEmpty = false;
                        }
                        catch ( TransferFailedException e )
                        {
                            // TODO: [jc; 08-Nov-2005] revisit this for 2.1
                            // suppressing logging to avoid logging this error twice.
                            metadataIsEmpty = true;
                        }
                    }

                    // TODO: should this be inside the above check?
                    // touch file so that this is not checked again until interval has passed
                    if ( file.exists() )
                    {
                        file.setLastModified( System.currentTimeMillis() );
                    }
                    else
                    {
                        // this ensures that files are not continuously checked when they don't exist remotely
                        try
                        {
                            metadata.storeInLocalRepository( localRepository, repository );
                        }
                        catch ( RepositoryMetadataStoreException e )
                        {
                            throw new RepositoryMetadataResolutionException(
                                ""Unable to store local copy of metadata: "" + e.getMessage(), e );
                        }
                    }
                }
            }
            cachedMetadata.add( metadata.getKey() );
        }

        try
        {
            mergeMetadata( metadata, remoteRepositories, localRepository );
        }
        catch ( RepositoryMetadataStoreException e )
        {
            throw new RepositoryMetadataResolutionException(
                ""Unable to store local copy of metadata: "" + e.getMessage(), e );
        }
        catch ( RepositoryMetadataReadException e )
        {
            throw new RepositoryMetadataResolutionException( ""Unable to read local copy of metadata: "" + e.getMessage(),
                                                             e );
        }
    }",1,[54]
5369,bugs-dot-jar_FLINK-3534_734ba01d,"public Map<IntermediateDataSetID, IntermediateResult> getAllIntermediateResults() {
		return Collections.unmodifiableMap(this.intermediateResults);
	}","public Map<IntermediateDataSetID, IntermediateResult> getAllIntermediateResults() {
		return Collections.unmodifiableMap(this.intermediateResults);
	}",0,[0]
38510,bugs-dot-jar_CAMEL-9124_9da2c05a,"public String getMaximumRedeliveries() {
        return maximumRedeliveries;
    }","public String getMaximumRedeliveries() {
        return maximumRedeliveries;
    }",0,[0]
33275,bugs-dot-jar_ACCUMULO-795_9453bcfa,"public SortedSet<String> list() {
    OpTimer opTimer = new OpTimer(log, Level.TRACE).start(""Fetching list of tables..."");
    TreeSet<String> tableNames = new TreeSet<String>(Tables.getNameToIdMap(instance).keySet());
    opTimer.stop(""Fetched "" + tableNames.size() + "" table names in %DURATION%"");
    return tableNames;
  }","public SortedSet<String> list() {
    OpTimer opTimer = new OpTimer(log, Level.TRACE).start(""Fetching list of tables..."");
    TreeSet<String> tableNames = new TreeSet<String>(Tables.getNameToIdMap(instance).keySet());
    opTimer.stop(""Fetched "" + tableNames.size() + "" table names in %DURATION%"");
    return tableNames;
  }",0,[0]
3957,bugs-dot-jar_WICKET-4578_c66cf607,"public Component setDefaultModel(final IModel<?> model)
	{
		IModel<?> prevModel = getModelImpl();
		// Detach current model
		if (prevModel != null)
		{
			prevModel.detach();
		}

		IModel<?> wrappedModel = prevModel;
		if (prevModel instanceof IWrapModel)
		{
			wrappedModel = ((IWrapModel<?>)prevModel).getWrappedModel();
		}

		// Change model
		if (wrappedModel != model)
		{
			modelChanging();
			setModelImpl(wrap(model));
			modelChanged();
		}

		return this;
	}","public Component setDefaultModel(final IModel<?> model)
	{
		IModel<?> prevModel = getModelImpl();
		// Detach current model
		if (prevModel != null)
		{
			prevModel.detach();
		}

		IModel<?> wrappedModel = prevModel;
		if (prevModel instanceof IWrapModel)
		{
			wrappedModel = ((IWrapModel<?>)prevModel).getWrappedModel();
		}

		// Change model
		if (wrappedModel != model)
		{
			modelChanging();
			setModelImpl(wrap(model));
			modelChanged();
		}

		return this;
	}",0,[0]
34335,bugs-dot-jar_CAMEL-3281_f7dd2fff,"public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        routeCollection.setCamelContext(getContext());
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }","public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        if (!routeCollection.getRoutes().isEmpty()) {
            throw new IllegalArgumentException(""errorHandler must be defined before any routes in the RouteBuilder"");
        }
        routeCollection.setCamelContext(getContext());
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }",1,[]
2572,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void deleteRows(ByteBuffer login, String tableName, ByteBuffer startRow, ByteBuffer endRow) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException, TException {
    try {
      getConnector(login).tableOperations().deleteRows(tableName, ByteBufferUtil.toText(startRow), ByteBufferUtil.toText(endRow));
    } catch (Exception e) {
      handleExceptionTNF(e);
    }
  }","@Override
  public void deleteRows(ByteBuffer login, String tableName, ByteBuffer startRow, ByteBuffer endRow) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException, TException {
    try {
      getConnector(login).tableOperations().deleteRows(tableName, ByteBufferUtil.toText(startRow), ByteBufferUtil.toText(endRow));
    } catch (Exception e) {
      handleExceptionTNF(e);
    }
  }",0,[0]
7843,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,
        final int start, final int end) {
        checkIndices(start, end);
        visitor.start(data.length, start, end);
        for (int i = start; i <= end; i++) {
            visitor.visit(i, data[i]);
        }
        return visitor.end();
    }","@Override
    public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor,
        final int start, final int end) {
        checkIndices(start, end);
        visitor.start(data.length, start, end);
        for (int i = start; i <= end; i++) {
            visitor.visit(i, data[i]);
        }
        return visitor.end();
    }",0,[0]
6997,bugs-dot-jar_LOG4J2-763_97203de8,"@Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final FormattedMessage that = (FormattedMessage) o;

        if (messagePattern != null ? !messagePattern.equals(that.messagePattern) : that.messagePattern != null) {
            return false;
        }
        if (!Arrays.equals(stringArgs, that.stringArgs)) {
            return false;
        }

        return true;
    }","@Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final FormattedMessage that = (FormattedMessage) o;

        if (messagePattern != null ? !messagePattern.equals(that.messagePattern) : that.messagePattern != null) {
            return false;
        }
        if (!Arrays.equals(stringArgs, that.stringArgs)) {
            return false;
        }

        return true;
    }",0,[0]
34905,bugs-dot-jar_CAMEL-5570_a57830ed,"public OnExceptionDefinition logRetryAttempted(boolean logRetryAttempted) {
        getOrCreateRedeliveryPolicy().logRetryAttempted(logRetryAttempted);
        return this;
    }","public OnExceptionDefinition logRetryAttempted(boolean logRetryAttempted) {
        getOrCreateRedeliveryPolicy().logRetryAttempted(logRetryAttempted);
        return this;
    }",0,[0]
24089,bugs-dot-jar_OAK-579_7d72e6ed,"public boolean isAlwaysFalse() {
        return alwaysFalse;
    }","public boolean isAlwaysFalse() {
        return alwaysFalse;
    }",0,[0]
369,Bears-15,"@Override
    public PropertyName findNameForSerialization(Annotated a)
    {
        JsonGetter jg = _findAnnotation(a, JsonGetter.class);
        if (jg != null) {
            return PropertyName.construct(jg.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_SER)) {
            return PropertyName.USE_DEFAULT;
        }
        return null;
    }","@Override
    public PropertyName findNameForSerialization(Annotated a)
    {
        JsonGetter jg = _findAnnotation(a, JsonGetter.class);
        if (jg != null) {
            return PropertyName.construct(jg.value());
        }
        JsonProperty pann = _findAnnotation(a, JsonProperty.class);
        if (pann != null) {
            return PropertyName.construct(pann.value());
        }
        if (_hasOneOf(a, ANNOTATIONS_TO_INFER_SER)) {
            return PropertyName.USE_DEFAULT;
        }
        return null;
    }",0,[0]
1799,bugs-dot-jar_MATH-482_6d6649ef,"public static double nextAfter(double d, double direction) {

        // handling of some important special cases
        if (Double.isNaN(d) || Double.isInfinite(d)) {
            return d;
        } else if (d == 0) {
            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
        }
        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
        // are handled just as normal numbers

        // split the double in raw components
        long bits     = Double.doubleToLongBits(d);
        long sign     = bits & 0x8000000000000000L;
        long exponent = bits & 0x7ff0000000000000L;
        long mantissa = bits & 0x000fffffffffffffL;

        if (d * (direction - d) >= 0) {
            // we should increase the mantissa
            if (mantissa == 0x000fffffffffffffL) {
                return Double.longBitsToDouble(sign |
                                               (exponent + 0x0010000000000000L));
            } else {
                return Double.longBitsToDouble(sign |
                                               exponent | (mantissa + 1));
            }
        } else {
            // we should decrease the mantissa
            if (mantissa == 0L) {
                return Double.longBitsToDouble(sign |
                                               (exponent - 0x0010000000000000L) |
                                               0x000fffffffffffffL);
            } else {
                return Double.longBitsToDouble(sign |
                                               exponent | (mantissa - 1));
            }
        }

    }","public static double nextAfter(double d, double direction) {

        // handling of some important special cases
        if (Double.isNaN(d) || Double.isInfinite(d)) {
            return d;
        } else if (d == 0) {
            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
        }
        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
        // are handled just as normal numbers

        // split the double in raw components
        long bits     = Double.doubleToLongBits(d);
        long sign     = bits & 0x8000000000000000L;
        long exponent = bits & 0x7ff0000000000000L;
        long mantissa = bits & 0x000fffffffffffffL;

        if (d * (direction - d) >= 0) {
            // we should increase the mantissa
            if (mantissa == 0x000fffffffffffffL) {
                return Double.longBitsToDouble(sign |
                                               (exponent + 0x0010000000000000L));
            } else {
                return Double.longBitsToDouble(sign |
                                               exponent | (mantissa + 1));
            }
        } else {
            // we should decrease the mantissa
            if (mantissa == 0L) {
                return Double.longBitsToDouble(sign |
                                               (exponent - 0x0010000000000000L) |
                                               0x000fffffffffffffL);
            } else {
                return Double.longBitsToDouble(sign |
                                               exponent | (mantissa - 1));
            }
        }

    }",0,[0]
1539,bugs-dot-jar_MATH-290_b01fcc31,"protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {
        double sum = 0;
        for (double coefficient : coefficients.getData()) {
            sum -= coefficient;
        }
        return sum;
    }","protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {
        double sum = 0;
        for (double coefficient : coefficients.getData()) {
            sum -= coefficient;
        }
        return sum;
    }",0,[0]
11698,bugs-dot-jar_CAMEL-5796_de6dd425,"public ExpressionClause<ProcessorDefinition<Type>> setBody() {
        ExpressionClause<ProcessorDefinition<Type>> clause = new ExpressionClause<ProcessorDefinition<Type>>(this);
        SetBodyDefinition answer = new SetBodyDefinition(clause);
        addOutput(answer);
        return clause;
    }","public ExpressionClause<ProcessorDefinition<Type>> setBody() {
        ExpressionClause<ProcessorDefinition<Type>> clause = new ExpressionClause<ProcessorDefinition<Type>>(this);
        SetBodyDefinition answer = new SetBodyDefinition(clause);
        addOutput(answer);
        return clause;
    }",0,[0]
27361,bugs-dot-jar_WICKET-1619_b154d12f,"private void setIterations(int i)
	{
		setDefaultModelObject(new Integer(i));
	}","private void setIterations(int i)
	{
		setDefaultModelObject(new Integer(i));
	}",0,[0]
4144,bugs-dot-jar_FLINK-2713_63d9800e,"@Override
	public Map<Serializable, S> getPartitionedState() throws Exception {
		return stateStore.getPartitionedState();
	}","@Override
	public Map<Serializable, S> getPartitionedState() throws Exception {
		return stateStore.getPartitionedState();
	}",0,[0]
1729,Bears-197,"public URIBuilder setParameter(final String param, final String value) {
        if (this.queryParams == null) {
            this.queryParams = new ArrayList<BasicNameValuePair>();
        }
        if (!this.queryParams.isEmpty()) {
            for (final Iterator<BasicNameValuePair> it = this.queryParams.iterator(); it.hasNext(); ) {
                final BasicNameValuePair nvp = it.next();
                if (nvp.getName().equals(param)) {
                    it.remove();
                }
            }
        }
        this.queryParams.add(new BasicNameValuePair(param, value));
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        this.query = null;
        return this;
    }","public URIBuilder setParameter(final String param, final String value) {
        if (this.queryParams == null) {
            this.queryParams = new ArrayList<BasicNameValuePair>();
        }
        if (!this.queryParams.isEmpty()) {
            for (final Iterator<BasicNameValuePair> it = this.queryParams.iterator(); it.hasNext(); ) {
                final BasicNameValuePair nvp = it.next();
                if (nvp.getName().equals(param)) {
                    it.remove();
                }
            }
        }
        this.queryParams.add(new BasicNameValuePair(param, value));
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        this.query = null;
        return this;
    }",0,[0]
33488,bugs-dot-jar_OAK-4066_9a109aa3,"static private Calendar getCalendar() {
        Calendar ret = Calendar.getInstance();
        ret.setTime(clock.getDate());
        return ret;
    }","static private Calendar getCalendar() {
        Calendar ret = Calendar.getInstance();
        ret.setTime(clock.getDate());
        return ret;
    }",0,[0]
3160,bugs-dot-jar_CAMEL-7736_7ad36e3d,"public void setEventNotifierEnabled(boolean eventNotifierEnabled) {
        this.eventNotifierEnabled = eventNotifierEnabled;
    }","public void setEventNotifierEnabled(boolean eventNotifierEnabled) {
        this.eventNotifierEnabled = eventNotifierEnabled;
    }",0,[0]
9887,bugs-dot-jar_OAK-3634_90ad50da,"@CheckForNull
    private static NodeDocument unwrap(@Nonnull NodeDocument doc) {
        return doc == NodeDocument.NULL ? null : doc;
    }","@CheckForNull
    private static NodeDocument unwrap(@Nonnull NodeDocument doc) {
        return doc == NodeDocument.NULL ? null : doc;
    }",0,[0]
4829,bugs-dot-jar_MATH-326_ce185345,"public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {
        checkVectorDimensions(v.getDimension());
        boolean thisIsSmaller  = entries.size() < v.entries.size();
        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();
        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;
        double d = 0;
        while(iter.hasNext()) {
            iter.advance();
            d += iter.value() * larger.get(iter.key());
        }
        return d;
    }","public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {
        checkVectorDimensions(v.getDimension());
        boolean thisIsSmaller  = entries.size() < v.entries.size();
        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();
        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;
        double d = 0;
        while(iter.hasNext()) {
            iter.advance();
            d += iter.value() * larger.get(iter.key());
        }
        return d;
    }",0,[0]
8187,bugs-dot-jar_MATH-294_2c8a114f,"public long nextLong(long lower, long upper) {
        if (lower >= upper) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""upper bound ({0}) must be greater than lower bound ({1})"",
                  upper, lower);
        }
        double r = getRan().nextDouble();
        return (long) ((r * upper) + ((1.0 - r) * lower) + r);
    }","public long nextLong(long lower, long upper) {
        if (lower >= upper) {
            throw MathRuntimeException.createIllegalArgumentException(
                  ""upper bound ({0}) must be greater than lower bound ({1})"",
                  upper, lower);
        }
        double r = getRan().nextDouble();
        return (long) ((r * upper) + ((1.0 - r) * lower) + r);
    }",0,[0]
15003,bugs-dot-jar_MNG-5075_2eb419ed,"public List<String> getRuntimeClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }","public List<String> getRuntimeClasspathElements()
        throws DependencyResolutionRequiredException
    {
        List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );

        String d = getBuild().getOutputDirectory();
        if ( d != null )
        {
            list.add( d );
        }

        for ( Artifact a : getArtifacts() )
        {
            if ( a.getArtifactHandler().isAddedToClasspath() )
            {
                // TODO: let the scope handler deal with this
                if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) )
                {
                    addArtifactPath( a, list );
                }
            }
        }
        return list;
    }",0,[0]
9738,bugs-dot-jar_OAK-1731_024e5d37,"public static void copy(RepositoryConfig source, NodeStore target)
            throws RepositoryException {
        RepositoryContext context = RepositoryContext.create(source);
        try {
            new RepositoryUpgrade(context, target).copy(null);
        } finally {
            context.getRepository().shutdown();
        }
    }","public static void copy(RepositoryConfig source, NodeStore target)
            throws RepositoryException {
        RepositoryContext context = RepositoryContext.create(source);
        try {
            new RepositoryUpgrade(context, target).copy(null);
        } finally {
            context.getRepository().shutdown();
        }
    }",0,[0]
12901,bugs-dot-jar_WICKET-4717_6a1b2f61,protected abstract R getValue(IValidatable<V> validatable);,protected abstract R getValue(IValidatable<V> validatable);,0,[0]
29289,bugs-dot-jar_CAMEL-7586_1f92fa42,"public void sendBody(String endpointUri, Object body) throws Exception {
        ProducerTemplate template = context.createProducerTemplate();
        try {
            template.sendBody(endpointUri, body);
        } finally {
            template.stop();
        }
    }","public void sendBody(String endpointUri, Object body) throws Exception {
        ProducerTemplate template = context.createProducerTemplate();
        try {
            template.sendBody(endpointUri, body);
        } finally {
            template.stop();
        }
    }",0,[0]
7090,bugs-dot-jar_LOG4J2-763_97203de8,"public StructuredDataMessage(final StructuredDataId id, final String msg, final String type) {
        this.id = id;
        this.message = msg;
        this.type = type;
    }","public StructuredDataMessage(final StructuredDataId id, final String msg, final String type) {
        this.id = id;
        this.message = msg;
        this.type = type;
    }",0,[0]
12583,bugs-dot-jar_MATH-864_abe53a53,"private static RealMatrix ones(int n, int m) {
        double[][] d = new double[n][m];
        for (int r = 0; r < n; r++) {
            Arrays.fill(d[r], 1.0);
        }
        return new Array2DRowRealMatrix(d, false);
    }","private static RealMatrix ones(int n, int m) {
        double[][] d = new double[n][m];
        for (int r = 0; r < n; r++) {
            Arrays.fill(d[r], 1.0);
        }
        return new Array2DRowRealMatrix(d, false);
    }",0,[0]
9392,bugs-dot-jar_ACCUMULO-2857_9fcca2ed,"synchronized void addMutation(Mutation m) {
    if (m.size() == 0)
      throw new IllegalArgumentException(""Can not add empty mutations"");
    long now = System.currentTimeMillis();
    mutationCount++;
    for (ColumnUpdate u : m.getUpdates()) {
      Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0,
          u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());
      if (u.isDeleted())
        key.setDeleted(true);
      if (!u.hasTimestamp())
        if (timeType.equals(TimeType.LOGICAL))
          key.setTimestamp(mutationCount);
        else
          key.setTimestamp(now);
      
      table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));
    }
  }","synchronized void addMutation(Mutation m) {
    if (m.size() == 0)
      throw new IllegalArgumentException(""Can not add empty mutations"");
    long now = System.currentTimeMillis();
    mutationCount++;
    for (ColumnUpdate u : m.getUpdates()) {
      Key key = new Key(m.getRow(), 0, m.getRow().length, u.getColumnFamily(), 0, u.getColumnFamily().length, u.getColumnQualifier(), 0,
          u.getColumnQualifier().length, u.getColumnVisibility(), 0, u.getColumnVisibility().length, u.getTimestamp());
      if (u.isDeleted())
        key.setDeleted(true);
      if (!u.hasTimestamp())
        if (timeType.equals(TimeType.LOGICAL))
          key.setTimestamp(mutationCount);
        else
          key.setTimestamp(now);
      
      table.put(new MockMemKey(key, mutationCount), new Value(u.getValue()));
    }
  }",0,[0]
37949,bugs-dot-jar_OAK-738_8ed779dc,"@Override
    @Nonnull
    public NodeIterator getNodes() throws RepositoryException {
        return perform(new ItemReadOperation<NodeIterator>() {
            @Override
            public NodeIterator perform() throws RepositoryException {
                Iterator<NodeDelegate> children = dlg.getChildren();
                long size = dlg.getChildCount();
                return new NodeIteratorAdapter(nodeIterator(children), size);
            }
        });
    }","@Override
    @Nonnull
    public NodeIterator getNodes() throws RepositoryException {
        return perform(new ItemReadOperation<NodeIterator>() {
            @Override
            public NodeIterator perform() throws RepositoryException {
                Iterator<NodeDelegate> children = dlg.getChildren();
                long size = dlg.getChildCount();
                return new NodeIteratorAdapter(nodeIterator(children), size);
            }
        });
    }",0,[0]
2120,bugs-dot-jar_WICKET-2961_3d8c9d75,"private void notifyBehaviorsComponentBeforeRender()
	{
		for (IBehavior behavior : getBehaviors())
		{
			if (isBehaviorAccepted(behavior))
			{
				behavior.beforeRender(this);
			}
		}
	}","private void notifyBehaviorsComponentBeforeRender()
	{
		for (IBehavior behavior : getBehaviors())
		{
			if (isBehaviorAccepted(behavior))
			{
				behavior.beforeRender(this);
			}
		}
	}",0,[0]
38108,bugs-dot-jar_OAK-3013_eabb4066,"@Override
    public void bindValue(String key, PropertyValue value) {
        left.bindValue(key, value);
        right.bindValue(key, value);
    }","@Override
    public void bindValue(String key, PropertyValue value) {
        left.bindValue(key, value);
        right.bindValue(key, value);
    }",0,[0]
29295,bugs-dot-jar_CAMEL-7586_1f92fa42,"public String dumpRestsAsXml() throws Exception {
        List<RestDefinition> rests = context.getRestDefinitions();
        if (rests.isEmpty()) {
            return null;
        }

        // use a routes definition to dump the rests
        RestsDefinition def = new RestsDefinition();
        def.setRests(rests);
        return ModelHelper.dumpModelAsXml(def);
    }","public String dumpRestsAsXml() throws Exception {
        List<RestDefinition> rests = context.getRestDefinitions();
        if (rests.isEmpty()) {
            return null;
        }

        // use a routes definition to dump the rests
        RestsDefinition def = new RestsDefinition();
        def.setRests(rests);
        return ModelHelper.dumpModelAsXml(def);
    }",0,[0]
26383,bugs-dot-jar_OAK-3310_4416a9f8,"private Property internalRemoveProperty(final String jcrName)
            throws RepositoryException {
        final String oakName = getOakName(checkNotNull(jcrName));
        return perform(new ItemWriteOperation<Property>(""internalRemoveProperty"") {
            @Nonnull
            @Override
            public Property perform() throws RepositoryException {
                PropertyDelegate property = dlg.getPropertyOrNull(oakName);
                if (property != null) {
                    property.remove();
                } else {
                    // Return an instance which throws on access; see OAK-395
                    property = dlg.getProperty(oakName);
                }
                return new PropertyImpl(property, sessionContext);
            }

            @Override
            public String toString() {
                return String.format(""Removing property [%s]"", jcrName);
            }
        });
    }","private Property internalRemoveProperty(final String jcrName)
            throws RepositoryException {
        final String oakName = getOakName(checkNotNull(jcrName));
        return perform(new ItemWriteOperation<Property>(""internalRemoveProperty"") {
            @Override
            public void checkPreconditions() throws RepositoryException {
                super.checkPreconditions();
                if (!isCheckedOut()) {
                    throw new VersionException(
                            ""Cannot remove property. Node is checked in."");
                }
            }
            @Nonnull
            @Override
            public Property perform() throws RepositoryException {
                PropertyDelegate property = dlg.getPropertyOrNull(oakName);
                if (property != null) {
                    property.remove();
                } else {
                    // Return an instance which throws on access; see OAK-395
                    property = dlg.getProperty(oakName);
                }
                return new PropertyImpl(property, sessionContext);
            }

            @Override
            public String toString() {
                return String.format(""Removing property [%s]"", jcrName);
            }
        });
    }",1,[]
32655,bugs-dot-jar_WICKET-4370_7ca927c1,"public Url getUrl()
	{
		String urlString = getRequestURI() + '?' + getQueryString();
		Url url = Url.parse(urlString, getCharset());
		url.setProtocol(scheme);
		url.setHost(serverName);
		url.setPort(serverPort);
		return url;
	}","public Url getUrl()
	{
		String urlString = getRequestURI() + '?' + getQueryString();
		Url url = Url.parse(urlString, getCharset());
		url.setProtocol(scheme);
		url.setHost(serverName);
		url.setPort(serverPort);
		return url;
	}",0,[0]
38071,bugs-dot-jar_CAMEL-7213_336663c9,"@Converter
    public static ByteBuffer toByteBuffer(Integer value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putInt(value);
        return buf;
    }","@Converter
    public static ByteBuffer toByteBuffer(Integer value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putInt(value);
        buf.flip();
        return buf;
    }",1,[]
4619,bugs-dot-jar_WICKET-4519_e62ded51,"public boolean visitObject(final Object object)
	{
		return clazz.isAssignableFrom(object.getClass());
	}","public boolean visitObject(final Object object)
	{
		return clazz == null || clazz.isAssignableFrom(object.getClass());
	}",1,[2]
29494,bugs-dot-jar_CAMEL-5515_b3bb8670,"protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition<?>> outputs) throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorDefinition<?> output : outputs) {

            // resolve properties before we create the processor
            resolvePropertyPlaceholders(routeContext, output);

            Processor processor = null;
            // at first use custom factory
            if (routeContext.getCamelContext().getProcessorFactory() != null) {
                processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);
            }
            // fallback to default implementation if factory did not create the processor
            if (processor == null) {
                processor = output.createProcessor(routeContext);
            }

            if (output instanceof Channel && processor == null) {
                continue;
            }

            Processor channel = wrapChannel(routeContext, processor, output);
            list.add(channel);
        }

        // if more than one output wrap than in a composite processor else just keep it as is
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(routeContext, list);
            }
        }

        return processor;
    }","protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition<?>> outputs) throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorDefinition<?> output : outputs) {

            // resolve properties before we create the processor
            resolvePropertyPlaceholders(routeContext, output);

            Processor processor = null;
            // at first use custom factory
            if (routeContext.getCamelContext().getProcessorFactory() != null) {
                processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);
            }
            // fallback to default implementation if factory did not create the processor
            if (processor == null) {
                processor = output.createProcessor(routeContext);
            }

            if (output instanceof Channel && processor == null) {
                continue;
            }

            Processor channel = wrapChannel(routeContext, processor, output);
            list.add(channel);
        }

        // if more than one output wrap than in a composite processor else just keep it as is
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(routeContext, list);
            }
        }

        return processor;
    }",0,[0]
22729,bugs-dot-jar_MATH-778_5b9302d5,"public boolean greaterThan(final Dfp x) {

        // make sure we don't mix number with different precision
        if (field.getRadixDigits() != x.field.getRadixDigits()) {
            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
            final Dfp result = newInstance(getZero());
            result.nans = QNAN;
            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);
            return false;
        }

        /* if a nan is involved, signal invalid and return false */
        if (isNaN() || x.isNaN()) {
            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));
            return false;
        }

        return compare(this, x) > 0;
    }","public boolean greaterThan(final Dfp x) {

        // make sure we don't mix number with different precision
        if (field.getRadixDigits() != x.field.getRadixDigits()) {
            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
            final Dfp result = newInstance(getZero());
            result.nans = QNAN;
            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);
            return false;
        }

        /* if a nan is involved, signal invalid and return false */
        if (isNaN() || x.isNaN()) {
            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));
            return false;
        }

        return compare(this, x) > 0;
    }",0,[0]
26415,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    public boolean getBoolean() throws RepositoryException {
        return getValue().getBoolean();
    }","@Override
    public boolean getBoolean() throws RepositoryException {
        return getValue().getBoolean();
    }",0,[0]
1126,bugs-dot-jar_WICKET-5546_f1af9e03,"public final Object getDefaultModelObject()
	{
		final IModel<?> model = getDefaultModel();
		if (model != null)
		{
			try
			{
				// Get model value for this component.
				return model.getObject();
			}
			catch (Exception ex)
			{
				// wrap the exception so that it brings info about the component
				RuntimeException rex = new RuntimeException(
					""An error occurred while getting the model object for Component: "" +
						this.toString(true), ex);
				throw rex;
			}
		}
		return null;
	}","public final Object getDefaultModelObject()
	{
		final IModel<?> model = getDefaultModel();
		if (model != null)
		{
			try
			{
				// Get model value for this component.
				return model.getObject();
			}
			catch (Exception ex)
			{
				// wrap the exception so that it brings info about the component
				RuntimeException rex = new RuntimeException(
					""An error occurred while getting the model object for Component: "" +
						this.toString(true), ex);
				throw rex;
			}
		}
		return null;
	}",0,[0]
1590,Bears-192,"public void setStartTime(DateTime startTime) {
    this.startTime = startTime;
  }","public void setStartTime(DateTime startTime) {
    this.startTime = startTime;
  }",0,[0]
21871,bugs-dot-jar_MNG-2174_778f044e,"private List<ModelProperty> mixPluginAndReturnConfigAsProperties(Plugin plugin, Model model) throws IOException
   {
        List<DomainModel> domainModels = new ArrayList<DomainModel>();
        domainModels.add( new PluginMixin(plugin) );
        domainModels.add( new PomClassicDomainModel(model) );

        PomClassicTransformer transformer = new PomClassicTransformer( new PomClassicDomainModelFactory() );

        ModelTransformerContext ctx = new ModelTransformerContext(PomTransformer.MODEL_CONTAINER_INFOS );

        PomClassicDomainModel transformedDomainModel = ( (PomClassicDomainModel) ctx.transform( domainModels,
                                                                                                transformer,
                                                                                                transformer,
                                                                                                Collections.EMPTY_LIST,
                                                                                                null,
                                                                                                listeners ) );
        ModelDataSource source =
                new DefaultModelDataSource(transformedDomainModel.getModelProperties(), PomTransformer.MODEL_CONTAINER_FACTORIES);
        for(ModelContainer pluginContainer : source.queryFor(ProjectUri.Build.Plugins.Plugin.xUri))
        {
            if(matchesIdOfPlugin(pluginContainer, plugin))
            {
                List<ModelProperty> config = new ArrayList<ModelProperty>();
                for(ModelProperty mp : pluginContainer.getProperties())
                {
                    if(mp.getUri().startsWith(ProjectUri.Build.Plugins.Plugin.configuration))
                    {
                        config.add(mp);
                    }
                }
                return config;

            }
        }
        return new ArrayList<ModelProperty>();
   }","private List<ModelProperty> mixPluginAndReturnConfigAsProperties(Plugin plugin, Model model) throws IOException
   {
        List<DomainModel> domainModels = new ArrayList<DomainModel>();
        domainModels.add( new PluginMixin(plugin) );
        domainModels.add( new PomClassicDomainModel(model) );

        PomClassicTransformer transformer = new PomClassicTransformer( new PomClassicDomainModelFactory() );

        ModelTransformerContext ctx = new ModelTransformerContext(PomTransformer.MODEL_CONTAINER_INFOS );

        PomClassicDomainModel transformedDomainModel = ( (PomClassicDomainModel) ctx.transform( domainModels,
                                                                                                transformer,
                                                                                                transformer,
                                                                                                Collections.EMPTY_LIST,
                                                                                                null,
                                                                                                listeners ) );
        ModelDataSource source =
                new DefaultModelDataSource(transformedDomainModel.getModelProperties(), PomTransformer.MODEL_CONTAINER_FACTORIES);
        for(ModelContainer pluginContainer : source.queryFor(ProjectUri.Build.Plugins.Plugin.xUri))
        {
            if(matchesIdOfPlugin(pluginContainer, plugin))
            {
                List<ModelProperty> config = new ArrayList<ModelProperty>();
                for(ModelProperty mp : pluginContainer.getProperties())
                {
                    if(mp.getUri().startsWith(ProjectUri.Build.Plugins.Plugin.configuration))
                    {
                        config.add(mp);
                    }
                }
                return config;

            }
        }
        return new ArrayList<ModelProperty>();
   }",0,[0]
2395,bugs-dot-jar_OAK-225_e33328e0,"private Expression parseFunction(String functionName) throws ParseException {
        if (""jcr:like"".equals(functionName)) {
            Condition c = new Condition(parseExpression(), ""like"", null);
            read("","");
            c.right = parseExpression();
            read("")"");
            return c;
        } else if (""jcr:contains"".equals(functionName)) {
            Function f = new Function(""contains"");
            if (readIf(""."")) {
                // special case: jcr:contains(., expr)
                f.params.add(new Literal(""*""));
            } else {
                f.params.add(parseExpression());
            }
            read("","");
            f.params.add(parseExpression());
            read("")"");
            return f;
        } else if (""jcr:score"".equals(functionName)) {
            Function f = new Function(""score"");
            // TODO score: support parameters?
            read("")"");
            return f;
        } else if (""xs:dateTime"".equals(functionName)) {
            Expression expr = parseExpression();
            Cast c = new Cast(expr, ""date"");
            read("")"");
            return c;
        // } else if (""jcr:deref"".equals(functionName)) {
            // TODO support jcr:deref?
        } else {
            throw getSyntaxError(""jcr:like | jcr:contains | jcr:score | jcr:deref"");
        }
    }","private Expression parseFunction(String functionName) throws ParseException {
        if (""jcr:like"".equals(functionName)) {
            Condition c = new Condition(parseExpression(), ""like"", null);
            read("","");
            c.right = parseExpression();
            read("")"");
            return c;
        } else if (""jcr:contains"".equals(functionName)) {
            Function f = new Function(""contains"");
            if (readIf(""."")) {
                // special case: jcr:contains(., expr)
                f.params.add(new Literal(""*""));
            } else {
                f.params.add(parseExpression());
            }
            read("","");
            f.params.add(parseExpression());
            read("")"");
            return f;
        } else if (""jcr:score"".equals(functionName)) {
            Function f = new Function(""score"");
            // TODO score: support parameters?
            read("")"");
            return f;
        } else if (""xs:dateTime"".equals(functionName)) {
            Expression expr = parseExpression();
            Cast c = new Cast(expr, ""date"");
            read("")"");
            return c;
        } else if (""fn:lower-case"".equals(functionName)) {
            Function f = new Function(""lower"");
            f.params.add(parseExpression());
            read("")"");
            return f;
        } else if (""fn:upper-case"".equals(functionName)) {
            Function f = new Function(""upper"");
            f.params.add(parseExpression());
            read("")"");
            return f;
        // } else if (""jcr:deref"".equals(functionName)) {
            // TODO support jcr:deref?
        } else {
            throw getSyntaxError(""jcr:like | jcr:contains | jcr:score | jcr:deref | fn:lower-case | fn:upper-case"");
        }
    }",1,[32]
38543,bugs-dot-jar_CAMEL-9124_9da2c05a,"public String getLogExhausted() {
        return logExhausted;
    }","public String getLogExhausted() {
        return logExhausted;
    }",0,[0]
37403,bugs-dot-jar_CAMEL-4482_e38494f1,"protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());

        int index = 0;
        for (Processor processor : processors) {
            // copy exchange, and do not share the unit of work
            Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);

            // if we share unit of work, we need to prepare the child exchange
            if (isShareUnitOfWork()) {
                prepareSharedUnitOfWork(copy, exchange);
            }

            // and add the pair
            RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null;
            result.add(createProcessorExchangePair(index++, processor, copy, routeContext));
        }

        return result;
    }","protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {
        List<ProcessorExchangePair> result = new ArrayList<ProcessorExchangePair>(processors.size());

        int index = 0;
        for (Processor processor : processors) {
            // copy exchange, and do not share the unit of work
            Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);

            // if we share unit of work, we need to prepare the child exchange
            if (isShareUnitOfWork()) {
                prepareSharedUnitOfWork(copy, exchange);
            }

            // and add the pair
            RouteContext routeContext = exchange.getUnitOfWork() != null ? exchange.getUnitOfWork().getRouteContext() : null;
            result.add(createProcessorExchangePair(index++, processor, copy, routeContext));
        }

        if (exchange.getException() != null) {
            // force any exceptions occurred during creation of exchange paris to be thrown
            // before returning the answer;
            throw exchange.getException();
        }

        return result;
    }",1,[]
25628,bugs-dot-jar_LOG4J2-1251_424068f7,"@Override
    public void logp(final Level level, final String sourceClass, final String sourceMethod, final String msg,
                     final Object[] params) {
        log(level, msg, params);
    }","@Override
    public void logp(final Level level, final String sourceClass, final String sourceMethod, final String msg,
                     final Object[] params) {
        log(level, msg, params);
    }",0,[0]
16391,bugs-dot-jar_CAMEL-7163_5f726d0b,"public void addConditionalBreakpoint(String nodeId, String language, String predicate) {
        backlogDebugger.addConditionalBreakpoint(nodeId, language, predicate);
    }","public void addConditionalBreakpoint(String nodeId, String language, String predicate) {
        backlogDebugger.addConditionalBreakpoint(nodeId, language, predicate);
    }",0,[0]
7743,bugs-dot-jar_OAK-1104_7ae92779,"private static int getSize(int head) {
        return head & ((1 << MapRecord.SIZE_BITS) - 1);
    }","private static int getSize(int head) {
        return head & ((1 << MapRecord.SIZE_BITS) - 1);
    }",0,[0]
24190,bugs-dot-jar_LOG4J2-523_837dcd89,"public LocalizedMessage(final ResourceBundle bundle, final Locale locale, final String key,
                            final Object[] arguments) {
        this.messagePattern = key;
        this.argArray = arguments;
        this.throwable = null;
        this.baseName = null;
        this.resourceBundle = bundle;
        this.locale = locale;
    }","public LocalizedMessage(final ResourceBundle bundle, final Locale locale, final String key,
                            final Object[] arguments) {
        this.messagePattern = key;
        this.argArray = arguments;
        this.throwable = null;
        this.baseName = null;
        this.resourceBundle = bundle;
        this.locale = locale;
    }",0,[0]
32640,bugs-dot-jar_WICKET-4370_7ca927c1,"public void setCookies(final Cookie[] theCookies)
	{
		cookies.clear();
		cookies.addAll(Arrays.asList(theCookies));
	}","public void setCookies(final Cookie[] theCookies)
	{
		cookies.clear();
		cookies.addAll(Arrays.asList(theCookies));
	}",0,[0]
2688,bugs-dot-jar_OAK-1932_913c2f53,"protected final int getOffset(int position) {
        return getOffset() + position;
    }","protected final int getOffset(int position) {
        return getOffset() + position;
    }",0,[0]
37586,bugs-dot-jar_WICKET-3646_12124902,"private void onInternalDetach()
	{
		if (Session.exists())
		{
			Session.get().internalDetach();
		}

		if (Application.exists())
		{
			IRequestLogger requestLogger = Application.get().getRequestLogger();
			if (requestLogger != null)
			{
				requestLogger.requestTime((System.currentTimeMillis() - startTime));
			}
		}
	}","private void onInternalDetach()
	{
		if (Session.exists())
		{
			Session.get().internalDetach();
		}

		if (Application.exists())
		{
			IRequestLogger requestLogger = Application.get().getRequestLogger();
			if (requestLogger != null)
			{
				requestLogger.requestTime((System.currentTimeMillis() - startTime));
			}
		}
	}",0,[0]
37955,bugs-dot-jar_OAK-738_8ed779dc,"@Override
    @Nonnull
    public PropertyIterator getProperties(final String[] nameGlobs) throws RepositoryException {
        return perform(new ItemReadOperation<PropertyIterator>() {
            @Override
            public PropertyIterator perform() throws RepositoryException {
                Iterator<PropertyDelegate> propertyNames = Iterators.filter(dlg.getProperties(),
                        new Predicate<PropertyDelegate>() {
                            @Override
                            public boolean apply(PropertyDelegate entry) {
                                try {
                                    return ItemNameMatcher.matches(toJcrPath(entry.getName()), nameGlobs);
                                } catch (InvalidItemStateException e) {
                                    return false;
                                }
                            }
                        });

                return new PropertyIteratorAdapter(propertyIterator(propertyNames));
            }
        });
    }","@Override
    @Nonnull
    public PropertyIterator getProperties(final String[] nameGlobs) throws RepositoryException {
        return perform(new ItemReadOperation<PropertyIterator>() {
            @Override
            public PropertyIterator perform() throws RepositoryException {
                Iterator<PropertyDelegate> propertyNames = Iterators.filter(dlg.getProperties(),
                        new Predicate<PropertyDelegate>() {
                            @Override
                            public boolean apply(PropertyDelegate entry) {
                                try {
                                    return ItemNameMatcher.matches(toJcrPath(entry.getName()), nameGlobs);
                                } catch (InvalidItemStateException e) {
                                    return false;
                                }
                            }
                        });

                return new PropertyIteratorAdapter(propertyIterator(propertyNames));
            }
        });
    }",0,[0]
23538,bugs-dot-jar_LOG4J2-127_029e79da,"public void fatal(Marker marker, String message, Object... params) {
        if (isEnabled(Level.FATAL, marker, message, params)) {
            ParameterizedMessage msg = new ParameterizedMessage(message, params);
            log(marker, FQCN, Level.FATAL, msg, msg.getThrowable());
        }
    }","public void fatal(Marker marker, String message, Object... params) {
        if (isEnabled(Level.FATAL, marker, message, params)) {
            ParameterizedMessage msg = new ParameterizedMessage(message, params);
            log(marker, FQCN, Level.FATAL, msg, msg.getThrowable());
        }
    }",0,[0]
2848,bugs-dot-jar_OAK-1364_05c89637,"@Override
    @Nullable
    public V getIfPresent(Object key) {
        int hash = getHash(key);
        return getSegment(hash).get(key, hash);
    }","@Override
    @Nullable
    public V getIfPresent(Object key) {
        int hash = getHash(key);
        return getSegment(hash).get(key, hash);
    }",0,[0]
1570,Bears-192,"@JsonProperty(""end_time"")
  public void setEndTimeIso8601(String dateStr) {
    if (null != dateStr) {
      endTime = ISODateTimeFormat.dateTimeNoMillis().parseDateTime(dateStr);
    }
  }","@JsonProperty(""end_time"")
  public void setEndTimeIso8601(String dateStr) {
    if (null != dateStr) {
      endTime = ISODateTimeFormat.dateTimeNoMillis().parseDateTime(dateStr);
    }
  }",0,[0]
22674,bugs-dot-jar_WICKET-428_4a6a573b,"public void putAll(final Map map)
	{
		for (final Iterator iterator = map.entrySet().iterator(); iterator.hasNext();)
		{
			final Map.Entry e = (Map.Entry)iterator.next();
			put(e.getKey(), e.getValue());
		}
	}","public void putAll(final Map map)
	{
		for (final Iterator iterator = map.entrySet().iterator(); iterator.hasNext();)
		{
			final Map.Entry e = (Map.Entry)iterator.next();
			put(e.getKey(), e.getValue());
		}
	}",0,[0]
34499,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"long getCompactionCancelID() {
    String zTablePath = Constants.ZROOT + ""/"" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + ""/"" + extent.getTableId()
        + Constants.ZTABLE_COMPACT_CANCEL_ID;

    try {
      return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null), Constants.UTF8));
    } catch (KeeperException e) {
      throw new RuntimeException(e);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
  }","long getCompactionCancelID() {
    String zTablePath = Constants.ZROOT + ""/"" + HdfsZooInstance.getInstance().getInstanceID() + Constants.ZTABLES + ""/"" + extent.getTableId()
        + Constants.ZTABLE_COMPACT_CANCEL_ID;

    try {
      return Long.parseLong(new String(ZooReaderWriter.getRetryingInstance().getData(zTablePath, null), Constants.UTF8));
    } catch (KeeperException e) {
      throw new RuntimeException(e);
    } catch (InterruptedException e) {
      throw new RuntimeException(e);
    }
  }",0,[0]
14334,bugs-dot-jar_ACCUMULO-1730_872b6db3,"@Override
  public String toString() {
    return ""["" + new String(expression, Constants.UTF8) + ""]"";
  }","@Override
  public String toString() {
    return ""["" + new String(expression, Constants.UTF8) + ""]"";
  }",0,[0]
20453,bugs-dot-jar_WICKET-128_7e1000dd,"public final void setLocale(final Locale locale)
	{
		if (locale == null)
		{
			throw new IllegalArgumentException(""Parameter 'locale' must not be null"");
		}
		this.locale = locale;
		dirty();
	}","public final void setLocale(final Locale locale)
	{
		if (locale == null)
		{
			throw new IllegalArgumentException(""Parameter 'locale' must not be null"");
		}
		this.locale = locale;
		dirty();
	}",0,[0]
4326,bugs-dot-jar_CAMEL-4682_1e54865c,"private void doResumeRouteConsumers(Map<Integer, DefaultRouteStartupOrder> inputs, boolean addingRoutes) throws Exception {
        doStartOrResumeRouteConsumers(inputs, true, addingRoutes);
    }","private void doResumeRouteConsumers(Map<Integer, DefaultRouteStartupOrder> inputs, boolean addingRoutes) throws Exception {
        doStartOrResumeRouteConsumers(inputs, true, addingRoutes);
    }",0,[0]
6465,bugs-dot-jar_MATH-929_cedf0d27,"private double getExponentTerm(final double[] values) {
        final double[] centered = new double[values.length];
        for (int i = 0; i < centered.length; i++) {
            centered[i] = values[i] - getMeans()[i];
        }
        final double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);
        double sum = 0;
        for (int i = 0; i < preMultiplied.length; i++) {
            sum += preMultiplied[i] * centered[i];
        }
        return FastMath.exp(-0.5 * sum);
    }","private double getExponentTerm(final double[] values) {
        final double[] centered = new double[values.length];
        for (int i = 0; i < centered.length; i++) {
            centered[i] = values[i] - getMeans()[i];
        }
        final double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);
        double sum = 0;
        for (int i = 0; i < preMultiplied.length; i++) {
            sum += preMultiplied[i] * centered[i];
        }
        return FastMath.exp(-0.5 * sum);
    }",0,[0]
4135,bugs-dot-jar_OAK-3082_29e5b734,"@Nonnull
    private Principal getPrincipal(@Nonnull Tree aceTree) {
        String principalName = checkNotNull(TreeUtil.getString(aceTree, REP_PRINCIPAL_NAME));
        Principal principal = principalManager.getPrincipal(principalName);
        if (principal == null) {
            log.debug(""Unknown principal "" + principalName);
            principal = new PrincipalImpl(principalName);
        }
        return principal;
    }","@Nonnull
    private Principal getPrincipal(@Nonnull Tree aceTree) {
        String principalName = checkNotNull(TreeUtil.getString(aceTree, REP_PRINCIPAL_NAME));
        Principal principal = principalManager.getPrincipal(principalName);
        if (principal == null) {
            log.debug(""Unknown principal "" + principalName);
            principal = new PrincipalImpl(principalName);
        }
        return principal;
    }",0,[0]
25363,bugs-dot-jar_MATH-1257_03178c8b,"public NormalDistribution(double mean, double sd)
        throws NotStrictlyPositiveException {
        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
    }","public NormalDistribution(double mean, double sd)
        throws NotStrictlyPositiveException {
        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
    }",0,[0]
40716,bugs-dot-jar_ACCUMULO-821_a450ac2f,"MockScanner(MockTable table, Authorizations auths) {
    super(table, auths);
  }","MockScanner(MockTable table, Authorizations auths) {
    super(table, auths);
  }",0,[0]
16713,bugs-dot-jar_OAK-678_6c54045d,"@Override @Nonnull
    public NodeBuilder setNode(String name, NodeState state) {
        write();

        MutableNodeState childState = getWriteState(name);
        if (childState == null) {
            writeState.nodes.remove(name);
            childState = createChildBuilder(name).write(root.revision + 1, true);
        }
        childState.reset(state);

        updated();
        return this;
    }","@Override @Nonnull
    public NodeBuilder setNode(String name, NodeState state) {
        write();

        MutableNodeState childState = getWriteState(name);
        if (childState == null) {
            writeState.nodes.remove(name);
            childState = createChildBuilder(name).write(root.revision + 1, true);
        }
        childState.reset(state);

        updated();
        return this;
    }",0,[0]
656,bugs-dot-jar_MNG-5727_ce6f0bfd,"public ProjectBuildingResult build( Artifact artifact, boolean allowStubModel, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        org.eclipse.aether.artifact.Artifact pomArtifact = RepositoryUtils.toArtifact( artifact );
        pomArtifact = ArtifactDescriptorUtils.toPomArtifact( pomArtifact );

        InternalConfig config = new InternalConfig( request, null );

        boolean localProject;

        if ( request.isResolveVersionRanges() )
        {
            VersionRangeRequest versionRangeRequest = new VersionRangeRequest( pomArtifact, config.repositories, null );

            try
            {
                VersionRangeResult versionRangeResult =
                    repoSystem.resolveVersionRange( config.session, versionRangeRequest );

                if ( versionRangeResult.getHighestVersion() == null )
                {
                    throw new ProjectBuildingException(
                        artifact.getId(), ""Error resolving project artifact: No versions matched the requested range"",
                        (Throwable) null );

                }

                if ( versionRangeResult.getVersionConstraint() != null
                         && versionRangeResult.getVersionConstraint().getRange() != null
                         && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
                {
                    throw new ProjectBuildingException(
                        artifact.getId(),
                        ""Error resolving project artifact: The requested version range does not specify an upper bound"",
                        (Throwable) null );

                }

                pomArtifact = pomArtifact.setVersion( versionRangeResult.getHighestVersion().toString() );
            }
            catch ( VersionRangeResolutionException e )
            {
                throw new ProjectBuildingException(
                    artifact.getId(), ""Error resolving project artifact: "" + e.getMessage(), e );

            }
        }

        try
        {
            ArtifactRequest pomRequest = new ArtifactRequest();
            pomRequest.setArtifact( pomArtifact );
            pomRequest.setRepositories( config.repositories );
            ArtifactResult pomResult = repoSystem.resolveArtifact( config.session, pomRequest );

            pomArtifact = pomResult.getArtifact();
            localProject = pomResult.getRepository() instanceof WorkspaceRepository;
        }
        catch ( org.eclipse.aether.resolution.ArtifactResolutionException e )
        {
            if ( e.getResults().get( 0 ).isMissing() && allowStubModel )
            {
                return build( null, createStubModelSource( artifact ), config );
            }
            throw new ProjectBuildingException( artifact.getId(),
                                                ""Error resolving project artifact: "" + e.getMessage(), e );
        }

        File pomFile = pomArtifact.getFile();

        if ( ""pom"".equals( artifact.getType() ) )
        {
            artifact.selectVersion( pomArtifact.getVersion() );
            artifact.setFile( pomFile );
            artifact.setResolved( true );
        }

        return build( localProject ? pomFile : null, new FileModelSource( pomFile ), config );
    }","public ProjectBuildingResult build( Artifact artifact, boolean allowStubModel, ProjectBuildingRequest request )
        throws ProjectBuildingException
    {
        org.eclipse.aether.artifact.Artifact pomArtifact = RepositoryUtils.toArtifact( artifact );
        pomArtifact = ArtifactDescriptorUtils.toPomArtifact( pomArtifact );

        InternalConfig config = new InternalConfig( request, null );

        boolean localProject;

        if ( request.isResolveVersionRanges() )
        {
            VersionRangeRequest versionRangeRequest = new VersionRangeRequest( pomArtifact, config.repositories, null );

            try
            {
                VersionRangeResult versionRangeResult =
                    repoSystem.resolveVersionRange( config.session, versionRangeRequest );

                if ( versionRangeResult.getHighestVersion() == null )
                {
                    throw new ProjectBuildingException(
                        artifact.getId(), ""Error resolving project artifact: No versions matched the requested range"",
                        (Throwable) null );

                }

                if ( versionRangeResult.getVersionConstraint() != null
                         && versionRangeResult.getVersionConstraint().getRange() != null
                         && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null )
                {
                    throw new ProjectBuildingException(
                        artifact.getId(),
                        ""Error resolving project artifact: The requested version range does not specify an upper bound"",
                        (Throwable) null );

                }

                pomArtifact = pomArtifact.setVersion( versionRangeResult.getHighestVersion().toString() );
            }
            catch ( VersionRangeResolutionException e )
            {
                throw new ProjectBuildingException(
                    artifact.getId(), ""Error resolving project artifact: "" + e.getMessage(), e );

            }
        }

        try
        {
            ArtifactRequest pomRequest = new ArtifactRequest();
            pomRequest.setArtifact( pomArtifact );
            pomRequest.setRepositories( config.repositories );
            ArtifactResult pomResult = repoSystem.resolveArtifact( config.session, pomRequest );

            pomArtifact = pomResult.getArtifact();
            localProject = pomResult.getRepository() instanceof WorkspaceRepository;
        }
        catch ( org.eclipse.aether.resolution.ArtifactResolutionException e )
        {
            if ( e.getResults().get( 0 ).isMissing() && allowStubModel )
            {
                return build( null, createStubModelSource( artifact ), config );
            }
            throw new ProjectBuildingException( artifact.getId(),
                                                ""Error resolving project artifact: "" + e.getMessage(), e );
        }

        File pomFile = pomArtifact.getFile();

        if ( ""pom"".equals( artifact.getType() ) )
        {
            artifact.selectVersion( pomArtifact.getVersion() );
            artifact.setFile( pomFile );
            artifact.setResolved( true );
        }

        return build( localProject ? pomFile : null, new FileModelSource( pomFile ), config );
    }",0,[0]
22899,bugs-dot-jar_WICKET-4398_f88721fd,"@Deprecated
	public String toAbsoluteString(final Charset charset)
	{
		StringBuilder result = new StringBuilder();

		String protocol = this.protocol;
		if (Strings.isEmpty(protocol))
		{
			protocol = ""http"";
		}

		// output scheme://host:port if specified
		if (Strings.isEmpty(host) == false)
		{
			result.append(protocol);
			result.append(""://"");
			result.append(host);

			if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)
			{
				result.append(':');
				result.append(port);
			}
		}

		// append relative part
		return Strings.join(""/"", result.toString(), this.toString());
	}","@Deprecated
	public String toAbsoluteString(final Charset charset)
	{
		StringBuilder result = new StringBuilder();

		String protocol = this.protocol;
		if (Strings.isEmpty(protocol))
		{
			protocol = ""http"";
		}

		// output scheme://host:port if specified
		if (Strings.isEmpty(host) == false)
		{
			result.append(protocol);
			result.append(""://"");
			result.append(host);

			if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)
			{
				result.append(':');
				result.append(port);
			}
		}

		// append relative part
		return Strings.join(""/"", result.toString(), this.toString());
	}",0,[0]
40864,bugs-dot-jar_CAMEL-7622_faa20255,"public static AdviceWithTask removeById(final RouteDefinition route, final String id,
                                            boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchById(id);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doRemove(route, matchBy, it);
    }","public static AdviceWithTask removeById(final RouteDefinition route, final String id,
                                            boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchById(id);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doRemove(route, matchBy, it);
    }",0,[0]
229,bugs-dot-jar_WICKET-2368_fae1601b,"final void componentStateChanging(final Component component, Change change)
	{
		dirty();
		if (mayTrackChangesFor(component, null))
		{
			versionManager.componentStateChanging(change);
		}
	}","final void componentStateChanging(final Component component, Change change)
	{
		dirty();
		if (mayTrackChangesFor(component, null))
		{
			versionManager.componentStateChanging(change);
		}
	}",0,[0]
17288,bugs-dot-jar_MATH-414_5fe9b36c,"public NormalDistributionImpl(){
        this(0, 1);
    }","public NormalDistributionImpl(){
        this(0, 1);
    }",0,[0]
15712,bugs-dot-jar_CAMEL-7562_689147e9,"public static ScheduledExecutorService getConfiguredScheduledExecutorService(RouteContext routeContext, String name,
                                                               ExecutorServiceAwareDefinition<?> definition,
                                                               boolean useDefault) throws IllegalArgumentException {
        ExecutorServiceManager manager = routeContext.getCamelContext().getExecutorServiceManager();
        ObjectHelper.notNull(manager, ""ExecutorServiceManager"", routeContext.getCamelContext());

        // prefer to use explicit configured executor on the definition
        if (definition.getExecutorService() != null) {
            ExecutorService executorService = definition.getExecutorService();
            if (executorService instanceof ScheduledExecutorService) {
                return (ScheduledExecutorService) executorService;
            }
            throw new IllegalArgumentException(""ExecutorServiceRef "" + definition.getExecutorServiceRef() + "" is not an ScheduledExecutorService instance"");
        } else if (definition.getExecutorServiceRef() != null) {
            ScheduledExecutorService answer = lookupScheduledExecutorServiceRef(routeContext, name, definition, definition.getExecutorServiceRef());
            if (answer == null) {
                throw new IllegalArgumentException(""ExecutorServiceRef "" + definition.getExecutorServiceRef() + "" not found in registry or as a thread pool profile."");
            }
            return answer;
        } else if (useDefault) {
            return manager.newDefaultScheduledThreadPool(definition, name);
        }

        return null;
    }","public static ScheduledExecutorService getConfiguredScheduledExecutorService(RouteContext routeContext, String name,
                                                               ExecutorServiceAwareDefinition<?> definition,
                                                               boolean useDefault) throws IllegalArgumentException {
        ExecutorServiceManager manager = routeContext.getCamelContext().getExecutorServiceManager();
        ObjectHelper.notNull(manager, ""ExecutorServiceManager"", routeContext.getCamelContext());

        // prefer to use explicit configured executor on the definition
        if (definition.getExecutorService() != null) {
            ExecutorService executorService = definition.getExecutorService();
            if (executorService instanceof ScheduledExecutorService) {
                return (ScheduledExecutorService) executorService;
            }
            throw new IllegalArgumentException(""ExecutorServiceRef "" + definition.getExecutorServiceRef() + "" is not an ScheduledExecutorService instance"");
        } else if (definition.getExecutorServiceRef() != null) {
            ScheduledExecutorService answer = lookupScheduledExecutorServiceRef(routeContext, name, definition, definition.getExecutorServiceRef());
            if (answer == null) {
                throw new IllegalArgumentException(""ExecutorServiceRef "" + definition.getExecutorServiceRef() + "" not found in registry or as a thread pool profile."");
            }
            return answer;
        } else if (useDefault) {
            return manager.newDefaultScheduledThreadPool(definition, name);
        }

        return null;
    }",0,[0]
9630,bugs-dot-jar_CAMEL-5707_3f70d612,"public NotifyBuilder fromRoute(final String routeId) {
        stack.add(new EventPredicateSupport() {

            @Override
            public boolean isAbstract() {
                // is abstract as its a filter
                return true;
            }

            @Override
            public boolean onExchange(Exchange exchange) {
                String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());
                // filter non matching exchanges
                return EndpointHelper.matchPattern(id, routeId);
            }

            public boolean matches() {
                // should be true as we use the onExchange to filter
                return true;
            }

            @Override
            public String toString() {
                return ""fromRoute("" + routeId + "")"";
            }
        });
        return this;
    }","public NotifyBuilder fromRoute(final String routeId) {
        stack.add(new EventPredicateSupport() {

            @Override
            public boolean isAbstract() {
                // is abstract as its a filter
                return true;
            }

            @Override
            public boolean onExchange(Exchange exchange) {
                String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());
                // filter non matching exchanges
                return EndpointHelper.matchPattern(id, routeId);
            }

            public boolean matches() {
                // should be true as we use the onExchange to filter
                return true;
            }

            @Override
            public String toString() {
                return ""fromRoute("" + routeId + "")"";
            }
        });
        return this;
    }",0,[0]
11677,bugs-dot-jar_CAMEL-5796_de6dd425,"@Deprecated
    public WireTapDefinition<Type> wireTap(String uri, Expression body) {
        return wireTap(uri, true, body);
    }","@Deprecated
    public WireTapDefinition<Type> wireTap(String uri, Expression body) {
        return wireTap(uri, true, body);
    }",0,[0]
1926,bugs-dot-jar_CAMEL-3535_b56d2962,"@Override
    public String toString() {
        return ""AggregateProcessor[to: "" + processor + ""]"";
    }","@Override
    public String toString() {
        return ""AggregateProcessor[to: "" + processor + ""]"";
    }",0,[0]
16543,bugs-dot-jar_OAK-1977_4bfbfcdd,"public static Cursor newTraversingCursor(Filter filter,
                                             NodeState rootState) {
        return new TraversingCursor(filter, rootState);
    }","public static Cursor newTraversingCursor(Filter filter,
                                             NodeState rootState) {
        return new TraversingCursor(filter, rootState);
    }",0,[0]
15653,bugs-dot-jar_MATH-329_6dd3724b,"public long getCount(int v) {
        return getCount(Long.valueOf(v));
    }","public long getCount(int v) {
        return getCount(Long.valueOf(v));
    }",0,[0]
17423,bugs-dot-jar_MATH-1045_a4ffd393,"public EigenDecomposition(final RealMatrix matrix)
        throws MathArithmeticException {
        final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;
        isSymmetric = MatrixUtils.isSymmetric(matrix, symTol);
        if (isSymmetric) {
            transformToTridiagonal(matrix);
            findEigenVectors(transformer.getQ().getData());
        } else {
            final SchurTransformer t = transformToSchur(matrix);
            findEigenVectorsFromSchur(t);
        }
    }","public EigenDecomposition(final RealMatrix matrix)
        throws MathArithmeticException {
        final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;
        isSymmetric = MatrixUtils.isSymmetric(matrix, symTol);
        if (isSymmetric) {
            transformToTridiagonal(matrix);
            findEigenVectors(transformer.getQ().getData());
        } else {
            final SchurTransformer t = transformToSchur(matrix);
            findEigenVectorsFromSchur(t);
        }
    }",0,[0]
40863,bugs-dot-jar_CAMEL-7622_faa20255,"public static AdviceWithTask removeByToString(final RouteDefinition route, final String toString,
                                                  boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchByToString(toString);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doRemove(route, matchBy, it);
    }","public static AdviceWithTask removeByToString(final RouteDefinition route, final String toString,
                                                  boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchByToString(toString);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doRemove(route, matchBy, it);
    }",0,[0]
30752,bugs-dot-jar_OAK-2695_0598498e,"void copyTo(DocumentNodeState newNode) {
        newNode.properties.putAll(properties);
    }","void copyTo(DocumentNodeState newNode) {
        newNode.properties.putAll(properties);
    }",0,[0]
15415,bugs-dot-jar_MATH-555_328513f3,"public static long binomialCoefficient(final int n, final int k) {
        checkBinomial(n, k);
        if ((n == k) || (k == 0)) {
            return 1;
        }
        if ((k == 1) || (k == n - 1)) {
            return n;
        }
        // Use symmetry for large k
        if (k > n / 2)
            return binomialCoefficient(n, n - k);

        // We use the formula
        // (n choose k) = n! / (n-k)! / k!
        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
        // which could be written
        // (n choose k) == (n-1 choose k-1) * n / k
        long result = 1;
        if (n <= 61) {
            // For n <= 61, the naive implementation cannot overflow.
            int i = n - k + 1;
            for (int j = 1; j <= k; j++) {
                result = result * i / j;
                i++;
            }
        } else if (n <= 66) {
            // For n > 61 but n <= 66, the result cannot overflow,
            // but we must take care not to overflow intermediate values.
            int i = n - k + 1;
            for (int j = 1; j <= k; j++) {
                // We know that (result * i) is divisible by j,
                // but (result * i) may overflow, so we split j:
                // Filter out the gcd, d, so j/d and i/d are integer.
                // result is divisible by (j/d) because (j/d)
                // is relative prime to (i/d) and is a divisor of
                // result * (i/d).
                final long d = gcd(i, j);
                result = (result / (j / d)) * (i / d);
                i++;
            }
        } else {
            // For n > 66, a result overflow might occur, so we check
            // the multiplication, taking care to not overflow
            // unnecessary.
            int i = n - k + 1;
            for (int j = 1; j <= k; j++) {
                final long d = gcd(i, j);
                result = mulAndCheck(result / (j / d), i / d);
                i++;
            }
        }
        return result;
    }","public static long binomialCoefficient(final int n, final int k) {
        checkBinomial(n, k);
        if ((n == k) || (k == 0)) {
            return 1;
        }
        if ((k == 1) || (k == n - 1)) {
            return n;
        }
        // Use symmetry for large k
        if (k > n / 2)
            return binomialCoefficient(n, n - k);

        // We use the formula
        // (n choose k) = n! / (n-k)! / k!
        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
        // which could be written
        // (n choose k) == (n-1 choose k-1) * n / k
        long result = 1;
        if (n <= 61) {
            // For n <= 61, the naive implementation cannot overflow.
            int i = n - k + 1;
            for (int j = 1; j <= k; j++) {
                result = result * i / j;
                i++;
            }
        } else if (n <= 66) {
            // For n > 61 but n <= 66, the result cannot overflow,
            // but we must take care not to overflow intermediate values.
            int i = n - k + 1;
            for (int j = 1; j <= k; j++) {
                // We know that (result * i) is divisible by j,
                // but (result * i) may overflow, so we split j:
                // Filter out the gcd, d, so j/d and i/d are integer.
                // result is divisible by (j/d) because (j/d)
                // is relative prime to (i/d) and is a divisor of
                // result * (i/d).
                final long d = gcd(i, j);
                result = (result / (j / d)) * (i / d);
                i++;
            }
        } else {
            // For n > 66, a result overflow might occur, so we check
            // the multiplication, taking care to not overflow
            // unnecessary.
            int i = n - k + 1;
            for (int j = 1; j <= k; j++) {
                final long d = gcd(i, j);
                result = mulAndCheck(result / (j / d), i / d);
                i++;
            }
        }
        return result;
    }",0,[0]
17405,bugs-dot-jar_CAMEL-7018_3244c1e5,"@Override
    protected void doStart() throws Exception {
        super.doStart();

        // force creating queue when starting
        if (queue == null) {
            queue = getQueue();
        }

        // special for unit testing where we can set a system property to make seda poll faster
        // and therefore also react faster upon shutdown, which makes overall testing faster of the Camel project
        String override = System.getProperty(""CamelSedaPollTimeout"", """" + getPollTimeout());
        setPollTimeout(Integer.valueOf(override));
    }","@Override
    protected void doStart() throws Exception {
        super.doStart();

        // force creating queue when starting
        if (queue == null) {
            queue = getQueue();
        }

        // special for unit testing where we can set a system property to make seda poll faster
        // and therefore also react faster upon shutdown, which makes overall testing faster of the Camel project
        String override = System.getProperty(""CamelSedaPollTimeout"", """" + getPollTimeout());
        setPollTimeout(Integer.valueOf(override));
    }",0,[0]
9156,bugs-dot-jar_MATH-377_c640932d,"public RealMatrix getD() throws InvalidMatrixException {
        if (cachedD == null) {
            // cache the matrix for subsequent calls
            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);
        }
        return cachedD;
    }","public RealMatrix getD() throws InvalidMatrixException {
        if (cachedD == null) {
            // cache the matrix for subsequent calls
            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);
        }
        return cachedD;
    }",0,[0]
34478,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"private static long lookupCompactID(KeyExtent extent, SortedMap<Key,Value> tabletsKeyValues) {
    Text row = extent.getMetadataEntry();
    for (Entry<Key,Value> entry : tabletsKeyValues.entrySet()) {
      Key key = entry.getKey();
      if (key.getRow().equals(row) && TabletsSection.ServerColumnFamily.COMPACT_COLUMN.equals(key.getColumnFamily(), key.getColumnQualifier()))
        return Long.parseLong(entry.getValue().toString());
    }

    return -1;
  }","private static long lookupCompactID(KeyExtent extent, SortedMap<Key,Value> tabletsKeyValues) {
    Text row = extent.getMetadataEntry();
    for (Entry<Key,Value> entry : tabletsKeyValues.entrySet()) {
      Key key = entry.getKey();
      if (key.getRow().equals(row) && TabletsSection.ServerColumnFamily.COMPACT_COLUMN.equals(key.getColumnFamily(), key.getColumnQualifier()))
        return Long.parseLong(entry.getValue().toString());
    }

    return -1;
  }",0,[0]
1876,bugs-dot-jar_CAMEL-8146_17475d80,"@Override
    protected void doSuspend() throws Exception {
        // dont stop/cancel the future task since we just check in the run method
    }","@Override
    protected void doSuspend() throws Exception {
        // dont stop/cancel the future task since we just check in the run method
    }",0,[0]
8201,bugs-dot-jar_MATH-294_2c8a114f,"public void setSecureAlgorithm(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
        secRand = SecureRandom.getInstance(algorithm, provider);
    }","public void setSecureAlgorithm(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
        secRand = SecureRandom.getInstance(algorithm, provider);
    }",0,[0]
34848,bugs-dot-jar_CAMEL-8964_ea8ee025,"public static void startServices(Object... services) throws Exception {
        if (services == null) {
            return;
        }
        List<Object> list = Arrays.asList(services);
        startServices(list);
    }","public static void startServices(Object... services) throws Exception {
        if (services == null) {
            return;
        }
        List<Object> list = Arrays.asList(services);
        startServices(list);
    }",0,[0]
21054,bugs-dot-jar_OAK-846_7acb091a,"@Override
    public synchronized String commit(String rootPath, String json, String baseRevId,
            String message) throws MicroKernelException {
        Revision baseRev;
        if (baseRevId == null) {
            baseRev = headRevision;
            baseRevId = baseRev.toString();
        } else {
            baseRev = Revision.fromString(stripBranchRevMarker(baseRevId));
        }
        JsopReader t = new JsopTokenizer(json);
        Revision rev = newRevision();
        Commit commit = new Commit(this, baseRev, rev);
        while (true) {
            int r = t.read();
            if (r == JsopReader.END) {
                break;
            }
            String path = PathUtils.concat(rootPath, t.readString());
            switch (r) {
            case '+':
                t.read(':');
                t.read('{');
                parseAddNode(commit, t, path);
                break;
            case '-':
                commit.removeNode(path);
                markAsDeleted(path, commit, true);
                commit.removeNodeDiff(path);
                break;
            case '^':
                t.read(':');
                String value;
                if (t.matches(JsopReader.NULL)) {
                    value = null;
                } else {
                    value = t.readRawValue().trim();
                }
                String p = PathUtils.getParentPath(path);
                String propertyName = PathUtils.getName(path);
                commit.updateProperty(p, propertyName, value);
                commit.updatePropertyDiff(p, propertyName, value);
                break;
            case '>': {
                // TODO support moving nodes that were modified within this commit
                t.read(':');
                String sourcePath = path;
                String targetPath = t.readString();
                if (!PathUtils.isAbsolute(targetPath)) {
                    targetPath = PathUtils.concat(rootPath, targetPath);
                }
                if (!nodeExists(sourcePath, baseRevId)) {
                    throw new MicroKernelException(""Node not found: "" + sourcePath + "" in revision "" + baseRevId);
                } else if (nodeExists(targetPath, baseRevId)) {
                    throw new MicroKernelException(""Node already exists: "" + targetPath + "" in revision "" + baseRevId);
                }
                commit.moveNode(sourcePath, targetPath);
                moveNode(sourcePath, targetPath, baseRev, commit);
                break;
            }
            case '*': {
                // TODO support copying nodes that were modified within this commit
                t.read(':');
                String sourcePath = path;
                String targetPath = t.readString();
                if (!PathUtils.isAbsolute(targetPath)) {
                    targetPath = PathUtils.concat(rootPath, targetPath);
                }
                if (!nodeExists(sourcePath, baseRevId)) {
                    throw new MicroKernelException(""Node not found: "" + sourcePath + "" in revision "" + baseRevId);
                } else if (nodeExists(targetPath, baseRevId)) {
                    throw new MicroKernelException(""Node already exists: "" + targetPath + "" in revision "" + baseRevId);
                }
                commit.copyNode(sourcePath, targetPath);
                copyNode(sourcePath, targetPath, baseRev, commit);
                break;
            }
            default:
                throw new MicroKernelException(""token: "" + (char) t.getTokenType());
            }
        }
        if (baseRevId.startsWith(""b"")) {
            // remember branch commit
            Branch b = branches.getBranch(baseRev);
            if (b == null) {
                b = branches.create(baseRev, rev);
            } else {
                b.addCommit(rev);
            }
            boolean success = false;
            try {
                // prepare commit
                commit.prepare(baseRev);
                success = true;
            } finally {
                if (!success) {
                    b.removeCommit(rev);
                    if (b.getCommits().isEmpty()) {
                        branches.remove(b);
                    }
                }
            }

            return ""b"" + rev.toString();
        }
        commit.apply();
        headRevision = commit.getRevision();
        return rev.toString();
    }","@Override
    public synchronized String commit(String rootPath, String json, String baseRevId,
            String message) throws MicroKernelException {
        Revision baseRev;
        if (baseRevId == null) {
            baseRev = headRevision;
            baseRevId = baseRev.toString();
        } else {
            baseRev = Revision.fromString(stripBranchRevMarker(baseRevId));
        }
        JsopReader t = new JsopTokenizer(json);
        Revision rev = newRevision();
        Commit commit = new Commit(this, baseRev, rev);
        while (true) {
            int r = t.read();
            if (r == JsopReader.END) {
                break;
            }
            String path = PathUtils.concat(rootPath, t.readString());
            switch (r) {
            case '+':
                t.read(':');
                t.read('{');
                parseAddNode(commit, t, path);
                break;
            case '-':
                commit.removeNode(path);
                markAsDeleted(path, commit, true);
                commit.removeNodeDiff(path);
                break;
            case '^':
                t.read(':');
                String value;
                if (t.matches(JsopReader.NULL)) {
                    value = null;
                } else {
                    value = t.readRawValue().trim();
                }
                String p = PathUtils.getParentPath(path);
                String propertyName = PathUtils.getName(path);
                commit.updateProperty(p, propertyName, value);
                commit.updatePropertyDiff(p, propertyName, value);
                break;
            case '>': {
                // TODO support moving nodes that were modified within this commit
                t.read(':');
                String sourcePath = path;
                String targetPath = t.readString();
                if (!PathUtils.isAbsolute(targetPath)) {
                    targetPath = PathUtils.concat(rootPath, targetPath);
                }
                if (!nodeExists(sourcePath, baseRevId)) {
                    throw new MicroKernelException(""Node not found: "" + sourcePath + "" in revision "" + baseRevId);
                } else if (nodeExists(targetPath, baseRevId)) {
                    throw new MicroKernelException(""Node already exists: "" + targetPath + "" in revision "" + baseRevId);
                }
                commit.moveNode(sourcePath, targetPath);
                moveNode(sourcePath, targetPath, baseRev, commit);
                break;
            }
            case '*': {
                // TODO support copying nodes that were modified within this commit
                t.read(':');
                String sourcePath = path;
                String targetPath = t.readString();
                if (!PathUtils.isAbsolute(targetPath)) {
                    targetPath = PathUtils.concat(rootPath, targetPath);
                }
                if (!nodeExists(sourcePath, baseRevId)) {
                    throw new MicroKernelException(""Node not found: "" + sourcePath + "" in revision "" + baseRevId);
                } else if (nodeExists(targetPath, baseRevId)) {
                    throw new MicroKernelException(""Node already exists: "" + targetPath + "" in revision "" + baseRevId);
                }
                commit.copyNode(sourcePath, targetPath);
                copyNode(sourcePath, targetPath, baseRev, commit);
                break;
            }
            default:
                throw new MicroKernelException(""token: "" + (char) t.getTokenType());
            }
        }
        if (baseRevId.startsWith(""b"")) {
            // remember branch commit
            Branch b = branches.getBranch(baseRev);
            if (b == null) {
                b = branches.create(baseRev, rev);
            } else {
                b.addCommit(rev);
            }
            boolean success = false;
            try {
                // prepare commit
                commit.prepare(baseRev);
                success = true;
            } finally {
                if (!success) {
                    b.removeCommit(rev);
                    if (b.getCommits().isEmpty()) {
                        branches.remove(b);
                    }
                }
            }

            return ""b"" + rev.toString();
        }
        commit.apply();
        headRevision = commit.getRevision();
        return rev.toString();
    }",0,[0]
22779,bugs-dot-jar_OAK-537_a8493efc,"public Set<String> find(String name, PropertyValue value) {
        Set<String> paths = Sets.newHashSet();

        NodeState state = getIndexDefinitionNode(name);
        if (state != null && state.getChildNode("":index"") != null) {
            state = state.getChildNode("":index"");
            if (value == null) {
                paths.addAll(store.find(state, null));
            } else {
                paths.addAll(store.find(state, Property2Index.encode(value)));
            }
        } else {
            // No index available, so first check this node for a match
            PropertyState property = root.getProperty(name);
            if (property != null) {
                if (value == null || value.isArray()) {
                    // let query engine handle property existence and
                    // multi-valued look ups;
                    // simply return all nodes that have this property
                    paths.add("""");
                } else {
                    // does it match any of the values of this property?
                    for (int i = 0; i < property.count(); i++) {
                        if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {
                            paths.add("""");
                            // no need to check for more matches in this property
                            break;
                        }
                    }
                }
            }

            // ... and then recursively look up from the rest of the tree
            for (ChildNodeEntry entry : root.getChildNodeEntries()) {
                String base = entry.getName();
                Property2IndexLookup lookup =
                        new Property2IndexLookup(entry.getNodeState());
                for (String path : lookup.find(name, value)) {
                    if (path.isEmpty()) {
                        paths.add(base);
                    } else {
                        paths.add(base + ""/"" + path);
                    }
                }
            }
        }

        return paths;
    }","public Set<String> find(String name, PropertyValue value) {
        NodeState state = getIndexDefinitionNode(root, name);
        if (state == null || state.getChildNode("":index"") == null) {
            throw new IllegalArgumentException(""No index for "" + name);
        }
        Set<String> paths = Sets.newHashSet();
        state = state.getChildNode("":index"");
        if (value == null) {
            paths.addAll(store.find(state, null));
        } else {
            paths.addAll(store.find(state, Property2Index.encode(value)));
        }
        return paths;
    }",1,"[3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44]"
11,bugs-dot-jar_LOG4J2-104_3b12e13d,"private static ClassLoader findClassLoader() {
        ClassLoader cl;
        if (System.getSecurityManager() == null) {
            cl = Thread.currentThread().getContextClassLoader();
        } else {
            cl = java.security.AccessController.doPrivileged(
                new java.security.PrivilegedAction<ClassLoader>() {
                    public ClassLoader run() {
                        return Thread.currentThread().getContextClassLoader();
                    }
                }
            );
        }
        if (cl == null) {
            cl = LogManager.class.getClassLoader();
        }

        return cl;
    }","private static ClassLoader findClassLoader() {
        ClassLoader cl;
        if (System.getSecurityManager() == null) {
            cl = Thread.currentThread().getContextClassLoader();
        } else {
            cl = java.security.AccessController.doPrivileged(
                new java.security.PrivilegedAction<ClassLoader>() {
                    public ClassLoader run() {
                        return Thread.currentThread().getContextClassLoader();
                    }
                }
            );
        }
        if (cl == null) {
            cl = LogManager.class.getClassLoader();
        }

        return cl;
    }",0,[0]
33085,bugs-dot-jar_WICKET-5759_0374c040,"private void renderExtraHeaderContributors(final Component component,
		final IHeaderResponse response)
	{
		AjaxRequestAttributes attributes = getAttributes();

		List<IAjaxCallListener> ajaxCallListeners = attributes.getAjaxCallListeners();
		for (IAjaxCallListener ajaxCallListener : ajaxCallListeners)
		{
			if (ajaxCallListener instanceof IComponentAwareHeaderContributor)
			{
				IComponentAwareHeaderContributor contributor = (IComponentAwareHeaderContributor)ajaxCallListener;
				contributor.renderHead(component, response);
			}
		}
	}","private void renderExtraHeaderContributors(final Component component,
		final IHeaderResponse response)
	{
		AjaxRequestAttributes attributes = getAttributes();

		List<IAjaxCallListener> ajaxCallListeners = attributes.getAjaxCallListeners();
		for (IAjaxCallListener ajaxCallListener : ajaxCallListeners)
		{
			if (ajaxCallListener instanceof IComponentAwareHeaderContributor)
			{
				IComponentAwareHeaderContributor contributor = (IComponentAwareHeaderContributor)ajaxCallListener;
				contributor.renderHead(component, response);
			}
		}
	}",0,[0]
32694,bugs-dot-jar_CAMEL-3617_02626724,"public void fatalError(SAXParseException exception) throws SAXException {
        throw exception;
    }","public void fatalError(SAXParseException exception) throws SAXException {
        throw exception;
    }",0,[0]
1942,Bears-232,"public static short packShort(byte[] a, byte pad) {
        return (short)pack(a, pad, 2);
    }","public static short packShort(byte[] a, byte pad) {
        return (short)pack(a, pad, 2);
    }",0,[0]
25644,bugs-dot-jar_LOG4J2-1251_424068f7,"@Override
    public void fine(final String msg) {
        logger.logIfEnabled(FQCN, org.apache.logging.log4j.Level.DEBUG, null, msg);
    }","@Override
    public void fine(final String msg) {
        logger.logIfEnabled(FQCN, org.apache.logging.log4j.Level.DEBUG, null, msg);
    }",0,[0]
18847,bugs-dot-jar_MATH-935_48dde378,"public void sinh(final double[] operand, final int operandOffset,
                     final double[] result, final int resultOffset) {

        // create the function value and derivatives
        double[] function = new double[1 + order];
        function[0] = FastMath.sinh(operand[operandOffset]);
        if (order > 0) {
            function[1] = FastMath.cosh(operand[operandOffset]);
            for (int i = 2; i <= order; ++i) {
                function[i] = function[i - 2];
            }
        }

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }","public void sinh(final double[] operand, final int operandOffset,
                     final double[] result, final int resultOffset) {

        // create the function value and derivatives
        double[] function = new double[1 + order];
        function[0] = FastMath.sinh(operand[operandOffset]);
        if (order > 0) {
            function[1] = FastMath.cosh(operand[operandOffset]);
            for (int i = 2; i <= order; ++i) {
                function[i] = function[i - 2];
            }
        }

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }",0,[0]
18803,bugs-dot-jar_OAK-2427_e6d4f9a6,"public void setSelectors(ArrayList<Selector> selectors) {
        this.selectors = selectors;
    }","public void setSelectors(ArrayList<Selector> selectors) {
        this.selectors = selectors;
    }",0,[0]
28374,bugs-dot-jar_WICKET-3511_4a875f46,"public ResourceNameIterator newResourceNameIterator(String path, Locale locale, String style,
		String variation, String extension, boolean strict)
	{
		return delegate.newResourceNameIterator(path, locale, style, variation, extension, strict);
	}","public ResourceNameIterator newResourceNameIterator(String path, Locale locale, String style,
		String variation, String extension, boolean strict)
	{
		return delegate.newResourceNameIterator(path, locale, style, variation, extension, strict);
	}",0,[0]
4492,bugs-dot-jar_OAK-2420_24cb1908,"public void dispose() {
        if (isDisposed.getAndSet(true)) {
            // only dispose once
            return;
        }
        // notify background threads waiting on isDisposed
        synchronized (isDisposed) {
            isDisposed.notifyAll();
        }
        try {
            backgroundThread.join();
        } catch (InterruptedException e) {
            // ignore
        }

        // do a final round of background operations after
        // the background thread stopped
        internalRunBackgroundOperations();

        if (leaseUpdateThread != null) {
            try {
                leaseUpdateThread.join();
            } catch (InterruptedException e) {
                // ignore
            }
        }

        // now mark this cluster node as inactive by
        // disposing the clusterNodeInfo
        if (clusterNodeInfo != null) {
            clusterNodeInfo.dispose();
        }
        store.dispose();

        if (blobStore instanceof Closeable) {
            try {
                ((Closeable) blobStore).close();
            } catch (IOException ex) {
                LOG.debug(""Error closing blob store "" + blobStore, ex);
            }
        }
        if (persistentCache != null) {
            persistentCache.close();
        }
        LOG.info(""Disposed DocumentNodeStore with clusterNodeId: {}"", clusterId);
    }","public void dispose() {
        if (isDisposed.getAndSet(true)) {
            // only dispose once
            return;
        }
        // notify background threads waiting on isDisposed
        synchronized (isDisposed) {
            isDisposed.notifyAll();
        }
        try {
            backgroundThread.join();
        } catch (InterruptedException e) {
            // ignore
        }

        // do a final round of background operations after
        // the background thread stopped
        internalRunBackgroundOperations();

        if (leaseUpdateThread != null) {
            try {
                leaseUpdateThread.join();
            } catch (InterruptedException e) {
                // ignore
            }
        }

        // now mark this cluster node as inactive by
        // disposing the clusterNodeInfo
        if (clusterNodeInfo != null) {
            clusterNodeInfo.dispose();
        }
        store.dispose();

        if (blobStore instanceof Closeable) {
            try {
                ((Closeable) blobStore).close();
            } catch (IOException ex) {
                LOG.debug(""Error closing blob store "" + blobStore, ex);
            }
        }
        if (persistentCache != null) {
            persistentCache.close();
        }
        LOG.info(""Disposed DocumentNodeStore with clusterNodeId: {}"", clusterId);
    }",0,[0]
10770,bugs-dot-jar_OAK-1035_b2ca8baa,"@Override
    public void update(
            NodeBuilder index, String path,
            Set<String> beforeKeys, Set<String> afterKeys) {
        for (String key : beforeKeys) {
            remove(index, key, path);
        }
        for (String key : afterKeys) {
            insert(index, key, path);
        }
    }","@Override
    public void update(
            NodeBuilder index, String path,
            Set<String> beforeKeys, Set<String> afterKeys) {
        for (String key : beforeKeys) {
            remove(index, key, path);
        }
        for (String key : afterKeys) {
            insert(index, key, path);
        }
    }",0,[0]
90,bugs-dot-jar_OAK-1822_3e83a4c1,"boolean isDelete() {
        return isDelete;
    }","boolean isDelete() {
        return isDelete;
    }",0,[0]
22069,bugs-dot-jar_MATH-779_ebadb558,"protected List<Chromosome> getChromosomeList() {
        return chromosomes;
    }","protected List<Chromosome> getChromosomeList() {
        return chromosomes;
    }",0,[0]
11448,bugs-dot-jar_ACCUMULO-1800_8ec4cb84,"@Override
  public void addSplits(ByteBuffer login, String tableName, Set<ByteBuffer> splits) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException, TException {
    
    try {
      SortedSet<Text> sorted = new TreeSet<Text>();
      for (ByteBuffer split : splits) {
        sorted.add(ByteBufferUtil.toText(split));
      }
      getConnector(login).tableOperations().addSplits(tableName, sorted);
    } catch (Exception e) {
      handleExceptionTNF(e);
    }
  }","@Override
  public void addSplits(ByteBuffer login, String tableName, Set<ByteBuffer> splits) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException, TException {
    
    try {
      SortedSet<Text> sorted = new TreeSet<Text>();
      for (ByteBuffer split : splits) {
        sorted.add(ByteBufferUtil.toText(split));
      }
      getConnector(login).tableOperations().addSplits(tableName, sorted);
    } catch (Exception e) {
      handleExceptionTNF(e);
    }
  }",0,[0]
38144,bugs-dot-jar_CAMEL-3314_4badd9c5,"protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorDefinition<?> output : outputs) {
            Processor processor = null;
            // at first use custom factory
            if (routeContext.getCamelContext().getProcessorFactory() != null) {
                processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);
            }
            // fallback to default implementation if factory did not create the processor
            if (processor == null) {
                processor = output.createProcessor(routeContext);
            }

            if (output instanceof Channel && processor == null) {
                continue;
            }

            Processor channel = wrapChannel(routeContext, processor, output);
            list.add(channel);
        }

        // if more than one output wrap than in a composite processor else just keep it as is
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(routeContext, list);
            }
        }

        return processor;
    }","protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorDefinition<?> output : outputs) {

            // resolve properties before we create the processor
            resolvePropertyPlaceholders(routeContext, output);

            Processor processor = null;
            // at first use custom factory
            if (routeContext.getCamelContext().getProcessorFactory() != null) {
                processor = routeContext.getCamelContext().getProcessorFactory().createProcessor(routeContext, output);
            }
            // fallback to default implementation if factory did not create the processor
            if (processor == null) {
                processor = output.createProcessor(routeContext);
            }

            if (output instanceof Channel && processor == null) {
                continue;
            }

            Processor channel = wrapChannel(routeContext, processor, output);
            list.add(channel);
        }

        // if more than one output wrap than in a composite processor else just keep it as is
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(routeContext, list);
            }
        }

        return processor;
    }",1,[]
1311,Bears-158,"public void setLongitude(Double longitude) {
        setCellAsDouble(Longitude, longitude);
    }","public void setLongitude(Double longitude) {
        setCellAsDouble(Longitude, longitude);
    }",0,[0]
10280,bugs-dot-jar_OAK-3897_94c6c575,"void runBackgroundReadOperations() {
        if (isDisposed.get()) {
            return;
        }
        try {
            internalRunBackgroundReadOperations();
        } catch (RuntimeException e) {
            if (isDisposed.get()) {
                LOG.warn(""Background read operation failed: "" + e.toString(), e);
                return;
            }
            throw e;
        }
    }","void runBackgroundReadOperations() {
        if (isDisposed.get()) {
            return;
        }
        try {
            internalRunBackgroundReadOperations();
        } catch (RuntimeException e) {
            if (isDisposed.get()) {
                LOG.warn(""Background read operation failed: "" + e.toString(), e);
                return;
            }
            throw e;
        }
    }",0,[0]
33596,bugs-dot-jar_WICKET-4520_b91154ea,"public final void setStoreSettings(final IStoreSettings storeSettings)
	{
		this.storeSettings = storeSettings;
	}","public final void setStoreSettings(final IStoreSettings storeSettings)
	{
		this.storeSettings = storeSettings;
	}",0,[0]
11739,bugs-dot-jar_CAMEL-5796_de6dd425,"public void setParent(ProcessorDefinition<?> parent) {
        this.parent = parent;
    }","public void setParent(ProcessorDefinition<?> parent) {
        this.parent = parent;
    }",0,[0]
6497,bugs-dot-jar_MNG-5645_af1ecd5f,"public String getQualifier()
    {
        return qualifier;
    }","public String getQualifier()
    {
        return qualifier;
    }",0,[0]
10097,bugs-dot-jar_WICKET-4292_9cb617ae,"@Override
	public boolean isCommitted()
	{
		return false;
	}","@Override
	public boolean isCommitted()
	{
		return false;
	}",0,[0]
10395,bugs-dot-jar_CAMEL-6667_1fc7bd7a,"@Override
    public boolean process(Exchange exchange, AsyncCallback callback) {
        // use atomic integer to be able to pass reference and keep track on the values
        AtomicInteger index = new AtomicInteger();
        AtomicInteger count = new AtomicInteger();

        // Intermediate conversion to String is needed when direct conversion to Integer is not available
        // but evaluation result is a textual representation of a numeric value.
        String text = expression.evaluate(exchange, String.class);
        try {
            int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);
            count.set(num);
        } catch (NoTypeConversionAvailableException e) {
            exchange.setException(e);
            callback.done(true);
            return true;
        }

        Exchange target = exchange;

        // set the size before we start
        exchange.setProperty(Exchange.LOOP_SIZE, count);

        // loop synchronously
        while (index.get() < count.get()) {

            // and prepare for next iteration
            target = prepareExchange(exchange, index.get());
            boolean sync = process(target, callback, index, count);

            if (!sync) {
                LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
                // the remainder of the routing slip will be completed async
                // so we break out now, then the callback will be invoked which then continue routing from where we left here
                return false;
            }

            LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", target.getExchangeId());

            // increment counter before next loop
            index.getAndIncrement();
        }

        // we are done so prepare the result
        ExchangeHelper.copyResults(exchange, target);
        LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
        callback.done(true);
        return true;
    }","@Override
    public boolean process(Exchange exchange, AsyncCallback callback) {
        // use atomic integer to be able to pass reference and keep track on the values
        AtomicInteger index = new AtomicInteger();
        AtomicInteger count = new AtomicInteger();

        // Intermediate conversion to String is needed when direct conversion to Integer is not available
        // but evaluation result is a textual representation of a numeric value.
        String text = expression.evaluate(exchange, String.class);
        try {
            int num = ExchangeHelper.convertToMandatoryType(exchange, Integer.class, text);
            count.set(num);
        } catch (NoTypeConversionAvailableException e) {
            exchange.setException(e);
            callback.done(true);
            return true;
        }
        
        // we hold on to the original Exchange in case it's needed for copies
        final Exchange original = exchange;
        
        // per-iteration exchange
        Exchange target = exchange;

        // set the size before we start
        exchange.setProperty(Exchange.LOOP_SIZE, count);

        // loop synchronously
        while (index.get() < count.get()) {

            // and prepare for next iteration
            // if (!copy) target = exchange; else copy of original
            target = prepareExchange(exchange, index.get(), original);
            boolean sync = process(target, callback, index, count, original);

            if (!sync) {
                LOG.trace(""Processing exchangeId: {} is continued being processed asynchronously"", target.getExchangeId());
                // the remainder of the routing slip will be completed async
                // so we break out now, then the callback will be invoked which then continue routing from where we left here
                return false;
            }

            LOG.trace(""Processing exchangeId: {} is continued being processed synchronously"", target.getExchangeId());

            // increment counter before next loop
            index.getAndIncrement();
        }

        // we are done so prepare the result
        ExchangeHelper.copyResults(exchange, target);
        LOG.trace(""Processing complete for exchangeId: {} >>> {}"", exchange.getExchangeId(), exchange);
        callback.done(true);
        return true;
    }",1,"[27, 28]"
5848,bugs-dot-jar_MATH-859_66dece12,"public double density(double x) {
        final double nhalf = numeratorDegreesOfFreedom / 2;
        final double mhalf = denominatorDegreesOfFreedom / 2;
        final double logx = FastMath.log(x);
        final double logn = FastMath.log(numeratorDegreesOfFreedom);
        final double logm = FastMath.log(denominatorDegreesOfFreedom);
        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +
                                           denominatorDegreesOfFreedom);
        return FastMath.exp(nhalf * logn + nhalf * logx - logx +
                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -
                            Beta.logBeta(nhalf, mhalf));
    }","public double density(double x) {
        final double nhalf = numeratorDegreesOfFreedom / 2;
        final double mhalf = denominatorDegreesOfFreedom / 2;
        final double logx = FastMath.log(x);
        final double logn = FastMath.log(numeratorDegreesOfFreedom);
        final double logm = FastMath.log(denominatorDegreesOfFreedom);
        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +
                                           denominatorDegreesOfFreedom);
        return FastMath.exp(nhalf * logn + nhalf * logx - logx +
                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -
                            Beta.logBeta(nhalf, mhalf));
    }",0,[0]
1830,Bears-211,"@SuppressWarnings(""resource"")
    @Override
    public CBORParser createParser(File f) throws IOException {
        return _createParser(new FileInputStream(f), _createContext(f, true));
    }","@SuppressWarnings(""resource"")
    @Override
    public CBORParser createParser(File f) throws IOException {
        IOContext ctxt = _createContext(f, true);
        return _createParser(_decorate(new FileInputStream(f), ctxt), ctxt);
    }",1,[3]
38775,bugs-dot-jar_FLINK-2567_948b6e05,"protected GenericCsvInputFormat(Path filePath) {
		super(filePath);
	}","protected GenericCsvInputFormat(Path filePath) {
		super(filePath);
	}",0,[0]
8016,bugs-dot-jar_ACCUMULO-3242_15e83709,"public static boolean isLockHeld(ZooKeeperConnectionInfo info, LockID lid) throws KeeperException, InterruptedException {
    final Retry retry = RETRY_FACTORY.create();
    while (true) {
      try {
        List<String> children = getZooKeeper(info).getChildren(lid.path, false);

        if (children.size() == 0) {
          return false;
        }

        Collections.sort(children);

        String lockNode = children.get(0);
        if (!lid.node.equals(lockNode))
          return false;

        Stat stat = getZooKeeper(info).exists(lid.path + ""/"" + lid.node, false);
        return stat != null && stat.getEphemeralOwner() == lid.eid;
      } catch (KeeperException ex) {
        final Code c = ex.code();
        if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {
          retryOrThrow(retry, ex);
        }
      }

      retry.waitForNextAttempt();
    }
  }","public static boolean isLockHeld(ZooKeeperConnectionInfo info, LockID lid) throws KeeperException, InterruptedException {
    final Retry retry = RETRY_FACTORY.create();
    while (true) {
      try {
        List<String> children = getZooKeeper(info).getChildren(lid.path, false);

        if (children.size() == 0) {
          return false;
        }

        Collections.sort(children);

        String lockNode = children.get(0);
        if (!lid.node.equals(lockNode))
          return false;

        Stat stat = getZooKeeper(info).exists(lid.path + ""/"" + lid.node, false);
        return stat != null && stat.getEphemeralOwner() == lid.eid;
      } catch (KeeperException ex) {
        final Code c = ex.code();
        if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {
          retryOrThrow(retry, ex);
        }
      }

      retry.waitForNextAttempt();
    }
  }",0,[0]
23372,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public boolean removeAll(final Collection<?> objects) {
        if (!useStack || objects.isEmpty()) {
            return false;
        }
        final List<String> list = stack.get();
        if (list == null || list.isEmpty()) {
            return false;
        }
        final List<String> copy = new ArrayList<String>(list);
        final boolean result = copy.removeAll(objects);
        stack.set(Collections.unmodifiableList(copy));
        return result;
    }","@Override
    public boolean removeAll(final Collection<?> objects) {
        if (!useStack || objects.isEmpty()) {
            return false;
        }
        final List<String> list = stack.get();
        if (list == null || list.isEmpty()) {
            return false;
        }
        final List<String> copy = new ArrayList<String>(list);
        final boolean result = copy.removeAll(objects);
        stack.set(Collections.unmodifiableList(copy));
        return result;
    }",0,[0]
26341,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    @Nonnull
    public NodeType getPrimaryNodeType() throws RepositoryException {
        return perform(new NodeOperation<NodeType>(dlg, ""getPrimaryNodeType"") {
            @Nonnull
            @Override
            public NodeType perform() throws RepositoryException {
                Tree tree = node.getTree();

                String primaryTypeName = null;
                if (tree.hasProperty(JcrConstants.JCR_PRIMARYTYPE)) {
                    primaryTypeName = TreeUtil.getPrimaryTypeName(tree);
                } else if (tree.getStatus() != Status.NEW) {
                    // OAK-2441: for backwards compatibility with Jackrabbit 2.x try to
                    // read the primary type from the underlying node state.
                    primaryTypeName = TreeUtil.getPrimaryTypeName(RootFactory.createReadOnlyRoot(sessionDelegate.getRoot()).getTree(tree.getPath()));
                }

                if (primaryTypeName != null) {
                    return getNodeTypeManager().getNodeType(sessionContext.getJcrName(primaryTypeName));
                } else {
                    throw new RepositoryException(""Unable to retrieve primary type for Node "" + getPath());
                }
            }
        });
    }","@Override
    @Nonnull
    public NodeType getPrimaryNodeType() throws RepositoryException {
        return perform(new NodeOperation<NodeType>(dlg, ""getPrimaryNodeType"") {
            @Nonnull
            @Override
            public NodeType perform() throws RepositoryException {
                Tree tree = node.getTree();

                String primaryTypeName = null;
                if (tree.hasProperty(JcrConstants.JCR_PRIMARYTYPE)) {
                    primaryTypeName = TreeUtil.getPrimaryTypeName(tree);
                } else if (tree.getStatus() != Status.NEW) {
                    // OAK-2441: for backwards compatibility with Jackrabbit 2.x try to
                    // read the primary type from the underlying node state.
                    primaryTypeName = TreeUtil.getPrimaryTypeName(RootFactory.createReadOnlyRoot(sessionDelegate.getRoot()).getTree(tree.getPath()));
                }

                if (primaryTypeName != null) {
                    return getNodeTypeManager().getNodeType(sessionContext.getJcrName(primaryTypeName));
                } else {
                    throw new RepositoryException(""Unable to retrieve primary type for Node "" + getPath());
                }
            }
        });
    }",0,[0]
1789,Bears-202,"public ClassGraph whitelistPathsNonRecursive(final String... paths) {
        for (final String path : paths) {
            if (path.contains(""*"")) {
                throw new IllegalArgumentException(""Cannot use a glob wildcard here: "" + path);
            }
            // Whitelist path, but not sub-directories / nested paths
            scanSpec.packageWhiteBlackList.addToWhitelist(WhiteBlackList.pathToPackageName(path));
            scanSpec.pathWhiteBlackList.addToWhitelist(WhiteBlackList.normalizePath(path));
        }
        return this;
    }","public ClassGraph whitelistPathsNonRecursive(final String... paths) {
        for (final String path : paths) {
            if (path.contains(""*"")) {
                throw new IllegalArgumentException(""Cannot use a glob wildcard here: "" + path);
            }
            // Whitelist path, but not sub-directories / nested paths
            scanSpec.packageWhiteBlackList.addToWhitelist(WhiteBlackList.pathToPackageName(path));
            scanSpec.pathWhiteBlackList.addToWhitelist(WhiteBlackList.normalizePath(path));
        }
        return this;
    }",0,[0]
9183,bugs-dot-jar_MATH-377_c640932d,"public void setMaxEvaluations(int maxEvaluations) {
        this.maxEvaluations = maxEvaluations;
    }","public void setMaxEvaluations(int maxEvaluations) {
        this.maxEvaluations = maxEvaluations;
    }",0,[0]
5256,bugs-dot-jar_OAK-499_61381ea2,"public Query parse(String query) throws ParseException {
        // TODO possibly support union,... as available at
        // http://docs.jboss.org/modeshape/latest/manuals/reference/html/jcr-query-and-search.html

        initialize(query);
        selectors = new ArrayList<SelectorImpl>();
        expected = new ArrayList<String>();
        bindVariables = new HashMap<String, BindVariableValueImpl>();
        read();
        boolean explain = false, measure = false;
        if (readIf(""EXPLAIN"")) {
            explain = true;
        } else if (readIf(""MEASURE"")) {
            measure = true;
        }
        read(""SELECT"");
        ArrayList<ColumnOrWildcard> list = parseColumns();
        if (supportSQL1) {
            addColumnIfNecessary(list, Query.JCR_PATH, Query.JCR_PATH);
            addColumnIfNecessary(list, Query.JCR_SCORE, Query.JCR_SCORE);
        }
        read(""FROM"");
        SourceImpl source = parseSource();
        ColumnImpl[] columnArray = resolveColumns(list);
        ConstraintImpl constraint = null;
        if (readIf(""WHERE"")) {
            constraint = parseConstraint();
        }
        OrderingImpl[] orderings = null;
        if (readIf(""ORDER"")) {
            read(""BY"");
            orderings = parseOrder();
        }
        if (!currentToken.isEmpty()) {
            throw getSyntaxError(""<end>"");
        }
        Query q = new Query(statement, source, constraint, orderings, columnArray);
        q.setExplain(explain);
        q.setMeasure(measure);
        try {
            q.init();
        } catch (Exception e) {
            ParseException e2 = new ParseException(query + "": "" + e.getMessage(), 0);
            e2.initCause(e);
            throw e2;
        }
        return q;
    }","public Query parse(String query) throws ParseException {
        // TODO possibly support union,... as available at
        // http://docs.jboss.org/modeshape/latest/manuals/reference/html/jcr-query-and-search.html

        initialize(query);
        selectors = new ArrayList<SelectorImpl>();
        expected = new ArrayList<String>();
        bindVariables = new HashMap<String, BindVariableValueImpl>();
        read();
        boolean explain = false, measure = false;
        if (readIf(""EXPLAIN"")) {
            explain = true;
        } else if (readIf(""MEASURE"")) {
            measure = true;
        }
        read(""SELECT"");
        ArrayList<ColumnOrWildcard> list = parseColumns();
        if (supportSQL1) {
            addColumnIfNecessary(list, Query.JCR_PATH, Query.JCR_PATH);
            addColumnIfNecessary(list, Query.JCR_SCORE, Query.JCR_SCORE);
        }
        read(""FROM"");
        SourceImpl source = parseSource();
        ColumnImpl[] columnArray = resolveColumns(list);
        ConstraintImpl constraint = null;
        if (readIf(""WHERE"")) {
            constraint = parseConstraint();
        }
        OrderingImpl[] orderings = null;
        if (readIf(""ORDER"")) {
            read(""BY"");
            orderings = parseOrder();
        }
        if (!currentToken.isEmpty()) {
            throw getSyntaxError(""<end>"");
        }
        Query q = new Query(statement, source, constraint, orderings, columnArray);
        q.setExplain(explain);
        q.setMeasure(measure);
        try {
            q.init();
        } catch (Exception e) {
            ParseException e2 = new ParseException(query + "": "" + e.getMessage(), 0);
            e2.initCause(e);
            throw e2;
        }
        return q;
    }",0,[0]
27366,bugs-dot-jar_WICKET-1619_b154d12f,"protected Link<?> newPagingNavigationIncrementLink(String id, IPageable pageable, int increment)
	{
		return new PagingNavigationIncrementLink<Void>(id, pageable, increment)
		{
			private static final long serialVersionUID = 1L;

			@Override
			public boolean isEnabled()
			{
				return PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();
			}
		};
	}","protected Link<?> newPagingNavigationIncrementLink(String id, IPageable pageable, int increment)
	{
		return new PagingNavigationIncrementLink<Void>(id, pageable, increment)
		{
			private static final long serialVersionUID = 1L;

			@Override
			public boolean isEnabled()
			{
				return super.isEnabled() && PagingNavigator.this.isEnabled() &&
					PagingNavigator.this.isEnableAllowed();
			}
		};
	}",1,[9]
13801,bugs-dot-jar_OAK-596_9b268da0,"public boolean isDeleted() {
        return getBoolean(KEY_DELETED);
    }","public boolean isDeleted() {
        return getBoolean(KEY_DELETED);
    }",0,[0]
20925,bugs-dot-jar_WICKET-5784_b6259e5f,"@Override
	public void requestTime(long timeTaken)
	{
		RequestData requestdata = RequestCycle.get().getMetaData(REQUEST_DATA);
		if (requestdata != null)
		{
			if (activeRequests.get() > 0)
			{
				requestdata.setActiveRequest(activeRequests.decrementAndGet());
			}
			Session session = Session.get();
			String sessionId = session.getId();
			requestdata.setSessionId(sessionId);

			Object sessionInfo = getSessionInfo(session);
			requestdata.setSessionInfo(sessionInfo);

			long sizeInBytes = -1;
			if (Application.exists() &&
				Application.get().getRequestLoggerSettings().getRecordSessionSize())
			{
				try
				{
					sizeInBytes = session.getSizeInBytes();
				}
				catch (Exception e)
				{
					// log the error and let the request logging continue (this is what happens in
					// the detach phase of the request cycle anyway. This provides better
					// diagnostics).
					LOG.error(
						""Exception while determining the size of the session in the request logger: "" +
							e.getMessage(), e);
				}
			}
			requestdata.setSessionSize(sizeInBytes);
			requestdata.setTimeTaken(timeTaken);

			addRequest(requestdata);

			SessionData sessiondata = null;
			if (sessionId != null)
			{
				sessiondata = liveSessions.get(sessionId);
				if (sessiondata == null)
				{
					// if the session has been destroyed during the request by
					// Session#invalidateNow, retrieve the old session data from the RequestCycle.
					sessiondata = RequestCycle.get().getMetaData(SESSION_DATA);
				}
				if (sessiondata == null)
				{
					// passivated session or logger only started after it.
					sessionCreated(sessionId);
					sessiondata = liveSessions.get(sessionId);
				}
				if (sessiondata != null)
				{
					sessiondata.setSessionInfo(sessionInfo);
					sessiondata.setSessionSize(sizeInBytes);
					sessiondata.addTimeTaken(timeTaken);
					RequestCycle.get().setMetaData(SESSION_DATA, sessiondata);
				}
			}
		}
	}","@Override
	public void requestTime(long timeTaken)
	{
		RequestData requestdata = RequestCycle.get().getMetaData(REQUEST_DATA);
		if (requestdata != null)
		{
			if (activeRequests.get() > 0)
			{
				requestdata.setActiveRequest(activeRequests.decrementAndGet());
			}
			Session session = Session.get();
			String sessionId = session.getId();
			requestdata.setSessionId(sessionId);

			Object sessionInfo = getSessionInfo(session);
			requestdata.setSessionInfo(sessionInfo);

			long sizeInBytes = -1;
			if (Application.exists() &&
				Application.get().getRequestLoggerSettings().getRecordSessionSize())
			{
				try
				{
					sizeInBytes = session.getSizeInBytes();
				}
				catch (Exception e)
				{
					// log the error and let the request logging continue (this is what happens in
					// the detach phase of the request cycle anyway. This provides better
					// diagnostics).
					LOG.error(
						""Exception while determining the size of the session in the request logger: "" +
							e.getMessage(), e);
				}
			}
			requestdata.setSessionSize(sizeInBytes);
			requestdata.setTimeTaken(timeTaken);

			addRequest(requestdata);

			SessionData sessiondata = null;
			if (sessionId != null)
			{
				sessiondata = liveSessions.get(sessionId);
				if (sessiondata == null)
				{
					// if the session has been destroyed during the request by
					// Session#invalidateNow, retrieve the old session data from the RequestCycle.
					sessiondata = RequestCycle.get().getMetaData(SESSION_DATA);
				}
				if (sessiondata == null)
				{
					// passivated session or logger only started after it.
					sessionCreated(sessionId);
					sessiondata = liveSessions.get(sessionId);
				}
				if (sessiondata != null)
				{
					sessiondata.setSessionInfo(sessionInfo);
					sessiondata.setSessionSize(sizeInBytes);
					sessiondata.addTimeTaken(timeTaken);
					RequestCycle.get().setMetaData(SESSION_DATA, sessiondata);
				}
			}
		}
	}",0,[0]
8769,bugs-dot-jar_WICKET-5883_cd3b9234,"@Override
	public void renderHead(IHeaderResponse response)
	{
		if (!isRootForm() && isMultiPart())
		{
			// register some metadata so we can later properly handle multipart ajax posts for
			// embedded forms
			registerJavaScriptNamespaces(response);
			response
				.render(JavaScriptHeaderItem.forScript(""Wicket.Forms[\"""" + getMarkupId()
					+ ""\""]={multipart:true};"", Form.class.getName() + '.' + getMarkupId()
					+ "".metadata""));
		}
	}","@Override
	public void renderHead(IHeaderResponse response)
	{
		if (!isRootForm() && isMultiPart())
		{
			// register some metadata so we can later properly handle multipart ajax posts for
			// embedded forms
			registerJavaScriptNamespaces(response);
			response
				.render(JavaScriptHeaderItem.forScript(""Wicket.Forms[\"""" + getMarkupId()
					+ ""\""]={multipart:true};"", Form.class.getName() + '.' + getMarkupId()
					+ "".metadata""));
		}
	}",0,[0]
1005,Bears-130,"private Position decodeRegularMessage(Channel channel, SocketAddress remoteAddress, ChannelBuffer buf) {

        Parser parser = new Parser(PATTERN, buf.toString(StandardCharsets.US_ASCII));
        if (!parser.matches()) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }
        position.setDeviceId(deviceSession.getDeviceId());

        int event = parser.nextInt(0);
        position.set(Position.KEY_EVENT, event);
        position.set(Position.KEY_ALARM, decodeAlarm(event));

        position.setLatitude(parser.nextDouble(0));
        position.setLongitude(parser.nextDouble(0));

        position.setTime(parser.nextDateTime());

        position.setValid(parser.next().equals(""A""));

        position.set(Position.KEY_SATELLITES, parser.nextInt());
        int rssi = parser.nextInt(0);

        position.setSpeed(UnitsConverter.knotsFromKph(parser.nextDouble(0)));
        position.setCourse(parser.nextDouble(0));

        position.set(Position.KEY_HDOP, parser.nextDouble());

        position.setAltitude(parser.nextDouble(0));

        position.set(Position.KEY_ODOMETER, parser.nextInt(0));
        position.set(""runtime"", parser.next());

        position.setNetwork(new Network(CellTower.from(
                parser.nextInt(0), parser.nextInt(0), parser.nextHexInt(0), parser.nextHexInt(0), rssi)));

        position.set(Position.KEY_STATUS, parser.next());

        for (int i = 1; i <= 3; i++) {
            if (parser.hasNext()) {
                position.set(Position.PREFIX_ADC + i, parser.nextHexInt(0));
            }
        }

        String deviceModel = Context.getIdentityManager().getById(deviceSession.getDeviceId()).getModel();
        if (deviceModel == null) {
            deviceModel = """";
        }
        switch (deviceModel.toUpperCase()) {
            case ""MVT340"":
            case ""MVT380"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) * 3.0 * 2.0 / 1024.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0) * 3.0 * 16.0 / 1024.0);
                break;
            case ""MT90"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) * 3.3 * 2.0 / 4096.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0));
                break;
            case ""T1"":
            case ""T3"":
            case ""MVT100"":
            case ""MVT600"":
            case ""MVT800"":
            case ""TC68"":
            case ""TC68S"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) * 3.3 * 2.0 / 4096.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0) * 3.3 * 16.0 / 4096.0);
                break;
            case ""T311"":
            case ""T322X"":
            case ""T333"":
            case ""T355"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) / 100.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0) / 100.0);
                break;
            default:
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0));
                position.set(Position.KEY_POWER, parser.nextHexInt(0));
                break;
        }

        String eventData = parser.next();
        if (eventData != null && !eventData.isEmpty()) {
            switch (event) {
                case 37:
                    position.set(Position.KEY_DRIVER_UNIQUE_ID, eventData);
                    break;
                default:
                    position.set(""eventData"", eventData);
                    break;
            }
        }

        if (parser.hasNext()) {
            String fuel = parser.next();
            position.set(Position.KEY_FUEL_LEVEL,
                    Integer.parseInt(fuel.substring(0, 2), 16) + Integer.parseInt(fuel.substring(2), 16) * 0.01);
        }

        if (parser.hasNext()) {
            for (String temp : parser.next().split(""\\|"")) {
                int index = Integer.valueOf(temp.substring(0, 2), 16);
                double value = Byte.valueOf(temp.substring(2, 4), 16);
                value += (value < 0 ? -0.01 : 0.01) * Integer.valueOf(temp.substring(4), 16);
                position.set(Position.PREFIX_TEMP + index, value);
            }
        }

        return position;
    }","private Position decodeRegularMessage(Channel channel, SocketAddress remoteAddress, ChannelBuffer buf) {

        Parser parser = new Parser(PATTERN, buf.toString(StandardCharsets.US_ASCII));
        if (!parser.matches()) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }
        position.setDeviceId(deviceSession.getDeviceId());

        int event = parser.nextInt(0);
        position.set(Position.KEY_EVENT, event);
        position.set(Position.KEY_ALARM, decodeAlarm(event));

        position.setLatitude(parser.nextDouble(0));
        position.setLongitude(parser.nextDouble(0));

        position.setTime(parser.nextDateTime());

        position.setValid(parser.next().equals(""A""));

        position.set(Position.KEY_SATELLITES, parser.nextInt());
        int rssi = parser.nextInt(0);

        position.setSpeed(UnitsConverter.knotsFromKph(parser.nextDouble(0)));
        position.setCourse(parser.nextDouble(0));

        position.set(Position.KEY_HDOP, parser.nextDouble());

        position.setAltitude(parser.nextDouble(0));

        position.set(Position.KEY_ODOMETER, parser.nextInt(0));
        position.set(""runtime"", parser.next());

        position.setNetwork(new Network(CellTower.from(
                parser.nextInt(0), parser.nextInt(0), parser.nextHexInt(0), parser.nextHexInt(0), rssi)));

        position.set(Position.KEY_STATUS, parser.next());

        for (int i = 1; i <= 3; i++) {
            if (parser.hasNext()) {
                position.set(Position.PREFIX_ADC + i, parser.nextHexInt(0));
            }
        }

        String deviceModel = Context.getIdentityManager().getById(deviceSession.getDeviceId()).getModel();
        if (deviceModel == null) {
            deviceModel = """";
        }
        switch (deviceModel.toUpperCase()) {
            case ""MVT340"":
            case ""MVT380"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) * 3.0 * 2.0 / 1024.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0) * 3.0 * 16.0 / 1024.0);
                break;
            case ""MT90"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) * 3.3 * 2.0 / 4096.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0));
                break;
            case ""T1"":
            case ""T3"":
            case ""MVT100"":
            case ""MVT600"":
            case ""MVT800"":
            case ""TC68"":
            case ""TC68S"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) * 3.3 * 2.0 / 4096.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0) * 3.3 * 16.0 / 4096.0);
                break;
            case ""T311"":
            case ""T322X"":
            case ""T333"":
            case ""T355"":
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0) / 100.0);
                position.set(Position.KEY_POWER, parser.nextHexInt(0) / 100.0);
                break;
            default:
                position.set(Position.KEY_BATTERY, parser.nextHexInt(0));
                position.set(Position.KEY_POWER, parser.nextHexInt(0));
                break;
        }

        String eventData = parser.next();
        if (eventData != null && !eventData.isEmpty()) {
            switch (event) {
                case 37:
                    position.set(Position.KEY_DRIVER_UNIQUE_ID, eventData);
                    break;
                default:
                    position.set(""eventData"", eventData);
                    break;
            }
        }

        if (parser.hasNext()) {
            String fuel = parser.next();
            position.set(Position.KEY_FUEL_LEVEL,
                    Integer.parseInt(fuel.substring(0, 2), 16) + Integer.parseInt(fuel.substring(2), 16) * 0.01);
        }

        if (parser.hasNext()) {
            for (String temp : parser.next().split(""\\|"")) {
                int index = Integer.valueOf(temp.substring(0, 2), 16);
                double value = Byte.valueOf(temp.substring(2, 4), 16);
                value += (value < 0 ? -0.01 : 0.01) * Integer.valueOf(temp.substring(4), 16);
                position.set(Position.PREFIX_TEMP + index, value);
            }
        }

        return position;
    }",0,[0]
7888,bugs-dot-jar_MATH-812_6eb46555,"public OpenMapRealVector subtract(OpenMapRealVector v) {
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = copy();
        Iterator iter = v.getEntries().iterator();
        while (iter.hasNext()) {
            iter.advance();
            int key = iter.key();
            if (entries.containsKey(key)) {
                res.setEntry(key, entries.get(key) - iter.value());
            } else {
                res.setEntry(key, -iter.value());
            }
        }
        return res;
    }","public OpenMapRealVector subtract(OpenMapRealVector v) {
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = copy();
        Iterator iter = v.getEntries().iterator();
        while (iter.hasNext()) {
            iter.advance();
            int key = iter.key();
            if (entries.containsKey(key)) {
                res.setEntry(key, entries.get(key) - iter.value());
            } else {
                res.setEntry(key, -iter.value());
            }
        }
        return res;
    }",0,[0]
28229,bugs-dot-jar_WICKET-3197_be70e608,"public final CharSequence urlFor(final IBehavior behaviour,
		final RequestListenerInterface listener)
	{
		PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);
		int id = getBehaviorId(behaviour);
		IRequestHandler handler;
		if (getPage().isPageStateless())
		{
			handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
		}
		else
		{
			handler = new ListenerInterfaceRequestHandler(provider, listener, id);
		}
		return getRequestCycle().urlFor(handler);
	}","public final CharSequence urlFor(final IBehavior behaviour,
		final RequestListenerInterface listener)
	{
		PageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);
		int id = getBehaviorId(behaviour);
		IRequestHandler handler;
		if (getPage().isPageStateless())
		{
			handler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);
		}
		else
		{
			handler = new ListenerInterfaceRequestHandler(provider, listener, id);
		}
		return getRequestCycle().urlFor(handler);
	}",0,[0]
24485,bugs-dot-jar_OAK-4420_d645112f,"public void setSkipInitialization(boolean skipInitialization) {
        this.skipInitialization = skipInitialization;
    }","public void setSkipInitialization(boolean skipInitialization) {
        this.skipInitialization = skipInitialization;
    }",0,[0]
1376,Bears-160,"protected void parseRenameTable(Marker start) {
        TableId from = parseQualifiedTableName(start);
        tokens.consume(""TO"");
        TableId to = parseQualifiedTableName(start);
        databaseTables.renameTable(from, to);
        // Signal a separate statement for this table rename action, even though multiple renames might be
        // performed by a single DDL statement on the token stream ...
        signalAlterTable(from, to, ""RENAME TABLE "" + from + "" TO "" + to);
    }","protected void parseRenameTable(Marker start) {
        TableId from = parseQualifiedTableName(start);
        tokens.consume(""TO"");
        TableId to = parseQualifiedTableName(start);
        databaseTables.renameTable(from, to);
        // Signal a separate statement for this table rename action, even though multiple renames might be
        // performed by a single DDL statement on the token stream ...
        signalAlterTable(from, to, ""RENAME TABLE "" + from + "" TO "" + to);
    }",0,[0]
38906,bugs-dot-jar_OAK-4358_74cbba24,"@CheckForNull
    public static String getParentId(String id){
        if(Utils.isIdFromLongPath(id)){
            return null;
        }
        String path = Utils.getPathFromId(id);
        if (!PathUtils.isValid(path)) {
            return null;
        }
        if(PathUtils.denotesRoot(path)){
            return null;
        }
        String parentPath = PathUtils.getParentPath(path);
        return Utils.getIdFromPath(parentPath);
    }","@CheckForNull
    public static String getParentId(String id){
        if(Utils.isIdFromLongPath(id)){
            return null;
        }
        String path = Utils.getPathFromId(id);
        if (!PathUtils.isValid(path)) {
            return null;
        }
        if(PathUtils.denotesRoot(path)){
            return null;
        }
        String parentPath = PathUtils.getParentPath(path);
        return Utils.getIdFromPath(parentPath);
    }",0,[0]
39589,bugs-dot-jar_OAK-1674_073b814c,"@Override
    public long getChildrenCount(long max) {
        if (max + INTERNAL_NODE_NAMES.length < 0) {
            // avoid overflow (if max is near Long.MAX_VALUE)
            max = Long.MAX_VALUE;
        } else {
            // fetch a few more
            max += INTERNAL_NODE_NAMES.length;
        }
        long count = nodeBuilder.getChildNodeCount(max);
        if (count > 0) {
            for (String name : INTERNAL_NODE_NAMES) {
                if (nodeBuilder.hasChildNode(name)) {
                    count--;
                }
            }
        }
        return count;
    }","@Override
    public long getChildrenCount(long max) {
        if (max + INTERNAL_NODE_NAMES.length < 0) {
            // avoid overflow (if max is near Long.MAX_VALUE)
            max = Long.MAX_VALUE;
        } else {
            // fetch a few more
            max += INTERNAL_NODE_NAMES.length;
        }
        long count = nodeBuilder.getChildNodeCount(max);
        if (count > 0) {
            for (String name : INTERNAL_NODE_NAMES) {
                if (nodeBuilder.hasChildNode(name)) {
                    count--;
                }
            }
        }
        return count;
    }",0,[0]
9657,bugs-dot-jar_CAMEL-5707_3f70d612,"public NotifyBuilder whenExactBodiesReceived(Object... bodies) {
        List<Object> bodyList = new ArrayList<Object>();
        bodyList.addAll(Arrays.asList(bodies));
        return doWhenBodies(bodyList, true, true);
    }","public NotifyBuilder whenExactBodiesReceived(Object... bodies) {
        List<Object> bodyList = new ArrayList<Object>();
        bodyList.addAll(Arrays.asList(bodies));
        return doWhenBodies(bodyList, true, true);
    }",0,[0]
4358,bugs-dot-jar_CAMEL-4682_1e54865c,"public InterceptStrategy getDefaultTracer() {
        if (defaultTracer == null) {
            defaultTracer = new Tracer();
        }
        return defaultTracer;
    }","public InterceptStrategy getDefaultTracer() {
        if (defaultTracer == null) {
            defaultTracer = new Tracer();
        }
        return defaultTracer;
    }",0,[0]
23896,bugs-dot-jar_ACCUMULO-3077_17654199,"public static boolean isInitialized(VolumeManager fs) throws IOException {
    for (String baseDir : VolumeConfiguration.getVolumeUris(SiteConfiguration.getInstance())) {
      if (fs.exists(new Path(baseDir, ServerConstants.INSTANCE_ID_DIR)) || fs.exists(new Path(baseDir, ServerConstants.VERSION_DIR)))
        return true;
    }

    return false;
  }","public static boolean isInitialized(VolumeManager fs) throws IOException {
    for (String baseDir : VolumeConfiguration.getVolumeUris(SiteConfiguration.getInstance())) {
      if (fs.exists(new Path(baseDir, ServerConstants.INSTANCE_ID_DIR)) || fs.exists(new Path(baseDir, ServerConstants.VERSION_DIR)))
        return true;
    }

    return false;
  }",0,[0]
29291,bugs-dot-jar_CAMEL-7586_1f92fa42,"public void sendBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers) throws Exception {
        ProducerTemplate template = context.createProducerTemplate();
        try {
            template.sendBodyAndHeaders(endpointUri, body, headers);
        } finally {
            template.stop();
        }
    }","public void sendBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers) throws Exception {
        ProducerTemplate template = context.createProducerTemplate();
        try {
            template.sendBodyAndHeaders(endpointUri, body, headers);
        } finally {
            template.stop();
        }
    }",0,[0]
7528,bugs-dot-jar_WICKET-2624_ef880545,"@SuppressWarnings(""unchecked"")
	public final IConverter set(final Class c, final IConverter converter)
	{
		if (converter == null)
		{
			throw new IllegalArgumentException(""CoverterLocator cannot be null"");
		}
		if (c == null)
		{
			throw new IllegalArgumentException(""Class cannot be null"");
		}
		return classToConverter.put(c.getName(), converter);
	}","@SuppressWarnings(""unchecked"")
	public final IConverter set(final Class c, final IConverter converter)
	{
		if (converter == null)
		{
			throw new IllegalArgumentException(""CoverterLocator cannot be null"");
		}
		if (c == null)
		{
			throw new IllegalArgumentException(""Class cannot be null"");
		}
		return classToConverter.put(c.getName(), converter);
	}",0,[0]
2562,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"private void handleExceptionMRE(Exception ex) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException,
      org.apache.accumulo.proxy.thrift.MutationsRejectedException, TException {
    try {
      throw ex;
    } catch (MutationsRejectedException e) {
      throw new org.apache.accumulo.proxy.thrift.MutationsRejectedException(ex.toString());
    } catch (AccumuloException e) {
      handleAccumuloException(e);
    } catch (AccumuloSecurityException e) {
      handleAccumuloSecurityException(e);
    } catch (TableNotFoundException e) {
      throw new org.apache.accumulo.proxy.thrift.TableNotFoundException(ex.toString());
    } catch (Exception e) {
      throw new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());
    }
  }","private void handleExceptionMRE(Exception ex) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, org.apache.accumulo.proxy.thrift.TableNotFoundException,
      org.apache.accumulo.proxy.thrift.MutationsRejectedException, TException {
    try {
      throw ex;
    } catch (MutationsRejectedException e) {
      throw new org.apache.accumulo.proxy.thrift.MutationsRejectedException(ex.toString());
    } catch (AccumuloException e) {
      handleAccumuloException(e);
    } catch (AccumuloSecurityException e) {
      handleAccumuloSecurityException(e);
    } catch (TableNotFoundException e) {
      throw new org.apache.accumulo.proxy.thrift.TableNotFoundException(ex.toString());
    } catch (Exception e) {
      throw new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());
    }
  }",0,[0]
39135,bugs-dot-jar_OAK-2238_a28098fd,"public long getUpdateCount() {
        return updateCount;
    }","public long getUpdateCount() {
        return updateCount;
    }",0,[0]
28391,bugs-dot-jar_WICKET-2172_ea4a3f8a,"protected void configureResponse(final Response response)
	{
	}","protected void configureResponse(final Response response)
	{
	}",0,[0]
28411,bugs-dot-jar_WICKET-2172_ea4a3f8a,"public String[] getStringArray(final String key)
	{
		final Object o = get(key);
		if (o == null)
		{
			return null;
		}
		else if (o instanceof String[])
		{
			return (String[])o;
		}
		else if (o.getClass().isArray())
		{
			int length = Array.getLength(o);
			String[] array = new String[length];
			for (int i = 0; i < length; i++)
			{
				final Object arrayValue = Array.get(o, i);
				if (arrayValue != null)
				{
					array[i] = arrayValue.toString();
				}
			}
			return array;
		}
		return new String[] { o.toString() };
	}","public String[] getStringArray(final String key)
	{
		final Object o = get(key);
		if (o == null)
		{
			return null;
		}
		else if (o instanceof String[])
		{
			return (String[])o;
		}
		else if (o.getClass().isArray())
		{
			int length = Array.getLength(o);
			String[] array = new String[length];
			for (int i = 0; i < length; i++)
			{
				final Object arrayValue = Array.get(o, i);
				if (arrayValue != null)
				{
					array[i] = arrayValue.toString();
				}
			}
			return array;
		}
		return new String[] { o.toString() };
	}",0,[0]
31401,bugs-dot-jar_CAMEL-9340_1cab39f6,"@ManagedAttribute(description = ""The maximum file size for the file store in bytes"")
    public long getMaxFileStoreSize() {
        return maxFileStoreSize;
    }","@ManagedAttribute(description = ""The maximum file size for the file store in bytes"")
    public long getMaxFileStoreSize() {
        return maxFileStoreSize;
    }",0,[0]
36324,bugs-dot-jar_CAMEL-9444_baece126,"public SplitDefinition executorServiceRef(String executorServiceRef) {
        setExecutorServiceRef(executorServiceRef);
        return this;
    }","public SplitDefinition executorServiceRef(String executorServiceRef) {
        setExecutorServiceRef(executorServiceRef);
        return this;
    }",0,[0]
33155,bugs-dot-jar_OAK-2418_039f892d,"public static <K> Iterator<K> newOffset(Iterator<K> it, long offset) {
        return new OffsetIterator<K>(it, offset);
    }","public static <K> Iterator<K> newOffset(Iterator<K> it, long offset) {
        return new OffsetIterator<K>(it, offset);
    }",0,[0]
4627,bugs-dot-jar_MATH-326_ce185345,"public RealVector subtract(double[] v) throws IllegalArgumentException {
        double[] result = v.clone();
        Iterator<Entry> it = sparseIterator();
        Entry e;
        while (it.hasNext() && (e = it.next()) != null) {
            final int index = e.getIndex();
            result[index] = e.getValue() - result[index];
        }
        return new ArrayRealVector(result, false);
    }","public RealVector subtract(double[] v) throws IllegalArgumentException {
        double[] result = v.clone();
        Iterator<Entry> it = sparseIterator();
        Entry e;
        while (it.hasNext() && (e = it.next()) != null) {
            final int index = e.getIndex();
            result[index] = e.getValue() - result[index];
        }
        return new ArrayRealVector(result, false);
    }",0,[0]
9479,bugs-dot-jar_OAK-1899_df59fb45,"private static String convert(String value) {
        return value.replaceAll(""%3A"", "":"");
    }","private static String convert(String value) {
        return value.replaceAll(""%3A"", "":"");
    }",0,[0]
724,Bears-23,"private final static boolean hasTimeZone(String str)
    {
        // Only accept ""+hh"", ""+hhmm"" and ""+hh:mm"" (and with minus), so
        int len = str.length();
        if (len >= 6) {
            char c = str.charAt(len-6);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-5);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-3);
            if (c == '+' || c == '-') return true;
        }
        return false;
    }","private final static boolean hasTimeZone(String str)
    {
        // Only accept ""+hh"", ""+hhmm"" and ""+hh:mm"" (and with minus), so
        int len = str.length();
        if (len >= 6) {
            char c = str.charAt(len-6);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-5);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-3);
            if (c == '+' || c == '-') return true;
        }
        return false;
    }",0,[0]
19143,bugs-dot-jar_OAK-1215_a9efe3c4,public abstract SelectorImpl getSelector(String selectorName);,public abstract SelectorImpl getSelector(String selectorName);,0,[0]
26966,bugs-dot-jar_LOG4J2-793_73400bfb,"@Override
    public void trace(final String format) {
        logger.logIfEnabled(FQCN, Level.TRACE, null, format);
    }","@Override
    public void trace(final String format) {
        logger.logIfEnabled(FQCN, Level.TRACE, null, format);
    }",0,[0]
2844,bugs-dot-jar_OAK-1364_05c89637,"V replace(K key, V value) {
        int hash = getHash(key);
        return getSegment(hash).replace(key, hash, value, sizeOf(key, value));
    }","V replace(K key, V value) {
        int hash = getHash(key);
        return getSegment(hash).replace(key, hash, value, sizeOf(key, value));
    }",0,[0]
22111,bugs-dot-jar_WICKET-1677_01a3dd66,"@Deprecated
	protected final boolean isEscapeLabelMarkup()
	{
		return getEscapeModelStrings();
	}","@Deprecated
	protected final boolean isEscapeLabelMarkup()
	{
		return getEscapeModelStrings();
	}",0,[0]
2988,bugs-dot-jar_OAK-3733_a5ff019e,"private void updateBinaryStatus() {
        DocumentStore store = this.nodeStore.getDocumentStore();

        for (String path : this.nodesWithBinaries) {
            NodeDocument nd = store.getIfCached(Collection.NODES, Utils.getIdFromPath(path));
            if ((nd == null) || !nd.hasBinary()) {
                UpdateOp updateParentOp = getUpdateOperationForNode(path);
                NodeDocument.setHasBinary(updateParentOp);
            }
        }
    }","private void updateBinaryStatus() {
        DocumentStore store = this.nodeStore.getDocumentStore();

        for (String path : this.nodesWithBinaries) {
            NodeDocument nd = store.getIfCached(Collection.NODES, Utils.getIdFromPath(path));
            if ((nd == null) || !nd.hasBinary()) {
                UpdateOp updateParentOp = getUpdateOperationForNode(path);
                NodeDocument.setHasBinary(updateParentOp);
            }
        }
    }",0,[0]
11311,bugs-dot-jar_OAK-395_e6c31270,"@Override
    @Nonnull
    public String getUUID() throws RepositoryException {
        checkStatus();

        return sessionDelegate.perform(new SessionOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                if (isNodeType(NodeType.MIX_REFERENCEABLE)) {
                    return getIdentifier();
                }

                throw new UnsupportedRepositoryOperationException(""Node is not referenceable."");
            }
        });
    }","@Override
    @Nonnull
    public String getUUID() throws RepositoryException {
        checkStatus();

        return sessionDelegate.perform(new SessionOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                if (isNodeType(NodeType.MIX_REFERENCEABLE)) {
                    return getIdentifier();
                }

                throw new UnsupportedRepositoryOperationException(""Node is not referenceable."");
            }
        });
    }",0,[0]
23482,bugs-dot-jar_LOG4J2-127_029e79da,"public void info(Marker marker, String message) {
        if (isEnabled(Level.INFO, marker, message)) {
            log(marker, FQCN, Level.INFO, new SimpleMessage(message), null);
        }
    }","public void info(Marker marker, String message) {
        if (isEnabled(Level.INFO, marker, message)) {
            log(marker, FQCN, Level.INFO, new SimpleMessage(message), null);
        }
    }",0,[0]
4139,bugs-dot-jar_FLINK-2713_63d9800e,"@SuppressWarnings(""unchecked"")
	@Override
	public S value() throws IOException {
		if (currentInput == null) {
			throw new IllegalStateException(""Need a valid input for accessing the state."");
		} else {
			Serializable key;
			try {
				key = keySelector.getKey(currentInput);
			} catch (Exception e) {
				throw new RuntimeException(""User-defined key selector threw an exception."", e);
			}
			if (stateStore.containsKey(key)) {
				return stateStore.getStateForKey(key);
			} else {
				try {
					return (S) checkpointer.restoreState((C) InstantiationUtil.deserializeObject(
							defaultState, cl));
				} catch (ClassNotFoundException e) {
					throw new RuntimeException(""Could not deserialize default state value."", e);
				}
			}
		}
	}","@SuppressWarnings(""unchecked"")
	@Override
	public S value() throws IOException {
		if (currentInput == null) {
			throw new IllegalStateException(""Need a valid input for accessing the state."");
		} else {
			if (!restored) {
				// If the state is not restored yet, restore now
				restoreWithCheckpointer();
			}
			Serializable key;
			try {
				key = keySelector.getKey(currentInput);
			} catch (Exception e) {
				throw new RuntimeException(""User-defined key selector threw an exception."", e);
			}
			if (stateStore.containsKey(key)) {
				return stateStore.getStateForKey(key);
			} else {
				try {
					return (S) checkpointer.restoreState((C) InstantiationUtil.deserializeObject(
							defaultState, cl));
				} catch (ClassNotFoundException e) {
					throw new RuntimeException(""Could not deserialize default state value."", e);
				}
			}
		}
	}",1,[]
28916,bugs-dot-jar_WICKET-5853_b80f6640,"@Override
	public Float convertToObject(final String value, final Locale locale)
	{
		final Number number = parse(value, -Float.MAX_VALUE, Float.MAX_VALUE, locale);

		if (number == null)
		{
			return null;
		}

		return number.floatValue();
	}","@Override
	public Float convertToObject(final String value, final Locale locale)
	{
		final BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);

		if (number == null)
		{
			return null;
		}

		return number.floatValue();
	}",1,[3]
23195,bugs-dot-jar_OAK-4397_e33516d5,"@CheckForNull
    protected Value[] createValues(@Nonnull Collection<?> propValues) throws RepositoryException {
        List<Value> values = new ArrayList<Value>();
        for (Object obj : propValues) {
            Value v = createValue(obj);
            if (v != null) {
                values.add(v);
            }
        }
        return values.toArray(new Value[values.size()]);
    }","@CheckForNull
    protected Value[] createValues(@Nonnull Collection<?> propValues) throws RepositoryException {
        List<Value> values = new ArrayList<Value>();
        for (Object obj : propValues) {
            Value v = createValue(obj);
            if (v != null) {
                values.add(v);
            }
        }
        return values.toArray(new Value[values.size()]);
    }",0,[0]
18980,bugs-dot-jar_MATH-1148_4080feff,"@Override
    public Collection<Vector2D> findHullVertices(final Collection<Vector2D> points) {

        final List<Vector2D> pointsSortedByXAxis = new ArrayList<Vector2D>(points);

        // sort the points in increasing order on the x-axis
        Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {
            public int compare(final Vector2D o1, final Vector2D o2) {
                final int diff = (int) FastMath.signum(o1.getX() - o2.getX());
                if (diff == 0) {
                    return (int) FastMath.signum(o1.getY() - o2.getY());
                } else {
                    return diff;
                }
            }
        });

        // build lower hull
        final List<Vector2D> lowerHull = new ArrayList<Vector2D>();
        for (Vector2D p : pointsSortedByXAxis) {
            updateHull(p, lowerHull);
        }

        // build upper hull
        final List<Vector2D> upperHull = new ArrayList<Vector2D>();
        for (int idx = pointsSortedByXAxis.size() - 1; idx >= 0; idx--) {
            final Vector2D p = pointsSortedByXAxis.get(idx);
            updateHull(p, upperHull);
        }

        // concatenate the lower and upper hulls
        // the last point of each list is omitted as it is repeated at the beginning of the other list
        final List<Vector2D> hullVertices = new ArrayList<Vector2D>(lowerHull.size() + upperHull.size() - 2);
        for (int idx = 0; idx < lowerHull.size() - 1; idx++) {
            hullVertices.add(lowerHull.get(idx));
        }
        for (int idx = 0; idx < upperHull.size() - 1; idx++) {
            hullVertices.add(upperHull.get(idx));
        }

        // special case: if the lower and upper hull may contain only 1 point if all are identical
        if (hullVertices.isEmpty() && ! lowerHull.isEmpty()) {
            hullVertices.add(lowerHull.get(0));
        }

        return hullVertices;
    }","@Override
    public Collection<Vector2D> findHullVertices(final Collection<Vector2D> points) {

        final List<Vector2D> pointsSortedByXAxis = new ArrayList<Vector2D>(points);

        // sort the points in increasing order on the x-axis
        Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {
            public int compare(final Vector2D o1, final Vector2D o2) {
                final double tolerance = getTolerance();
                // need to take the tolerance value into account, otherwise collinear points
                // will not be handled correctly when building the upper/lower hull
                final int diff = Precision.compareTo(o1.getX(), o2.getX(), tolerance);
                if (diff == 0) {
                    return Precision.compareTo(o1.getY(), o2.getY(), tolerance);
                } else {
                    return diff;
                }
            }
        });

        // build lower hull
        final List<Vector2D> lowerHull = new ArrayList<Vector2D>();
        for (Vector2D p : pointsSortedByXAxis) {
            updateHull(p, lowerHull);
        }

        // build upper hull
        final List<Vector2D> upperHull = new ArrayList<Vector2D>();
        for (int idx = pointsSortedByXAxis.size() - 1; idx >= 0; idx--) {
            final Vector2D p = pointsSortedByXAxis.get(idx);
            updateHull(p, upperHull);
        }

        // concatenate the lower and upper hulls
        // the last point of each list is omitted as it is repeated at the beginning of the other list
        final List<Vector2D> hullVertices = new ArrayList<Vector2D>(lowerHull.size() + upperHull.size() - 2);
        for (int idx = 0; idx < lowerHull.size() - 1; idx++) {
            hullVertices.add(lowerHull.get(idx));
        }
        for (int idx = 0; idx < upperHull.size() - 1; idx++) {
            hullVertices.add(upperHull.get(idx));
        }

        // special case: if the lower and upper hull may contain only 1 point if all are identical
        if (hullVertices.isEmpty() && ! lowerHull.isEmpty()) {
            hullVertices.add(lowerHull.get(0));
        }

        return hullVertices;
    }",1,"[8, 10]"
26086,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"@Override
  public boolean validateOptions(Map<String,String> options) {
    super.validateOptions(options);
    try {
      if (options.containsKey(START))
        dateParser.parse(options.get(START));
      if (options.containsKey(END))
        dateParser.parse(options.get(END));
      if (options.get(START_INCL) != null)
        Boolean.parseBoolean(options.get(START_INCL));
      if (options.get(END_INCL) != null)
        Boolean.parseBoolean(options.get(END_INCL));
    } catch (Exception e) {
      return false;
    }
    return true;
  }","@Override
  public boolean validateOptions(Map<String,String> options) {
    super.validateOptions(options);
    try {
      if (options.containsKey(START))
        dateParser.parse(options.get(START));
      if (options.containsKey(END))
        dateParser.parse(options.get(END));
      if (options.get(START_INCL) != null)
        Boolean.parseBoolean(options.get(START_INCL));
      if (options.get(END_INCL) != null)
        Boolean.parseBoolean(options.get(END_INCL));
    } catch (Exception e) {
      return false;
    }
    return true;
  }",0,[0]
2298,bugs-dot-jar_MNG-4918_691a03a7,"public List<Profile> getActiveProfiles()
    {
        return activeProfiles;
    }","public List<Profile> getActiveProfiles()
    {
        return activeProfiles;
    }",0,[0]
24995,bugs-dot-jar_OAK-4423_275eca83,"@Override
    public boolean release(@Nonnull String checkpoint) {
        checkNotNull(checkpoint);

        // try 5 times
        for (int i = 0; i < 5; i++) {
            if (commitSemaphore.tryAcquire()) {
                try {
                    refreshHead();

                    SegmentNodeState state = head.get();
                    SegmentNodeBuilder builder = state.builder();

                    NodeBuilder cp = builder.child(""checkpoints"").child(
                            checkpoint);
                    if (cp.exists()) {
                        cp.remove();
                        SegmentNodeState newState = builder.getNodeState();
                        if (store.setHead(state, newState)) {
                            refreshHead();
                            return true;
                        }
                    }
                } finally {
                    commitSemaphore.release();
                }
            }
        }
        return false;
    }","@Override
    public boolean release(@Nonnull String checkpoint) {
        checkNotNull(checkpoint);

        // try 5 times
        for (int i = 0; i < 5; i++) {
            if (commitSemaphore.tryAcquire()) {
                try {
                    refreshHead();

                    SegmentNodeState state = head.get();
                    SegmentNodeBuilder builder = state.builder();

                    NodeBuilder cp = builder.child(""checkpoints"").child(
                            checkpoint);
                    if (cp.exists()) {
                        cp.remove();
                        SegmentNodeState newState = builder.getNodeState();
                        if (store.setHead(state, newState)) {
                            refreshHead();
                            return true;
                        }
                    }
                } finally {
                    commitSemaphore.release();
                }
            }
        }
        return false;
    }",0,[0]
4657,bugs-dot-jar_MATH-326_ce185345,"public RealVector mapCoshToSelf() {
        try {
            return mapToSelf(ComposableFunction.COSH);
        } catch (FunctionEvaluationException e) {
            throw new IllegalArgumentException(e);
        }
    }","public RealVector mapCoshToSelf() {
        try {
            return mapToSelf(ComposableFunction.COSH);
        } catch (FunctionEvaluationException e) {
            throw new IllegalArgumentException(e);
        }
    }",0,[0]
1831,bugs-dot-jar_CAMEL-8146_17475d80,"@Override
    protected void doStop() throws Exception {
        if (future != null) {
            LOG.debug(""This consumer is stopping, so cancelling scheduled task: "" + future);
            future.cancel(false);
            future = null;
        }
    }","@Override
    protected void doStop() throws Exception {
        if (future != null) {
            LOG.debug(""This consumer is stopping, so cancelling scheduled task: "" + future);
            future.cancel(true);
            future = null;
        }

        if (shutdownExecutor && scheduledExecutorService != null) {
            getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);
            scheduledExecutorService = null;
            future = null;
        }
    }",1,[4]
22088,bugs-dot-jar_WICKET-1677_01a3dd66,"public Check(String id, IModel<T> model, CheckGroup<T> group)
	{
		super(id, model);
		this.group = group;
	}","public Check(String id, IModel<T> model, CheckGroup<T> group)
	{
		super(id, model);
		this.group = group;
		setOutputMarkupId(true);
	}",1,[]
16965,bugs-dot-jar_WICKET-5728_3cc3fe95,"public void dequeue()
	{
		if (!(this instanceof IQueueRegion))
		{
			throw new UnsupportedOperationException(
					""Only implementations of IQueueRegion can use component queueing"");
		}

		if (getRequestFlag(RFLAG_CONTAINER_DEQUEING))
		{
			throw new IllegalStateException(""This container is already dequeing: "" + this);
		}

		setRequestFlag(RFLAG_CONTAINER_DEQUEING, true);
		try
		{
			DequeueContext dequeue = newDequeueContext();
			if (dequeue == null)
			{
				// not ready to dequeue yet
				return;
			}

			if (dequeue.peekTag() != null)
			{
				dequeue(dequeue);
			}
		}
		finally
		{
			setRequestFlag(RFLAG_CONTAINER_DEQUEING, false);
		}
	}","public void dequeue()
	{
		if (!(this instanceof IQueueRegion))
		{
			throw new UnsupportedOperationException(
					""Only implementations of IQueueRegion can use component queueing"");
		}

		if (getRequestFlag(RFLAG_CONTAINER_DEQUEING))
		{
			throw new IllegalStateException(""This container is already dequeing: "" + this);
		}

		setRequestFlag(RFLAG_CONTAINER_DEQUEING, true);
		try
		{
			DequeueContext dequeue = newDequeueContext();
			if (dequeue == null)
			{
				// not ready to dequeue yet
				return;
			}

			if (dequeue.peekTag() != null)
			{
				dequeue(dequeue);
			}
		}
		finally
		{
			setRequestFlag(RFLAG_CONTAINER_DEQUEING, false);
		}
	}",0,[0]
7289,bugs-dot-jar_LOG4J2-581_bb02fa15,"public void setEndOfBatch(final boolean isEndOfBatch) {
        this.isEndOfBatch.set(Boolean.valueOf(isEndOfBatch));
    }","public void setEndOfBatch(final boolean isEndOfBatch) {
        this.isEndOfBatch.set(Boolean.valueOf(isEndOfBatch));
    }",0,[0]
14936,bugs-dot-jar_CAMEL-5683_0c3c7d1b,"public long getEvicted() {
        long evicted = -1;
        if (consumers instanceof LRUCache) {
            LRUCache<String, PollingConsumer> cache = (LRUCache<String, PollingConsumer>)consumers;
            evicted = cache.getEvicted();
        }
        return evicted;
    }","public long getEvicted() {
        long evicted = -1;
        if (consumers instanceof LRUCache) {
            LRUCache<String, PollingConsumer> cache = (LRUCache<String, PollingConsumer>)consumers;
            evicted = cache.getEvicted();
        }
        return evicted;
    }",0,[0]
14544,bugs-dot-jar_WICKET-5176_34634266,"public StringResourceModel(final String resourceKey, final IModel<?> model,
		final IModel<String> defaultValue, final Object... parameters)
	{
		this(resourceKey, null, model, defaultValue, parameters);
	}","public StringResourceModel(final String resourceKey, final IModel<?> model,
		final IModel<String> defaultValue, final Object... parameters)
	{
		this(resourceKey, null, model, defaultValue, parameters);
	}",0,[0]
11078,bugs-dot-jar_MATH-1269_a94ff90a,"private static double log(final double x, final double[] hiPrec) {
        if (x==0) { // Handle special case of +0/-0
            return Double.NEGATIVE_INFINITY;
        }
        long bits = Double.doubleToRawLongBits(x);

        /* Handle special cases of negative input, and NaN */
        if (((bits & 0x8000000000000000L) != 0 || Double.isNaN(x)) && x != 0.0) {
            if (hiPrec != null) {
                hiPrec[0] = Double.NaN;
            }

            return Double.NaN;
        }

        /* Handle special cases of Positive infinity. */
        if (x == Double.POSITIVE_INFINITY) {
            if (hiPrec != null) {
                hiPrec[0] = Double.POSITIVE_INFINITY;
            }

            return Double.POSITIVE_INFINITY;
        }

        /* Extract the exponent */
        int exp = (int)(bits >> 52)-1023;

        if ((bits & 0x7ff0000000000000L) == 0) {
            // Subnormal!
            if (x == 0) {
                // Zero
                if (hiPrec != null) {
                    hiPrec[0] = Double.NEGATIVE_INFINITY;
                }

                return Double.NEGATIVE_INFINITY;
            }

            /* Normalize the subnormal number. */
            bits <<= 1;
            while ( (bits & 0x0010000000000000L) == 0) {
                --exp;
                bits <<= 1;
            }
        }


        if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) {
            /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
           polynomial expansion in higer precision. */

            /* Compute x - 1.0 and split it */
            double xa = x - 1.0;
            double xb = xa - x + 1.0;
            double tmp = xa * HEX_40000000;
            double aa = xa + tmp - tmp;
            double ab = xa - aa;
            xa = aa;
            xb = ab;

            final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
            double ya = lnCoef_last[0];
            double yb = lnCoef_last[1];

            for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                /* Add  a = y + lnQuickCoef */
                final double[] lnCoef_i = LN_QUICK_COEF[i];
                aa = ya + lnCoef_i[0];
                ab = yb + lnCoef_i[1];
                /* Split y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;
            }

            /* Multiply a = y * x */
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;
            /* split, so now y = a */
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;

            return ya + yb;
        }

        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)
        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];

        /*
    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);

    epsilon -= 1.0;
         */

        // y is the most significant 10 bits of the mantissa
        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);
        //double epsilon = (x - y) / y;
        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));

        double lnza = 0.0;
        double lnzb = 0.0;

        if (hiPrec != null) {
            /* split epsilon -> x */
            double tmp = epsilon * HEX_40000000;
            double aa = epsilon + tmp - tmp;
            double ab = epsilon - aa;
            double xa = aa;
            double xb = ab;

            /* Need a more accurate epsilon, so adjust the division. */
            final double numer = bits & 0x3ffffffffffL;
            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
            aa = numer - xa*denom - xb * denom;
            xb += aa / denom;

            /* Remez polynomial evaluation */
            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];
            double ya = lnCoef_last[0];
            double yb = lnCoef_last[1];

            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                /* Add  a = y + lnHiPrecCoef */
                final double[] lnCoef_i = LN_HI_PREC_COEF[i];
                aa = ya + lnCoef_i[0];
                ab = yb + lnCoef_i[1];
                /* Split y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;
            }

            /* Multiply a = y * x */
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;

            /* split, so now lnz = a */
            /*
      tmp = aa * 1073741824.0;
      lnza = aa + tmp - tmp;
      lnzb = aa - lnza + ab;
             */
            lnza = aa + ab;
            lnzb = -(lnza - aa - ab);
        } else {
            /* High precision not required.  Eval Remez polynomial
         using standard double precision */
            lnza = -0.16624882440418567;
            lnza = lnza * epsilon + 0.19999954120254515;
            lnza = lnza * epsilon + -0.2499999997677497;
            lnza = lnza * epsilon + 0.3333333333332802;
            lnza = lnza * epsilon + -0.5;
            lnza = lnza * epsilon + 1.0;
            lnza *= epsilon;
        }

        /* Relative sizes:
         * lnzb     [0, 2.33E-10]
         * lnm[1]   [0, 1.17E-7]
         * ln2B*exp [0, 1.12E-4]
         * lnza      [0, 9.7E-4]
         * lnm[0]   [0, 0.692]
         * ln2A*exp [0, 709]
         */

        /* Compute the following sum:
         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
         */

        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
        double a = LN_2_A*exp;
        double b = 0.0;
        double c = a+lnm[0];
        double d = -(c-a-lnm[0]);
        a = c;
        b += d;

        c = a + lnza;
        d = -(c - a - lnza);
        a = c;
        b += d;

        c = a + LN_2_B*exp;
        d = -(c - a - LN_2_B*exp);
        a = c;
        b += d;

        c = a + lnm[1];
        d = -(c - a - lnm[1]);
        a = c;
        b += d;

        c = a + lnzb;
        d = -(c - a - lnzb);
        a = c;
        b += d;

        if (hiPrec != null) {
            hiPrec[0] = a;
            hiPrec[1] = b;
        }

        return a + b;
    }","private static double log(final double x, final double[] hiPrec) {
        if (x==0) { // Handle special case of +0/-0
            return Double.NEGATIVE_INFINITY;
        }
        long bits = Double.doubleToRawLongBits(x);

        /* Handle special cases of negative input, and NaN */
        if (((bits & 0x8000000000000000L) != 0 || Double.isNaN(x)) && x != 0.0) {
            if (hiPrec != null) {
                hiPrec[0] = Double.NaN;
            }

            return Double.NaN;
        }

        /* Handle special cases of Positive infinity. */
        if (x == Double.POSITIVE_INFINITY) {
            if (hiPrec != null) {
                hiPrec[0] = Double.POSITIVE_INFINITY;
            }

            return Double.POSITIVE_INFINITY;
        }

        /* Extract the exponent */
        int exp = (int)(bits >> 52)-1023;

        if ((bits & 0x7ff0000000000000L) == 0) {
            // Subnormal!
            if (x == 0) {
                // Zero
                if (hiPrec != null) {
                    hiPrec[0] = Double.NEGATIVE_INFINITY;
                }

                return Double.NEGATIVE_INFINITY;
            }

            /* Normalize the subnormal number. */
            bits <<= 1;
            while ( (bits & 0x0010000000000000L) == 0) {
                --exp;
                bits <<= 1;
            }
        }


        if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) {
            /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
           polynomial expansion in higer precision. */

            /* Compute x - 1.0 and split it */
            double xa = x - 1.0;
            double xb = xa - x + 1.0;
            double tmp = xa * HEX_40000000;
            double aa = xa + tmp - tmp;
            double ab = xa - aa;
            xa = aa;
            xb = ab;

            final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
            double ya = lnCoef_last[0];
            double yb = lnCoef_last[1];

            for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                /* Add  a = y + lnQuickCoef */
                final double[] lnCoef_i = LN_QUICK_COEF[i];
                aa = ya + lnCoef_i[0];
                ab = yb + lnCoef_i[1];
                /* Split y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;
            }

            /* Multiply a = y * x */
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;
            /* split, so now y = a */
            tmp = aa * HEX_40000000;
            ya = aa + tmp - tmp;
            yb = aa - ya + ab;

            return ya + yb;
        }

        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)
        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];

        /*
    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);

    epsilon -= 1.0;
         */

        // y is the most significant 10 bits of the mantissa
        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);
        //double epsilon = (x - y) / y;
        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));

        double lnza = 0.0;
        double lnzb = 0.0;

        if (hiPrec != null) {
            /* split epsilon -> x */
            double tmp = epsilon * HEX_40000000;
            double aa = epsilon + tmp - tmp;
            double ab = epsilon - aa;
            double xa = aa;
            double xb = ab;

            /* Need a more accurate epsilon, so adjust the division. */
            final double numer = bits & 0x3ffffffffffL;
            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
            aa = numer - xa*denom - xb * denom;
            xb += aa / denom;

            /* Remez polynomial evaluation */
            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];
            double ya = lnCoef_last[0];
            double yb = lnCoef_last[1];

            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                /* Add  a = y + lnHiPrecCoef */
                final double[] lnCoef_i = LN_HI_PREC_COEF[i];
                aa = ya + lnCoef_i[0];
                ab = yb + lnCoef_i[1];
                /* Split y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;
            }

            /* Multiply a = y * x */
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;

            /* split, so now lnz = a */
            /*
      tmp = aa * 1073741824.0;
      lnza = aa + tmp - tmp;
      lnzb = aa - lnza + ab;
             */
            lnza = aa + ab;
            lnzb = -(lnza - aa - ab);
        } else {
            /* High precision not required.  Eval Remez polynomial
         using standard double precision */
            lnza = -0.16624882440418567;
            lnza = lnza * epsilon + 0.19999954120254515;
            lnza = lnza * epsilon + -0.2499999997677497;
            lnza = lnza * epsilon + 0.3333333333332802;
            lnza = lnza * epsilon + -0.5;
            lnza = lnza * epsilon + 1.0;
            lnza *= epsilon;
        }

        /* Relative sizes:
         * lnzb     [0, 2.33E-10]
         * lnm[1]   [0, 1.17E-7]
         * ln2B*exp [0, 1.12E-4]
         * lnza      [0, 9.7E-4]
         * lnm[0]   [0, 0.692]
         * ln2A*exp [0, 709]
         */

        /* Compute the following sum:
         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
         */

        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
        double a = LN_2_A*exp;
        double b = 0.0;
        double c = a+lnm[0];
        double d = -(c-a-lnm[0]);
        a = c;
        b += d;

        c = a + lnza;
        d = -(c - a - lnza);
        a = c;
        b += d;

        c = a + LN_2_B*exp;
        d = -(c - a - LN_2_B*exp);
        a = c;
        b += d;

        c = a + lnm[1];
        d = -(c - a - lnm[1]);
        a = c;
        b += d;

        c = a + lnzb;
        d = -(c - a - lnzb);
        a = c;
        b += d;

        if (hiPrec != null) {
            hiPrec[0] = a;
            hiPrec[1] = b;
        }

        return a + b;
    }",0,[0]
27752,bugs-dot-jar_WICKET-5698_f45ce896,"int size()
	{
		return mappers.size();
	}","int size()
	{
		return mappers.size();
	}",0,[0]
21044,bugs-dot-jar_OAK-846_7acb091a,"private Node readNode(String path, Revision rev) {
        String id = Utils.getIdFromPath(path);
        Map<String, Object> map = store.find(DocumentStore.Collection.NODES, id);
        if (map == null) {
            return null;
        }
        Revision min = getLiveRevision(map, rev);
        if (min == null) {
            // deleted
            return null;
        }
        Node n = new Node(path, rev);
        Revision lastRevision = null;
        Revision revision =  unsavedLastRevisions.get(path);
        if (revision != null) {
            if (isRevisionNewer(revision, rev)) {
                // at most the read revision
                revision = rev;
            }
            lastRevision = revision;
        }
        for (String key : map.keySet()) {
            if (key.equals(UpdateOp.LAST_REV)) {
                Object v = map.get(key);
                @SuppressWarnings(""unchecked"")
                Map<String, String> valueMap = (Map<String, String>) v;
                for (String r : valueMap.keySet()) {
                    revision = Revision.fromString(valueMap.get(r));
                    if (isRevisionNewer(revision, rev)) {
                        // at most the read revision
                        revision = rev;
                    }
                    if (lastRevision == null || isRevisionNewer(revision, lastRevision)) {
                        lastRevision = revision;
                    }
                }
            }
            if (!Utils.isPropertyName(key)) {
                continue;
            }
            Object v = map.get(key);
            @SuppressWarnings(""unchecked"")
            Map<String, String> valueMap = (Map<String, String>) v;
            if (valueMap != null) {
                if (valueMap instanceof TreeMap) {
                    // use descending keys (newest first) if map is sorted
                    valueMap = ((TreeMap<String, String>) valueMap).descendingMap();
                }
                String value = getLatestValue(valueMap, min, rev);
                String propertyName = Utils.unescapePropertyName(key);
                n.setProperty(propertyName, value);
            }
        }
        n.setLastRevision(lastRevision);
        return n;
    }","private Node readNode(String path, Revision rev) {
        String id = Utils.getIdFromPath(path);
        Map<String, Object> map = store.find(DocumentStore.Collection.NODES, id);
        if (map == null) {
            return null;
        }
        Revision min = getLiveRevision(map, rev);
        if (min == null) {
            // deleted
            return null;
        }
        Node n = new Node(path, rev);
        Revision lastRevision = null;
        Revision revision =  unsavedLastRevisions.get(path);
        if (revision != null) {
            if (isRevisionNewer(revision, rev)) {
                // at most the read revision
                revision = rev;
            }
            lastRevision = revision;
        }
        for (String key : map.keySet()) {
            if (key.equals(UpdateOp.LAST_REV)) {
                Object v = map.get(key);
                @SuppressWarnings(""unchecked"")
                Map<String, String> valueMap = (Map<String, String>) v;
                for (String r : valueMap.keySet()) {
                    revision = Revision.fromString(valueMap.get(r));
                    if (isRevisionNewer(revision, rev)) {
                        // at most the read revision
                        revision = rev;
                    }
                    if (lastRevision == null || isRevisionNewer(revision, lastRevision)) {
                        lastRevision = revision;
                    }
                }
            }
            if (!Utils.isPropertyName(key)) {
                continue;
            }
            Object v = map.get(key);
            @SuppressWarnings(""unchecked"")
            Map<String, String> valueMap = (Map<String, String>) v;
            if (valueMap != null) {
                if (valueMap instanceof TreeMap) {
                    // use descending keys (newest first) if map is sorted
                    valueMap = ((TreeMap<String, String>) valueMap).descendingMap();
                }
                String value = getLatestValue(valueMap, min, rev);
                String propertyName = Utils.unescapePropertyName(key);
                n.setProperty(propertyName, value);
            }
        }
        n.setLastRevision(lastRevision);
        return n;
    }",0,[0]
36763,bugs-dot-jar_CAMEL-3690_2a3f3392,"public Endpoint getEndpoint(String uri) {
        ObjectHelper.notEmpty(uri, ""uri"");

        if (log.isTraceEnabled()) {
            log.trace(""Getting endpoint with uri: "" + uri);
        }

        // in case path has property placeholders then try to let property component resolve those
        try {
            uri = resolvePropertyPlaceholders(uri);
        } catch (Exception e) {
            throw new ResolveEndpointFailedException(uri, e);
        }

        // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
        uri = normalizeEndpointUri(uri);

        if (log.isTraceEnabled()) {
            log.trace(""Getting endpoint with normalized uri: "" + uri);
        }

        Endpoint answer;
        String scheme = null;
        synchronized (endpoints) {
            answer = endpoints.get(getEndpointKey(uri));
            if (answer == null) {
                try {
                    // Use the URI prefix to find the component.
                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                    if (splitURI[1] != null) {
                        scheme = splitURI[0];
                        Component component = getComponent(scheme);

                        // Ask the component to resolve the endpoint.
                        if (component != null) {
                            // Have the component create the endpoint if it can.
                            answer = component.createEndpoint(uri);

                            if (answer != null && log.isDebugEnabled()) {
                                log.debug(uri + "" converted to endpoint: "" + answer + "" by component: "" + component);
                            }
                        }
                    }

                    if (answer == null) {
                        // no component then try in registry and elsewhere
                        answer = createEndpoint(uri);
                    }

                    if (answer != null) {
                        addService(answer);
                        answer = addEndpointToRegistry(uri, answer);
                    }
                } catch (Exception e) {
                    throw new ResolveEndpointFailedException(uri, e);
                }
            }
        }

        // unknown scheme
        if (answer == null && scheme != null) {
            throw new ResolveEndpointFailedException(uri, ""No component found with scheme: "" + scheme);
        }

        return answer;
    }","public Endpoint getEndpoint(String uri) {
        ObjectHelper.notEmpty(uri, ""uri"");

        if (log.isTraceEnabled()) {
            log.trace(""Getting endpoint with uri: "" + uri);
        }

        // in case path has property placeholders then try to let property component resolve those
        try {
            uri = resolvePropertyPlaceholders(uri);
        } catch (Exception e) {
            throw new ResolveEndpointFailedException(uri, e);
        }

        // normalize uri so we can do endpoint hits with minor mistakes and parameters is not in the same order
        uri = normalizeEndpointUri(uri);

        if (log.isTraceEnabled()) {
            log.trace(""Getting endpoint with normalized uri: "" + uri);
        }

        Endpoint answer;
        String scheme = null;
        synchronized (endpoints) {
            answer = endpoints.get(getEndpointKey(uri));
            if (answer == null) {
                try {
                    // Use the URI prefix to find the component.
                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                    if (splitURI[1] != null) {
                        scheme = splitURI[0];
                        Component component = getComponent(scheme);

                        // Ask the component to resolve the endpoint.
                        if (component != null) {
                            // Have the component create the endpoint if it can.
                            answer = component.createEndpoint(uri);

                            if (answer != null && log.isDebugEnabled()) {
                                log.debug(uri + "" converted to endpoint: "" + answer + "" by component: "" + component);
                            }
                        }
                    }

                    if (answer == null) {
                        // no component then try in registry and elsewhere
                        answer = createEndpoint(uri);
                    }

                    if (answer != null) {
                        addService(answer);
                        answer = addEndpointToRegistry(uri, answer);
                    }
                } catch (Exception e) {
                    throw new ResolveEndpointFailedException(uri, e);
                }
            }
        }

        // unknown scheme
        if (answer == null && scheme != null) {
            throw new ResolveEndpointFailedException(uri, ""No component found with scheme: "" + scheme);
        }

        return answer;
    }",0,[0]
25646,bugs-dot-jar_LOG4J2-1251_424068f7,"@Override
    public void finest(final String msg) {
        logger.logIfEnabled(FQCN, LevelTranslator.FINEST, null, msg);
    }","@Override
    public void finest(final String msg) {
        logger.logIfEnabled(FQCN, LevelTranslator.FINEST, null, msg);
    }",0,[0]
32872,bugs-dot-jar_WICKET-4038_f3d7565c,"protected IRequestHandler processHybrid(PageInfo pageInfo,
		Class<? extends IRequestablePage> pageClass, PageParameters pageParameters,
		Integer renderCount)
	{
		PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,
			renderCount);
		provider.setPageSource(getContext());
		return new RenderPageRequestHandler(provider);
	}","protected IRequestHandler processHybrid(PageInfo pageInfo,
		Class<? extends IRequestablePage> pageClass, PageParameters pageParameters,
		Integer renderCount)
	{
		PageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,
			renderCount);
		provider.setPageSource(getContext());
		return new RenderPageRequestHandler(provider);
	}",0,[0]
10100,bugs-dot-jar_WICKET-4292_9cb617ae,"@Override
	public void reset()
	{
		initialize();
	}","@Override
	public void reset()
	{
		initialize();
	}",0,[0]
2448,bugs-dot-jar_CAMEL-8137_53b4e90c,"private static Class<?> getTargetClass(Class<?> clazz) {
        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
            Class<?> superClass = clazz.getSuperclass();
            if (superClass != null && !Object.class.equals(superClass)) {
                return superClass;
            }
        }
        return clazz;
    }","private static Class<?> getTargetClass(Class<?> clazz) {
        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
            Class<?> superClass = clazz.getSuperclass();
            if (superClass != null && !Object.class.equals(superClass)) {
                return superClass;
            }
        }
        return clazz;
    }",0,[0]
23646,bugs-dot-jar_MATH-744_8a83581e,"public BigDecimal bigDecimalValue() {
        return new BigDecimal(numerator).divide(new BigDecimal(denominator));
    }","public BigDecimal bigDecimalValue() {
        return new BigDecimal(numerator).divide(new BigDecimal(denominator));
    }",0,[0]
1616,bugs-dot-jar_WICKET-5345_3fc7234e,"public String toString(StringMode mode, Charset charset)
	{
		StringBuilder result = new StringBuilder();
		final String path = getPath(charset);

		if (StringMode.FULL == mode)
		{
			if (Strings.isEmpty(host))
			{
				throw new IllegalStateException(""Cannot render this url in "" +
					StringMode.FULL.name() + "" mode because it does not have a host set."");
			}

			if (Strings.isEmpty(protocol) == false)
			{
				result.append(protocol);
				result.append(""://"");
			}
			else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)
			{
				result.append(""//"");
			}
			result.append(host);

			if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)
			{
				result.append(':');
				result.append(port);
			}

			if (segments.contains(""..""))
			{
				throw new IllegalStateException(""Cannot render this url in "" +
					StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
			}

			if (!path.startsWith(""/""))
			{
				result.append('/');
			}

		}

		result.append(path);

		final String queryString = getQueryString(charset);
		if (queryString != null)
		{
			result.append('?').append(queryString);
		}
		return result.toString();
	}","public String toString(StringMode mode, Charset charset)
	{
		StringBuilder result = new StringBuilder();
		final String path = getPath(charset);

		if (StringMode.FULL == mode)
		{
			if (Strings.isEmpty(host))
			{
				throw new IllegalStateException(""Cannot render this url in "" +
					StringMode.FULL.name() + "" mode because it does not have a host set."");
			}

			if (Strings.isEmpty(protocol) == false)
			{
				result.append(protocol);
				result.append(""://"");
			}
			else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)
			{
				result.append(""//"");
			}
			result.append(host);

			if (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)
			{
				result.append(':');
				result.append(port);
			}

			if (segments.contains(""..""))
			{
				throw new IllegalStateException(""Cannot render this url in "" +
					StringMode.FULL.name() + "" mode because it has a `..` segment: "" + toString());
			}

			if (!path.startsWith(""/""))
			{
				result.append('/');
			}

		}

		result.append(path);

		final String queryString = getQueryString(charset);
		if (queryString != null)
		{
			result.append('?').append(queryString);
		}
		return result.toString();
	}",0,[0]
15408,bugs-dot-jar_FLINK-2484_d738430c,"private void releaseBlocks() throws IOException {
		if (LOG.isDebugEnabled()) {
			LOG.debug(""Releasing blocks"");
		}

		for (int i = 0; i < blockedChannels.length; i++) {
			blockedChannels[i] = false;
		}
		numReceivedBarriers = 0;

		if (currentBuffered == null) {
			// common case: no more buffered data
			currentBuffered = bufferSpiller.rollOver();
			if (currentBuffered != null) {
				currentBuffered.open();
			}
		}
		else {
			// uncommon case: buffered data pending
			// push back the pending data
			queuedBuffered.addFirst(currentBuffered);
			
			// since we did not fully drain the previous sequence, we need to allocate a new buffer for this one 
			currentBuffered = bufferSpiller.rollOverWithNewBuffer();
			if (currentBuffered != null) {
				currentBuffered.open();
			}
		}
	}","private void releaseBlocks() throws IOException {
		if (LOG.isDebugEnabled()) {
			LOG.debug(""Releasing blocks"");
		}

		for (int i = 0; i < blockedChannels.length; i++) {
			blockedChannels[i] = false;
		}
		numReceivedBarriers = 0;

		if (currentBuffered == null) {
			// common case: no more buffered data
			currentBuffered = bufferSpiller.rollOver();
			if (currentBuffered != null) {
				currentBuffered.open();
			}
		}
		else {
			// uncommon case: buffered data pending
			// push back the pending data
			queuedBuffered.addFirst(currentBuffered);
			
			// since we did not fully drain the previous sequence, we need to allocate a new buffer for this one 
			currentBuffered = bufferSpiller.rollOverWithNewBuffer();
			if (currentBuffered != null) {
				currentBuffered.open();
			}
		}
	}",0,[0]
695,bugs-dot-jar_MATH-320_b2f3f6db,"public double[] getSingularValues()
        throws InvalidMatrixException {
        return singularValues.clone();
    }","public double[] getSingularValues()
        throws InvalidMatrixException {
        return singularValues.clone();
    }",0,[0]
22544,bugs-dot-jar_FLINK-1820_39d526e6,"@Override
	public Byte getLastResult() {
		return Byte.valueOf(this.result);
	}","@Override
	public Byte getLastResult() {
		return Byte.valueOf(this.result);
	}",0,[0]
33333,bugs-dot-jar_ACCUMULO-795_9453bcfa,"public static byte[] encodeIteratorSettings(List<IteratorSetting> iterators) {
    return encodeIteratorSettings(toIteratorConfig(iterators));
  }","public static byte[] encodeIteratorSettings(List<IteratorSetting> iterators) {
    return encodeIteratorSettings(toIteratorConfig(iterators));
  }",0,[0]
2758,bugs-dot-jar_LOG4J2-1025_a96b455c,"@Override
    public Level toLevel(final java.util.logging.Level javaLevel) {
        return julToLog4j.get(javaLevel);
    }","@Override
    public Level toLevel(final java.util.logging.Level javaLevel) {
        final Level level = julToLog4j.get(javaLevel);
        return level != null ? level : addCustomJulLevel(javaLevel);
    }",1,[2]
4768,bugs-dot-jar_MATH-326_ce185345,"public double dotProduct(RealVector v)
        throws IllegalArgumentException {
        if (v instanceof ArrayRealVector) {
            return dotProduct((ArrayRealVector) v);
        } else {
            checkVectorDimensions(v);
            double dot = 0;
            Iterator<Entry> it = v.sparseIterator();
            Entry e;
            while(it.hasNext() && (e = it.next()) != null) {
                dot += data[e.getIndex()] * e.getValue();
            }
            return dot;
        }
    }","public double dotProduct(RealVector v)
        throws IllegalArgumentException {
        if (v instanceof ArrayRealVector) {
            return dotProduct((ArrayRealVector) v);
        } else {
            checkVectorDimensions(v);
            double dot = 0;
            Iterator<Entry> it = v.sparseIterator();
            Entry e;
            while(it.hasNext() && (e = it.next()) != null) {
                dot += data[e.getIndex()] * e.getValue();
            }
            return dot;
        }
    }",0,[0]
26890,bugs-dot-jar_WICKET-5724_b92591f6,"@Override
	public final boolean closes(final MarkupElement open)
	{
		if (open instanceof ComponentTag)
		{
			return (openTag == open) || getXmlTag().closes(((ComponentTag)open).getXmlTag());
		}

		return false;
	}","@Override
	public final boolean closes(final MarkupElement open)
	{
		if (open instanceof ComponentTag)
		{
			return (openTag == open) || getXmlTag().closes(((ComponentTag)open).getXmlTag());
		}

		return false;
	}",0,[0]
24012,bugs-dot-jar_OAK-579_7d72e6ed,"public void bindSelector(SourceImpl source) {
        parentSelector = source.getExistingSelector(parentSelectorName);
        childSelector = source.getExistingSelector(childSelectorName);
    }","public void bindSelector(SourceImpl source) {
        parentSelector = source.getExistingSelector(parentSelectorName);
        childSelector = source.getExistingSelector(childSelectorName);
    }",0,[0]
785,bugs-dot-jar_ACCUMULO-412_5594b2e0,"@Override
  public void setup(final Context context) {
    Configuration conf = context.getConfiguration();
    tablename = new Text(WikipediaConfiguration.getTableName(conf));
    indexTableName = new Text(tablename + ""Index"");
    reverseIndexTableName = new Text(tablename + ""ReverseIndex"");
    metadataTableName = new Text(tablename + ""Metadata"");
    
    try {
      mtbw = WikipediaConfiguration.getConnector(conf).createMultiTableBatchWriter(10000000, 1000, 10);
    } catch (AccumuloException e) {
      throw new RuntimeException(e);
    } catch (AccumuloSecurityException e) {
      throw new RuntimeException(e);
    }
    
    final Text metadataTableNameFinal = metadataTableName;
    final Text indexTableNameFinal = indexTableName;
    final Text reverseIndexTableNameFinal = reverseIndexTableName;
    
    numPartitions = WikipediaConfiguration.getNumPartitions(conf);

    LRUOutputCombiner.Fold<CountAndSet> indexFold = 
        new LRUOutputCombiner.Fold<CountAndSet>() {
      @Override
      public CountAndSet fold(CountAndSet oldValue, CountAndSet newValue) {
        oldValue.count += newValue.count;
        if(oldValue.set == null || newValue.set == null)
        {
          oldValue.set = null;
          return oldValue;
        }
        oldValue.set.addAll(newValue.set);
        if(oldValue.set.size() > GlobalIndexUidCombiner.MAX)
          oldValue.set = null;
        return oldValue;
      }
    };
    LRUOutputCombiner.Output<MutationInfo,CountAndSet> indexOutput =
        new LRUOutputCombiner.Output<WikipediaPartitionedMapper.MutationInfo,CountAndSet>() {
      
      @Override
      public void output(MutationInfo key, CountAndSet value)
      {
          Uid.List.Builder builder = Uid.List.newBuilder();
          builder.setCOUNT(value.count);
          if (value.set == null) {
            builder.setIGNORE(true);
            builder.clearUID();
          } else {
            builder.setIGNORE(false);
            builder.addAllUID(value.set);
          }
          Uid.List list = builder.build();
          Value val = new Value(list.toByteArray());
          Mutation m = new Mutation(key.row);
          m.put(key.colfam, key.colqual, key.cv, key.timestamp, val);
          try {
            mtbw.getBatchWriter(indexTableNameFinal.toString()).addMutation(m);
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
      }
    };
    LRUOutputCombiner.Output<MutationInfo,CountAndSet> reverseIndexOutput =
        new LRUOutputCombiner.Output<WikipediaPartitionedMapper.MutationInfo,CountAndSet>() {
      
      @Override
      public void output(MutationInfo key, CountAndSet value)
      {
          Uid.List.Builder builder = Uid.List.newBuilder();
          builder.setCOUNT(value.count);
          if (value.set == null) {
            builder.setIGNORE(true);
            builder.clearUID();
          } else {
            builder.setIGNORE(false);
            builder.addAllUID(value.set);
          }
          Uid.List list = builder.build();
          Value val = new Value(list.toByteArray());
          Mutation m = new Mutation(key.row);
          m.put(key.colfam, key.colqual, key.cv, key.timestamp, val);
          try {
            mtbw.getBatchWriter(reverseIndexTableNameFinal.toString()).addMutation(m);
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
      }
    };
      
    wikiIndexOutput = new LRUOutputCombiner<WikipediaPartitionedMapper.MutationInfo,CountAndSet>(10000,indexFold,indexOutput);
    wikiReverseIndexOutput = new LRUOutputCombiner<WikipediaPartitionedMapper.MutationInfo,CountAndSet>(10000, indexFold,reverseIndexOutput);
    wikiMetadataOutput = new LRUOutputCombiner<WikipediaPartitionedMapper.MutationInfo,Value>(10000,
        new LRUOutputCombiner.Fold<Value>() {
          @Override
          public Value fold(Value oldValue, Value newValue) {
            return oldValue;
          }},
        new LRUOutputCombiner.Output<MutationInfo,Value>() {
          @Override
          public void output(MutationInfo key, Value value) {
            Mutation m = new Mutation(key.row);
            m.put(key.colfam, key.colqual, key.cv, key.timestamp, value);
            try {
              mtbw.getBatchWriter(metadataTableNameFinal.toString()).addMutation(m);
            } catch (Exception e) {
              throw new RuntimeException(e);
            }
          }});
  }","@Override
  public void setup(final Context context) {
    Configuration conf = context.getConfiguration();
    tablename = new Text(WikipediaConfiguration.getTableName(conf));
    indexTableName = new Text(tablename + ""Index"");
    reverseIndexTableName = new Text(tablename + ""ReverseIndex"");
    metadataTableName = new Text(tablename + ""Metadata"");
    
    try {
      mtbw = WikipediaConfiguration.getConnector(conf).createMultiTableBatchWriter(10000000, 1000, 10);
    } catch (AccumuloException e) {
      throw new RuntimeException(e);
    } catch (AccumuloSecurityException e) {
      throw new RuntimeException(e);
    }
    
    final Text metadataTableNameFinal = metadataTableName;
    final Text indexTableNameFinal = indexTableName;
    final Text reverseIndexTableNameFinal = reverseIndexTableName;
    
    numPartitions = WikipediaConfiguration.getNumPartitions(conf);

    LRUOutputCombiner.Fold<CountAndSet> indexFold = 
        new LRUOutputCombiner.Fold<CountAndSet>() {
      @Override
      public CountAndSet fold(CountAndSet oldValue, CountAndSet newValue) {
        oldValue.count += newValue.count;
        if(oldValue.set == null || newValue.set == null)
        {
          oldValue.set = null;
          return oldValue;
        }
        oldValue.set.addAll(newValue.set);
        if(oldValue.set.size() > GlobalIndexUidCombiner.MAX)
          oldValue.set = null;
        return oldValue;
      }
    };
    LRUOutputCombiner.Output<MutationInfo,CountAndSet> indexOutput =
        new LRUOutputCombiner.Output<WikipediaPartitionedMapper.MutationInfo,CountAndSet>() {
      
      @Override
      public void output(MutationInfo key, CountAndSet value)
      {
          Uid.List.Builder builder = Uid.List.newBuilder();
          builder.setCOUNT(value.count);
          if (value.set == null) {
            builder.setIGNORE(true);
            builder.clearUID();
          } else {
            builder.setIGNORE(false);
            builder.addAllUID(value.set);
          }
          Uid.List list = builder.build();
          Value val = new Value(list.toByteArray());
          Mutation m = new Mutation(key.row);
          m.put(key.colfam, key.colqual, key.cv, key.timestamp, val);
          try {
            mtbw.getBatchWriter(indexTableNameFinal.toString()).addMutation(m);
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
      }
    };
    LRUOutputCombiner.Output<MutationInfo,CountAndSet> reverseIndexOutput =
        new LRUOutputCombiner.Output<WikipediaPartitionedMapper.MutationInfo,CountAndSet>() {
      
      @Override
      public void output(MutationInfo key, CountAndSet value)
      {
          Uid.List.Builder builder = Uid.List.newBuilder();
          builder.setCOUNT(value.count);
          if (value.set == null) {
            builder.setIGNORE(true);
            builder.clearUID();
          } else {
            builder.setIGNORE(false);
            builder.addAllUID(value.set);
          }
          Uid.List list = builder.build();
          Value val = new Value(list.toByteArray());
          Mutation m = new Mutation(key.row);
          m.put(key.colfam, key.colqual, key.cv, key.timestamp, val);
          try {
            mtbw.getBatchWriter(reverseIndexTableNameFinal.toString()).addMutation(m);
          } catch (Exception e) {
            throw new RuntimeException(e);
          }
      }
    };
      
    wikiIndexOutput = new LRUOutputCombiner<WikipediaPartitionedMapper.MutationInfo,CountAndSet>(10000,indexFold,indexOutput);
    wikiReverseIndexOutput = new LRUOutputCombiner<WikipediaPartitionedMapper.MutationInfo,CountAndSet>(10000, indexFold,reverseIndexOutput);
    wikiMetadataOutput = new LRUOutputCombiner<WikipediaPartitionedMapper.MutationInfo,Value>(10000,
        new LRUOutputCombiner.Fold<Value>() {
          @Override
          public Value fold(Value oldValue, Value newValue) {
            return oldValue;
          }},
        new LRUOutputCombiner.Output<MutationInfo,Value>() {
          @Override
          public void output(MutationInfo key, Value value) {
            Mutation m = new Mutation(key.row);
            m.put(key.colfam, key.colqual, key.cv, key.timestamp, value);
            try {
              mtbw.getBatchWriter(metadataTableNameFinal.toString()).addMutation(m);
            } catch (Exception e) {
              throw new RuntimeException(e);
            }
          }});
  }",0,[0]
17604,bugs-dot-jar_WICKET-4715_4fc82e35,"@Override
	protected void onComponentTag(final ComponentTag tag)
	{
		super.onComponentTag(tag);

		checkComponentTag(tag, ""form"");

		if (isRootForm())
		{
			String method = getMethod().toLowerCase(Locale.ENGLISH);
			tag.put(""method"", method);
			String url = getActionUrl().toString();
			if (encodeUrlInHiddenFields())
			{
				int i = url.indexOf('?');
				String action = (i > -1) ? url.substring(0, i) : """";
				tag.put(""action"", action);
				// alternatively, we could just put an empty string here, so
				// that mounted paths stay in good order. I decided against this
				// as I'm not sure whether that could have side effects with
				// other encoders
			}
			else
			{
				tag.put(""action"", url);
			}

			if (isMultiPart())
			{
				if (METHOD_GET.equalsIgnoreCase(method))
				{
					log.warn(""Form with id '{}' is multipart. It should use method 'POST'!"",
						getId());
					tag.put(""method"", METHOD_POST.toLowerCase(Locale.ENGLISH));
				}

				tag.put(""enctype"", ""multipart/form-data"");
				//
				// require the application-encoding for multipart/form-data to be sure to
				// get multipart-uploaded characters with the proper encoding on the following
				// request.
				//
				// for details see: http://stackoverflow.com/questions/546365
				//
				tag.put(""accept-charset"", getApplication().getRequestCycleSettings()
					.getResponseRequestEncoding());
			}
			else
			{
				// sanity check
				String enctype = (String)tag.getAttributes().get(""enctype"");
				if (""multipart/form-data"".equalsIgnoreCase(enctype))
				{
					// though not set explicitly in Java, this is a multipart
					// form
					setMultiPart(true);
				}
			}
		}
		else
		{
			tag.setName(""div"");
			tag.remove(""method"");
			tag.remove(""action"");
			tag.remove(""enctype"");
		}
	}","@Override
	protected void onComponentTag(final ComponentTag tag)
	{
		super.onComponentTag(tag);

		checkComponentTag(tag, ""form"");

		if (isRootForm())
		{
			String method = getMethod().toLowerCase(Locale.ENGLISH);
			tag.put(""method"", method);
			String url = getActionUrl().toString();
			if (encodeUrlInHiddenFields())
			{
				int i = url.indexOf('?');
				String action = (i > -1) ? url.substring(0, i) : """";
				tag.put(""action"", action);
				// alternatively, we could just put an empty string here, so
				// that mounted paths stay in good order. I decided against this
				// as I'm not sure whether that could have side effects with
				// other encoders
			}
			else
			{
				tag.put(""action"", url);
			}

			if (isMultiPart())
			{
				if (METHOD_GET.equalsIgnoreCase(method))
				{
					log.warn(""Form with id '{}' is multipart. It should use method 'POST'!"",
						getId());
					tag.put(""method"", METHOD_POST.toLowerCase(Locale.ENGLISH));
				}

				tag.put(""enctype"", ENCTYPE_MULTIPART_FORM_DATA);
				//
				// require the application-encoding for multipart/form-data to be sure to
				// get multipart-uploaded characters with the proper encoding on the following
				// request.
				//
				// for details see: http://stackoverflow.com/questions/546365
				//
				tag.put(""accept-charset"", getApplication().getRequestCycleSettings()
					.getResponseRequestEncoding());
			}
			else
			{
				// sanity check
				String enctype = (String)tag.getAttributes().get(""enctype"");
				if (ENCTYPE_MULTIPART_FORM_DATA.equalsIgnoreCase(enctype))
				{
					// though not set explicitly in Java, this is a multipart
					// form
					setMultiPart(true);
				}
			}
		}
		else
		{
			tag.setName(""div"");
			tag.remove(""method"");
			tag.remove(""action"");
			tag.remove(""enctype"");
		}
	}",1,"[36, 51]"
8038,bugs-dot-jar_OAK-2147_a1556c30,"public Iterable<String> query(final Filter filter, final String indexName,
                                  final NodeState indexMeta, final PropertyRestriction pr,
                                  String pathPrefix) {
        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr, pathPrefix);
    }","public Iterable<String> query(final Filter filter, final String indexName,
                                  final NodeState indexMeta, final PropertyRestriction pr,
                                  String pathPrefix) {
        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr, pathPrefix);
    }",0,[0]
22720,bugs-dot-jar_MATH-778_5b9302d5,"public DfpField getField() {
        return field;
    }","public DfpField getField() {
        return field;
    }",0,[0]
16632,bugs-dot-jar_WICKET-5689_2ac29d30,"public void setServletContext(ServletContext servletContext)
	{
		this.servletContext = servletContext;
	}","public void setServletContext(ServletContext servletContext)
	{
		this.servletContext = servletContext;
	}",0,[0]
22109,bugs-dot-jar_WICKET-1677_01a3dd66,"@Override
	protected void onComponentTag(ComponentTag tag)
	{
		super.onComponentTag(tag);
		// No longer applicable, breaks XHTML validation.
		tag.remove(""multiple"");
		tag.remove(""size"");
		tag.remove(""disabled"");
		tag.remove(""name"");
	}","@Override
	protected void onComponentTag(ComponentTag tag)
	{
		super.onComponentTag(tag);
		// No longer applicable, breaks XHTML validation.
		tag.remove(""multiple"");
		tag.remove(""size"");
		tag.remove(""disabled"");
		tag.remove(""name"");
	}",0,[0]
2995,bugs-dot-jar_OAK-3733_a5ff019e,"private void checkConflicts(@Nonnull UpdateOp op,
                                @Nullable NodeDocument before)
            throws ConflictException {
        DocumentStore store = nodeStore.getDocumentStore();
        collisions.clear();
        if (baseRevision != null) {
            Revision newestRev = null;
            if (before != null) {
                Revision base = baseRevision;
                if (nodeStore.isDisableBranches()) {
                    base = base.asTrunkRevision();
                }
                newestRev = before.getNewestRevision(
                        nodeStore, base, revision, getBranch(), collisions);
            }
            String conflictMessage = null;
            Revision conflictRevision = newestRev;
            if (newestRev == null) {
                if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" does not exist or is already deleted"";
                    if (before != null && !before.getLocalDeleted().isEmpty()) {
                        conflictRevision = before.getLocalDeleted().firstKey();
                    }
                }
            } else {
                if (op.isNew() && isConflicting(before, op)) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was already added in revision\n"" +
                            formatConflictRevision(newestRev);
                } else if (nodeStore.isRevisionNewer(newestRev, baseRevision)
                        && (op.isDelete() || isConflicting(before, op))) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was changed in revision\n"" +
                            formatConflictRevision(newestRev) +
                            "", which was applied after the base revision\n"" +
                            baseRevision;
                }
            }
            if (conflictMessage == null) {
                // the modification was successful
                // -> check for collisions and conflict (concurrent updates
                // on a node are possible if property updates do not overlap)
                // TODO: unify above conflict detection and isConflicting()
                if (!collisions.isEmpty() && isConflicting(before, op)) {
                    for (Revision r : collisions) {
                        // mark collisions on commit root
                        Collision c = new Collision(before, r, op, revision);
                        if (c.mark(store).equals(revision)) {
                            // our revision was marked
                            if (baseRevision.isBranch()) {
                                // this is a branch commit. do not fail immediately
                                // merging this branch will fail later.
                            } else {
                                // fail immediately
                                conflictMessage = ""The node "" +
                                        op.getId() + "" was changed in revision\n"" +
                                        formatConflictRevision(r) +
                                        "", which was applied after the base revision\n"" +
                                        baseRevision;
                                conflictRevision = r;
                            }
                        }
                    }
                }
            }
            if (conflictMessage != null) {
                conflictMessage += "", before\n"" + revision;
                if (LOG.isDebugEnabled()) {
                    LOG.debug(conflictMessage  + ""; document:\n"" +
                            (before == null ? """" : before.format()) +
                            "",\nrevision order:\n"" +
                            nodeStore.getRevisionComparator());
                }
                throw new ConflictException(conflictMessage, conflictRevision);
            }
        }
    }","private void checkConflicts(@Nonnull UpdateOp op,
                                @Nullable NodeDocument before)
            throws ConflictException {
        DocumentStore store = nodeStore.getDocumentStore();
        collisions.clear();
        if (baseRevision != null) {
            Revision newestRev = null;
            if (before != null) {
                Revision base = baseRevision;
                if (nodeStore.isDisableBranches()) {
                    base = base.asTrunkRevision();
                }
                newestRev = before.getNewestRevision(
                        nodeStore, base, revision, getBranch(), collisions);
            }
            String conflictMessage = null;
            Revision conflictRevision = newestRev;
            if (newestRev == null) {
                if ((op.isDelete() || !op.isNew())
                        && !allowConcurrentAddRemove(before, op)) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" does not exist or is already deleted"";
                    if (before != null && !before.getLocalDeleted().isEmpty()) {
                        conflictRevision = before.getLocalDeleted().firstKey();
                    }
                }
            } else {
                if (op.isNew() && !allowConcurrentAddRemove(before, op)) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was already added in revision\n"" +
                            formatConflictRevision(newestRev);
                } else if (nodeStore.isRevisionNewer(newestRev, baseRevision)
                        && (op.isDelete() || isConflicting(before, op))) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was changed in revision\n"" +
                            formatConflictRevision(newestRev) +
                            "", which was applied after the base revision\n"" +
                            baseRevision;
                }
            }
            if (conflictMessage == null) {
                // the modification was successful
                // -> check for collisions and conflict (concurrent updates
                // on a node are possible if property updates do not overlap)
                // TODO: unify above conflict detection and isConflicting()
                if (!collisions.isEmpty() && isConflicting(before, op)) {
                    for (Revision r : collisions) {
                        // mark collisions on commit root
                        Collision c = new Collision(before, r, op, revision);
                        if (c.mark(store).equals(revision)) {
                            // our revision was marked
                            if (baseRevision.isBranch()) {
                                // this is a branch commit. do not fail immediately
                                // merging this branch will fail later.
                            } else {
                                // fail immediately
                                conflictMessage = ""The node "" +
                                        op.getId() + "" was changed in revision\n"" +
                                        formatConflictRevision(r) +
                                        "", which was applied after the base revision\n"" +
                                        baseRevision;
                                conflictRevision = r;
                            }
                        }
                    }
                }
            }
            if (conflictMessage != null) {
                conflictMessage += "", before\n"" + revision;
                if (LOG.isDebugEnabled()) {
                    LOG.debug(conflictMessage  + ""; document:\n"" +
                            (before == null ? """" : before.format()) +
                            "",\nrevision order:\n"" +
                            nodeStore.getRevisionComparator());
                }
                throw new ConflictException(conflictMessage, conflictRevision);
            }
        }
    }",1,"[18, 26]"
14311,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public void importDirectory(ByteBuffer login, String tableName, String importDir, String failureDir, boolean setTime) throws TException {
    try {
      getConnector(login).tableOperations().importDirectory(tableName, importDir, failureDir, setTime);
    } catch (Exception e) {
      throw translateException(e);
    }
    
  }","@Override
  public void importDirectory(ByteBuffer login, String tableName, String importDir, String failureDir, boolean setTime) throws TException {
    try {
      getConnector(login).tableOperations().importDirectory(tableName, importDir, failureDir, setTime);
    } catch (Exception e) {
      throw translateException(e);
    }
    
  }",0,[0]
37456,bugs-dot-jar_OAK-3137_c65b07c3,"private static boolean canSortByProperty(List<OrderEntry> sortOrder) {
        if (sortOrder.isEmpty()) {
            return false;
        }

        // If jcr:score is the only sort order then opt out
        if (sortOrder.size() == 1 &&
                JCR_SCORE.equals(sortOrder.get(0).getPropertyName())) {
            return false;
        }

        return true;
    }","private static boolean canSortByProperty(List<OrderEntry> sortOrder) {
        if (sortOrder.isEmpty()) {
            return false;
        }

        // If jcr:score is the only sort order then opt out
        if (sortOrder.size() == 1 &&
                JCR_SCORE.equals(sortOrder.get(0).getPropertyName())) {
            return false;
        }

        return true;
    }",0,[0]
18549,bugs-dot-jar_CAMEL-9666_da035952,"public void setUnitOfWork(UnitOfWork unitOfWork) {
        this.unitOfWork = unitOfWork;
        if (unitOfWork != null && onCompletions != null) {
            // now an unit of work has been assigned so add the on completions
            // we might have registered already
            for (Synchronization onCompletion : onCompletions) {
                unitOfWork.addSynchronization(onCompletion);
            }
            // cleanup the temporary on completion list as they now have been registered
            // on the unit of work
            onCompletions.clear();
            onCompletions = null;
        }
    }","public void setUnitOfWork(UnitOfWork unitOfWork) {
        this.unitOfWork = unitOfWork;
        if (unitOfWork != null && onCompletions != null) {
            // now an unit of work has been assigned so add the on completions
            // we might have registered already
            for (Synchronization onCompletion : onCompletions) {
                unitOfWork.addSynchronization(onCompletion);
            }
            // cleanup the temporary on completion list as they now have been registered
            // on the unit of work
            onCompletions.clear();
            onCompletions = null;
        }
    }",0,[0]
1185,Bears-152,"public Boolean getKeepAlive() {
        return keepAlive;
    }","public Boolean getKeepAlive() {
        return keepAlive;
    }",0,[0]
20430,bugs-dot-jar_WICKET-128_7e1000dd,"public Application getApplication()
	{
		return Application.get();
	}","public Application getApplication()
	{
		return Application.get();
	}",0,[0]
13234,bugs-dot-jar_OAK-2260_0ac7ff20,"private void initSync() {
        log.debug(""new head id "" + head);
        long t = System.currentTimeMillis();

        try {
            store.setLoader(this);
            SegmentNodeState before = store.getHead();
            SegmentNodeBuilder builder = before.builder();

            SegmentNodeState current = new SegmentNodeState(head);
            do {
                try {
                    current.compareAgainstBaseState(before, new ApplyDiff(builder));
                    break;
                }
                catch (SegmentNotFoundException e) {
                    // the segment is locally damaged or not present anymore
                    // lets try to read this from the primary again
                    String id = e.getSegmentId();
                    Segment s = readSegment(e.getSegmentId());
                    if (s == null) {
                        log.warn(""can't read locally corrupt segment "" + id + "" from primary"");
                        throw e;
                    }

                    log.debug(""did reread locally corrupt segment "" + id + "" with size "" + s.size());
                    ByteArrayOutputStream bout = new ByteArrayOutputStream(s.size());
                    try {
                        s.writeTo(bout);
                    }
                    catch (IOException f) {
                        log.error(""can't wrap segment to output stream"", f);
                        throw e;
                    }
                    store.writeSegment(s.getSegmentId(), bout.toByteArray(), 0, s.size());
                }
            } while(true);
            boolean ok = store.setHead(before, builder.getNodeState());
            log.debug(""updated head state successfully: {} in {}ms."", ok,
                    System.currentTimeMillis() - t);
        } finally {
            close();
        }
    }","private void initSync() {
        log.debug(""new head id "" + head);
        long t = System.currentTimeMillis();

        try {
            store.setLoader(this);
            SegmentNodeState before = store.getHead();
            SegmentNodeBuilder builder = before.builder();

            SegmentNodeState current = new SegmentNodeState(head);
            do {
                try {
                    current.compareAgainstBaseState(before, new ApplyDiff(builder));
                    break;
                }
                catch (SegmentNotFoundException e) {
                    // the segment is locally damaged or not present anymore
                    // lets try to read this from the primary again
                    String id = e.getSegmentId();
                    Segment s = readSegment(e.getSegmentId());
                    if (s == null) {
                        log.warn(""can't read locally corrupt segment "" + id + "" from primary"");
                        throw e;
                    }

                    log.debug(""did reread locally corrupt segment "" + id + "" with size "" + s.size());
                    ByteArrayOutputStream bout = new ByteArrayOutputStream(s.size());
                    try {
                        s.writeTo(bout);
                    }
                    catch (IOException f) {
                        log.error(""can't wrap segment to output stream"", f);
                        throw e;
                    }
                    store.writeSegment(s.getSegmentId(), bout.toByteArray(), 0, s.size());
                }
            } while(true);
            boolean ok = store.setHead(before, builder.getNodeState());
            log.debug(""updated head state successfully: {} in {}ms."", ok,
                    System.currentTimeMillis() - t);
        } finally {
            close();
        }
    }",0,[0]
29409,bugs-dot-jar_OAK-1129_2f95b81f,"public MongoNodeStore(MongoMK.Builder builder) {
        if (builder.isUseSimpleRevision()) {
            this.simpleRevisionCounter = new AtomicInteger(0);
        }
        DocumentStore s = builder.getDocumentStore();
        if (builder.getTiming()) {
            s = new TimingDocumentStoreWrapper(s);
        }
        if (builder.getLogging()) {
            s = new LoggingDocumentStoreWrapper(s);
        }
        this.store = s;
        int cid = builder.getClusterId();
        cid = Integer.getInteger(""oak.mongoMK.clusterId"", cid);
        if (cid == 0) {
            clusterNodeInfo = ClusterNodeInfo.getInstance(store);
            // TODO we should ensure revisions generated from now on
            // are never ""older"" than revisions already in the repository for
            // this cluster id
            cid = clusterNodeInfo.getId();
        } else {
            clusterNodeInfo = null;
        }
        this.clusterId = cid;
        this.revisionComparator = new Revision.RevisionComparator(clusterId);
        this.branches = new UnmergedBranches(getRevisionComparator());
        this.splitDocumentAgeMillis = builder.getSplitDocumentAgeMillis();
        this.asyncDelay = builder.getAsyncDelay();

        //TODO Make stats collection configurable as it add slight overhead

        nodeCache = builder.buildCache(builder.getNodeCacheSize());
        nodeCacheStats = new CacheStats(nodeCache, ""MongoMk-Node"",
                builder.getWeigher(), builder.getNodeCacheSize());

        nodeChildrenCache = builder.buildCache(builder.getChildrenCacheSize());
        nodeChildrenCacheStats = new CacheStats(nodeChildrenCache, ""MongoMk-NodeChildren"",
                builder.getWeigher(), builder.getChildrenCacheSize());

        docChildrenCache = builder.buildCache(builder.getDocChildrenCacheSize());
        docChildrenCacheStats = new CacheStats(docChildrenCache, ""MongoMk-DocChildren"",
                builder.getWeigher(), builder.getDocChildrenCacheSize());

        init();
        // initial reading of the revisions of other cluster nodes
        backgroundRead();
        getRevisionComparator().add(headRevision, Revision.newRevision(0));
        headRevision = newRevision();
        dispatcher = new ChangeDispatcher(this);
        commitQueue = new CommitQueue(this, dispatcher);

        LOG.info(""Initialized MongoNodeStore with clusterNodeId: {}"", clusterId);
    }","public MongoNodeStore(MongoMK.Builder builder) {
        if (builder.isUseSimpleRevision()) {
            this.simpleRevisionCounter = new AtomicInteger(0);
        }
        DocumentStore s = builder.getDocumentStore();
        if (builder.getTiming()) {
            s = new TimingDocumentStoreWrapper(s);
        }
        if (builder.getLogging()) {
            s = new LoggingDocumentStoreWrapper(s);
        }
        this.store = s;
        int cid = builder.getClusterId();
        cid = Integer.getInteger(""oak.mongoMK.clusterId"", cid);
        if (cid == 0) {
            clusterNodeInfo = ClusterNodeInfo.getInstance(store);
            // TODO we should ensure revisions generated from now on
            // are never ""older"" than revisions already in the repository for
            // this cluster id
            cid = clusterNodeInfo.getId();
        } else {
            clusterNodeInfo = null;
        }
        this.clusterId = cid;
        this.revisionComparator = new Revision.RevisionComparator(clusterId);
        this.branches = new UnmergedBranches(getRevisionComparator());
        this.splitDocumentAgeMillis = builder.getSplitDocumentAgeMillis();
        this.asyncDelay = builder.getAsyncDelay();

        //TODO Make stats collection configurable as it add slight overhead

        nodeCache = builder.buildCache(builder.getNodeCacheSize());
        nodeCacheStats = new CacheStats(nodeCache, ""MongoMk-Node"",
                builder.getWeigher(), builder.getNodeCacheSize());

        nodeChildrenCache = builder.buildCache(builder.getChildrenCacheSize());
        nodeChildrenCacheStats = new CacheStats(nodeChildrenCache, ""MongoMk-NodeChildren"",
                builder.getWeigher(), builder.getChildrenCacheSize());

        docChildrenCache = builder.buildCache(builder.getDocChildrenCacheSize());
        docChildrenCacheStats = new CacheStats(docChildrenCache, ""MongoMk-DocChildren"",
                builder.getWeigher(), builder.getDocChildrenCacheSize());

        init();
        // initial reading of the revisions of other cluster nodes
        backgroundRead();
        getRevisionComparator().add(headRevision, Revision.newRevision(0));
        headRevision = newRevision();
        dispatcher = new ChangeDispatcher(this);
        commitQueue = new CommitQueue(this, dispatcher);

        LOG.info(""Initialized MongoNodeStore with clusterNodeId: {}"", clusterId);
    }",0,[0]
31838,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"public void putDelete(byte[] columnFamily, byte[] columnQualifier, ColumnVisibility columnVisibility, long timestamp) {
    put(columnFamily, columnQualifier, columnVisibility.getExpression(), true, timestamp, true, EMPTY_BYTES);
  }","public void putDelete(byte[] columnFamily, byte[] columnQualifier, ColumnVisibility columnVisibility, long timestamp) {
    put(columnFamily, columnQualifier, columnVisibility.getExpression(), true, timestamp, true, EMPTY_BYTES);
  }",0,[0]
26,Bears-2,"@Override
    public Object deserializeKey(String key, DeserializationContext ctxt)
        throws IOException
    {
        if (key == null) { // is this even legal call?
            return null;
        }
        try {
            Object result = _parse(key, ctxt);
            if (result != null) {
                return result;
            }
        } catch (Exception re) {
            throw ctxt.weirdKeyException(_keyClass, key, ""not a valid representation: ""+re.getMessage());
        }
        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
            return null;
        }
        throw ctxt.weirdKeyException(_keyClass, key, ""not a valid representation"");
    }","@Override
    public Object deserializeKey(String key, DeserializationContext ctxt)
        throws IOException
    {
        if (key == null) { // is this even legal call?
            return null;
        }
        try {
            Object result = _parse(key, ctxt);
            if (result != null) {
                return result;
            }
        } catch (Exception re) {
            throw ctxt.weirdKeyException(_keyClass, key, ""not a valid representation: ""+re.getMessage());
        }
        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
            return null;
        }
        throw ctxt.weirdKeyException(_keyClass, key, ""not a valid representation"");
    }",0,[0]
40266,bugs-dot-jar_FLINK-3256_44061882,"public void restart() {
		try {
			synchronized (progressLock) {
				JobStatus current = state;

				if (current == JobStatus.CANCELED) {
					LOG.info(""Canceled job during restart. Aborting restart."");
					return;
				}
				else if (current != JobStatus.RESTARTING) {
					throw new IllegalStateException(""Can only restart job from state restarting."");
				}

				if (scheduler == null) {
					throw new IllegalStateException(""The execution graph has not been scheduled before - scheduler is null."");
				}

				this.currentExecutions.clear();

				for (ExecutionJobVertex jv : this.verticesInCreationOrder) {
					jv.resetForNewExecution();
				}

				for (int i = 0; i < stateTimestamps.length; i++) {
					stateTimestamps[i] = 0;
				}
				numFinishedJobVertices = 0;
				transitionState(JobStatus.RESTARTING, JobStatus.CREATED);
				
				// if we have checkpointed state, reload it into the executions
				if (checkpointCoordinator != null) {
					checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);
				}
			}

			scheduleForExecution(scheduler);
		}
		catch (Throwable t) {
			fail(t);
		}
	}","public void restart() {
		try {
			synchronized (progressLock) {
				JobStatus current = state;

				if (current == JobStatus.CANCELED) {
					LOG.info(""Canceled job during restart. Aborting restart."");
					return;
				}
				else if (current != JobStatus.RESTARTING) {
					throw new IllegalStateException(""Can only restart job from state restarting."");
				}

				if (scheduler == null) {
					throw new IllegalStateException(""The execution graph has not been scheduled before - scheduler is null."");
				}

				this.currentExecutions.clear();

				Collection<CoLocationGroup> colGroups = new HashSet<>();
				
				for (ExecutionJobVertex jv : this.verticesInCreationOrder) {
					
					CoLocationGroup cgroup = jv.getCoLocationGroup();
					if(cgroup != null && !colGroups.contains(cgroup)){
						cgroup.resetConstraints();
						colGroups.add(cgroup);
					}
					
					jv.resetForNewExecution();
				}

				for (int i = 0; i < stateTimestamps.length; i++) {
					stateTimestamps[i] = 0;
				}
				numFinishedJobVertices = 0;
				transitionState(JobStatus.RESTARTING, JobStatus.CREATED);
				
				// if we have checkpointed state, reload it into the executions
				if (checkpointCoordinator != null) {
					checkpointCoordinator.restoreLatestCheckpointedState(getAllVertices(), false, false);
				}
			}

			scheduleForExecution(scheduler);
		}
		catch (Throwable t) {
			fail(t);
		}
	}",1,[]
19863,bugs-dot-jar_WICKET-1718_bb7f9cf5,"protected void reportMissingHead(final CharSequence collectedHeaderOutput)
	{
		log.error(""^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"");
		log.error(""You probably forgot to add a <body> or <head> tag to your markup since no Header Container was \n"" +
				""found but components were found which want to write to the <head> section.\n"" +
				collectedHeaderOutput);
		log.error(""^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"");
	}","protected void reportMissingHead(final CharSequence collectedHeaderOutput)
	{
		log.error(""^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"");
		log.error(""You probably forgot to add a <body> or <head> tag to your markup since no Header Container was \n"" +
				""found but components were found which want to write to the <head> section.\n"" +
				collectedHeaderOutput);
		log.error(""^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"");
	}",0,[0]
4765,bugs-dot-jar_MATH-326_ce185345,"public ArrayRealVector ebeDivide(ArrayRealVector v)
        throws IllegalArgumentException {
        return (ArrayRealVector) ebeDivide(v.data);
    }","public ArrayRealVector ebeDivide(ArrayRealVector v)
        throws IllegalArgumentException {
        return (ArrayRealVector) ebeDivide(v.data);
    }",0,[0]
1742,bugs-dot-jar_OAK-2117_c7669f31,"@Override @Nonnull
    public Editor childNodeChanged(
            String name, NodeState before, NodeState after)
            throws CommitFailedException {
        List<Editor> children = newArrayListWithCapacity(1 + editors.size());
        children.add(new IndexUpdate(this, name));
        for (Editor editor : editors) {
            Editor child = editor.childNodeChanged(name, before, after);
            if (child != null) {
                children.add(child);
            }
        }
        return compose(children);
    }","@Override @Nonnull
    public Editor childNodeChanged(
            String name, NodeState before, NodeState after)
            throws CommitFailedException {
        List<Editor> children = newArrayListWithCapacity(1 + editors.size());
        children.add(new IndexUpdate(this, name));
        for (Editor editor : editors) {
            Editor child = editor.childNodeChanged(name, before, after);
            if (child != null) {
                children.add(child);
            }
        }
        return compose(children);
    }",0,[0]
471,bugs-dot-jar_CAMEL-4370_7345fefc,"public Object getBody() {
        return getBinding().getBody(this);
    }","public Object getBody() {
        return getBinding().getBody(this);
    }",0,[0]
23901,bugs-dot-jar_ACCUMULO-3077_17654199,"protected synchronized static Writer getWriter(Credentials credentials) {
    Writer replicationTable = writers.get(credentials);
    if (replicationTable == null) {
      Instance inst = HdfsZooInstance.getInstance();
      Connector conn;
      try {
        conn = inst.getConnector(credentials.getPrincipal(), credentials.getToken());
      } catch (AccumuloException | AccumuloSecurityException e) {
        throw new RuntimeException(e);
      }

      configureMetadataTable(conn, MetadataTable.NAME);

      replicationTable = new Writer(inst, credentials, MetadataTable.ID);
      writers.put(credentials, replicationTable);
    }
    return replicationTable;
  }","protected synchronized static Writer getWriter(Credentials credentials) {
    Writer replicationTable = writers.get(credentials);
    if (replicationTable == null) {
      Instance inst = HdfsZooInstance.getInstance();
      Connector conn;
      try {
        conn = inst.getConnector(credentials.getPrincipal(), credentials.getToken());
      } catch (AccumuloException | AccumuloSecurityException e) {
        throw new RuntimeException(e);
      }

      configureMetadataTable(conn, MetadataTable.NAME);

      replicationTable = new Writer(inst, credentials, MetadataTable.ID);
      writers.put(credentials, replicationTable);
    }
    return replicationTable;
  }",0,[0]
11505,bugs-dot-jar_ACCUMULO-1800_8ec4cb84,"private void addUpdatesToMutation(HashMap<Text,ColumnVisibility> vizMap, Mutation m, List<ColumnUpdate> cu) {
    for (ColumnUpdate update : cu) {
      ColumnVisibility viz = EMPTY_VIS;
      if (update.isSetColVisibility()) {
        viz = getCahcedCV(vizMap, update.getColVisibility());
      }
      byte[] value = new byte[0];
      if (update.isSetValue())
        value = update.getValue();
      if (update.isSetTimestamp()) {
        if (update.isSetDeleteCell()) {
          m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
        } else {
          if (update.isSetDeleteCell()) {
            m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
          } else {
            m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);
          }
        }
      } else {
        m.put(update.getColFamily(), update.getColQualifier(), viz, value);
      }
    }
  }","private void addUpdatesToMutation(HashMap<Text,ColumnVisibility> vizMap, Mutation m, List<ColumnUpdate> cu) {
    for (ColumnUpdate update : cu) {
      ColumnVisibility viz = EMPTY_VIS;
      if (update.isSetColVisibility()) {
        viz = getCahcedCV(vizMap, update.getColVisibility());
      }
      byte[] value = new byte[0];
      if (update.isSetValue())
        value = update.getValue();
      if (update.isSetTimestamp()) {
        if (update.isSetDeleteCell()) {
          m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());
        } else {
          m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);
        }
      } else {
        if (update.isSetDeleteCell()) {
          m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);
        } else {
          m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));
        }
      }
    }
  }",1,"[13, 14, 15, 16, 17, 20]"
6991,bugs-dot-jar_LOG4J2-763_97203de8,"public FormattedMessage(final String messagePattern, final Object arg) {
        this.messagePattern = messagePattern;
        this.argArray = new Object[] {arg};
        this.throwable = null;
    }","public FormattedMessage(final String messagePattern, final Object arg) {
        this(messagePattern, new Object[] {arg}, null);
    }",1,"[1, 2, 3]"
963,Bears-126,"private Position decodeLocationString(Position position, String sentence) {
        Parser parser = new Parser(PATTERN_LOCATION, sentence);
        if (!parser.matches()) {
            return null;
        }

        position.setValid(true);
        position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));
        position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));
        position.setCourse(parser.nextDouble());
        position.setSpeed(parser.nextDouble());
        position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));

        return position;
    }","private Position decodeLocationString(Position position, String sentence) {
        Parser parser = new Parser(PATTERN_LOCATION, sentence);
        if (!parser.matches()) {
            return null;
        }

        position.setValid(true);
        position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));
        position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));
        position.setCourse(parser.nextDouble());
        position.setSpeed(parser.nextDouble());
        position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));

        return position;
    }",0,[0]
40448,bugs-dot-jar_WICKET-442_246d53c5,"public final CharSequence urlFor(final IPageMap pageMap, final Class pageClass,
			final PageParameters parameters)
	{
		return getRequestCycle().urlFor(pageMap, pageClass, parameters);
	}","public final CharSequence urlFor(final IPageMap pageMap, final Class pageClass,
			final PageParameters parameters)
	{
		return getRequestCycle().urlFor(pageMap, pageClass, parameters);
	}",0,[0]
2765,bugs-dot-jar_OAK-2174_5931a4a7,"public static ScheduledExecutorService defaultScheduledExecutor() {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(32, new ThreadFactory() {
            private final AtomicInteger counter = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r, createName());
                thread.setDaemon(true);
                return thread;
            }

            private String createName() {
                return ""oak-scheduled-executor-"" + counter.getAndIncrement();
            }
        });
        executor.setKeepAliveTime(1, TimeUnit.MINUTES);
        executor.allowCoreThreadTimeOut(true);
        return executor;
    }","public static ScheduledExecutorService defaultScheduledExecutor() {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(32, new ThreadFactory() {
            private final AtomicInteger counter = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r, createName());
                thread.setDaemon(true);
                return thread;
            }

            private String createName() {
                return ""oak-scheduled-executor-"" + counter.getAndIncrement();
            }
        });
        executor.setKeepAliveTime(1, TimeUnit.MINUTES);
        executor.allowCoreThreadTimeOut(true);
        return executor;
    }",0,[0]
7981,bugs-dot-jar_MATH-924_2836a6f9,"@Override
    protected void setUp() {
        super.setUp();

        // Reset counter.
        jacobianEvaluations = 0;

        // Square-root of the weight matrix.
        weightMatrixSqrt = squareRoot(getWeight());

        // Store least squares problem characteristics.
        // XXX The conversion won't be necessary when the generic argument of
        // the base class becomes ""MultivariateDifferentiableVectorFunction"".
        // XXX ""jF"" is not strictly necessary anymore but is currently more
        // efficient than converting the value returned from ""getObjectiveFunction()""
        // every time it is used.
        jF = FunctionUtils.toMultivariateDifferentiableVectorFunction((DifferentiableMultivariateVectorFunction) getObjectiveFunction());

        // Arrays shared with ""private"" and ""protected"" methods.
        point = getStartPoint();
        rows = getTarget().length;
        cols = point.length;
    }","@Override
    protected void setUp() {
        super.setUp();

        // Reset counter.
        jacobianEvaluations = 0;

        // Square-root of the weight matrix.
        weightMatrixSqrt = squareRoot(getWeight());

        // Store least squares problem characteristics.
        // XXX The conversion won't be necessary when the generic argument of
        // the base class becomes ""MultivariateDifferentiableVectorFunction"".
        // XXX ""jF"" is not strictly necessary anymore but is currently more
        // efficient than converting the value returned from ""getObjectiveFunction()""
        // every time it is used.
        jF = FunctionUtils.toMultivariateDifferentiableVectorFunction((DifferentiableMultivariateVectorFunction) getObjectiveFunction());

        // Arrays shared with ""private"" and ""protected"" methods.
        point = getStartPoint();
        rows = getTarget().length;
        cols = point.length;
    }",0,[0]
33656,bugs-dot-jar_WICKET-4659_ccd74641,"private IRequestHandler internalMap(Exception e)
	{
		final Application application = Application.get();

		// check if we are processing an Ajax request and if we want to invoke the failure handler
		if (isProcessingAjaxRequest())
		{
			switch (application.getExceptionSettings().getAjaxErrorHandlingStrategy())
			{
				case INVOKE_FAILURE_HANDLER :
					return new ErrorCodeRequestHandler(500);
			}
		}

		if (e instanceof StalePageException)
		{
			// If the page was stale, just rerender it
			// (the url should always be updated by an redirect in that case)
			return new RenderPageRequestHandler(new PageProvider(((StalePageException)e).getPage()));
		}
		else if (e instanceof PageExpiredException)
		{
			return createPageRequestHandler(new PageProvider(Application.get()
				.getApplicationSettings()
				.getPageExpiredErrorPage()));
		}
		else if (e instanceof AuthorizationException ||
			e instanceof ListenerInvocationNotAllowedException)
		{
			return createPageRequestHandler(new PageProvider(Application.get()
				.getApplicationSettings()
				.getAccessDeniedPage()));
		}
		else if (e instanceof ResponseIOException)
		{
			logger.error(""Connection lost, give up responding."", e);
			return new EmptyRequestHandler();
		}
		else
		{

			final UnexpectedExceptionDisplay unexpectedExceptionDisplay = application.getExceptionSettings()
				.getUnexpectedExceptionDisplay();

			logger.error(""Unexpected error occurred"", e);

			if (IExceptionSettings.SHOW_EXCEPTION_PAGE.equals(unexpectedExceptionDisplay))
			{
				Page currentPage = extractCurrentPage();
				return createPageRequestHandler(new PageProvider(new ExceptionErrorPage(e,
					currentPage)));
			}
			else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionDisplay))
			{
				return createPageRequestHandler(new PageProvider(
					application.getApplicationSettings().getInternalErrorPage()));
			}
			else
			{
				// IExceptionSettings.SHOW_NO_EXCEPTION_PAGE
				return new ErrorCodeRequestHandler(500);
			}
		}
	}","private IRequestHandler internalMap(Exception e)
	{
		final Application application = Application.get();

		// check if we are processing an Ajax request and if we want to invoke the failure handler
		if (isProcessingAjaxRequest())
		{
			switch (application.getExceptionSettings().getAjaxErrorHandlingStrategy())
			{
				case INVOKE_FAILURE_HANDLER :
					return new ErrorCodeRequestHandler(500);
			}
		}

		if (e instanceof StalePageException)
		{
			// If the page was stale, just rerender it
			// (the url should always be updated by an redirect in that case)
			return new RenderPageRequestHandler(new PageProvider(((StalePageException)e).getPage()));
		}
		else if (e instanceof PageExpiredException)
		{
			return createPageRequestHandler(new PageProvider(Application.get()
				.getApplicationSettings()
				.getPageExpiredErrorPage()));
		}
		else if (e instanceof AuthorizationException ||
			e instanceof ListenerInvocationNotAllowedException)
		{
			return createPageRequestHandler(new PageProvider(Application.get()
				.getApplicationSettings()
				.getAccessDeniedPage()));
		}
		else if (e instanceof ResponseIOException)
		{
			logger.error(""Connection lost, give up responding."", e);
			return new EmptyRequestHandler();
		}
		else
		{

			final UnexpectedExceptionDisplay unexpectedExceptionDisplay = application.getExceptionSettings()
				.getUnexpectedExceptionDisplay();

			logger.error(""Unexpected error occurred"", e);

			if (IExceptionSettings.SHOW_EXCEPTION_PAGE.equals(unexpectedExceptionDisplay))
			{
				Page currentPage = extractCurrentPage();
				return createPageRequestHandler(new PageProvider(new ExceptionErrorPage(e,
					currentPage)));
			}
			else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionDisplay))
			{
				return createPageRequestHandler(new PageProvider(
					application.getApplicationSettings().getInternalErrorPage()));
			}
			else
			{
				// IExceptionSettings.SHOW_NO_EXCEPTION_PAGE
				return new ErrorCodeRequestHandler(500);
			}
		}
	}",0,[0]
1211,bugs-dot-jar_WICKET-5546_f1af9e03,"public final <R, C extends MarkupContainer> R visitParents(final Class<C> parentClass,
		final IVisitor<C, R> visitor)
	{
		return visitParents(parentClass, visitor, IVisitFilter.ANY);
	}","public final <R, C extends MarkupContainer> R visitParents(final Class<C> parentClass,
		final IVisitor<C, R> visitor)
	{
		return visitParents(parentClass, visitor, IVisitFilter.ANY);
	}",0,[0]
14256,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public void removeTableProperty(ByteBuffer login, String tableName, String property) throws TException {
    try {
      getConnector(login).tableOperations().removeProperty(tableName, property);
    } catch (Exception e) {
      throw translateException(e);
    }
  }","@Override
  public void removeTableProperty(ByteBuffer login, String tableName, String property) throws TException {
    try {
      getConnector(login).tableOperations().removeProperty(tableName, property);
    } catch (Exception e) {
      throw translateException(e);
    }
  }",0,[0]
6181,bugs-dot-jar_OAK-3028_89317b28,"void equals(@Nonnull String property,
                @Nullable Revision revision,
                @Nonnull Object value) {
        if (isNew) {
            throw new IllegalStateException(""Cannot perform equals check on new document"");
        }
        getOrCreateConditions().put(new Key(property, revision),
                Condition.newEqualsCondition(value));
    }","void equals(@Nonnull String property,
                @Nullable Revision revision,
                @Nonnull Object value) {
        if (isNew) {
            throw new IllegalStateException(""Cannot perform equals check on new document"");
        }
        getOrCreateConditions().put(new Key(property, revision),
                Condition.newEqualsCondition(value));
    }",0,[0]
1508,bugs-dot-jar_OAK-4307_f303c916,"public SegmentWriter(SegmentStore store, SegmentVersion version, WriteOperationHandler writeOperationHandler,
            RecordCache<String> nodeCache) {
        this.store = store;
        this.version = version;
        this.writeOperationHandler = writeOperationHandler;
        this.nodeCache = nodeCache;
    }","public SegmentWriter(SegmentStore store, SegmentVersion version, WriteOperationHandler writeOperationHandler,
            RecordCache<String> nodeCache) {
        this.store = store;
        this.version = version;
        this.writeOperationHandler = writeOperationHandler;
        this.nodeCache = nodeCache;
    }",0,[0]
768,bugs-dot-jar_FLINK-3762_dc78a747,"protected KryoSerializer(KryoSerializer<T> toCopy) {
		registeredTypesWithSerializers = toCopy.registeredTypesWithSerializers;
		registeredTypesWithSerializerClasses = toCopy.registeredTypesWithSerializerClasses;
		defaultSerializers = toCopy.defaultSerializers;
		defaultSerializerClasses = toCopy.defaultSerializerClasses;
		registeredTypes = toCopy.registeredTypes;

		type = toCopy.type;
		if(type == null){
			throw new NullPointerException(""Type class cannot be null."");
		}
	}","protected KryoSerializer(KryoSerializer<T> toCopy) {
		registeredTypesWithSerializers = toCopy.registeredTypesWithSerializers;
		registeredTypesWithSerializerClasses = toCopy.registeredTypesWithSerializerClasses;
		defaultSerializers = toCopy.defaultSerializers;
		defaultSerializerClasses = toCopy.defaultSerializerClasses;
		registeredTypes = toCopy.registeredTypes;

		type = toCopy.type;
		if(type == null){
			throw new NullPointerException(""Type class cannot be null."");
		}
	}",0,[0]
36181,bugs-dot-jar_CAMEL-9444_baece126,"@SuppressWarnings(""unchecked"")
    @Deprecated
    public Type beanRef(String ref, boolean cache) {
        BeanDefinition answer = new BeanDefinition(ref);
        answer.setCache(cache);
        addOutput(answer);
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    @Deprecated
    public Type beanRef(String ref, boolean cache) {
        BeanDefinition answer = new BeanDefinition(ref);
        answer.setCache(cache);
        addOutput(answer);
        return (Type) this;
    }",0,[0]
19866,bugs-dot-jar_ACCUMULO-3229_891584fb,"public Shell() throws IOException {
    this(new ConsoleReader(), new PrintWriter(
        new OutputStreamWriter(System.out,
        System.getProperty(""jline.WindowsTerminal.output.encoding"", System.getProperty(""file.encoding"")))));
  }","public Shell() throws IOException {
    this(new ConsoleReader(), new PrintWriter(
        new OutputStreamWriter(System.out,
        System.getProperty(""jline.WindowsTerminal.output.encoding"", System.getProperty(""file.encoding"")))));
  }",0,[0]
1032,Bears-134,"public TmgProtocolDecoder(TmgProtocol protocol) {
        super(protocol);
    }","public TmgProtocolDecoder(TmgProtocol protocol) {
        super(protocol);
    }",0,[0]
12321,bugs-dot-jar_MATH-691_118f0cc0,"public double getStandardDeviation() {
        double stdDev = Double.NaN;
        if (getN() > 0) {
            if (getN() > 1) {
                stdDev = FastMath.sqrt(getVariance());
            } else {
                stdDev = 0.0;
            }
        }
        return stdDev;
    }","public double getStandardDeviation() {
        double stdDev = Double.NaN;
        if (getN() > 0) {
            if (getN() > 1) {
                stdDev = FastMath.sqrt(getVariance());
            } else {
                stdDev = 0.0;
            }
        }
        return stdDev;
    }",0,[0]
31691,bugs-dot-jar_FLINK-2800_b654e989,"@SuppressWarnings(""unchecked"")
	@Override
	public T deserialize(DataInputView source) throws IOException {
		checkKryoInitialized();
		if (source != previousIn) {
			DataInputViewStream inputStream = new DataInputViewStream(source);
			input = new NoFetchingInput(inputStream);
			previousIn = source;
		}

		try {
			return (T) kryo.readClassAndObject(input);
		} catch (KryoException ke) {
			Throwable cause = ke.getCause();

			if(cause instanceof EOFException) {
				throw (EOFException) cause;
			} else {
				throw ke;
			}
		}
	}","@SuppressWarnings(""unchecked"")
	@Override
	public T deserialize(DataInputView source) throws IOException {
		checkKryoInitialized();
		if (source != previousIn) {
			DataInputViewStream inputStream = new DataInputViewStream(source);
			input = new NoFetchingInput(inputStream);
			previousIn = source;
		}

		try {
			return (T) kryo.readClassAndObject(input);
		} catch (KryoException ke) {
			Throwable cause = ke.getCause();

			if (cause instanceof EOFException) {
				throw (EOFException) cause;
			} else {
				throw ke;
			}
		}
	}",1,[15]
27841,bugs-dot-jar_CAMEL-8053_cac72b14,"void removeRouteCollection(Collection<Route> routes) {
        synchronized (routes) {
            this.routes.removeAll(routes);
        }
    }","void removeRouteCollection(Collection<Route> routes) {
        synchronized (routes) {
            this.routes.removeAll(routes);
        }
    }",0,[0]
40212,bugs-dot-jar_ACCUMULO-4029_5ca779a0,"private void oldReadFields(byte first, DataInput in) throws IOException {

    byte b = (byte) in.readByte();
    byte c = (byte) in.readByte();
    byte d = (byte) in.readByte();

    int len = (((first & 0xff) << 24) | ((b & 0xff) << 16) | ((c & 0xff) << 8) | (d & 0xff));
    row = new byte[len];
    in.readFully(row);
    len = in.readInt();
    byte[] localData = new byte[len];
    in.readFully(localData);
    int localEntries = in.readInt();

    List<byte[]> localValues;
    boolean valuesPresent = in.readBoolean();
    if (!valuesPresent) {
      localValues = null;
    } else {
      localValues = new ArrayList<byte[]>();
      int numValues = in.readInt();
      for (int i = 0; i < numValues; i++) {
        len = in.readInt();
        byte val[] = new byte[len];
        in.readFully(val);
        localValues.add(val);
      }
    }

    // convert data to new format
    UnsynchronizedBuffer.Reader din = new UnsynchronizedBuffer.Reader(localData);
    buffer = new UnsynchronizedBuffer.Writer();
    for (int i = 0; i < localEntries; i++) {
      byte[] cf = oldReadBytes(din);
      byte[] cq = oldReadBytes(din);
      byte[] cv = oldReadBytes(din);
      boolean hasts = din.readBoolean();
      long ts = din.readLong();
      boolean deleted = din.readBoolean();

      byte[] val;
      int valLen = din.readInt();

      if (valLen < 0) {
        val = localValues.get((-1 * valLen) - 1);
      } else if (valLen == 0) {
        val = EMPTY_BYTES;
      } else {
        val = new byte[valLen];
        din.readBytes(val);
      }

      put(cf, cq, cv, hasts, ts, deleted, val);
      if (!hasts)
        droppingOldTimestamp(ts);
    }

    serialize();

  }","private void oldReadFields(byte first, DataInput in) throws IOException {

    byte b = (byte) in.readByte();
    byte c = (byte) in.readByte();
    byte d = (byte) in.readByte();

    int len = (((first & 0xff) << 24) | ((b & 0xff) << 16) | ((c & 0xff) << 8) | (d & 0xff));
    row = new byte[len];
    in.readFully(row);
    len = in.readInt();
    byte[] localData = new byte[len];
    in.readFully(localData);
    int localEntries = in.readInt();

    List<byte[]> localValues;
    boolean valuesPresent = in.readBoolean();
    if (!valuesPresent) {
      localValues = null;
    } else {
      localValues = new ArrayList<byte[]>();
      int numValues = in.readInt();
      for (int i = 0; i < numValues; i++) {
        len = in.readInt();
        byte val[] = new byte[len];
        in.readFully(val);
        localValues.add(val);
      }
    }

    // convert data to new format
    UnsynchronizedBuffer.Reader din = new UnsynchronizedBuffer.Reader(localData);
    buffer = new UnsynchronizedBuffer.Writer();
    for (int i = 0; i < localEntries; i++) {
      byte[] cf = oldReadBytes(din);
      byte[] cq = oldReadBytes(din);
      byte[] cv = oldReadBytes(din);
      boolean hasts = din.readBoolean();
      long ts = din.readLong();
      boolean deleted = din.readBoolean();

      byte[] val;
      int valLen = din.readInt();

      if (valLen < 0) {
        val = localValues.get((-1 * valLen) - 1);
      } else if (valLen == 0) {
        val = EMPTY_BYTES;
      } else {
        val = new byte[valLen];
        din.readBytes(val);
      }

      put(cf, cq, cv, hasts, ts, deleted, val);
      if (!hasts)
        droppingOldTimestamp(ts);
    }

    serialize();

  }",0,[0]
20124,bugs-dot-jar_FLINK-3107_937963e3,"@Override
	protected void onCancelCheckpoint(long canceledCheckpointId) {
		Promise<String> promise = savepointPromises.remove(canceledCheckpointId);

		if (promise != null) {
			promise.failure(new Exception(""Savepoint expired before completing""));
		}
	}","@Override
	protected void onCancelCheckpoint(long canceledCheckpointId) {
		Promise<String> promise = savepointPromises.remove(canceledCheckpointId);

		if (promise != null) {
			promise.failure(new Exception(""Savepoint expired before completing""));
		}
	}",0,[0]
543,Bears-16,"protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,
            List<BeanPropertyDefinition> properties)
    {
        AnnotationIntrospector intr = config.getAnnotationIntrospector();
        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();
        Iterator<BeanPropertyDefinition> it = properties.iterator();
        while (it.hasNext()) {
            BeanPropertyDefinition property = it.next();
            AnnotatedMember accessor = property.getAccessor();
            /* 22-Oct-2016, tatu: Looks like this removal is an important part of
             *    processing, as taking it out will result in a few test failures...
             *    But should probably be done somewhere else, not here?
             */
            if (accessor == null) {
                it.remove();
                continue;
            }
            Class<?> type = property.getRawPrimaryType();
            Boolean result = ignores.get(type);
            if (result == null) {
                // 21-Apr-2016, tatu: For 2.8, can specify config overrides
                result = config.getConfigOverride(type).getIsIgnoredType();
                if (result == null) {
                    BeanDescription desc = config.introspectClassAnnotations(type);
                    AnnotatedClass ac = desc.getClassInfo();
                    result = intr.isIgnorableType(ac);
                    // default to false, non-ignorable
                    if (result == null) {
                        result = Boolean.FALSE;
                    }
                }
                ignores.put(type, result);
            }
            // lotsa work, and yes, it is ignorable type, so:
            if (result.booleanValue()) {
                it.remove();
            }
        }
    }","protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,
            List<BeanPropertyDefinition> properties)
    {
        AnnotationIntrospector intr = config.getAnnotationIntrospector();
        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();
        Iterator<BeanPropertyDefinition> it = properties.iterator();
        while (it.hasNext()) {
            BeanPropertyDefinition property = it.next();
            AnnotatedMember accessor = property.getAccessor();
            /* 22-Oct-2016, tatu: Looks like this removal is an important part of
             *    processing, as taking it out will result in a few test failures...
             *    But should probably be done somewhere else, not here?
             */
            if (accessor == null) {
                it.remove();
                continue;
            }
            Class<?> type = property.getRawPrimaryType();
            Boolean result = ignores.get(type);
            if (result == null) {
                // 21-Apr-2016, tatu: For 2.8, can specify config overrides
                result = config.getConfigOverride(type).getIsIgnoredType();
                if (result == null) {
                    BeanDescription desc = config.introspectClassAnnotations(type);
                    AnnotatedClass ac = desc.getClassInfo();
                    result = intr.isIgnorableType(ac);
                    // default to false, non-ignorable
                    if (result == null) {
                        result = Boolean.FALSE;
                    }
                }
                ignores.put(type, result);
            }
            // lotsa work, and yes, it is ignorable type, so:
            if (result.booleanValue()) {
                it.remove();
            }
        }
    }",0,[0]
12358,bugs-dot-jar_OAK-2465_60186813,"@Nonnull
    public Collection<PermissionEntry> getEntries(@Nonnull String path) {
        if (existingNames.isEmpty()) {
            return Collections.emptyList();
        } else if (pathEntryMap != null) {
            Collection<PermissionEntry> entries = pathEntryMap.get(path);
            return (entries != null) ? entries : Collections.<PermissionEntry>emptyList();
        } else {
            return loadEntries(path);
        }
    }","@Nonnull
    public Collection<PermissionEntry> getEntries(@Nonnull String path) {
        if (existingNames.isEmpty()) {
            return Collections.emptyList();
        } else if (pathEntryMap != null) {
            Collection<PermissionEntry> entries = pathEntryMap.get(path);
            return (entries != null) ? entries : Collections.<PermissionEntry>emptyList();
        } else {
            return loadEntries(path);
        }
    }",0,[0]
26174,bugs-dot-jar_OAK-208_daf9a4ef,"private void commit(String jsop) {
        MicroKernel kernel = store.getKernel();
        branchRevision = kernel.commit(""/"", jsop, branchRevision, null);
        currentRoot = new KernelNodeState(kernel, ""/"", branchRevision);
        committed = currentRoot;
    }","private void commit(String jsop) {
        MicroKernel kernel = store.getKernel();
        branchRevision = kernel.commit(""/"", jsop, branchRevision, null);
        currentRoot = new KernelNodeState(kernel, ""/"", branchRevision);
        committed = currentRoot;
    }",0,[0]
29,Bears-2,"protected int _parseInt(String key) throws IllegalArgumentException {
        return Integer.parseInt(key);
    }","protected int _parseInt(String key) throws IllegalArgumentException {
        return Integer.parseInt(key);
    }",0,[0]
938,bugs-dot-jar_WICKET-2033_420ac965,"public final AjaxEventBehavior setThrottleDelay(Duration throttleDelay)
	{
		throttlingSettings = new ThrottlingSettings(""th"" + (++sequence), throttleDelay);
		return this;
	}","public final AjaxEventBehavior setThrottleDelay(Duration throttleDelay)
	{
		throttlingSettings = new ThrottlingSettings(""th"" + (++sequence), throttleDelay);
		return this;
	}",0,[0]
20,Bears-1,"public boolean hasPropertyBasedCreator() {
        return _creators[C_PROPS] != null;
    }","public boolean hasPropertyBasedCreator() {
        return _creators[C_PROPS] != null;
    }",0,[0]
7920,bugs-dot-jar_MATH-812_6eb46555,"public double getDistance(RealVector v) {
        checkVectorDimensions(v);
        double d = 0;
        Iterator<Entry> it = iterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            final double diff = e.getValue() - v.getEntry(e.getIndex());
            d += diff * diff;
        }
        return FastMath.sqrt(d);
    }","public double getDistance(RealVector v) {
        checkVectorDimensions(v);
        double d = 0;
        Iterator<Entry> it = iterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            final double diff = e.getValue() - v.getEntry(e.getIndex());
            d += diff * diff;
        }
        return FastMath.sqrt(d);
    }",0,[0]
14268,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public boolean testClassLoad(ByteBuffer login, String className, String asTypeName) throws TException {
    try {
      return getConnector(login).instanceOperations().testClassLoad(className, asTypeName);
    } catch (Exception e) {
      throw translateException(e);
    }
  }","@Override
  public boolean testClassLoad(ByteBuffer login, String className, String asTypeName) throws TException {
    try {
      return getConnector(login).instanceOperations().testClassLoad(className, asTypeName);
    } catch (Exception e) {
      throw translateException(e);
    }
  }",0,[0]
23196,bugs-dot-jar_OAK-4397_e33516d5,"protected boolean isSameIDP(@Nullable Authorizable auth) throws RepositoryException {
        ExternalIdentityRef ref = getIdentityRef(auth);
        return ref != null && idp.getName().equals(ref.getProviderName());
    }","protected boolean isSameIDP(@Nullable Authorizable auth) throws RepositoryException {
        ExternalIdentityRef ref = getIdentityRef(auth);
        return ref != null && idp.getName().equals(ref.getProviderName());
    }",0,[0]
18707,bugs-dot-jar_ACCUMULO-3218_1b35d263,"public ClientConfiguration withSsl(boolean sslEnabled) {
    return withSsl(sslEnabled, false);
  }","public ClientConfiguration withSsl(boolean sslEnabled) {
    return withSsl(sslEnabled, false);
  }",0,[0]
40321,bugs-dot-jar_LOG4J2-219_ed951c76,"@Override
    public void start() {
        setup();
        doConfigure();
        for (final LoggerConfig logger : loggers.values()) {
            logger.startFilter();
        }
        for (final Appender appender : appenders.values()) {
            appender.start();
        }

        startFilter();
    }","@Override
    public void start() {
        setup();
        doConfigure();
        for (final LoggerConfig logger : loggers.values()) {
            logger.startFilter();
        }
        for (final Appender appender : appenders.values()) {
            appender.start();
        }

        startFilter();
    }",0,[0]
17353,bugs-dot-jar_CAMEL-7018_3244c1e5,"public SedaEndpoint() {
        queueFactory = new LinkedBlockingQueueFactory<Exchange>();
    }","public SedaEndpoint() {
        queueFactory = new LinkedBlockingQueueFactory<Exchange>();
    }",0,[0]
33378,bugs-dot-jar_LOG4J2-210_aeb6fc9d,"public String getFormattedMessage() {
        return asString();
    }","public String getFormattedMessage() {
        return asString();
    }",0,[0]
11758,bugs-dot-jar_WICKET-3413_499a9c6b,"protected void onMarkupAttached()
	{
		if (log.isDebugEnabled())
		{
			log.debug(""Markup available "" + toString());
		}

		// move the component to its real parent if necessary
// moveComponentToItsRealParent();
	}","protected void onMarkupAttached()
	{
		if (log.isDebugEnabled())
		{
			log.debug(""Markup available "" + toString());
		}

		// move the component to its real parent if necessary
// moveComponentToItsRealParent();
	}",0,[0]
2504,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static Expression outBodyExpression() {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                if (exchange.hasOut()) {
                    return exchange.getOut().getBody();
                } else {
                    return null;
                }
            }

            @Override
            public String toString() {
                return ""outBody"";
            }
        };
    }","public static Expression outBodyExpression() {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                if (exchange.hasOut()) {
                    return exchange.getOut().getBody();
                } else {
                    return null;
                }
            }

            @Override
            public String toString() {
                return ""outBody"";
            }
        };
    }",0,[0]
30734,bugs-dot-jar_OAK-2695_0598498e,"DocumentNodeState(@Nonnull DocumentNodeStore store, @Nonnull String path,
                      @Nonnull Revision rev) {
        this(store, path, rev, false);
    }","DocumentNodeState(@Nonnull DocumentNodeStore store, @Nonnull String path,
                      @Nonnull Revision rev) {
        this(store, path, rev, false);
    }",0,[0]
16194,bugs-dot-jar_CAMEL-6687_617eab1c,"private void collectMethodAnnotations(Class<?> c, Method method, Map<Class<?>, Annotation> annotations) {
        for (Class<?> i : c.getInterfaces()) {
            collectMethodAnnotations(i, method, annotations);
        }
        if (!c.isInterface() && c.getSuperclass() != null) {
            collectMethodAnnotations(c.getSuperclass(), method, annotations);
        }
        // make sure the sub class can override the definition
        try {
            Annotation[] ma = c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotations();
            for (Annotation a : ma) {
                annotations.put(a.annotationType(), a);
            }
        } catch (SecurityException e) {
            // do nothing here
        } catch (NoSuchMethodException e) {
            // do nothing here
        }
    }","private void collectMethodAnnotations(Class<?> c, Method method, Map<Class<?>, Annotation> annotations) {
        for (Class<?> i : c.getInterfaces()) {
            collectMethodAnnotations(i, method, annotations);
        }
        if (!c.isInterface() && c.getSuperclass() != null) {
            collectMethodAnnotations(c.getSuperclass(), method, annotations);
        }
        // make sure the sub class can override the definition
        try {
            Annotation[] ma = c.getDeclaredMethod(method.getName(), method.getParameterTypes()).getAnnotations();
            for (Annotation a : ma) {
                annotations.put(a.annotationType(), a);
            }
        } catch (SecurityException e) {
            // do nothing here
        } catch (NoSuchMethodException e) {
            // do nothing here
        }
    }",0,[0]
25067,bugs-dot-jar_OAK-1227_117b0a3d,"@Override
    public boolean canAddMixin(String mixinName) throws RepositoryException {
        final String oakTypeName = getOakName(mixinName);
        return perform(new NodeOperation<Boolean>(dlg) {
            @Override
            public Boolean perform() throws RepositoryException {
                PropertyState prop = PropertyStates.createProperty(JCR_MIXINTYPES, singleton(oakTypeName), NAMES);
                return sessionContext.getAccessManager().hasPermissions(
                    node.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT)
                        && !node.isProtected()
                        && getVersionManager().isCheckedOut(toJcrPath(dlg.getPath())) // TODO: avoid nested calls
                        && node.canAddMixin(oakTypeName);
            }
        });
    }","@Override
    public boolean canAddMixin(String mixinName) throws RepositoryException {
        final String oakTypeName = getOakName(mixinName);
        return perform(new NodeOperation<Boolean>(dlg) {
            @Override
            public Boolean perform() throws RepositoryException {
                PropertyState prop = PropertyStates.createProperty(JCR_MIXINTYPES, singleton(oakTypeName), NAMES);
                return sessionContext.getAccessManager().hasPermissions(
                    node.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT)
                        && !node.isProtected()
                        && getVersionManager().isCheckedOut(toJcrPath(dlg.getPath())) // TODO: avoid nested calls
                        && node.canAddMixin(oakTypeName);
            }
        });
    }",0,[0]
11734,bugs-dot-jar_CAMEL-5796_de6dd425,"@SuppressWarnings(""unchecked"")
    public Type marshal(DataFormatDefinition dataFormatType) {
        addOutput(new MarshalDefinition(dataFormatType));
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    public Type marshal(DataFormatDefinition dataFormatType) {
        addOutput(new MarshalDefinition(dataFormatType));
        return (Type) this;
    }",0,[0]
5955,bugs-dot-jar_OAK-3110_d10362c0,"public String getSkippedFromUploadSize() {
        return humanReadableByteCount(skippedFromUploadSize.get());
    }","public String getSkippedFromUploadSize() {
        return humanReadableByteCount(skippedFromUploadSize.get());
    }",0,[0]
1959,Bears-235,"@Override
    public void create(AccountCreationDto account) {
        
        if (!hasName(account)){
            throw new NoSuchElementException(""Missing Account Name"");
        }
        if (account.getParentId() == 0){
            throw new NoSuchElementException(""Missing Parent Account Id"");
        }
        Optional<Account> parentAccountWrapper = accountRepository
                            .findById(account.getParentId());
        Account parentAccount = parentAccountWrapper.orElseThrow(NoSuchElementException::new);
        
        Account accountEntity = new Account();
        accountEntity.setId(account.getId());
        accountEntity.setName(account.getName());
        accountEntity.setDescription(account.getDescription());
        accountEntity.setIncreasedBy(parentAccount.getIncreasedBy());
        accountEntity.setParent(parentAccount);
        accountEntity.setBalance(BigDecimal.ZERO);
        
        accountRepository.save(accountEntity);
    }","@Override
    public void create(AccountCreationDto account) {
        
        if (!hasName(account)){
            throw new NoSuchElementException(""Missing Account Name"");
        }
        if (account.getParentId() == 0){
            throw new NoSuchElementException(""Missing Parent Account Id"");
        }
        Optional<Account> parentAccountWrapper = accountRepository
                            .findById(account.getParentId());
        Account parentAccount = parentAccountWrapper.orElseThrow(NoSuchElementException::new);
        
        Account accountEntity = new Account();
        accountEntity.setId(account.getId());
        accountEntity.setName(account.getName());
        accountEntity.setDescription(account.getDescription());
        accountEntity.setIncreasedBy(parentAccount.getIncreasedBy());
        accountEntity.setParent(parentAccount);
        accountEntity.setBalance(BigDecimal.ZERO);
        
        accountRepository.save(accountEntity);
    }",0,[0]
18185,bugs-dot-jar_MATH-554_fbbb96eb,"public Vector3D add(double factor, Vector3D v) {
    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);
  }","public Vector3D add(double factor, Vector3D v) {
    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);
  }",0,[0]
29321,bugs-dot-jar_CAMEL-5357_4cf7e80e,"public static String encode(String s) {
        int n = s == null ? 0 : s.length();
        if (n == 0) {
            return s;
        }

        // First check whether we actually need to encode
        char chars[] = s.toCharArray();
        for (int i = 0;;) {
            // just deal with the ascii character
            if (chars[i] > 0 && chars[i] < 128) {
                if (unsafeCharacters.get(chars[i])) {
                    break;
                }
            }
            if (++i >= chars.length) {
                return s;
            }
        }

        // okay there are some unsafe characters so we do need to encode
        StringBuilder sb = new StringBuilder();
        for (char ch : chars) {
            if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {
                appendEscape(sb, (byte)ch);
            } else {
                sb.append(ch);
            }
        }
        return sb.toString();

    }","public static String encode(String s) {
        int n = s == null ? 0 : s.length();
        if (n == 0) {
            return s;
        }

        // First check whether we actually need to encode
        char chars[] = s.toCharArray();
        for (int i = 0;;) {
            // just deal with the ascii character
            if (chars[i] > 0 && chars[i] < 128) {
                if (unsafeCharacters.get(chars[i])) {
                    break;
                }
            }
            if (++i >= chars.length) {
                return s;
            }
        }

        // okay there are some unsafe characters so we do need to encode
        // see details at: http://en.wikipedia.org/wiki/Url_encode
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < chars.length; i++) {
            char ch = chars[i];
            if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {
                // special for % sign as it may be a decimal encoded value
                if (ch == '%') {
                    char next = i + 1 < chars.length ? chars[i + 1] : ' ';
                    char next2 = i + 2 < chars.length ? chars[i + 2] : ' ';

                    if (isHexDigit(next) && isHexDigit(next2)) {
                        // its already encoded (decimal encoded) so just append as is
                        sb.append(ch);
                    } else {
                        // must escape then, as its an unsafe character
                        appendEscape(sb, (byte)ch);
                    }
                } else {
                    // must escape then, as its an unsafe character
                    appendEscape(sb, (byte)ch);
                }
            } else {
                sb.append(ch);
            }
        }
        return sb.toString();
    }",1,"[22, 24]"
12331,bugs-dot-jar_MATH-691_118f0cc0,"@Override
    public boolean equals(Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof SummaryStatistics == false) {
            return false;
        }
        SummaryStatistics stat = (SummaryStatistics)object;
        return Precision.equalsIncludingNaN(stat.getGeometricMean(), getGeometricMean()) &&
               Precision.equalsIncludingNaN(stat.getMax(),           getMax())           &&
               Precision.equalsIncludingNaN(stat.getMean(),          getMean())          &&
               Precision.equalsIncludingNaN(stat.getMin(),           getMin())           &&
               Precision.equalsIncludingNaN(stat.getN(),             getN())             &&
               Precision.equalsIncludingNaN(stat.getSum(),           getSum())           &&
               Precision.equalsIncludingNaN(stat.getSumsq(),         getSumsq())         &&
               Precision.equalsIncludingNaN(stat.getVariance(),      getVariance());
    }","@Override
    public boolean equals(Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof SummaryStatistics == false) {
            return false;
        }
        SummaryStatistics stat = (SummaryStatistics)object;
        return Precision.equalsIncludingNaN(stat.getGeometricMean(), getGeometricMean()) &&
               Precision.equalsIncludingNaN(stat.getMax(),           getMax())           &&
               Precision.equalsIncludingNaN(stat.getMean(),          getMean())          &&
               Precision.equalsIncludingNaN(stat.getMin(),           getMin())           &&
               Precision.equalsIncludingNaN(stat.getN(),             getN())             &&
               Precision.equalsIncludingNaN(stat.getSum(),           getSum())           &&
               Precision.equalsIncludingNaN(stat.getSumsq(),         getSumsq())         &&
               Precision.equalsIncludingNaN(stat.getVariance(),      getVariance());
    }",0,[0]
13242,bugs-dot-jar_OAK-1287_14849e22,"public List<RecordId> getEntries() {
        if (size == 0) {
            return emptyList();
        } else if (size == 1) {
            return singletonList(getRecordId());
        } else {
            List<RecordId> list = newArrayListWithCapacity(size);
            Segment segment = getSegment();
            int offset = getOffset();
            for (int i = 0; i < size; i += bucketSize) {
                RecordId id = segment.readRecordId(offset);
                if (bucketSize == 1) {
                    list.add(id);
                } else {
                    ListRecord bucket = new ListRecord(
                            segment, id, Math.min(bucketSize, size - offset));
                    list.addAll(bucket.getEntries());
                }
                offset += Segment.RECORD_ID_BYTES;
            }
            return list;
        }
    }","public List<RecordId> getEntries() {
        if (size == 0) {
            return emptyList();
        } else if (size == 1) {
            return singletonList(getRecordId());
        } else {
            List<RecordId> list = newArrayListWithCapacity(size);
            Segment segment = getSegment();
            int offset = getOffset();
            for (int i = 0; i < size; i += bucketSize) {
                RecordId id = segment.readRecordId(offset);
                if (bucketSize == 1) {
                    list.add(id);
                } else {
                    ListRecord bucket = new ListRecord(
                            segment, id, Math.min(bucketSize, size - i));
                    list.addAll(bucket.getEntries());
                }
                offset += Segment.RECORD_ID_BYTES;
            }
            return list;
        }
    }",1,[15]
23285,bugs-dot-jar_FLINK-1496_0a4c7694,"public void onAvailableInputChannel(InputChannel inputChannel) {
		inputChannelsWithData.add(inputChannel);

		if (readerListener.get() != null) {
			readerListener.get().onEvent(this);
		}
	}","public void onAvailableInputChannel(InputChannel inputChannel) {
		inputChannelsWithData.add(inputChannel);

		if (readerListener.get() != null) {
			readerListener.get().onEvent(this);
		}
	}",0,[0]
2664,bugs-dot-jar_OAK-3872_c13708e3,"@Override
    public long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) throws Exception {
        long count = 0;

        for (List<String> chunk : Lists.partition(chunkIds, RDBJDBCTools.MAX_IN_CLAUSE)) {
            Connection con = this.ch.getRWConnection();
            PreparedStatement prepMeta = null;
            PreparedStatement prepData = null;

            try {
                PreparedStatementComponent inClause = RDBJDBCTools.createInStatement(""ID"", chunk, false);

                StringBuilder metaStatement = new StringBuilder(""delete from "" + this.tnMeta + "" where "")
                        .append(inClause.getStatementComponent());
                StringBuilder dataStatement = new StringBuilder(""delete from "" + this.tnData + "" where "")
                        .append(inClause.getStatementComponent());

                if (maxLastModifiedTime > 0) {
                    metaStatement.append("" and LASTMOD <= ?"");
                    dataStatement.append("" and not exists(select * from "" + this.tnMeta + "" m where ID = m.ID and m.LASTMOD <= ?)"");
                }

                prepMeta = con.prepareStatement(metaStatement.toString());
                prepData = con.prepareStatement(dataStatement.toString());

                int mindex = 1, dindex = 1;
                mindex = inClause.setParameters(prepMeta, mindex);
                dindex = inClause.setParameters(prepData, dindex);

                if (maxLastModifiedTime > 0) {
                    prepMeta.setLong(mindex, maxLastModifiedTime);
                    prepData.setLong(dindex, maxLastModifiedTime);
                }

                count += prepMeta.executeUpdate();
                prepData.execute();
            } finally {
                closeStatement(prepMeta);
                closeStatement(prepData);
                con.commit();
                this.ch.closeConnection(con);
            }
        }

        return count;
    }","@Override
    public long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) throws Exception {
        long count = 0;

        for (List<String> chunk : Lists.partition(chunkIds, RDBJDBCTools.MAX_IN_CLAUSE)) {
            Connection con = this.ch.getRWConnection();
            PreparedStatement prepMeta = null;
            PreparedStatement prepData = null;

            try {
                PreparedStatementComponent inClause = RDBJDBCTools.createInStatement(""ID"", chunk, false);

                StringBuilder metaStatement = new StringBuilder(""delete from "" + this.tnMeta + "" where "")
                        .append(inClause.getStatementComponent());
                StringBuilder dataStatement = new StringBuilder(""delete from "" + this.tnData + "" where "")
                        .append(inClause.getStatementComponent());

                if (maxLastModifiedTime > 0) {
                    // delete only if the last modified is OLDER than x
                    metaStatement.append("" and LASTMOD <= ?"");
                    // delete if there is NO entry where the last modified of the meta is YOUNGER than x
                    dataStatement.append("" and not exists(select * from "" + this.tnMeta + "" m where ID = m.ID and m.LASTMOD > ?)"");
                }

                prepMeta = con.prepareStatement(metaStatement.toString());
                prepData = con.prepareStatement(dataStatement.toString());

                int mindex = 1, dindex = 1;
                mindex = inClause.setParameters(prepMeta, mindex);
                dindex = inClause.setParameters(prepData, dindex);

                if (maxLastModifiedTime > 0) {
                    prepMeta.setLong(mindex, maxLastModifiedTime);
                    prepData.setLong(dindex, maxLastModifiedTime);
                }

                int deletedMeta = prepMeta.executeUpdate();
                int deletedData = prepData.executeUpdate();

                if (deletedMeta != deletedData) {
                    String message = String.format(
                            ""chunk deletion affected different numbers of DATA records (%s) and META records (%s)"", deletedMeta,
                            deletedData);
                    LOG.info(message);
                }

                count += deletedMeta;
            } finally {
                closeStatement(prepMeta);
                closeStatement(prepData);
                con.commit();
                this.ch.closeConnection(con);
            }
        }

        return count;
    }",1,"[19, 34, 35]"
34537,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"public TreeMap<KeyExtent,SplitInfo> split(byte[] sp) throws IOException {

    if (sp != null && extent.getEndRow() != null && extent.getEndRow().equals(new Text(sp))) {
      throw new IllegalArgumentException();
    }

    if (extent.isRootTablet()) {
      String msg = ""Cannot split root tablet"";
      log.warn(msg);
      throw new RuntimeException(msg);
    }

    try {
      initiateClose(true, false, false);
    } catch (IllegalStateException ise) {
      log.debug(""File "" + extent + "" not splitting : "" + ise.getMessage());
      return null;
    }

    // obtain this info outside of synch block since it will involve opening
    // the map files... it is ok if the set of map files changes, because
    // this info is used for optimization... it is ok if map files are missing
    // from the set... can still query and insert into the tablet while this
    // map file operation is happening
    Map<FileRef,FileUtil.FileInfo> firstAndLastRows = FileUtil.tryToGetFirstAndLastRows(fs, tabletServer.getSystemConfiguration(), datafileManager.getFiles());

    synchronized (this) {
      // java needs tuples ...
      TreeMap<KeyExtent,SplitInfo> newTablets = new TreeMap<KeyExtent,SplitInfo>();

      long t1 = System.currentTimeMillis();

      // choose a split point
      SplitRowSpec splitPoint;
      if (sp == null)
        splitPoint = findSplitRow(datafileManager.getFiles());
      else {
        Text tsp = new Text(sp);
        splitPoint = new SplitRowSpec(FileUtil.estimatePercentageLTE(fs, tabletServer.getSystemConfiguration(), extent.getPrevEndRow(), extent.getEndRow(),
            FileUtil.toPathStrings(datafileManager.getFiles()), tsp), tsp);
      }

      if (splitPoint == null || splitPoint.row == null) {
        log.info(""had to abort split because splitRow was null"");
        closing = false;
        return null;
      }

      closed = true;
      completeClose(true, false);

      Text midRow = splitPoint.row;
      double splitRatio = splitPoint.splitRatio;

      KeyExtent low = new KeyExtent(extent.getTableId(), midRow, extent.getPrevEndRow());
      KeyExtent high = new KeyExtent(extent.getTableId(), extent.getEndRow(), midRow);

      String lowDirectory = TabletOperations.createTabletDirectory(fs, extent.getTableId().toString(), midRow);

      // write new tablet information to MetadataTable
      SortedMap<FileRef,DataFileValue> lowDatafileSizes = new TreeMap<FileRef,DataFileValue>();
      SortedMap<FileRef,DataFileValue> highDatafileSizes = new TreeMap<FileRef,DataFileValue>();
      List<FileRef> highDatafilesToRemove = new ArrayList<FileRef>();

      MetadataTableUtil.splitDatafiles(extent.getTableId(), midRow, splitRatio, firstAndLastRows, datafileManager.getDatafileSizes(), lowDatafileSizes,
          highDatafileSizes, highDatafilesToRemove);

      log.debug(""Files for low split "" + low + ""  "" + lowDatafileSizes.keySet());
      log.debug(""Files for high split "" + high + ""  "" + highDatafileSizes.keySet());

      String time = tabletTime.getMetadataValue();

      // it is possible that some of the bulk loading flags will be deleted after being read below because the bulk load
      // finishes.... therefore split could propagate load flags for a finished bulk load... there is a special iterator
      // on the metadata table to clean up this type of garbage
      Map<FileRef,Long> bulkLoadedFiles = MetadataTableUtil.getBulkFilesLoaded(SystemCredentials.get(), extent);

      MetadataTableUtil.splitTablet(high, extent.getPrevEndRow(), splitRatio, SystemCredentials.get(), tabletServer.getLock());
      MasterMetadataUtil.addNewTablet(low, lowDirectory, tabletServer.getTabletSession(), lowDatafileSizes, bulkLoadedFiles, SystemCredentials.get(), time,
          lastFlushID, lastCompactID, tabletServer.getLock());
      MetadataTableUtil.finishSplit(high, highDatafileSizes, highDatafilesToRemove, SystemCredentials.get(), tabletServer.getLock());

      log.log(TLevel.TABLET_HIST, extent + "" split "" + low + "" "" + high);

      newTablets.put(high, new SplitInfo(tabletDirectory, highDatafileSizes, time, lastFlushID, lastCompactID, this.lastLocation));
      newTablets.put(low, new SplitInfo(lowDirectory, lowDatafileSizes, time, lastFlushID, lastCompactID, this.lastLocation));

      long t2 = System.currentTimeMillis();

      log.debug(String.format(""offline split time : %6.2f secs"", (t2 - t1) / 1000.0));

      closeComplete = true;

      return newTablets;
    }
  }","public TreeMap<KeyExtent,SplitInfo> split(byte[] sp) throws IOException {

    if (sp != null && extent.getEndRow() != null && extent.getEndRow().equals(new Text(sp))) {
      throw new IllegalArgumentException();
    }

    if (extent.isRootTablet()) {
      String msg = ""Cannot split root tablet"";
      log.warn(msg);
      throw new RuntimeException(msg);
    }

    try {
      initiateClose(true, false, false);
    } catch (IllegalStateException ise) {
      log.debug(""File "" + extent + "" not splitting : "" + ise.getMessage());
      return null;
    }

    // obtain this info outside of synch block since it will involve opening
    // the map files... it is ok if the set of map files changes, because
    // this info is used for optimization... it is ok if map files are missing
    // from the set... can still query and insert into the tablet while this
    // map file operation is happening
    Map<FileRef,FileUtil.FileInfo> firstAndLastRows = FileUtil.tryToGetFirstAndLastRows(fs, tabletServer.getSystemConfiguration(), datafileManager.getFiles());

    synchronized (this) {
      // java needs tuples ...
      TreeMap<KeyExtent,SplitInfo> newTablets = new TreeMap<KeyExtent,SplitInfo>();

      long t1 = System.currentTimeMillis();

      // choose a split point
      SplitRowSpec splitPoint;
      if (sp == null)
        splitPoint = findSplitRow(datafileManager.getFiles());
      else {
        Text tsp = new Text(sp);
        splitPoint = new SplitRowSpec(FileUtil.estimatePercentageLTE(fs, tabletServer.getSystemConfiguration(), extent.getPrevEndRow(), extent.getEndRow(),
            FileUtil.toPathStrings(datafileManager.getFiles()), tsp), tsp);
      }

      if (splitPoint == null || splitPoint.row == null) {
        log.info(""had to abort split because splitRow was null"");
        closing = false;
        return null;
      }

      closed = true;
      completeClose(true, false);

      Text midRow = splitPoint.row;
      double splitRatio = splitPoint.splitRatio;

      KeyExtent low = new KeyExtent(extent.getTableId(), midRow, extent.getPrevEndRow());
      KeyExtent high = new KeyExtent(extent.getTableId(), extent.getEndRow(), midRow);

      String lowDirectory = TabletOperations.createTabletDirectory(fs, extent.getTableId().toString(), midRow);

      // write new tablet information to MetadataTable
      SortedMap<FileRef,DataFileValue> lowDatafileSizes = new TreeMap<FileRef,DataFileValue>();
      SortedMap<FileRef,DataFileValue> highDatafileSizes = new TreeMap<FileRef,DataFileValue>();
      List<FileRef> highDatafilesToRemove = new ArrayList<FileRef>();

      MetadataTableUtil.splitDatafiles(extent.getTableId(), midRow, splitRatio, firstAndLastRows, datafileManager.getDatafileSizes(), lowDatafileSizes,
          highDatafileSizes, highDatafilesToRemove);

      log.debug(""Files for low split "" + low + ""  "" + lowDatafileSizes.keySet());
      log.debug(""Files for high split "" + high + ""  "" + highDatafileSizes.keySet());

      String time = tabletTime.getMetadataValue();

      // it is possible that some of the bulk loading flags will be deleted after being read below because the bulk load
      // finishes.... therefore split could propagate load flags for a finished bulk load... there is a special iterator
      // on the metadata table to clean up this type of garbage
      Map<FileRef,Long> bulkLoadedFiles = MetadataTableUtil.getBulkFilesLoaded(SystemCredentials.get(), extent);

      MetadataTableUtil.splitTablet(high, extent.getPrevEndRow(), splitRatio, SystemCredentials.get(), tabletServer.getLock());
      MasterMetadataUtil.addNewTablet(low, lowDirectory, tabletServer.getTabletSession(), lowDatafileSizes, bulkLoadedFiles, SystemCredentials.get(), time,
          lastFlushID, lastCompactID, tabletServer.getLock());
      MetadataTableUtil.finishSplit(high, highDatafileSizes, highDatafilesToRemove, SystemCredentials.get(), tabletServer.getLock());

      log.log(TLevel.TABLET_HIST, extent + "" split "" + low + "" "" + high);

      newTablets.put(high, new SplitInfo(tabletDirectory, highDatafileSizes, time, lastFlushID, lastCompactID, this.lastLocation));
      newTablets.put(low, new SplitInfo(lowDirectory, lowDatafileSizes, time, lastFlushID, lastCompactID, this.lastLocation));

      long t2 = System.currentTimeMillis();

      log.debug(String.format(""offline split time : %6.2f secs"", (t2 - t1) / 1000.0));

      closeComplete = true;

      return newTablets;
    }
  }",0,[0]
9647,bugs-dot-jar_CAMEL-5707_3f70d612,"public NotifyBuilder whenAllDoneMatches(final Predicate predicate) {
        return doWhenAllMatches(predicate, false);
    }","public NotifyBuilder whenAllDoneMatches(final Predicate predicate) {
        return doWhenAllMatches(predicate, false);
    }",0,[0]
39305,bugs-dot-jar_MATH-938_73605560,"public double distance(final Vector3D p) {
        final Vector3D d = p.subtract(zero);
        final Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);
        return n.getNorm();
    }","public double distance(final Vector3D p) {
        final Vector3D d = p.subtract(zero);
        final Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);
        return n.getNorm();
    }",0,[0]
23623,bugs-dot-jar_WICKET-3644_ab1856db,"public void onBeginRequest(final RequestCycle cycle)
	{
		notify(new INotifier<IRequestCycleListener>()
		{
			public void notify(IRequestCycleListener listener)
			{
				listener.onBeginRequest(cycle);
			}
		});
	}","public void onBeginRequest(final RequestCycle cycle)
	{
		notify(new INotifier<IRequestCycleListener>()
		{
			public void notify(IRequestCycleListener listener)
			{
				listener.onBeginRequest(cycle);
			}
		});
	}",0,[0]
5428,bugs-dot-jar_OAK-1186_52372042,"Node.Children readChildren(String path, Revision rev, int limit) {
        // TODO use offset, to avoid O(n^2) and running out of memory
        // to do that, use the *name* of the last entry of the previous batch of children
        // as the starting point
        Iterable<NodeDocument> docs;
        Node.Children c = new Node.Children();
        int rawLimit = limit;
        Set<Revision> validRevisions = new HashSet<Revision>();
        do {
            c.children.clear();
            c.hasMore = true;
            docs = readChildren(path, rawLimit);
            int numReturned = 0;
            for (NodeDocument doc : docs) {
                numReturned++;
                // filter out deleted children
                if (doc.isDeleted(this, rev, validRevisions)) {
                    continue;
                }
                String p = Utils.getPathFromId(doc.getId());
                if (c.children.size() < limit) {
                    // add to children until limit is reached
                    c.children.add(p);
                }
            }
            if (numReturned < rawLimit) {
                // fewer documents returned than requested
                // -> no more documents
                c.hasMore = false;
            }
            // double rawLimit for next round
            rawLimit = (int) Math.min(((long) rawLimit) * 2, Integer.MAX_VALUE);
        } while (c.children.size() < limit && c.hasMore);
        return c;
    }","Node.Children readChildren(String path, Revision rev, int limit) {
        // TODO use offset, to avoid O(n^2) and running out of memory
        // to do that, use the *name* of the last entry of the previous batch of children
        // as the starting point
        Iterable<NodeDocument> docs;
        Node.Children c = new Node.Children();
        int rawLimit = limit;
        Set<Revision> validRevisions = new HashSet<Revision>();
        do {
            c.children.clear();
            c.hasMore = true;
            docs = readChildren(path, rawLimit);
            int numReturned = 0;
            for (NodeDocument doc : docs) {
                numReturned++;
                // filter out deleted children
                if (doc.isDeleted(this, rev, validRevisions)) {
                    continue;
                }
                String p = Utils.getPathFromId(doc.getId());
                if (c.children.size() < limit) {
                    // add to children until limit is reached
                    c.children.add(p);
                }
            }
            if (numReturned < rawLimit) {
                // fewer documents returned than requested
                // -> no more documents
                c.hasMore = false;
            }
            // double rawLimit for next round
            rawLimit = (int) Math.min(((long) rawLimit) * 2, Integer.MAX_VALUE);
        } while (c.children.size() < limit && c.hasMore);
        return c;
    }",0,[0]
27420,bugs-dot-jar_MATH-1297_56434517,"public void setMinReduction(final double minReduction) {
        this.minReduction = minReduction;
    }","public void setMinReduction(final double minReduction) {
        this.minReduction = minReduction;
    }",0,[0]
4095,bugs-dot-jar_WICKET-3620_1a2bc1bc,"public void writeMetaData(WebResponse response)
	{
		for (Action action : actions)
		{
			if (action instanceof MetaDataAction)
				action.invoke(response);
		}
	}","public void writeMetaData(WebResponse response)
	{
		for (Action action : actions)
		{
			if (action instanceof MetaDataAction)
				action.invoke(response);
		}
	}",0,[0]
23653,bugs-dot-jar_MATH-744_8a83581e,"public BigFraction divide(final BigFraction fraction) {
        if (fraction == null) {
            throw new NullArgumentException(LocalizedFormats.FRACTION);
        }
        if (BigInteger.ZERO.equals(fraction.numerator)) {
            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);
        }

        return multiply(fraction.reciprocal());
    }","public BigFraction divide(final BigFraction fraction) {
        if (fraction == null) {
            throw new NullArgumentException(LocalizedFormats.FRACTION);
        }
        if (BigInteger.ZERO.equals(fraction.numerator)) {
            throw new ZeroException(LocalizedFormats.ZERO_DENOMINATOR);
        }

        return multiply(fraction.reciprocal());
    }",0,[0]
24038,bugs-dot-jar_OAK-579_7d72e6ed,"@Override
    public String toString() {
        return left + "" "" + joinType +
                "" "" + right + "" on "" + joinCondition;
    }","@Override
    public String toString() {
        return left + "" "" + joinType +
                "" "" + right + "" on "" + joinCondition;
    }",0,[0]
17115,bugs-dot-jar_MATH-949_f83bbc1d,"private static RealMatrix triu(final RealMatrix m, int k) {
        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
        for (int r = 0; r < m.getRowDimension(); r++) {
            for (int c = 0; c < m.getColumnDimension(); c++) {
                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;
            }
        }
        return new Array2DRowRealMatrix(d, false);
    }","private static RealMatrix triu(final RealMatrix m, int k) {
        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
        for (int r = 0; r < m.getRowDimension(); r++) {
            for (int c = 0; c < m.getColumnDimension(); c++) {
                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;
            }
        }
        return new Array2DRowRealMatrix(d, false);
    }",0,[0]
33618,bugs-dot-jar_WICKET-4520_b91154ea,"public final void setHeaderResponseDecorator(
		final IHeaderResponseDecorator headerResponseDecorator)
	{
		this.headerResponseDecorator = headerResponseDecorator;
	}","public final void setHeaderResponseDecorator(
		final IHeaderResponseDecorator headerResponseDecorator)
	{
		this.headerResponseDecorator = headerResponseDecorator;
	}",0,[0]
6189,bugs-dot-jar_OAK-510_f63d745a,"@Override
    @Nonnull
    public String getName() throws RepositoryException {
        return perform(new ItemReadOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                String oakName = dlg.getName();
                // special case name of root node
                return oakName.isEmpty() ? """" : toJcrPath(dlg.getName());
            }
        });
    }","@Override
    @Nonnull
    public String getName() throws RepositoryException {
        return perform(new ItemReadOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                String oakName = dlg.getName();
                // special case name of root node
                return oakName.isEmpty() ? """" : toJcrPath(dlg.getName());
            }
        });
    }",0,[0]
455,bugs-dot-jar_CAMEL-4370_7345fefc,"public void copyFromPopulateAdditional(GenericFile<T> source, GenericFile<T> result) {
        // noop
    }","public void copyFromPopulateAdditional(GenericFile<T> source, GenericFile<T> result) {
        // noop
    }",0,[0]
15447,bugs-dot-jar_MATH-555_328513f3,"public static int indicator(final int x) {
        return (x >= 0) ? 1 : -1;
    }","public static int indicator(final int x) {
        return (x >= 0) ? 1 : -1;
    }",0,[0]
23932,bugs-dot-jar_ACCUMULO-3077_17654199,"public void importMapFiles(long tid, Map<FileRef,DataFileValue> pathsString, boolean setTime) throws IOException {

    final KeyExtent extent = tablet.getExtent();
    String bulkDir = null;

    Map<FileRef,DataFileValue> paths = new HashMap<FileRef,DataFileValue>();
    for (Entry<FileRef,DataFileValue> entry : pathsString.entrySet())
      paths.put(entry.getKey(), entry.getValue());

    for (FileRef tpath : paths.keySet()) {

      boolean inTheRightDirectory = false;
      Path parent = tpath.path().getParent().getParent();
      for (String tablesDir : ServerConstants.getTablesDirs()) {
        if (parent.equals(new Path(tablesDir, tablet.getExtent().getTableId().toString()))) {
          inTheRightDirectory = true;
          break;
        }
      }
      if (!inTheRightDirectory) {
        throw new IOException(""Data file "" + tpath + "" not in table dirs"");
      }

      if (bulkDir == null)
        bulkDir = tpath.path().getParent().toString();
      else if (!bulkDir.equals(tpath.path().getParent().toString()))
        throw new IllegalArgumentException(""bulk files in different dirs "" + bulkDir + "" "" + tpath);

    }

    if (tablet.getExtent().isRootTablet()) {
      throw new IllegalArgumentException(""Can not import files to root tablet"");
    }

    synchronized (bulkFileImportLock) {
      Credentials creds = SystemCredentials.get();
      Connector conn;
      try {
        conn = HdfsZooInstance.getInstance().getConnector(creds.getPrincipal(), creds.getToken());
      } catch (Exception ex) {
        throw new IOException(ex);
      }
      // Remove any bulk files we've previously loaded and compacted away
      List<FileRef> files = MetadataTableUtil.getBulkFilesLoaded(conn, extent, tid);

      for (FileRef file : files)
        if (paths.keySet().remove(file))
          log.debug(""Ignoring request to re-import a file already imported: "" + extent + "": "" + file);

      if (paths.size() > 0) {
        long bulkTime = Long.MIN_VALUE;
        if (setTime) {
          for (DataFileValue dfv : paths.values()) {
            long nextTime = tablet.getAndUpdateTime();
            if (nextTime < bulkTime)
              throw new IllegalStateException(""Time went backwards unexpectedly "" + nextTime + "" "" + bulkTime);
            bulkTime = nextTime;
            dfv.setTime(bulkTime);
          }
        }
        
        tablet.updatePersistedTime(bulkTime, paths, tid);
      }
    }

    synchronized (tablet) {
      for (Entry<FileRef,DataFileValue> tpath : paths.entrySet()) {
        if (datafileSizes.containsKey(tpath.getKey())) {
          log.error(""Adding file that is already in set "" + tpath.getKey());
        }
        datafileSizes.put(tpath.getKey(), tpath.getValue());

      }

      tablet.getTabletResources().importedMapFiles();

      tablet.computeNumEntries();
    }

    for (Entry<FileRef,DataFileValue> entry : paths.entrySet()) {
      log.log(TLevel.TABLET_HIST, tablet.getExtent() + "" import "" + entry.getKey() + "" "" + entry.getValue());
    }
  }","public void importMapFiles(long tid, Map<FileRef,DataFileValue> pathsString, boolean setTime) throws IOException {

    final KeyExtent extent = tablet.getExtent();
    String bulkDir = null;

    Map<FileRef,DataFileValue> paths = new HashMap<FileRef,DataFileValue>();
    for (Entry<FileRef,DataFileValue> entry : pathsString.entrySet())
      paths.put(entry.getKey(), entry.getValue());

    for (FileRef tpath : paths.keySet()) {

      boolean inTheRightDirectory = false;
      Path parent = tpath.path().getParent().getParent();
      for (String tablesDir : ServerConstants.getTablesDirs()) {
        if (parent.equals(new Path(tablesDir, tablet.getExtent().getTableId().toString()))) {
          inTheRightDirectory = true;
          break;
        }
      }
      if (!inTheRightDirectory) {
        throw new IOException(""Data file "" + tpath + "" not in table dirs"");
      }

      if (bulkDir == null)
        bulkDir = tpath.path().getParent().toString();
      else if (!bulkDir.equals(tpath.path().getParent().toString()))
        throw new IllegalArgumentException(""bulk files in different dirs "" + bulkDir + "" "" + tpath);

    }

    if (tablet.getExtent().isRootTablet()) {
      throw new IllegalArgumentException(""Can not import files to root tablet"");
    }

    synchronized (bulkFileImportLock) {
      Credentials creds = SystemCredentials.get();
      Connector conn;
      try {
        conn = HdfsZooInstance.getInstance().getConnector(creds.getPrincipal(), creds.getToken());
      } catch (Exception ex) {
        throw new IOException(ex);
      }
      // Remove any bulk files we've previously loaded and compacted away
      List<FileRef> files = MetadataTableUtil.getBulkFilesLoaded(conn, extent, tid);

      for (FileRef file : files)
        if (paths.keySet().remove(file))
          log.debug(""Ignoring request to re-import a file already imported: "" + extent + "": "" + file);

      if (paths.size() > 0) {
        long bulkTime = Long.MIN_VALUE;
        if (setTime) {
          for (DataFileValue dfv : paths.values()) {
            long nextTime = tablet.getAndUpdateTime();
            if (nextTime < bulkTime)
              throw new IllegalStateException(""Time went backwards unexpectedly "" + nextTime + "" "" + bulkTime);
            bulkTime = nextTime;
            dfv.setTime(bulkTime);
          }
        }

        tablet.updatePersistedTime(bulkTime, paths, tid);
      }
    }

    synchronized (tablet) {
      for (Entry<FileRef,DataFileValue> tpath : paths.entrySet()) {
        if (datafileSizes.containsKey(tpath.getKey())) {
          log.error(""Adding file that is already in set "" + tpath.getKey());
        }
        datafileSizes.put(tpath.getKey(), tpath.getValue());

      }

      tablet.getTabletResources().importedMapFiles();

      tablet.computeNumEntries();
    }

    for (Entry<FileRef,DataFileValue> entry : paths.entrySet()) {
      log.log(TLevel.TABLET_HIST, tablet.getExtent() + "" import "" + entry.getKey() + "" "" + entry.getValue());
    }
  }",1,[]
40588,bugs-dot-jar_WICKET-442_246d53c5,"public final CharSequence urlFor(final Component component,
			final RequestListenerInterface listener)
	{
		// Get Page holding component and mark it as stateful.
		final Page page = component.getPage();
		final IRequestTarget target;
		if (listener != IRedirectListener.INTERFACE && component.isStateless()
				&& page.isBookmarkable())
		{
			target = new BookmarkableListenerInterfaceRequestTarget(page.getPageMap().getName(),
					page.getClass(), new PageParameters(), component, listener);
		}
		else
		{
			if (listener == IRedirectListener.INTERFACE)
			{
				page.setPageStateless(Boolean.FALSE);
			}

			// trigger creation of the actual session in case it was deferred
			session.getSessionStore().getSessionId(request, true);

			// Get the listener interface name
			target = new ListenerInterfaceRequestTarget(page, component, listener);
		}
		final IRequestCodingStrategy requestCodingStrategy = getProcessor()
				.getRequestCodingStrategy();
		return requestCodingStrategy.encode(this, target);
	}","public final CharSequence urlFor(final Component component,
			final RequestListenerInterface listener)
	{
		// Get Page holding component and mark it as stateful.
		final Page page = component.getPage();
		final IRequestTarget target;
		if (listener != IRedirectListener.INTERFACE && component.isStateless()
				&& page.isBookmarkable())
		{
			target = new BookmarkableListenerInterfaceRequestTarget(page.getPageMap().getName(),
					page.getClass(), new PageParameters(), component, listener);
		}
		else
		{
			if (listener == IRedirectListener.INTERFACE)
			{
				page.setPageStateless(Boolean.FALSE);
			}

			// trigger creation of the actual session in case it was deferred
			session.getSessionStore().getSessionId(request, true);

			// Get the listener interface name
			target = new ListenerInterfaceRequestTarget(page, component, listener);
		}
		final IRequestCodingStrategy requestCodingStrategy = getProcessor()
				.getRequestCodingStrategy();
		return requestCodingStrategy.encode(this, target);
	}",0,[0]
2381,bugs-dot-jar_CAMEL-5140_8898d491,"public boolean isMultiParameterArray() {
        return multiParameterArray;
    }","public boolean isMultiParameterArray() {
        return multiParameterArray;
    }",0,[0]
4416,bugs-dot-jar_OAK-4291_cdb34ffc,"private String getWriterId(String wid) {
        if (++writerId > 9999) {
            writerId = 0;
        }
        // Manual padding seems to be fastest here
        if (writerId < 10) {
            return wid + "".000"" + writerId;
        } else if (writerId < 100) {
            return wid + "".00"" + writerId;
        } else if (writerId < 1000) {
            return wid + "".0"" + writerId;
        } else {
            return wid + ""."" + writerId;
        }
    }","private String getWriterId(String wid) {
        if (++writerId > 9999) {
            writerId = 0;
        }
        // Manual padding seems to be fastest here
        if (writerId < 10) {
            return wid + "".000"" + writerId;
        } else if (writerId < 100) {
            return wid + "".00"" + writerId;
        } else if (writerId < 1000) {
            return wid + "".0"" + writerId;
        } else {
            return wid + ""."" + writerId;
        }
    }",0,[0]
5938,bugs-dot-jar_OAK-3110_d10362c0,"@Override
    public int getWriterLocalReadCount() {
        return writerLocalReadCount.get();
    }","@Override
    public int getWriterLocalReadCount() {
        return writerLocalReadCount.get();
    }",0,[0]
40505,bugs-dot-jar_WICKET-442_246d53c5,"protected Page(final IModel model)
	{
		// A Page's id is not determined until setId is called when the Page is
		// added to a PageMap in the Session.
		super(null, model);
		init();
	}","protected Page(final IModel model)
	{
		// A Page's id is not determined until setId is called when the Page is
		// added to a PageMap in the Session.
		super(null, model);
		init();
	}",0,[0]
38782,bugs-dot-jar_FLINK-2567_948b6e05,"public void setCommentPrefix(String commentPrefix, String charsetName) throws IllegalCharsetNameException, UnsupportedCharsetException {
		if (charsetName == null) {
			throw new IllegalArgumentException(""Charset name must not be null"");
		}

		if (commentPrefix != null) {
			Charset charset = Charset.forName(charsetName);
			setCommentPrefix(commentPrefix, charset);
		} else {
			this.commentPrefix = null;
		}
	}","public void setCommentPrefix(String commentPrefix, String charsetName) throws IllegalCharsetNameException, UnsupportedCharsetException {
		if (charsetName == null) {
			throw new IllegalArgumentException(""Charset name must not be null"");
		}

		if (commentPrefix != null) {
			Charset charset = Charset.forName(charsetName);
			setCommentPrefix(commentPrefix, charset);
		} else {
			this.commentPrefix = null;
		}
	}",0,[0]
206,bugs-dot-jar_WICKET-2368_fae1601b,"public final void setStatelessHint(boolean value)
	{
		if (value && !isBookmarkable())
		{
			throw new WicketRuntimeException(
				""Can't set stateless hint to true on a page when the page is not bookmarkable, page: "" +
					this);
		}
		setFlag(FLAG_STATELESS_HINT, value);
	}","public final void setStatelessHint(boolean value)
	{
		if (value && !isBookmarkable())
		{
			throw new WicketRuntimeException(
				""Can't set stateless hint to true on a page when the page is not bookmarkable, page: "" +
					this);
		}
		setFlag(FLAG_STATELESS_HINT, value);
	}",0,[0]
17978,bugs-dot-jar_ACCUMULO-1348_ef0f6ddc,"public final void printLines(Iterator<String> lines, boolean paginate, PrintLine out) throws IOException {
    int linesPrinted = 0;
    String prompt = ""-- hit any key to continue or 'q' to quit --"";
    int lastPromptLength = prompt.length();
    int termWidth = reader.getTermwidth();
    int maxLines = reader.getTermheight();
    
    String peek = null;
    while (lines.hasNext()) {
      String nextLine = lines.next();
      if (nextLine == null)
        continue;
      for (String line : nextLine.split(""\\n"")) {
        if (out == null) {
          if (peek != null) {
            reader.printString(peek);
            reader.printNewline();
            if (paginate) {
              linesPrinted += peek.length() == 0 ? 0 : Math.ceil(peek.length() * 1.0 / termWidth);
              
              // check if displaying the next line would result in
              // scrolling off the screen
              if (linesPrinted + Math.ceil(lastPromptLength * 1.0 / termWidth) + Math.ceil(prompt.length() * 1.0 / termWidth)
                  + Math.ceil(line.length() * 1.0 / termWidth) > maxLines) {
                linesPrinted = 0;
                int numdashes = (termWidth - prompt.length()) / 2;
                String nextPrompt = repeat(""-"", numdashes) + prompt + repeat(""-"", numdashes);
                lastPromptLength = nextPrompt.length();
                reader.printString(nextPrompt);
                reader.flushConsole();
                if (Character.toUpperCase((char) reader.readVirtualKey()) == 'Q') {
                  reader.printNewline();
                  return;
                }
                reader.printNewline();
                termWidth = reader.getTermwidth();
                maxLines = reader.getTermheight();
              }
            }
          }
          peek = line;
        } else {
          out.print(line);
        }
      }
    }
    if (out == null && peek != null) {
      reader.printString(peek);
      reader.printNewline();
    }
  }","public final void printLines(Iterator<String> lines, boolean paginate, PrintLine out) throws IOException {
    int linesPrinted = 0;
    String prompt = ""-- hit any key to continue or 'q' to quit --"";
    int lastPromptLength = prompt.length();
    int termWidth = reader.getTermwidth();
    int maxLines = reader.getTermheight();
    
    String peek = null;
    while (lines.hasNext()) {
      String nextLine = lines.next();
      if (nextLine == null)
        continue;
      for (String line : nextLine.split(""\\n"")) {
        if (out == null) {
          if (peek != null) {
            reader.printString(peek);
            reader.printNewline();
            if (paginate) {
              linesPrinted += peek.length() == 0 ? 0 : Math.ceil(peek.length() * 1.0 / termWidth);
              
              // check if displaying the next line would result in
              // scrolling off the screen
              if (linesPrinted + Math.ceil(lastPromptLength * 1.0 / termWidth) + Math.ceil(prompt.length() * 1.0 / termWidth)
                  + Math.ceil(line.length() * 1.0 / termWidth) > maxLines) {
                linesPrinted = 0;
                int numdashes = (termWidth - prompt.length()) / 2;
                String nextPrompt = repeat(""-"", numdashes) + prompt + repeat(""-"", numdashes);
                lastPromptLength = nextPrompt.length();
                reader.printString(nextPrompt);
                reader.flushConsole();
                if (Character.toUpperCase((char) reader.readVirtualKey()) == 'Q') {
                  reader.printNewline();
                  return;
                }
                reader.printNewline();
                termWidth = reader.getTermwidth();
                maxLines = reader.getTermheight();
              }
            }
          }
          peek = line;
        } else {
          out.print(line);
        }
      }
    }
    if (out == null && peek != null) {
      reader.printString(peek);
      reader.printNewline();
    }
  }",0,[0]
1639,Bears-194,"private void addClassFieldsToTaintedVariables(Node node) {

		this.fieldTypes = new HashMap<String, Class<?>>();
		this.fieldTypesTainted = new HashSet<String>();

		ASTClassOrInterfaceBody astBody = node.getFirstParentOfType(ASTClassOrInterfaceBody.class);
		if (astBody == null) {
			return;
		}

		List<ASTClassOrInterfaceBodyDeclaration> declarations = astBody
				.findChildrenOfType(ASTClassOrInterfaceBodyDeclaration.class);
		for (ASTClassOrInterfaceBodyDeclaration declaration : declarations) {
			ASTFieldDeclaration field = declaration.getFirstChildOfType(ASTFieldDeclaration.class);
			if (field != null) {
				Class<?> type = field.getType();
				ASTVariableDeclarator declarator = field.getFirstChildOfType(ASTVariableDeclarator.class);
				ASTVariableDeclaratorId name1 = declarator.getFirstChildOfType(ASTVariableDeclaratorId.class);
				if (name1 != null) {
					String name = name1.getImage();
					this.fieldTypes.put(name, type);
					if (!field.isFinal() && isUnsafeType(field.getType())) {
						this.fieldTypesTainted.add(""this."" + name);
					}
				}
			}
		}

	}","private void addClassFieldsToTaintedVariables(Node node) {

		this.fieldTypes = new HashMap<String, Class<?>>();
		this.fieldTypesTainted = new HashSet<String>();

		ASTClassOrInterfaceBody astBody = node.getFirstParentOfType(ASTClassOrInterfaceBody.class);
		if (astBody == null) {
			return;
		}

		List<ASTClassOrInterfaceBodyDeclaration> declarations = astBody
				.findChildrenOfType(ASTClassOrInterfaceBodyDeclaration.class);
		for (ASTClassOrInterfaceBodyDeclaration declaration : declarations) {
			ASTFieldDeclaration field = declaration.getFirstChildOfType(ASTFieldDeclaration.class);
			if (field != null) {
				Class<?> type = field.getType();
				ASTVariableDeclarator declarator = field.getFirstChildOfType(ASTVariableDeclarator.class);
				ASTVariableDeclaratorId name1 = declarator.getFirstChildOfType(ASTVariableDeclaratorId.class);
				if (name1 != null) {
					String name = name1.getImage();
					this.fieldTypes.put(name, type);
					if (!field.isFinal() && isUnsafeType(field.getType())) {
						this.fieldTypesTainted.add(""this."" + name);
					}
				}
			}
		}

	}",0,[0]
1526,bugs-dot-jar_MNG-5212_712c4fff,"public void flush()
    {
        descriptors.clear();
    }","public void flush()
    {
        descriptors.clear();
    }",0,[0]
30629,bugs-dot-jar_CAMEL-3531_41e4b5b9,"public static String getPropertyName(Method method) {
        String propertyName = method.getName();
        if (propertyName.startsWith(""set"") && method.getParameterTypes().length == 1) {
            propertyName = propertyName.substring(3, 4).toLowerCase() + propertyName.substring(4);
        }
        return propertyName;
    }","public static String getPropertyName(Method method) {
        String propertyName = method.getName();
        if (propertyName.startsWith(""set"") && method.getParameterTypes().length == 1) {
            propertyName = propertyName.substring(3, 4).toLowerCase() + propertyName.substring(4);
        }
        return propertyName;
    }",0,[0]
27917,bugs-dot-jar_CAMEL-8053_cac72b14,"public void setRoutePolicyFactories(List<RoutePolicyFactory> routePolicyFactories) {
        this.routePolicyFactories = routePolicyFactories;
    }","public void setRoutePolicyFactories(List<RoutePolicyFactory> routePolicyFactories) {
        this.routePolicyFactories = routePolicyFactories;
    }",0,[0]
34393,bugs-dot-jar_OAK-4166_374e3f3d,"public void copy(RepositoryInitializer initializer) throws RepositoryException {
        RepositoryConfig config = source.getRepositoryConfig();
        logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
        try {
            NodeBuilder targetBuilder = target.getRoot().builder();
            final Root upgradeRoot = new UpgradeRoot(targetBuilder);

            String workspaceName =
                    source.getRepositoryConfig().getDefaultWorkspaceName();
            SecurityProviderImpl security = new SecurityProviderImpl(
                    mapSecurityConfig(config.getSecurityConfig()));

            // init target repository first
            logger.info(""Initializing initial repository content from {}"", config.getHomeDir());
            new InitialContent().initialize(targetBuilder);
            if (initializer != null) {
                initializer.initialize(targetBuilder);
            }
            logger.debug(""InitialContent completed from {}"", config.getHomeDir());

            for (SecurityConfiguration sc : security.getConfigurations()) {
                RepositoryInitializer ri = sc.getRepositoryInitializer();
                ri.initialize(targetBuilder);
                logger.debug(""Repository initializer '"" + ri.getClass().getName() + ""' completed"", config.getHomeDir());
            }
            for (SecurityConfiguration sc : security.getConfigurations()) {
                WorkspaceInitializer wi = sc.getWorkspaceInitializer();
                wi.initialize(targetBuilder, workspaceName);
                logger.debug(""Workspace initializer '"" + wi.getClass().getName() + ""' completed"", config.getHomeDir());
            }

            HashBiMap<String, String> uriToPrefix = HashBiMap.create();
            logger.info(""Copying registered namespaces"");
            copyNamespaces(targetBuilder, uriToPrefix);
            logger.debug(""Namespace registration completed."");

            logger.info(""Copying registered node types"");
            NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {
                @Override
                protected Tree getTypes() {
                    return upgradeRoot.getTree(NODE_TYPES_PATH);
                }

                @Nonnull
                @Override
                protected Root getWriteRoot() {
                    return upgradeRoot;
                }
            };
            copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));
            logger.debug(""Node type registration completed."");

            // migrate privileges
            logger.info(""Copying registered privileges"");
            PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);
            copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));
            logger.debug(""Privilege registration completed."");

            // Triggers compilation of type information, which we need for
            // the type predicates used by the bulk  copy operations below.
            new TypeEditorProvider(false).getRootEditor(
                    targetBuilder.getBaseState(), targetBuilder.getNodeState(), targetBuilder, null);

            final NodeState reportingSourceRoot = ReportingNodeState.wrap(
                    JackrabbitNodeState.createRootNodeState(
                            source, workspaceName, targetBuilder.getNodeState(), 
                            uriToPrefix, copyBinariesByReference, skipOnError
                    ),
                    new LoggingReporter(logger, ""Migrating"", 10000, -1)
            );
            final NodeState sourceRoot;
            if (skipLongNames) {
                sourceRoot = NameFilteringNodeState.wrap(reportingSourceRoot);
            } else {
                sourceRoot = reportingSourceRoot;
            }

            final Stopwatch watch = Stopwatch.createStarted();

            logger.info(""Copying workspace content"");
            copyWorkspace(sourceRoot, targetBuilder, workspaceName);
            targetBuilder.getNodeState(); // on TarMK this does call triggers the actual copy
            logger.info(""Upgrading workspace content completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);

            if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {
                logger.info(""Copying version storage"");
                watch.reset().start();
                copyVersionStorage(sourceRoot, targetBuilder, versionCopyConfiguration);
                targetBuilder.getNodeState(); // on TarMK this does call triggers the actual copy
                logger.info(""Version storage copied in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
            } else {
                logger.info(""Skipping the version storage as the copyOrphanedVersions is set to false"");
            }

            watch.reset().start();
            logger.info(""Applying default commit hooks"");
            // TODO: default hooks?
            List<CommitHook> hooks = newArrayList();

            UserConfiguration userConf =
                    security.getConfiguration(UserConfiguration.class);
            String groupsPath = userConf.getParameters().getConfigValue(
                    UserConstants.PARAM_GROUP_PATH,
                    UserConstants.DEFAULT_GROUP_PATH);

            // hooks specific to the upgrade, need to run first
            hooks.add(new EditorHook(new CompositeEditorProvider(
                    new RestrictionEditorProvider(),
                    new GroupEditorProvider(groupsPath),
                    // copy referenced version histories
                    new VersionableEditor.Provider(sourceRoot, workspaceName, versionCopyConfiguration),
                    new SameNameSiblingsEditor.Provider()
            )));

            // security-related hooks
            for (SecurityConfiguration sc : security.getConfigurations()) {
                hooks.addAll(sc.getCommitHooks(workspaceName));
            }

            if (customCommitHooks != null) {
                hooks.addAll(customCommitHooks);
            }

            // type validation, reference and indexing hooks
            hooks.add(new EditorHook(new CompositeEditorProvider(
                createTypeEditorProvider(),
                createIndexEditorProvider()
            )));

            target.merge(targetBuilder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);
            logger.info(""Processing commit hooks completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
            logger.debug(""Repository upgrade completed."");
        } catch (Exception e) {
            throw new RepositoryException(""Failed to copy content"", e);
        }
    }","public void copy(RepositoryInitializer initializer) throws RepositoryException {
        RepositoryConfig config = source.getRepositoryConfig();
        logger.info(""Copying repository content from {} to Oak"", config.getHomeDir());
        try {
            NodeBuilder targetBuilder = target.getRoot().builder();
            final Root upgradeRoot = new UpgradeRoot(targetBuilder);

            String workspaceName =
                    source.getRepositoryConfig().getDefaultWorkspaceName();
            SecurityProviderImpl security = new SecurityProviderImpl(
                    mapSecurityConfig(config.getSecurityConfig()));

            // init target repository first
            logger.info(""Initializing initial repository content from {}"", config.getHomeDir());
            new InitialContent().initialize(targetBuilder);
            if (initializer != null) {
                initializer.initialize(targetBuilder);
            }
            logger.debug(""InitialContent completed from {}"", config.getHomeDir());

            for (SecurityConfiguration sc : security.getConfigurations()) {
                RepositoryInitializer ri = sc.getRepositoryInitializer();
                ri.initialize(targetBuilder);
                logger.debug(""Repository initializer '"" + ri.getClass().getName() + ""' completed"", config.getHomeDir());
            }
            for (SecurityConfiguration sc : security.getConfigurations()) {
                WorkspaceInitializer wi = sc.getWorkspaceInitializer();
                wi.initialize(targetBuilder, workspaceName);
                logger.debug(""Workspace initializer '"" + wi.getClass().getName() + ""' completed"", config.getHomeDir());
            }

            HashBiMap<String, String> uriToPrefix = HashBiMap.create();
            logger.info(""Copying registered namespaces"");
            copyNamespaces(targetBuilder, uriToPrefix);
            logger.debug(""Namespace registration completed."");

            logger.info(""Copying registered node types"");
            NodeTypeManager ntMgr = new ReadWriteNodeTypeManager() {
                @Override
                protected Tree getTypes() {
                    return upgradeRoot.getTree(NODE_TYPES_PATH);
                }

                @Nonnull
                @Override
                protected Root getWriteRoot() {
                    return upgradeRoot;
                }
            };
            copyNodeTypes(ntMgr, new ValueFactoryImpl(upgradeRoot, NamePathMapper.DEFAULT));
            logger.debug(""Node type registration completed."");

            // migrate privileges
            logger.info(""Copying registered privileges"");
            PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(PrivilegeConfiguration.class);
            copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));
            logger.debug(""Privilege registration completed."");

            // Triggers compilation of type information, which we need for
            // the type predicates used by the bulk  copy operations below.
            new TypeEditorProvider(false).getRootEditor(
                    targetBuilder.getBaseState(), targetBuilder.getNodeState(), targetBuilder, null);

            final NodeState reportingSourceRoot = ReportingNodeState.wrap(
                    JackrabbitNodeState.createRootNodeState(
                            source, workspaceName, targetBuilder.getNodeState(), 
                            uriToPrefix, copyBinariesByReference, skipOnError
                    ),
                    new LoggingReporter(logger, ""Migrating"", 10000, -1)
            );
            final NodeState sourceRoot;
            if (skipLongNames) {
                sourceRoot = NameFilteringNodeState.wrap(reportingSourceRoot);
            } else {
                sourceRoot = reportingSourceRoot;
            }

            final Stopwatch watch = Stopwatch.createStarted();

            logger.info(""Copying workspace content"");
            copyWorkspace(sourceRoot, targetBuilder, workspaceName);
            targetBuilder.getNodeState(); // on TarMK this does call triggers the actual copy
            logger.info(""Upgrading workspace content completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);

            if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {
                logger.info(""Copying version storage"");
                watch.reset().start();
                copyVersionStorage(sourceRoot, targetBuilder, versionCopyConfiguration);
                targetBuilder.getNodeState(); // on TarMK this does call triggers the actual copy
                logger.info(""Version storage copied in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
            } else {
                logger.info(""Skipping the version storage as the copyOrphanedVersions is set to false"");
            }

            watch.reset().start();
            logger.info(""Applying default commit hooks"");
            // TODO: default hooks?
            List<CommitHook> hooks = newArrayList();

            UserConfiguration userConf =
                    security.getConfiguration(UserConfiguration.class);
            String groupsPath = userConf.getParameters().getConfigValue(
                    UserConstants.PARAM_GROUP_PATH,
                    UserConstants.DEFAULT_GROUP_PATH);

            // hooks specific to the upgrade, need to run first
            hooks.add(new EditorHook(new CompositeEditorProvider(
                    new RestrictionEditorProvider(),
                    new GroupEditorProvider(groupsPath),
                    // copy referenced version histories
                    new VersionableEditor.Provider(sourceRoot, workspaceName, versionCopyConfiguration),
                    new SameNameSiblingsEditor.Provider()
            )));

            // this editor works on the VersionableEditor output, so it can't be
            // a part of the same EditorHook
            hooks.add(new EditorHook(new VersionablePropertiesEditor.Provider()));

            // security-related hooks
            for (SecurityConfiguration sc : security.getConfigurations()) {
                hooks.addAll(sc.getCommitHooks(workspaceName));
            }

            if (customCommitHooks != null) {
                hooks.addAll(customCommitHooks);
            }

            // type validation, reference and indexing hooks
            hooks.add(new EditorHook(new CompositeEditorProvider(
                createTypeEditorProvider(),
                createIndexEditorProvider()
            )));

            target.merge(targetBuilder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);
            logger.info(""Processing commit hooks completed in {}s ({})"", watch.elapsed(TimeUnit.SECONDS), watch);
            logger.debug(""Repository upgrade completed."");
        } catch (Exception e) {
            throw new RepositoryException(""Failed to copy content"", e);
        }
    }",1,[]
3714,bugs-dot-jar_CAMEL-3448_b345dd82,"public Class<?> getExceptionClass() {
        return exceptionClass;
    }","public Class<?> getExceptionClass() {
        return exceptionClass;
    }",0,[0]
1495,bugs-dot-jar_MATH-924_b07ecae3,"protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {
        super(checker);
    }","protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {
        super(checker);
    }",0,[0]
32145,bugs-dot-jar_WICKET-5398_19e7c1cd,"@Override
	public final CharSequence getString()
	{
		return lastText;
	}","@Override
	public final CharSequence getString()
	{
		return lastText;
	}",0,[0]
33617,bugs-dot-jar_WICKET-4520_b91154ea,"public final RequestCycle createRequestCycle(final Request request, final Response response)
	{
		RequestCycleContext context = new RequestCycleContext(request, response,
			getRootRequestMapper(), getExceptionMapperProvider().get());

		RequestCycle requestCycle = getRequestCycleProvider().get(context);
		requestCycle.getListeners().add(requestCycleListeners);
		requestCycle.getListeners().add(new AbstractRequestCycleListener()
		{
			@Override
			public void onDetach(final RequestCycle requestCycle)
			{
				if (Session.exists())
				{
					Session.get().getPageManager().commitRequest();
				}
			}

			@Override
			public void onEndRequest(RequestCycle cycle)
			{
				if (Application.exists())
				{
					IRequestLogger requestLogger = Application.get().getRequestLogger();
					if (requestLogger != null)
					{
						requestLogger.requestTime((System.currentTimeMillis() - cycle.getStartTime()));
					}
				}
			}
		});
		return requestCycle;
	}","public final RequestCycle createRequestCycle(final Request request, final Response response)
	{
		RequestCycleContext context = new RequestCycleContext(request, response,
			getRootRequestMapper(), getExceptionMapperProvider().get());

		RequestCycle requestCycle = getRequestCycleProvider().get(context);
		requestCycle.getListeners().add(requestCycleListeners);
		requestCycle.getListeners().add(new AbstractRequestCycleListener()
		{
			@Override
			public void onDetach(final RequestCycle requestCycle)
			{
				if (Session.exists())
				{
					Session.get().getPageManager().commitRequest();
				}
			}

			@Override
			public void onEndRequest(RequestCycle cycle)
			{
				if (Application.exists())
				{
					IRequestLogger requestLogger = Application.get().getRequestLogger();
					if (requestLogger != null)
					{
						requestLogger.requestTime((System.currentTimeMillis() - cycle.getStartTime()));
					}
				}
			}
		});
		return requestCycle;
	}",0,[0]
32949,bugs-dot-jar_MATH-891_2b852d79,"public SpearmansCorrelation() {
        this(new NaturalRanking());
    }","public SpearmansCorrelation() {
        this(new NaturalRanking());
    }",0,[0]
27326,bugs-dot-jar_ACCUMULO-3055_94c2a31f,"private void appendProp(Writer fileWriter, Property key, String value, Map<String,String> siteConfig) throws IOException {
    appendProp(fileWriter, key.getKey(), value, siteConfig);
  }","private void appendProp(Writer fileWriter, Property key, String value, Map<String,String> siteConfig) throws IOException {
    appendProp(fileWriter, key.getKey(), value, siteConfig);
  }",0,[0]
22639,bugs-dot-jar_OAK-47_b62f1c26,"public synchronized void dispose() {
        if (!disposed) {
            disposed = true;
            gate.commit(""end"");
            nodeMap.close();
            ds.close();
            if (server != null) {
                server.stop();
                server = null;
            }
        }
    }","public synchronized void dispose() {
        if (!disposed) {
            disposed = true;
            gate.commit(""end"");
            nodeMap.close();
            ds.close();
            if (server != null) {
                server.stop();
                server = null;
            }
        }
    }",0,[0]
5425,bugs-dot-jar_OAK-1186_52372042,"void markAsDeleted(String path, Commit commit, boolean subTreeAlso) {
        Revision rev = commit.getBaseRevision();
        checkState(rev != null, ""Base revision of commit must not be null"");
        commit.removeNode(path);

        if (subTreeAlso) {
            // recurse down the tree
            // TODO causes issue with large number of children
            Node n = getNode(path, rev);

            if (n != null) {
                Node.Children c = getChildren(path, rev, Integer.MAX_VALUE);
                for (String childPath : c.children) {
                    markAsDeleted(childPath, commit, true);
                }
            }
        }
    }","void markAsDeleted(String path, Commit commit, boolean subTreeAlso) {
        Revision rev = commit.getBaseRevision();
        checkState(rev != null, ""Base revision of commit must not be null"");
        commit.removeNode(path);

        if (subTreeAlso) {
            // recurse down the tree
            // TODO causes issue with large number of children
            Node n = getNode(path, rev);

            if (n != null) {
                Node.Children c = getChildren(path, rev, Integer.MAX_VALUE);
                for (String childPath : c.children) {
                    markAsDeleted(childPath, commit, true);
                }
            }
        }
    }",0,[0]
1977,bugs-dot-jar_LOG4J2-258_7b38965d,"@Override
    public byte[] getFooter() {
        final StringBuilder sbuf = new StringBuilder();
        sbuf.append(""</table>"").append(Constants.LINE_SEP);
        sbuf.append(""<br>"").append(Constants.LINE_SEP);
        sbuf.append(""</body></html>"");
        return sbuf.toString().getBytes(getCharset());
    }","@Override
    public byte[] getFooter() {
        final StringBuilder sbuf = new StringBuilder();
        sbuf.append(""</table>"").append(Constants.LINE_SEP);
        sbuf.append(""<br>"").append(Constants.LINE_SEP);
        sbuf.append(""</body></html>"");
        return sbuf.toString().getBytes(getCharset());
    }",0,[0]
1475,bugs-dot-jar_OAK-185_7fe28a0e,"@Override
    public boolean isLocked() throws RepositoryException {
        String lockOwner = sessionDelegate.getOakPathOrThrow(JCR_LOCK_OWNER);
        String lockIsDeep = sessionDelegate.getOakPathOrThrow(JCR_LOCK_IS_DEEP);

        if (dlg.getProperty(lockOwner) != null) {
            return true;
        }

        NodeDelegate parent = dlg.getParent();
        while (parent != null) {
            if (parent.getProperty(lockOwner) != null) {
                PropertyDelegate isDeep = parent.getProperty(lockIsDeep);
                if (isDeep != null && !isDeep.isMultivalue()
                        && isDeep.getValue().getBoolean()) {
                    return true;
                }
            }
            parent = parent.getParent();
        }

        return false;
    }","@Override
    public boolean isLocked() throws RepositoryException {
        String lockOwner = sessionDelegate.getOakPathOrThrow(JCR_LOCK_OWNER);
        String lockIsDeep = sessionDelegate.getOakPathOrThrow(JCR_LOCK_IS_DEEP);

        if (dlg.getProperty(lockOwner) != null) {
            return true;
        }

        NodeDelegate parent = dlg.getParent();
        while (parent != null) {
            if (parent.getProperty(lockOwner) != null) {
                PropertyDelegate isDeep = parent.getProperty(lockIsDeep);
                if (isDeep != null && !isDeep.isMultivalue()
                        && isDeep.getValue().getBoolean()) {
                    return true;
                }
            }
            parent = parent.getParent();
        }

        return false;
    }",0,[0]
13123,bugs-dot-jar_CAMEL-6987_37e0e6bb,"public static String extractBodyForLogging(Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {
        if (maxChars < 0) {
            return prepend + ""[Body is not logged]"";
        }

        Object obj = message.getBody();
        if (obj == null) {
            return prepend + ""[Body is null]"";
        }

        if (!allowStreams) {
            if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {
                // for Source its only StringSource or BytesSource that is okay as they are memory based
                // all other kinds we should not touch the body
                return prepend + ""[Body is instance of java.xml.transform.Source]"";
            } else if (obj instanceof StreamCache) {
                return prepend + ""[Body is instance of org.apache.camel.StreamCache]"";
            } else if (obj instanceof InputStream) {
                return prepend + ""[Body is instance of java.io.InputStream]"";
            } else if (obj instanceof OutputStream) {
                return prepend + ""[Body is instance of java.io.OutputStream]"";
            } else if (obj instanceof Reader) {
                return prepend + ""[Body is instance of java.io.Reader]"";
            } else if (obj instanceof Writer) {
                return prepend + ""[Body is instance of java.io.Writer]"";
            } else if (obj instanceof WrappedFile || obj instanceof File) {
                return prepend + ""[Body is file based: "" + obj + ""]"";
            }
        }

        if (!allowFiles) {
            if (obj instanceof WrappedFile || obj instanceof File) {
                return prepend + ""[Body is file based: "" + obj + ""]"";
            }
        }

        // is the body a stream cache
        StreamCache cache;
        if (obj instanceof StreamCache) {
            cache = (StreamCache)obj;
        } else {
            cache = null;
        }

        // grab the message body as a string
        String body = null;
        if (message.getExchange() != null) {
            try {
                body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);
            } catch (Exception e) {
                // ignore as the body is for logging purpose
            }
        }
        if (body == null) {
            body = obj.toString();
        }

        // reset stream cache after use
        if (cache != null) {
            cache.reset();
        }

        if (body == null) {
            return prepend + ""[Body is null]"";
        }

        // clip body if length enabled and the body is too big
        if (maxChars > 0 && body.length() > maxChars) {
            body = body.substring(0, maxChars) + ""... [Body clipped after "" + maxChars + "" chars, total length is "" + body.length() + ""]"";
        }

        return prepend + body;
    }","public static String extractBodyForLogging(Message message, String prepend, boolean allowStreams, boolean allowFiles, int maxChars) {
        if (maxChars < 0) {
            return prepend + ""[Body is not logged]"";
        }

        Object obj = message.getBody();
        if (obj == null) {
            return prepend + ""[Body is null]"";
        }

        if (!allowStreams) {
            if (obj instanceof Source && !(obj instanceof StringSource || obj instanceof BytesSource)) {
                // for Source its only StringSource or BytesSource that is okay as they are memory based
                // all other kinds we should not touch the body
                return prepend + ""[Body is instance of java.xml.transform.Source]"";
            } else if (obj instanceof StreamCache) {
                return prepend + ""[Body is instance of org.apache.camel.StreamCache]"";
            } else if (obj instanceof InputStream) {
                return prepend + ""[Body is instance of java.io.InputStream]"";
            } else if (obj instanceof OutputStream) {
                return prepend + ""[Body is instance of java.io.OutputStream]"";
            } else if (obj instanceof Reader) {
                return prepend + ""[Body is instance of java.io.Reader]"";
            } else if (obj instanceof Writer) {
                return prepend + ""[Body is instance of java.io.Writer]"";
            } else if (obj instanceof WrappedFile || obj instanceof File) {
                if (!allowFiles) {
                    return prepend + ""[Body is file based: "" + obj + ""]"";
                }
            }
        }

        if (!allowFiles) {
            if (obj instanceof WrappedFile || obj instanceof File) {
                return prepend + ""[Body is file based: "" + obj + ""]"";
            }
        }

        // is the body a stream cache
        StreamCache cache;
        if (obj instanceof StreamCache) {
            cache = (StreamCache)obj;
        } else {
            cache = null;
        }

        // grab the message body as a string
        String body = null;
        if (message.getExchange() != null) {
            try {
                body = message.getExchange().getContext().getTypeConverter().convertTo(String.class, message.getExchange(), obj);
            } catch (Exception e) {
                // ignore as the body is for logging purpose
            }
        }
        if (body == null) {
            body = obj.toString();
        }

        // reset stream cache after use
        if (cache != null) {
            cache.reset();
        }

        if (body == null) {
            return prepend + ""[Body is null]"";
        }

        // clip body if length enabled and the body is too big
        if (maxChars > 0 && body.length() > maxChars) {
            body = body.substring(0, maxChars) + ""... [Body clipped after "" + maxChars + "" chars, total length is "" + body.length() + ""]"";
        }

        return prepend + body;
    }",1,[26]
30990,bugs-dot-jar_LOG4J2-410_8f0c4871,"private Level getLevel(final int i) {
        switch (i) {
            case TRACE_INT :
                return Level.TRACE;
            case DEBUG_INT :
                return Level.DEBUG;
            case INFO_INT :
                return Level.INFO;
            case WARN_INT :
                return Level.WARN;
            case ERROR_INT :
                return Level.ERROR;
        }
        return Level.ERROR;
    }","private Level getLevel(final int i) {
        switch (i) {
            case TRACE_INT :
                return Level.TRACE;
            case DEBUG_INT :
                return Level.DEBUG;
            case INFO_INT :
                return Level.INFO;
            case WARN_INT :
                return Level.WARN;
            case ERROR_INT :
                return Level.ERROR;
        }
        return Level.ERROR;
    }",0,[0]
6289,bugs-dot-jar_OAK-2439_beaca1a4,"private IndexPlan.Builder defaultPlan() {
        return new IndexPlan.Builder()
                .setCostPerExecution(defn.getCostPerExecution())
                .setCostPerEntry(defn.getCostPerEntry())
                .setFulltextIndex(defn.isFullTextEnabled())
                .setIncludesNodeData(false) // we should not include node data
                .setFilter(filter)
                .setPathPrefix(getPathPrefix())
                .setDelayed(true) //Lucene is always async
                .setAttribute(LucenePropertyIndex.ATTR_PLAN_RESULT, result)
                .setEstimatedEntryCount(estimatedEntryCount());
    }","private IndexPlan.Builder defaultPlan() {
        return new IndexPlan.Builder()
                .setCostPerExecution(defn.getCostPerExecution())
                .setCostPerEntry(defn.getCostPerEntry())
                .setFulltextIndex(defn.isFullTextEnabled())
                .setIncludesNodeData(false) // we should not include node data
                .setFilter(filter)
                .setPathPrefix(getPathPrefix())
                .setDelayed(true) //Lucene is always async
                .setAttribute(LucenePropertyIndex.ATTR_PLAN_RESULT, result)
                .setEstimatedEntryCount(estimatedEntryCount());
    }",0,[0]
20387,bugs-dot-jar_WICKET-5572_cd414fa5,"public MarkupContainer queue(Component... components)
	{
		if (queue == null)
		{
			queue = new ComponentQueue();
		}
		queue.add(components);

		MarkupContainer region = null;
		Page page = null;

		MarkupContainer cursor = this;

		while (cursor != null)
		{
			if (region == null && cursor instanceof IQueueRegion)
			{
				region = cursor;
			}
			if (cursor instanceof Page)
			{
				page = (Page)cursor;
			}
			cursor = cursor.getParent();
		}

		if (page != null)
		{
			if (!region.getRequestFlag(RFLAG_CONTAINER_DEQUEING))
			{
				region.dequeue();
			}
		}

		return this;
	}","public MarkupContainer queue(Component... components)
	{
		if (queue == null)
		{
			queue = new ComponentQueue();
		}
		queue.add(components);

		MarkupContainer region = null;
		Page page = null;

		MarkupContainer cursor = this;

		while (cursor != null)
		{
			if (region == null && cursor instanceof IQueueRegion)
			{
				region = cursor;
			}
			if (cursor instanceof Page)
			{
				page = (Page)cursor;
			}
			cursor = cursor.getParent();
		}

		if (page != null)
		{
			if (!region.getRequestFlag(RFLAG_CONTAINER_DEQUEING))
			{
				region.dequeue();
			}
		}

		return this;
	}",0,[0]
4574,bugs-dot-jar_OAK-2420_24cb1908,"private static long now(){
        return System.currentTimeMillis();
    }","private static long now(){
        return System.currentTimeMillis();
    }",0,[0]
16667,bugs-dot-jar_WICKET-5689_2ac29d30,"public AjaxRequestTargetListenerCollection getAjaxRequestTargetListeners()
	{
		return ajaxRequestTargetListeners;
	}","public AjaxRequestTargetListenerCollection getAjaxRequestTargetListeners()
	{
		return ajaxRequestTargetListeners;
	}",0,[0]
12780,bugs-dot-jar_LOG4J2-1061_86d8944f,"public Log4jMarker(final org.apache.logging.log4j.Marker marker) {
        this.marker = marker;
    }","public Log4jMarker(final org.apache.logging.log4j.Marker marker) {
        this.marker = marker;
    }",0,[0]
14271,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public void createLocalUser(ByteBuffer login, String user, ByteBuffer password) throws TException {
    try {
      getConnector(login).securityOperations().createLocalUser(user, new PasswordToken(password));
    } catch (Exception e) {
      throw translateException(e);
    }
  }","@Override
  public void createLocalUser(ByteBuffer login, String user, ByteBuffer password) throws TException {
    try {
      getConnector(login).securityOperations().createLocalUser(user, new PasswordToken(password));
    } catch (Exception e) {
      throw translateException(e);
    }
  }",0,[0]
9799,bugs-dot-jar_OAK-3634_90ad50da,"@Override
    public <T extends Document> void update(Collection<T> collection,
                                            List<String> keys,
                                            UpdateOp updateOp) {
        log(""update"", keys, updateOp);
        UpdateUtils.assertUnconditional(updateOp);
        DBCollection dbCollection = getDBCollection(collection);
        QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);
        // make sure we don't modify the original updateOp
        updateOp = updateOp.copy();
        DBObject update = createUpdate(updateOp);
        final long start = PERFLOG.start();
        try {
            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();
            if (collection == Collection.NODES) {
                cachedDocs = Maps.newHashMap();
                for (String key : keys) {
                    cachedDocs.put(key, nodesCache.getIfPresent(key));
                }
            }
            try {
                dbCollection.update(query.get(), update, false, true);
                if (collection == Collection.NODES) {
                    // update cache
                    for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {
                        // the cachedDocs is not empty, so the collection = NODES
                        Lock lock = nodeLocks.acquire(entry.getKey());
                        try {
                            if (entry.getValue() == null || entry.getValue() == NodeDocument.NULL) {
                                // make sure concurrently loaded document is
                                // invalidated
                                nodesCache.invalidate(entry.getKey());
                            } else {
                                NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));
                                nodesCache.replaceCachedDocument(entry.getValue(), newDoc);
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                }
            } catch (MongoException e) {
                throw DocumentStoreException.convert(e);
            }
        } finally {
            PERFLOG.end(start, 1, ""update"");
        }
    }","@Override
    public <T extends Document> void update(Collection<T> collection,
                                            List<String> keys,
                                            UpdateOp updateOp) {
        log(""update"", keys, updateOp);
        UpdateUtils.assertUnconditional(updateOp);
        DBCollection dbCollection = getDBCollection(collection);
        QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);
        // make sure we don't modify the original updateOp
        updateOp = updateOp.copy();
        DBObject update = createUpdate(updateOp);
        final long start = PERFLOG.start();
        try {
            Map<String, NodeDocument> cachedDocs = Collections.emptyMap();
            if (collection == Collection.NODES) {
                cachedDocs = Maps.newHashMap();
                for (String key : keys) {
                    cachedDocs.put(key, nodesCache.getIfPresent(key));
                }
            }
            try {
                dbCollection.update(query.get(), update, false, true);
                if (collection == Collection.NODES) {
                    Map<String, Number> modCounts = getModCounts(filterValues(cachedDocs, notNull()).keySet());
                    // update cache
                    for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {
                        // the cachedDocs is not empty, so the collection = NODES
                        Lock lock = nodeLocks.acquire(entry.getKey());
                        try {
                            Number postUpdateModCount = modCounts.get(entry.getKey());
                            if (postUpdateModCount != null
                                    && entry.getValue() != null
                                    && entry.getValue() != NodeDocument.NULL
                                    && (postUpdateModCount.longValue() - 1) == entry.getValue().getModCount()) {
                                // post update modCount is one higher than
                                // what we currently see in the cache. we can
                                // replace the cached document
                                NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));
                                nodesCache.replaceCachedDocument(entry.getValue(), newDoc);
                            } else {
                                // make sure concurrently loaded document is
                                // invalidated
                                nodesCache.invalidate(entry.getKey());
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                }
            } catch (MongoException e) {
                // some documents may still have been updated
                // invalidate all documents affected by this update call
                for (String k : keys) {
                    nodesCache.invalidate(k);
                }
                throw DocumentStoreException.convert(e);
            }
        } finally {
            PERFLOG.end(start, 1, ""update"");
        }
    }",1,"[28, 32, 33, 34]"
11090,bugs-dot-jar_MATH-1269_a94ff90a,"private static void reducePayneHanek(double x, double result[])
    {
        /* Convert input double to bits */
        long inbits = Double.doubleToRawLongBits(x);
        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;

        /* Convert to fixed point representation */
        inbits &= 0x000fffffffffffffL;
        inbits |= 0x0010000000000000L;

        /* Normalize input to be between 0.5 and 1.0 */
        exponent++;
        inbits <<= 11;

        /* Based on the exponent, get a shifted copy of recip2pi */
        long shpi0;
        long shpiA;
        long shpiB;
        int idx = exponent >> 6;
        int shift = exponent - (idx << 6);

        if (shift != 0) {
            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);
            shpi0 |= RECIP_2PI[idx] >>> (64-shift);
            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));
            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));
        } else {
            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];
            shpiA = RECIP_2PI[idx];
            shpiB = RECIP_2PI[idx+1];
        }

        /* Multiply input by shpiA */
        long a = inbits >>> 32;
        long b = inbits & 0xffffffffL;

        long c = shpiA >>> 32;
        long d = shpiA & 0xffffffffL;

        long ac = a * c;
        long bd = b * d;
        long bc = b * c;
        long ad = a * d;

        long prodB = bd + (ad << 32);
        long prodA = ac + (ad >>> 32);

        boolean bita = (bd & 0x8000000000000000L) != 0;
        boolean bitb = (ad & 0x80000000L ) != 0;
        boolean bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prodB += bc << 32;
        prodA += bc >>> 32;

        bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply input by shpiB */
        c = shpiB >>> 32;
        d = shpiB & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac += (bc + ad) >>> 32;

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prodB += ac;
        bitsum = (prodB & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply by shpi0 */
        c = shpi0 >>> 32;
        d = shpi0 & 0xffffffffL;

        bd = b * d;
        bc = b * c;
        ad = a * d;

        prodA += bd + ((bc + ad) << 32);

        /*
         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
         * PI/2, so use the following steps:
         * 1.) multiply by 4.
         * 2.) do a fixed point muliply by PI/4.
         * 3.) Convert to floating point.
         * 4.) Multiply by 2
         */

        /* This identifies the quadrant */
        int intPart = (int)(prodA >>> 62);

        /* Multiply by 4 */
        prodA <<= 2;
        prodA |= prodB >>> 62;
        prodB <<= 2;

        /* Multiply by PI/4 */
        a = prodA >>> 32;
        b = prodA & 0xffffffffL;

        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;

        ac = a * c;
        bd = b * d;
        bc = b * c;
        ad = a * d;

        long prod2B = bd + (ad << 32);
        long prod2A = ac + (ad >>> 32);

        bita = (bd & 0x8000000000000000L) != 0;
        bitb = (ad & 0x80000000L ) != 0;
        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prod2B += bc << 32;
        prod2A += bc >>> 32;

        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply input by pio4bits[1] */
        c = PI_O_4_BITS[1] >>> 32;
        d = PI_O_4_BITS[1] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac += (bc + ad) >>> 32;

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply inputB by pio4bits[0] */
        a = prodB >>> 32;
        b = prodB & 0xffffffffL;
        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac += (bc + ad) >>> 32;

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Convert to double */
        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits
        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits

        double sumA = tmpA + tmpB;
        double sumB = -(sumA - tmpA - tmpB);

        /* Multiply by PI/2 and return */
        result[0] = intPart;
        result[1] = sumA * 2.0;
        result[2] = sumB * 2.0;
    }","private static void reducePayneHanek(double x, double result[])
    {
        /* Convert input double to bits */
        long inbits = Double.doubleToRawLongBits(x);
        int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;

        /* Convert to fixed point representation */
        inbits &= 0x000fffffffffffffL;
        inbits |= 0x0010000000000000L;

        /* Normalize input to be between 0.5 and 1.0 */
        exponent++;
        inbits <<= 11;

        /* Based on the exponent, get a shifted copy of recip2pi */
        long shpi0;
        long shpiA;
        long shpiB;
        int idx = exponent >> 6;
        int shift = exponent - (idx << 6);

        if (shift != 0) {
            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);
            shpi0 |= RECIP_2PI[idx] >>> (64-shift);
            shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));
            shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));
        } else {
            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];
            shpiA = RECIP_2PI[idx];
            shpiB = RECIP_2PI[idx+1];
        }

        /* Multiply input by shpiA */
        long a = inbits >>> 32;
        long b = inbits & 0xffffffffL;

        long c = shpiA >>> 32;
        long d = shpiA & 0xffffffffL;

        long ac = a * c;
        long bd = b * d;
        long bc = b * c;
        long ad = a * d;

        long prodB = bd + (ad << 32);
        long prodA = ac + (ad >>> 32);

        boolean bita = (bd & 0x8000000000000000L) != 0;
        boolean bitb = (ad & 0x80000000L ) != 0;
        boolean bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prodB += bc << 32;
        prodA += bc >>> 32;

        bitsum = (prodB & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply input by shpiB */
        c = shpiB >>> 32;
        d = shpiB & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac += (bc + ad) >>> 32;

        bita = (prodB & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prodB += ac;
        bitsum = (prodB & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prodA++;
        }

        /* Multiply by shpi0 */
        c = shpi0 >>> 32;
        d = shpi0 & 0xffffffffL;

        bd = b * d;
        bc = b * c;
        ad = a * d;

        prodA += bd + ((bc + ad) << 32);

        /*
         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
         * PI/2, so use the following steps:
         * 1.) multiply by 4.
         * 2.) do a fixed point muliply by PI/4.
         * 3.) Convert to floating point.
         * 4.) Multiply by 2
         */

        /* This identifies the quadrant */
        int intPart = (int)(prodA >>> 62);

        /* Multiply by 4 */
        prodA <<= 2;
        prodA |= prodB >>> 62;
        prodB <<= 2;

        /* Multiply by PI/4 */
        a = prodA >>> 32;
        b = prodA & 0xffffffffL;

        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;

        ac = a * c;
        bd = b * d;
        bc = b * c;
        ad = a * d;

        long prod2B = bd + (ad << 32);
        long prod2A = ac + (ad >>> 32);

        bita = (bd & 0x8000000000000000L) != 0;
        bitb = (ad & 0x80000000L ) != 0;
        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (bc & 0x80000000L ) != 0;

        prod2B += bc << 32;
        prod2A += bc >>> 32;

        bitsum = (prod2B & 0x8000000000000000L) != 0;

        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply input by pio4bits[1] */
        c = PI_O_4_BITS[1] >>> 32;
        d = PI_O_4_BITS[1] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac += (bc + ad) >>> 32;

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Multiply inputB by pio4bits[0] */
        a = prodB >>> 32;
        b = prodB & 0xffffffffL;
        c = PI_O_4_BITS[0] >>> 32;
        d = PI_O_4_BITS[0] & 0xffffffffL;
        ac = a * c;
        bc = b * c;
        ad = a * d;

        /* Collect terms */
        ac += (bc + ad) >>> 32;

        bita = (prod2B & 0x8000000000000000L) != 0;
        bitb = (ac & 0x8000000000000000L ) != 0;
        prod2B += ac;
        bitsum = (prod2B & 0x8000000000000000L) != 0;
        /* Carry */
        if ( (bita && bitb) ||
                ((bita || bitb) && !bitsum) ) {
            prod2A++;
        }

        /* Convert to double */
        double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits
        double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits

        double sumA = tmpA + tmpB;
        double sumB = -(sumA - tmpA - tmpB);

        /* Multiply by PI/2 and return */
        result[0] = intPart;
        result[1] = sumA * 2.0;
        result[2] = sumB * 2.0;
    }",0,[0]
38694,bugs-dot-jar_OAK-2355_74f22886,"public String getMBeanName() {
        return StandbyStatusMBean.JMX_NAME + "",id=\"""" + this.observer.getID() + ""\"""";
    }","public String getMBeanName() {
        return StandbyStatusMBean.JMX_NAME + "",id=\"""" + this.observer.getID() + ""\"""";
    }",0,[0]
23192,bugs-dot-jar_OAK-4397_e33516d5,"private boolean isExpired(@Nonnull Authorizable authorizable) throws RepositoryException {
        long expTime = (authorizable.isGroup()) ? config.group().getExpirationTime() : config.user().getExpirationTime();
        return isExpired(authorizable, expTime, ""Properties"");
    }","private boolean isExpired(@Nonnull Authorizable authorizable) throws RepositoryException {
        long expTime = (authorizable.isGroup()) ? config.group().getExpirationTime() : config.user().getExpirationTime();
        return isExpired(authorizable, expTime, ""Properties"");
    }",0,[0]
3247,bugs-dot-jar_ACCUMULO-907_4aeaeb2a,"@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    return new VisibilityFilter(getSource().deepCopy(env), ve.getAuthorizations(), TextUtil.getBytes(defaultVisibility));
  }","@Override
  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {
    return new VisibilityFilter(getSource().deepCopy(env), ve.getAuthorizations(), TextUtil.getBytes(defaultVisibility));
  }",0,[0]
3122,bugs-dot-jar_OAK-1216_e403e003,"@Override
    @CheckForNull
    public String getOakNameOrNull(@Nonnull String jcrName) {
        return namePathMapper.getOakNameOrNull(jcrName);
    }","@Override
    @CheckForNull
    public String getOakNameOrNull(@Nonnull String jcrName) {
        return namePathMapper.getOakNameOrNull(jcrName);
    }",0,[0]
25200,bugs-dot-jar_OAK-3549_9772f5b2,"private void internalRunBackgroundReadOperations() {
        synchronized (backgroundReadMonitor) {
            long start = clock.getTime();
            // pull in changes from other cluster nodes
            BackgroundReadStats readStats = backgroundRead(true);
            long readTime = clock.getTime() - start;
            String msg = ""Background read operations stats (read:{} {})"";
            if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {
                // log as info if it took more than 10 seconds
                LOG.info(msg, readTime, readStats);
            } else {
                LOG.debug(msg, readTime, readStats);
            }
        }
    }","private void internalRunBackgroundReadOperations() {
        synchronized (backgroundReadMonitor) {
            long start = clock.getTime();
            // pull in changes from other cluster nodes
            BackgroundReadStats readStats = backgroundRead();
            long readTime = clock.getTime() - start;
            String msg = ""Background read operations stats (read:{} {})"";
            if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {
                // log as info if it took more than 10 seconds
                LOG.info(msg, readTime, readStats);
            } else {
                LOG.debug(msg, readTime, readStats);
            }
        }
    }",1,[4]
19298,bugs-dot-jar_OAK-2389_0fa892b3,"private static void escape(String s, int length, StringBuilder buff) {
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            int ic = (int)c;
            switch (c) {
            case '""':
                // quotation mark
                buff.append(""\\\"""");
                break;
            case '\\':
                // backslash
                buff.append(""\\\\"");
                break;
            case '\b':
                // backspace
                buff.append(""\\b"");
                break;
            case '\f':
                // formfeed
                buff.append(""\\f"");
                break;
            case '\n':
                // newline
                buff.append(""\\n"");
                break;
            case '\r':
                // carriage return
                buff.append(""\\r"");
                break;
            case '\t':
                // horizontal tab
                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    buff.append(String.format(""\\u%04x"", ic));
                } else if (ic >= 0xD800 && ic <= 0xDBFF) {
                    // isSurrogate(), only available in Java 7
                    if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {
                        // ok surrogate
                        buff.append(c);
                        buff.append(s.charAt(i + 1));
                        i += 1;
                    } else {
                        // broken surrogate -> escape
                        buff.append(String.format(""\\u%04x"", ic));
                    }
                } else {
                    buff.append(c);
                }
            }
        }
    }","private static void escape(String s, int length, StringBuilder buff) {
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            switch (c) {
            case '""':
                // quotation mark
                buff.append(""\\\"""");
                break;
            case '\\':
                // backslash
                buff.append(""\\\\"");
                break;
            case '\b':
                // backspace
                buff.append(""\\b"");
                break;
            case '\f':
                // formfeed
                buff.append(""\\f"");
                break;
            case '\n':
                // newline
                buff.append(""\\n"");
                break;
            case '\r':
                // carriage return
                buff.append(""\\r"");
                break;
            case '\t':
                // horizontal tab
                buff.append(""\\t"");
                break;
            default:
                if (c < ' ') {
                    buff.append(String.format(""\\u%04x"", (int) c));
                } else if (c >= 0xd800 && c <= 0xdbff) {
                    // isSurrogate(), only available in Java 7
                    if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {
                        // ok surrogate
                        buff.append(c);
                        buff.append(s.charAt(i + 1));
                        i += 1;
                    } else {
                        // broken surrogate -> escape
                        buff.append(String.format(""\\u%04x"", (int) c));
                    }
                } else {
                    buff.append(c);
                }
            }
        }
    }",1,"[3, 35, 36, 45]"
25086,bugs-dot-jar_OAK-1227_117b0a3d,"@Override @Nonnull
    public Lock lock(final boolean isDeep, final boolean isSessionScoped)
            throws RepositoryException {
        perform(new LockOperation<Void>(sessionDelegate, dlg) {
            @Override
            public Void perform(NodeDelegate node) throws RepositoryException {
                if (node.getStatus() != Status.EXISTING) {
                    throw new LockException(
                            ""Unable to lock a node with pending changes"");
                }
                node.lock(isDeep);
                String path = node.getPath();
                if (isSessionScoped) {
                    sessionContext.getSessionScopedLocks().add(path);
                } else {
                    sessionContext.getOpenScopedLocks().add(path);
                }
                session.refresh(true);
                return null;
            }
        });
        return new LockImpl(sessionContext, dlg);
    }","@Override @Nonnull
    public Lock lock(final boolean isDeep, final boolean isSessionScoped)
            throws RepositoryException {
        perform(new LockOperation<Void>(sessionDelegate, dlg) {
            @Override
            public Void perform(NodeDelegate node) throws RepositoryException {
                if (node.getStatus() != Status.EXISTING) {
                    throw new LockException(
                            ""Unable to lock a node with pending changes"");
                }
                node.lock(isDeep);
                String path = node.getPath();
                if (isSessionScoped) {
                    sessionContext.getSessionScopedLocks().add(path);
                } else {
                    sessionContext.getOpenScopedLocks().add(path);
                }
                session.refresh(true);
                return null;
            }
        });
        return new LockImpl(sessionContext, dlg);
    }",0,[0]
18199,bugs-dot-jar_MATH-554_fbbb96eb,"public static double distance(Vector3D v1, Vector3D v2) {
    final double dx = v2.x - v1.x;
    final double dy = v2.y - v1.y;
    final double dz = v2.z - v1.z;
    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);
  }","public static double distance(Vector3D v1, Vector3D v2) {
    final double dx = v2.x - v1.x;
    final double dy = v2.y - v1.y;
    final double dz = v2.z - v1.z;
    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);
  }",0,[0]
4419,bugs-dot-jar_WICKET-2350_cd281092,"public static final void visitComponentsPostOrder(Component component,
		final Component.IVisitor<Component> visitor)
	{
		if (visitor == null)
		{
			throw new IllegalArgumentException(""Argument `visitor` cannot be null"");
		}

		visitComponentsPostOrderHelper(component, visitor);
	}","public static final void visitComponentsPostOrder(Component component,
		final Component.IVisitor<Component> visitor)
	{
		if (visitor == null)
		{
			throw new IllegalArgumentException(""Argument `visitor` cannot be null"");
		}

		visitComponentsPostOrderHelper(component, visitor);
	}",0,[0]
3743,bugs-dot-jar_OAK-3324_5f863af6,"public boolean matches(@Nonnull String treePath) {
        return restriction == RestrictionPattern.EMPTY || restriction.matches(treePath);
    }","public boolean matches(@Nonnull String treePath) {
        return restriction == RestrictionPattern.EMPTY || restriction.matches(treePath);
    }",0,[0]
20521,bugs-dot-jar_LOG4J2-811_7bb1ad47,"@Override
    public boolean isEnabled(final Level level, final Marker marker, final String msg) {
        return this.level.intLevel() >= level.intLevel();
    }","@Override
    public boolean isEnabled(final Level level, final Marker marker, final String msg) {
        return this.level.intLevel() >= level.intLevel();
    }",0,[0]
20237,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Override
  public MultiTableBatchWriter createMultiTableBatchWriter(BatchWriterConfig config) {
    return new MultiTableBatchWriterImpl(instance, credentials, config);
  }","@Override
  public MultiTableBatchWriter createMultiTableBatchWriter(BatchWriterConfig config) {
    return new MultiTableBatchWriterImpl(instance, credentials, config);
  }",0,[0]
4783,bugs-dot-jar_MATH-326_ce185345,"public RealVector projection(double[] v) {
        return projection(new ArrayRealVector(v, false));
    }","public RealVector projection(double[] v) {
        return projection(new ArrayRealVector(v, false));
    }",0,[0]
35437,bugs-dot-jar_LOG4J2-1099_3f41ff48,"@Override
    public byte[] toByteArray(final LogEvent event) {
        return getBytes(toSerializable(event));
    }","@Override
    public byte[] toByteArray(final LogEvent event) {
        return getBytes(toSerializable(event));
    }",0,[0]
17848,bugs-dot-jar_OAK-1075_79467350,"@Override
    public String getPath() {
        return path;
    }","@Override
    public String getPath() {
        return path;
    }",0,[0]
22954,bugs-dot-jar_CAMEL-3428_320545cd,"public void removeRouteDefinitions(Collection<RouteDefinition> routeDefinitions) throws Exception {
        this.routeDefinitions.removeAll(routeDefinitions);
        for (RouteDefinition routeDefinition : routeDefinitions) {
            removeRouteDefinition(routeDefinition);
        }
    }","public void removeRouteDefinitions(Collection<RouteDefinition> routeDefinitions) throws Exception {
        this.routeDefinitions.removeAll(routeDefinitions);
        for (RouteDefinition routeDefinition : routeDefinitions) {
            removeRouteDefinition(routeDefinition);
        }
    }",0,[0]
38104,bugs-dot-jar_OAK-3013_eabb4066,"@Override
    public void setExecutionContext(ExecutionContext context) {
        left.setExecutionContext(context);
        right.setExecutionContext(context);
    }","@Override
    public void setExecutionContext(ExecutionContext context) {
        left.setExecutionContext(context);
        right.setExecutionContext(context);
    }",0,[0]
1625,Bears-194,"private boolean isSink(String objectType, String objectMethod) {
		return isSink(objectType + ""."" + objectMethod);
	}","private boolean isSink(String objectType, String objectMethod) {
		return isSink(objectType + ""."" + objectMethod);
	}",0,[0]
2628,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"private IteratorScope getIteratorScope(org.apache.accumulo.proxy.thrift.IteratorScope scope) {
    return IteratorScope.valueOf(scope.toString().toLowerCase());
  }","private IteratorScope getIteratorScope(org.apache.accumulo.proxy.thrift.IteratorScope scope) {
    return IteratorScope.valueOf(scope.toString().toLowerCase());
  }",0,[0]
1014,bugs-dot-jar_ACCUMULO-3408_81d25bc2,"public static String commas(double d, double errMin, double errMax) {
    if (d < errMin || d > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(d));
    return bigNumberForQuantity(d);
  }","public static String commas(double d, double errMin, double errMax) {
    if (d < errMin || d > errMax)
      return String.format(""<span class='error'>%s</span>"", bigNumberForQuantity(d));
    return bigNumberForQuantity(d);
  }",0,[0]
2401,bugs-dot-jar_OAK-225_e33328e0,"private void addExpected(String token) {
        if (expected != null) {
            expected.add(token);
        }
    }","private void addExpected(String token) {
        if (expected != null) {
            expected.add(token);
        }
    }",0,[0]
12569,bugs-dot-jar_MATH-864_abe53a53,"private void updateCovariance(boolean hsig, final RealMatrix bestArx,
            final RealMatrix arz, final int[] arindex, final RealMatrix xold) {
        double negccov = 0;
        if (ccov1 + ccovmu > 0) {
            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))
                    .scalarMultiply(1. / sigma); // mu difference vectors
            RealMatrix roneu = pc.multiply(pc.transpose())
                    .scalarMultiply(ccov1); // rank one update
            // minor correction if hsig==false
            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);
            oldFac += 1. - ccov1 - ccovmu;
            if (isActiveCMA) {
                // Adapt covariance matrix C active CMA
                negccov = (1. - ccovmu) * 0.25 * mueff /
                (Math.pow(dimension + 2., 1.5) + 2. * mueff);
                double negminresidualvariance = 0.66;
                // keep at least 0.66 in all directions, small popsize are most
                // critical
                double negalphaold = 0.5; // where to make up for the variance
                                          // loss,
                // prepare vectors, compute negative updating matrix Cneg
                int[] arReverseIndex = reverse(arindex);
                RealMatrix arzneg
                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));
                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));
                int[] idxnorms = sortedIndices(arnorms.getRow(0));
                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);
                int[] idxReverse = reverse(idxnorms);
                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);
                arnorms = divide(arnormsReverse, arnormsSorted);
                int[] idxInv = inverse(idxnorms);
                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);
                // check and set learning rate negccov
                double negcovMax = (1. - negminresidualvariance) /
                        square(arnormsInv).multiply(weights).getEntry(0, 0);
                if (negccov > negcovMax) {
                    negccov = negcovMax;
                }
                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));
                RealMatrix artmp = BD.multiply(arzneg);
                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(
                        artmp.transpose());
                oldFac += negalphaold * negccov;
                C = C.scalarMultiply(oldFac)
                        // regard old matrix
                        .add(roneu)
                        // plus rank one update
                        .add(arpos.scalarMultiply(
                                // plus rank mu update
                                ccovmu + (1. - negalphaold) * negccov)
                                .multiply(
                                        times(repmat(weights, 1, dimension),
                                                arpos.transpose())))
                        .subtract(Cneg.scalarMultiply(negccov));
            } else {
                // Adapt covariance matrix C - nonactive
                C = C.scalarMultiply(oldFac) // regard old matrix
                        .add(roneu)
                        // plus rank one update
                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update
                                .multiply(
                                        times(repmat(weights, 1, dimension),
                                                arpos.transpose())));
            }
        }
        updateBD(negccov);
    }","private void updateCovariance(boolean hsig, final RealMatrix bestArx,
            final RealMatrix arz, final int[] arindex, final RealMatrix xold) {
        double negccov = 0;
        if (ccov1 + ccovmu > 0) {
            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))
                    .scalarMultiply(1. / sigma); // mu difference vectors
            RealMatrix roneu = pc.multiply(pc.transpose())
                    .scalarMultiply(ccov1); // rank one update
            // minor correction if hsig==false
            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);
            oldFac += 1. - ccov1 - ccovmu;
            if (isActiveCMA) {
                // Adapt covariance matrix C active CMA
                negccov = (1. - ccovmu) * 0.25 * mueff /
                (Math.pow(dimension + 2., 1.5) + 2. * mueff);
                double negminresidualvariance = 0.66;
                // keep at least 0.66 in all directions, small popsize are most
                // critical
                double negalphaold = 0.5; // where to make up for the variance
                                          // loss,
                // prepare vectors, compute negative updating matrix Cneg
                int[] arReverseIndex = reverse(arindex);
                RealMatrix arzneg
                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));
                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));
                int[] idxnorms = sortedIndices(arnorms.getRow(0));
                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);
                int[] idxReverse = reverse(idxnorms);
                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);
                arnorms = divide(arnormsReverse, arnormsSorted);
                int[] idxInv = inverse(idxnorms);
                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);
                // check and set learning rate negccov
                double negcovMax = (1. - negminresidualvariance) /
                        square(arnormsInv).multiply(weights).getEntry(0, 0);
                if (negccov > negcovMax) {
                    negccov = negcovMax;
                }
                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));
                RealMatrix artmp = BD.multiply(arzneg);
                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(
                        artmp.transpose());
                oldFac += negalphaold * negccov;
                C = C.scalarMultiply(oldFac)
                        // regard old matrix
                        .add(roneu)
                        // plus rank one update
                        .add(arpos.scalarMultiply(
                                // plus rank mu update
                                ccovmu + (1. - negalphaold) * negccov)
                                .multiply(
                                        times(repmat(weights, 1, dimension),
                                                arpos.transpose())))
                        .subtract(Cneg.scalarMultiply(negccov));
            } else {
                // Adapt covariance matrix C - nonactive
                C = C.scalarMultiply(oldFac) // regard old matrix
                        .add(roneu)
                        // plus rank one update
                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update
                                .multiply(
                                        times(repmat(weights, 1, dimension),
                                                arpos.transpose())));
            }
        }
        updateBD(negccov);
    }",0,[0]
7018,bugs-dot-jar_LOG4J2-763_97203de8,"public LocalizedMessage(final String baseName, final Locale locale, final String key, final Object arg1,
                            final Object arg2) {
        this(baseName, locale, key, new Object[] {arg1, arg2});
    }","public LocalizedMessage(final String baseName, final Locale locale, final String key, final Object arg1,
                            final Object arg2) {
        this(baseName, locale, key, new Object[] {arg1, arg2});
    }",0,[0]
38427,bugs-dot-jar_MATH-867_bfbb156d,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = fitfun.encode(getStartPoint());
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum = new PointValuePair(getStartPoint(),
                isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------

        generationLoop:
            for (iterations = 1; iterations <= maxIterations; iterations++) {
                // Generate and evaluate lambda offspring
                RealMatrix arz = randn1(dimension, lambda);
                RealMatrix arx = zeros(dimension, lambda);
                double[] fitness = new double[lambda];
                // generate random offspring
                for (int k = 0; k < lambda; k++) {
                    RealMatrix arxk = null;
                    for (int i = 0; i < checkFeasableCount+1; i++) {
                        if (diagonalOnly <= 0) {
                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                        } else {
                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma));
                        }
                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                            break;
                        }
                        // regenerate random arguments for row
                        arz.setColumn(k, randn(dimension));
                    }
                    copyColumn(arxk, 0, arx, k);
                    try {
                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                    } catch (TooManyEvaluationsException e) {
                        break generationLoop;
                    }
                }
                // Sort by fitness and compute weighted mean into xmean
                int[] arindex = sortedIndices(fitness);
                // Calculate new xmean, this is selection and recombination
                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
                xmean = bestArx.multiply(weights);
                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
                RealMatrix zmean = bestArz.multiply(weights);
                boolean hsig = updateEvolutionPaths(zmean, xold);
                if (diagonalOnly <= 0) {
                    updateCovariance(hsig, bestArx, arz, arindex, xold);
                } else {
                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);
                }
                // Adapt step size sigma - Eq. (5)
                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
                double bestFitness = fitness[arindex[0]];
                double worstFitness = fitness[arindex[arindex.length-1]];
                if (bestValue > bestFitness) {
                    bestValue = bestFitness;
                    lastResult = optimum;
                    optimum = new PointValuePair(
                            fitfun.repairAndDecode(bestArx.getColumn(0)),
                            isMinimize ? bestFitness : -bestFitness);
                    if (getConvergenceChecker() != null && lastResult != null) {
                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                            break generationLoop;
                        }
                    }
                }
                // handle termination criteria
                // Break, if fitness is good enough
                if (stopFitness != 0) { // only if stopFitness is defined
                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                        break generationLoop;
                    }
                }
                double[] sqrtDiagC = sqrt(diagC).getColumn(0);
                double[] pcCol = pc.getColumn(0);
                for (int i = 0; i < dimension; i++) {
                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                        break;
                    }
                    if (i >= dimension-1) {
                        break generationLoop;
                    }
                }
                for (int i = 0; i < dimension; i++) {
                    if (sigma*sqrtDiagC[i] > stopTolUpX) {
                        break generationLoop;
                    }
                }
                double historyBest = min(fitnessHistory);
                double historyWorst = max(fitnessHistory);
                if (iterations > 2 && Math.max(historyWorst, worstFitness) -
                        Math.min(historyBest, bestFitness) < stopTolFun) {
                    break generationLoop;
                }
                if (iterations > fitnessHistory.length &&
                        historyWorst-historyBest < stopTolHistFun) {
                    break generationLoop;
                }
                // condition number of the covariance matrix exceeds 1e14
                if (max(diagD)/min(diagD) > 1e7) {
                    break generationLoop;
                }
                // user defined termination
                if (getConvergenceChecker() != null) {
                    PointValuePair current =
                        new PointValuePair(bestArx.getColumn(0),
                                isMinimize ? bestFitness : -bestFitness);
                    if (lastResult != null &&
                        getConvergenceChecker().converged(iterations, current, lastResult)) {
                        break generationLoop;
                    }
                    lastResult = current;
                }
                // Adjust step size in case of equal function values (flat fitness)
                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                        Math.min(historyBest, bestFitness) == 0) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                // store best in history
                push(fitnessHistory,bestFitness);
                fitfun.setValueRange(worstFitness-bestFitness);
                if (generateStatistics) {
                    statisticsSigmaHistory.add(sigma);
                    statisticsFitnessHistory.add(bestFitness);
                    statisticsMeanHistory.add(xmean.transpose());
                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
                }
            }
        return optimum;
    }","@Override
    protected PointValuePair doOptimize() {
        checkParameters();
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = getStartPoint();
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum = new PointValuePair(getStartPoint(),
                isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------

        generationLoop:
            for (iterations = 1; iterations <= maxIterations; iterations++) {
                // Generate and evaluate lambda offspring
                RealMatrix arz = randn1(dimension, lambda);
                RealMatrix arx = zeros(dimension, lambda);
                double[] fitness = new double[lambda];
                // generate random offspring
                for (int k = 0; k < lambda; k++) {
                    RealMatrix arxk = null;
                    for (int i = 0; i < checkFeasableCount+1; i++) {
                        if (diagonalOnly <= 0) {
                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                        } else {
                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                    .scalarMultiply(sigma));
                        }
                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
                            break;
                        }
                        // regenerate random arguments for row
                        arz.setColumn(k, randn(dimension));
                    }
                    copyColumn(arxk, 0, arx, k);
                    try {
                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                    } catch (TooManyEvaluationsException e) {
                        break generationLoop;
                    }
                }
                // Sort by fitness and compute weighted mean into xmean
                int[] arindex = sortedIndices(fitness);
                // Calculate new xmean, this is selection and recombination
                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
                xmean = bestArx.multiply(weights);
                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
                RealMatrix zmean = bestArz.multiply(weights);
                boolean hsig = updateEvolutionPaths(zmean, xold);
                if (diagonalOnly <= 0) {
                    updateCovariance(hsig, bestArx, arz, arindex, xold);
                } else {
                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);
                }
                // Adapt step size sigma - Eq. (5)
                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
                double bestFitness = fitness[arindex[0]];
                double worstFitness = fitness[arindex[arindex.length-1]];
                if (bestValue > bestFitness) {
                    bestValue = bestFitness;
                    lastResult = optimum;
                    optimum = new PointValuePair(
                            fitfun.repair(bestArx.getColumn(0)),
                            isMinimize ? bestFitness : -bestFitness);
                    if (getConvergenceChecker() != null && lastResult != null) {
                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                            break generationLoop;
                        }
                    }
                }
                // handle termination criteria
                // Break, if fitness is good enough
                if (stopFitness != 0) { // only if stopFitness is defined
                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                        break generationLoop;
                    }
                }
                double[] sqrtDiagC = sqrt(diagC).getColumn(0);
                double[] pcCol = pc.getColumn(0);
                for (int i = 0; i < dimension; i++) {
                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
                        break;
                    }
                    if (i >= dimension-1) {
                        break generationLoop;
                    }
                }
                for (int i = 0; i < dimension; i++) {
                    if (sigma*sqrtDiagC[i] > stopTolUpX) {
                        break generationLoop;
                    }
                }
                double historyBest = min(fitnessHistory);
                double historyWorst = max(fitnessHistory);
                if (iterations > 2 && Math.max(historyWorst, worstFitness) -
                        Math.min(historyBest, bestFitness) < stopTolFun) {
                    break generationLoop;
                }
                if (iterations > fitnessHistory.length &&
                        historyWorst-historyBest < stopTolHistFun) {
                    break generationLoop;
                }
                // condition number of the covariance matrix exceeds 1e14
                if (max(diagD)/min(diagD) > 1e7) {
                    break generationLoop;
                }
                // user defined termination
                if (getConvergenceChecker() != null) {
                    PointValuePair current =
                        new PointValuePair(bestArx.getColumn(0),
                                isMinimize ? bestFitness : -bestFitness);
                    if (lastResult != null &&
                        getConvergenceChecker().converged(iterations, current, lastResult)) {
                        break generationLoop;
                    }
                    lastResult = current;
                }
                // Adjust step size in case of equal function values (flat fitness)
                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                        Math.min(historyBest, bestFitness) == 0) {
                    sigma = sigma * Math.exp(0.2+cs/damps);
                }
                // store best in history
                push(fitnessHistory,bestFitness);
                fitfun.setValueRange(worstFitness-bestFitness);
                if (generateStatistics) {
                    statisticsSigmaHistory.add(sigma);
                    statisticsFitnessHistory.add(bestFitness);
                    statisticsMeanHistory.add(xmean.transpose());
                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
                }
            }
        return optimum;
    }",1,"[6, 71]"
2596,bugs-dot-jar_ACCUMULO-3474_cfb832a1,"@Override
  public void setProperty(ByteBuffer login, String property, String value) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      getConnector(login).instanceOperations().setProperty(property, value);
    } catch (Exception e) {
      handleException(e);
    }
  }","@Override
  public void setProperty(ByteBuffer login, String property, String value) throws org.apache.accumulo.proxy.thrift.AccumuloException,
      org.apache.accumulo.proxy.thrift.AccumuloSecurityException, TException {
    try {
      getConnector(login).instanceOperations().setProperty(property, value);
    } catch (Exception e) {
      handleException(e);
    }
  }",0,[0]
31097,bugs-dot-jar_CAMEL-8125_36e7b668,"public String resolvePropertyPlaceholders(String text) throws Exception {
        // While it is more efficient to only do the lookup if we are sure we need the component,
        // with custom tokens, we cannot know if the URI contains a property or not without having
        // the component.  We also lose fail-fast behavior for the missing component with this change.
        PropertiesComponent pc = getPropertiesComponent();

        // Do not parse uris that are designated for the properties component as it will handle that itself
        if (text != null && !text.startsWith(""properties:"")) {
            // No component, assume default tokens.
            if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {

                // try to lookup component, as we may be initializing CamelContext itself
                Component existing = lookupPropertiesComponent();
                if (existing != null) {
                    if (existing instanceof PropertiesComponent) {
                        pc = (PropertiesComponent) existing;
                    } else {
                        // properties component must be expected type
                        throw new IllegalArgumentException(""Found properties component of type: "" + existing.getClass() + "" instead of expected: "" + PropertiesComponent.class);
                    }
                }

                if (pc == null) {
                    // create a default properties component to be used as there may be default values we can use
                    log.info(""No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties"");
                    pc = getComponent(""properties"", PropertiesComponent.class);
                }
            }

            if (pc != null && text.contains(pc.getPrefixToken())) {
                // the parser will throw exception if property key was not found
                String answer = pc.parseUri(text);
                log.debug(""Resolved text: {} -> {}"", text, answer);
                return answer; 
            }
        }

        // return original text as is
        return text;
    }","public String resolvePropertyPlaceholders(String text) throws Exception {
        // While it is more efficient to only do the lookup if we are sure we need the component,
        // with custom tokens, we cannot know if the URI contains a property or not without having
        // the component.  We also lose fail-fast behavior for the missing component with this change.
        PropertiesComponent pc = getPropertiesComponent();

        // Do not parse uris that are designated for the properties component as it will handle that itself
        if (text != null && !text.startsWith(""properties:"")) {
            // No component, assume default tokens.
            if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {
                // lookup existing properties component, or force create a new default component
                pc = (PropertiesComponent) CamelContextHelper.lookupPropertiesComponent(this, true);
            }

            if (pc != null && text.contains(pc.getPrefixToken())) {
                // the parser will throw exception if property key was not found
                String answer = pc.parseUri(text);
                log.debug(""Resolved text: {} -> {}"", text, answer);
                return answer; 
            }
        }

        // return original text as is
        return text;
    }",1,"[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 24, 25, 26]"
29677,bugs-dot-jar_ACCUMULO-217_46f62443,"@Override
  public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values())
      lifecycles.add(scope.name().toLowerCase());
    for (Entry<String,String> property : this.getProperties(tableName)) {
      String name = property.getKey();
      String[] parts = name.split(""\\."");
      if (parts.length == 4) {
        if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
          result.add(parts[3]);
      }
    }
    return result;
  }","@Override
  public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {
    if (!exists(tableName))
      throw new TableNotFoundException(null, tableName, null);
    Set<String> result = new HashSet<String>();
    Set<String> lifecycles = new HashSet<String>();
    for (IteratorScope scope : IteratorScope.values())
      lifecycles.add(scope.name().toLowerCase());
    for (Entry<String,String> property : this.getProperties(tableName)) {
      String name = property.getKey();
      String[] parts = name.split(""\\."");
      if (parts.length == 4) {
        if (parts[0].equals(""table"") && parts[1].equals(""iterator"") && lifecycles.contains(parts[2]))
          result.add(parts[3]);
      }
    }
    return result;
  }",1,[]
37041,bugs-dot-jar_OAK-1883_9c2421ed,"public Iterable<ClusterNodeInfoDocument> getAllClusters() {
        return store.query(Collection.CLUSTER_NODES, ClusterNodeInfoDocument.MIN_ID_VALUE,
                ClusterNodeInfoDocument.MAX_ID_VALUE, Integer.MAX_VALUE);
    }","public Iterable<ClusterNodeInfoDocument> getAllClusters() {
        return store.query(Collection.CLUSTER_NODES, ClusterNodeInfoDocument.MIN_ID_VALUE,
                ClusterNodeInfoDocument.MAX_ID_VALUE, Integer.MAX_VALUE);
    }",0,[0]
13815,bugs-dot-jar_OAK-596_9b268da0,"public Map<String, Object> getAddedProps() {
        return addedProps;
    }","public Map<String, Object> getAddedProps() {
        return addedProps;
    }",0,[0]
2289,bugs-dot-jar_MNG-4918_691a03a7,"public void setRemoteArtifactRepositories( List<ArtifactRepository> remoteArtifactRepositories )
    {
        this.remoteArtifactRepositories = remoteArtifactRepositories;
        this.remoteProjectRepositories = RepositoryUtils.toRepos( getRemoteArtifactRepositories() );
    }","public void setRemoteArtifactRepositories( List<ArtifactRepository> remoteArtifactRepositories )
    {
        this.remoteArtifactRepositories = remoteArtifactRepositories;
        this.remoteProjectRepositories = RepositoryUtils.toRepos( getRemoteArtifactRepositories() );
    }",0,[0]
25088,bugs-dot-jar_OAK-1227_117b0a3d,"@Override @Nonnull
    public NodeIterator getSharedSet() {
        return new NodeIteratorAdapter(singleton(this));
    }","@Override @Nonnull
    public NodeIterator getSharedSet() {
        return new NodeIteratorAdapter(singleton(this));
    }",0,[0]
28383,bugs-dot-jar_WICKET-2172_ea4a3f8a,"@Override
	public Object put(String key, Object value)
	{
		return super.put(key, value);
		/*
		 * see WICKET-2162 as well. BRING BACK IN 1.4
		 * 
		 * if (!(key instanceof String)) { throw new IllegalArgumentException( ""PageParameter keys
		 * must be of type String, but you supplied a "" + key.getClass().getName()); } if (value
		 * instanceof String || value instanceof String[]) { return super.put(key, value); } else {
		 * throw new IllegalArgumentException(""You tried to add an object of type "" +
		 * value.getClass().getName() + "" to your PageParameters for key "" + key + "", but you are
		 * only allowed to use String or String[].""); }
		 */
	}","@Override
	public Object put(String key, Object value)
	{
		return super.put(key, value);
		/*
		 * see WICKET-2162 as well. BRING BACK IN 1.4
		 * 
		 * if (!(key instanceof String)) { throw new IllegalArgumentException( ""PageParameter keys
		 * must be of type String, but you supplied a "" + key.getClass().getName()); } if (value
		 * instanceof String || value instanceof String[]) { return super.put(key, value); } else {
		 * throw new IllegalArgumentException(""You tried to add an object of type "" +
		 * value.getClass().getName() + "" to your PageParameters for key "" + key + "", but you are
		 * only allowed to use String or String[].""); }
		 */
	}",0,[0]
22029,bugs-dot-jar_OAK-4050_52ca008c,"@CheckForNull
    private UpdateOp createSplitOps() {
        UpdateOp main = null;
        // check if we have enough data to split off
        if (high != null && low != null
                && (numValues >= numRevsThreshold
                || doc.getMemory() > DOC_SIZE_THRESHOLD)) {
            // enough changes to split off
            // move to another document
            main = new UpdateOp(id, false);
            setPrevious(main, new Range(high, low, 0));
            String oldPath = Utils.getPreviousPathFor(path, high, 0);
            UpdateOp old = new UpdateOp(Utils.getIdFromPath(oldPath), true);
            old.set(Document.ID, old.getId());
            if (Utils.isLongPath(oldPath)) {
                old.set(NodeDocument.PATH, oldPath);
            }
            for (String property : committedChanges.keySet()) {
                NavigableMap<Revision, String> splitMap = committedChanges.get(property);
                for (Map.Entry<Revision, String> entry : splitMap.entrySet()) {
                    Revision r = entry.getKey();
                    if (isRevisionsEntry(property) || isCommitRootEntry(property)) {
                        // only remove from main document if it is not
                        // referenced anymore from from most recent changes
                        if (!mostRecentRevs.contains(r)) {
                            main.removeMapEntry(property, r);
                        }
                    } else {
                        main.removeMapEntry(property, r);
                    }
                    old.setMapEntry(property, r, entry.getValue());
                }
            }
            // check size of old document
            NodeDocument oldDoc = new NodeDocument(STORE);
            UpdateUtils.applyChanges(oldDoc, old);
            setSplitDocProps(doc, oldDoc, old, high);
            // only split if enough of the data can be moved to old document
            if (oldDoc.getMemory() > doc.getMemory() * SPLIT_RATIO
                    || numValues >= numRevsThreshold) {
                splitOps.add(old);
            } else {
                main = null;
            }
        }
        return main;
    }","@CheckForNull
    private UpdateOp createSplitOps() {
        UpdateOp main = null;
        // check if we have enough data to split off
        if (high != null && low != null
                && (numValues >= numRevsThreshold
                || doc.getMemory() > DOC_SIZE_THRESHOLD)) {
            // enough changes to split off
            // move to another document
            main = new UpdateOp(id, false);
            setPrevious(main, new Range(high, low, 0));
            String oldPath = Utils.getPreviousPathFor(path, high, 0);
            UpdateOp old = new UpdateOp(Utils.getIdFromPath(oldPath), true);
            old.set(Document.ID, old.getId());
            if (Utils.isLongPath(oldPath)) {
                old.set(NodeDocument.PATH, oldPath);
            }
            for (String property : committedChanges.keySet()) {
                NavigableMap<Revision, String> splitMap = committedChanges.get(property);
                for (Map.Entry<Revision, String> entry : splitMap.entrySet()) {
                    Revision r = entry.getKey();
                    if (isRevisionsEntry(property) || isCommitRootEntry(property)) {
                        // only remove from main document if it is not
                        // referenced anymore from from most recent changes
                        if (!mostRecentRevs.contains(r)) {
                            main.removeMapEntry(property, r);
                        }
                    } else {
                        main.removeMapEntry(property, r);
                    }
                    old.setMapEntry(property, r, entry.getValue());
                }
            }
            // check size of old document
            NodeDocument oldDoc = new NodeDocument(STORE);
            UpdateUtils.applyChanges(oldDoc, old);
            setSplitDocProps(doc, oldDoc, old, high);
            // only split if enough of the data can be moved to old document
            if (oldDoc.getMemory() > doc.getMemory() * SPLIT_RATIO
                    || numValues >= numRevsThreshold) {
                splitOps.add(old);
            } else {
                main = null;
            }
        }
        return main;
    }",0,[0]
2913,bugs-dot-jar_WICKET-3455_f30bd1cb,"private final Component children_get(final String id)
	{
		if (children == null)
		{
			return null;
		}
		Component component = null;
		if ((children instanceof Object[] == false) && (children instanceof List == false))
		{
			if (getId(children).equals(id))
			{
				component = (Component)postprocess(children, true, this, 0);
				if (children != component)
				{
					children = component;
				}
			}
		}
		else
		{
			Object[] children;
			int size = 0;
			if (this.children instanceof ChildList)
			{
				children = ((ChildList)this.children).childs;
				size = ((ChildList)this.children).size;
			}
			else
			{
				children = (Object[])this.children;
				size = children.length;
			}
			for (int i = 0; i < size; i++)
			{
				if (getId(children[i]).equals(id))
				{
					component = (Component)postprocess(children[i], true, this, i);
					if (children[i] != component)
					{
						children[i] = component;
					}
					break;
				}
			}
		}
		return component;
	}","private final Component children_get(final String id)
	{
		if (children == null)
		{
			return null;
		}
		Component component = null;
		if ((children instanceof Object[] == false) && (children instanceof List == false))
		{
			if (getId(children).equals(id))
			{
				component = (Component)postprocess(children, true, this, 0);
				if (children != component)
				{
					children = component;
				}
			}
		}
		else
		{
			Object[] children;
			int size = 0;
			if (this.children instanceof ChildList)
			{
				children = ((ChildList)this.children).childs;
				size = ((ChildList)this.children).size;
			}
			else
			{
				children = (Object[])this.children;
				size = children.length;
			}
			for (int i = 0; i < size; i++)
			{
				if (getId(children[i]).equals(id))
				{
					component = (Component)postprocess(children[i], true, this, i);
					if (children[i] != component)
					{
						children[i] = component;
					}
					break;
				}
			}
		}
		return component;
	}",0,[0]
6451,bugs-dot-jar_FLINK-1133_27e40205,"public static <X> TypeInformation<X> getForClass(Class<X> clazz) {
		return new TypeExtractor().privateGetForClass(clazz);
	}","public static <X> TypeInformation<X> getForClass(Class<X> clazz) {
		return new TypeExtractor().privateGetForClass(clazz);
	}",0,[0]
36639,bugs-dot-jar_MATH-904_6844aba9,"private static double expm1(double x, double hiPrecOut[]) {
        if (x != x || x == 0.0) { // NaN or zero
            return x;
        }

        if (x <= -1.0 || x >= 1.0) {
            // If not between +/- 1.0
            //return exp(x) - 1.0;
            double hiPrec[] = new double[2];
            exp(x, 0.0, hiPrec);
            if (x > 0.0) {
                return -1.0 + hiPrec[0] + hiPrec[1];
            } else {
                final double ra = -1.0 + hiPrec[0];
                double rb = -(ra + 1.0 - hiPrec[0]);
                rb += hiPrec[1];
                return ra + rb;
            }
        }

        double baseA;
        double baseB;
        double epsilon;
        boolean negative = false;

        if (x < 0.0) {
            x = -x;
            negative = true;
        }

        {
            int intFrac = (int) (x * 1024.0);
            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;
            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];

            double temp = tempA + tempB;
            tempB = -(temp - tempA - tempB);
            tempA = temp;

            temp = tempA * HEX_40000000;
            baseA = tempA + temp - temp;
            baseB = tempB + (tempA - baseA);

            epsilon = x - intFrac/1024.0;
        }


        /* Compute expm1(epsilon) */
        double zb = 0.008336750013465571;
        zb = zb * epsilon + 0.041666663879186654;
        zb = zb * epsilon + 0.16666666666745392;
        zb = zb * epsilon + 0.49999999999999994;
        zb = zb * epsilon;
        zb = zb * epsilon;

        double za = epsilon;
        double temp = za + zb;
        zb = -(temp - za - zb);
        za = temp;

        temp = za * HEX_40000000;
        temp = za + temp - temp;
        zb += za - temp;
        za = temp;

        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */
        double ya = za * baseA;
        //double yb = za*baseB + zb*baseA + zb*baseB;
        temp = ya + za * baseB;
        double yb = -(temp - ya - za * baseB);
        ya = temp;

        temp = ya + zb * baseA;
        yb += -(temp - ya - zb * baseA);
        ya = temp;

        temp = ya + zb * baseB;
        yb += -(temp - ya - zb*baseB);
        ya = temp;

        //ya = ya + za + baseA;
        //yb = yb + zb + baseB;
        temp = ya + baseA;
        yb += -(temp - baseA - ya);
        ya = temp;

        temp = ya + za;
        //yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);
        yb += -(temp - ya - za);
        ya = temp;

        temp = ya + baseB;
        //yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);
        yb += -(temp - ya - baseB);
        ya = temp;

        temp = ya + zb;
        //yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);
        yb += -(temp - ya - zb);
        ya = temp;

        if (negative) {
            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
            double denom = 1.0 + ya;
            double denomr = 1.0 / denom;
            double denomb = -(denom - 1.0 - ya) + yb;
            double ratio = ya * denomr;
            temp = ratio * HEX_40000000;
            final double ra = ratio + temp - temp;
            double rb = ratio - ra;

            temp = denom * HEX_40000000;
            za = denom + temp - temp;
            zb = denom - za;

            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;

            // f(x) = x/1+x
            // Compute f'(x)
            // Product rule:  d(uv) = du*v + u*dv
            // Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))
            // d(1/x) = -1/(x*x)
            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))
            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))

            // Adjust for yb
            rb += yb * denomr;                      // numerator
            rb += -ya * denomb * denomr * denomr;   // denominator

            // negate
            ya = -ra;
            yb = -rb;
        }

        if (hiPrecOut != null) {
            hiPrecOut[0] = ya;
            hiPrecOut[1] = yb;
        }

        return ya + yb;
    }","private static double expm1(double x, double hiPrecOut[]) {
        if (x != x || x == 0.0) { // NaN or zero
            return x;
        }

        if (x <= -1.0 || x >= 1.0) {
            // If not between +/- 1.0
            //return exp(x) - 1.0;
            double hiPrec[] = new double[2];
            exp(x, 0.0, hiPrec);
            if (x > 0.0) {
                return -1.0 + hiPrec[0] + hiPrec[1];
            } else {
                final double ra = -1.0 + hiPrec[0];
                double rb = -(ra + 1.0 - hiPrec[0]);
                rb += hiPrec[1];
                return ra + rb;
            }
        }

        double baseA;
        double baseB;
        double epsilon;
        boolean negative = false;

        if (x < 0.0) {
            x = -x;
            negative = true;
        }

        {
            int intFrac = (int) (x * 1024.0);
            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;
            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];

            double temp = tempA + tempB;
            tempB = -(temp - tempA - tempB);
            tempA = temp;

            temp = tempA * HEX_40000000;
            baseA = tempA + temp - temp;
            baseB = tempB + (tempA - baseA);

            epsilon = x - intFrac/1024.0;
        }


        /* Compute expm1(epsilon) */
        double zb = 0.008336750013465571;
        zb = zb * epsilon + 0.041666663879186654;
        zb = zb * epsilon + 0.16666666666745392;
        zb = zb * epsilon + 0.49999999999999994;
        zb = zb * epsilon;
        zb = zb * epsilon;

        double za = epsilon;
        double temp = za + zb;
        zb = -(temp - za - zb);
        za = temp;

        temp = za * HEX_40000000;
        temp = za + temp - temp;
        zb += za - temp;
        za = temp;

        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */
        double ya = za * baseA;
        //double yb = za*baseB + zb*baseA + zb*baseB;
        temp = ya + za * baseB;
        double yb = -(temp - ya - za * baseB);
        ya = temp;

        temp = ya + zb * baseA;
        yb += -(temp - ya - zb * baseA);
        ya = temp;

        temp = ya + zb * baseB;
        yb += -(temp - ya - zb*baseB);
        ya = temp;

        //ya = ya + za + baseA;
        //yb = yb + zb + baseB;
        temp = ya + baseA;
        yb += -(temp - baseA - ya);
        ya = temp;

        temp = ya + za;
        //yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);
        yb += -(temp - ya - za);
        ya = temp;

        temp = ya + baseB;
        //yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);
        yb += -(temp - ya - baseB);
        ya = temp;

        temp = ya + zb;
        //yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);
        yb += -(temp - ya - zb);
        ya = temp;

        if (negative) {
            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
            double denom = 1.0 + ya;
            double denomr = 1.0 / denom;
            double denomb = -(denom - 1.0 - ya) + yb;
            double ratio = ya * denomr;
            temp = ratio * HEX_40000000;
            final double ra = ratio + temp - temp;
            double rb = ratio - ra;

            temp = denom * HEX_40000000;
            za = denom + temp - temp;
            zb = denom - za;

            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;

            // f(x) = x/1+x
            // Compute f'(x)
            // Product rule:  d(uv) = du*v + u*dv
            // Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))
            // d(1/x) = -1/(x*x)
            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))
            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))

            // Adjust for yb
            rb += yb * denomr;                      // numerator
            rb += -ya * denomb * denomr * denomr;   // denominator

            // negate
            ya = -ra;
            yb = -rb;
        }

        if (hiPrecOut != null) {
            hiPrecOut[0] = ya;
            hiPrecOut[1] = yb;
        }

        return ya + yb;
    }",0,[0]
1730,Bears-197,"public URIBuilder clearParameters() {
        this.queryParams = null;
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        return this;
    }","public URIBuilder clearParameters() {
        this.queryParams = null;
        this.encodedQuery = null;
        this.encodedSchemeSpecificPart = null;
        return this;
    }",0,[0]
37160,bugs-dot-jar_OAK-1648_fdc54465,"public void release(String checkpoint) {
        UpdateOp op = new UpdateOp(ID, false);
        op.removeMapEntry(PROP_CHECKPOINT, Revision.fromString(checkpoint));
        store.findAndUpdate(Collection.SETTINGS, op);
    }","public void release(String checkpoint) {
        UpdateOp op = new UpdateOp(ID, false);
        op.removeMapEntry(PROP_CHECKPOINT, Revision.fromString(checkpoint));
        store.findAndUpdate(Collection.SETTINGS, op);
    }",0,[0]
61,bugs-dot-jar_OAK-1822_3e83a4c1,"public static void removeCommitRoot(@Nonnull UpdateOp op,
                                        @Nonnull Revision revision) {
        checkNotNull(op).removeMapEntry(COMMIT_ROOT, revision);
    }","public static void removeCommitRoot(@Nonnull UpdateOp op,
                                        @Nonnull Revision revision) {
        checkNotNull(op).removeMapEntry(COMMIT_ROOT, revision);
    }",0,[0]
33082,bugs-dot-jar_OAK-2999_3bf07779,"private String getIndexName() {
        return context.getDefinition().getIndexName();
    }","private String getIndexName() {
        return context.getDefinition().getIndexName();
    }",0,[0]
23546,bugs-dot-jar_LOG4J2-127_029e79da,"protected abstract boolean isEnabled(Level level, Marker marker, String data);","protected abstract boolean isEnabled(Level level, Marker marker, String data);",0,[0]
21422,bugs-dot-jar_MATH-1211_a06a1584,"@Override
    public PolyhedronsSet buildNew(final BSPTree<Euclidean3D> tree) {
        return new PolyhedronsSet(tree, getTolerance());
    }","@Override
    public PolyhedronsSet buildNew(final BSPTree<Euclidean3D> tree) {
        return new PolyhedronsSet(tree, getTolerance());
    }",0,[0]
13142,bugs-dot-jar_OAK-2434_8159fc21,"private static void addNonFullTextConstraints(List<Query> qs,
            Filter filter, IndexReader reader, Analyzer analyzer, IndexDefinition indexDefinition) {
        if (!filter.matchesAllTypes()) {
            addNodeTypeConstraints(qs, filter);
        }

        String path = filter.getPath();
        switch (filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (USE_PATH_RESTRICTION) {
                if (""/"".equals(path)) {
                    break;
                }
                if (!path.endsWith(""/"")) {
                    path += ""/"";
                }
                qs.add(new PrefixQuery(newPathTerm(path)));
            }
            break;
        case DIRECT_CHILDREN:
            if (USE_PATH_RESTRICTION) {
                if (!path.endsWith(""/"")) {
                    path += ""/"";
                }
                qs.add(new PrefixQuery(newPathTerm(path)));
            }
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (denotesRoot(path)) {
                // there's no parent of the root node
                // we add a path that can not possibly occur because there
                // is no way to say ""match no documents"" in Lucene
                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
        }

        //Fulltext index definition used by LuceneIndex only works with old format
        //which is not nodeType based. So just use the nt:base index
        IndexingRule rule = indexDefinition.getApplicableIndexingRule(JcrConstants.NT_BASE);
        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {

            if (pr.first == null && pr.last == null) {
                // ignore property existence checks, Lucene can't to 'property
                // is not null' queries (OAK-1208)
                continue;
            }

            // check excluded properties and types
            if (isExcludedProperty(pr, rule)) {
                continue;
            }

            String name = pr.propertyName;
            if (""rep:excerpt"".equals(name)) {
                continue;
            }
            if (JCR_PRIMARYTYPE.equals(name)) {
                continue;
            }

            if (skipTokenization(name)) {
                qs.add(new TermQuery(new Term(name, pr.first
                        .getValue(STRING))));
                continue;
            }

            String first = null;
            String last = null;
            boolean isLike = pr.isLike;

            // TODO what to do with escaped tokens?
            if (pr.first != null) {
                first = pr.first.getValue(STRING);
                first = first.replace(""\\"", """");
            }
            if (pr.last != null) {
                last = pr.last.getValue(STRING);
                last = last.replace(""\\"", """");
            }

            if (isLike) {
                first = first.replace('%', WildcardQuery.WILDCARD_STRING);
                first = first.replace('_', WildcardQuery.WILDCARD_CHAR);

                int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
                int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
                int len = first.length();

                if (indexOfWS == len || indexOfWC == len) {
                    // remove trailing ""*"" for prefixquery
                    first = first.substring(0, first.length() - 1);
                    if (JCR_PATH.equals(name)) {
                        qs.add(new PrefixQuery(newPathTerm(first)));
                    } else {
                        qs.add(new PrefixQuery(new Term(name, first)));
                    }
                } else {
                    if (JCR_PATH.equals(name)) {
                        qs.add(new WildcardQuery(newPathTerm(first)));
                    } else {
                        qs.add(new WildcardQuery(new Term(name, first)));
                    }
                }
                continue;
            }

            if (first != null && first.equals(last) && pr.firstIncluding
                    && pr.lastIncluding) {
                if (JCR_PATH.equals(name)) {
                    qs.add(new TermQuery(newPathTerm(first)));
                } else {
                    if (""*"".equals(name)) {
                        addReferenceConstraint(first, qs, reader);
                    } else {
                        for (String t : tokenize(first, analyzer)) {
                            qs.add(new TermQuery(new Term(name, t)));
                        }
                    }
                }
                continue;
            }

            first = tokenizeAndPoll(first, analyzer);
            last = tokenizeAndPoll(last, analyzer);
            qs.add(TermRangeQuery.newStringRange(name, first, last,
                    pr.firstIncluding, pr.lastIncluding));
        }
    }","private static void addNonFullTextConstraints(List<Query> qs,
            Filter filter, IndexReader reader, Analyzer analyzer, IndexDefinition indexDefinition) {
        if (!filter.matchesAllTypes()) {
            addNodeTypeConstraints(qs, filter);
        }

        String path = filter.getPath();
        switch (filter.getPathRestriction()) {
        case ALL_CHILDREN:
            if (USE_PATH_RESTRICTION) {
                if (""/"".equals(path)) {
                    break;
                }
                if (!path.endsWith(""/"")) {
                    path += ""/"";
                }
                qs.add(new PrefixQuery(newPathTerm(path)));
            }
            break;
        case DIRECT_CHILDREN:
            if (USE_PATH_RESTRICTION) {
                if (!path.endsWith(""/"")) {
                    path += ""/"";
                }
                qs.add(new PrefixQuery(newPathTerm(path)));
            }
            break;
        case EXACT:
            qs.add(new TermQuery(newPathTerm(path)));
            break;
        case PARENT:
            if (denotesRoot(path)) {
                // there's no parent of the root node
                // we add a path that can not possibly occur because there
                // is no way to say ""match no documents"" in Lucene
                qs.add(new TermQuery(new Term(FieldNames.PATH, ""///"")));
            } else {
                qs.add(new TermQuery(newPathTerm(getParentPath(path))));
            }
            break;
        case NO_RESTRICTION:
            break;
        }

        //Fulltext index definition used by LuceneIndex only works with old format
        //which is not nodeType based. So just use the nt:base index
        IndexingRule rule = indexDefinition.getApplicableIndexingRule(JcrConstants.NT_BASE);
        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {

            if (pr.first == null && pr.last == null) {
                // ignore property existence checks, Lucene can't to 'property
                // is not null' queries (OAK-1208)
                continue;
            }

            // check excluded properties and types
            if (isExcludedProperty(pr, rule)) {
                continue;
            }

            String name = pr.propertyName;
            if (""rep:excerpt"".equals(name)) {
                continue;
            }
            if (JCR_PRIMARYTYPE.equals(name)) {
                continue;
            }

            if (skipTokenization(name)) {
                qs.add(new TermQuery(new Term(name, pr.first
                        .getValue(STRING))));
                continue;
            }

            String first = null;
            String last = null;
            boolean isLike = pr.isLike;

            // TODO what to do with escaped tokens?
            if (pr.first != null) {
                first = pr.first.getValue(STRING);
                first = first.replace(""\\"", """");
            }
            if (pr.last != null) {
                last = pr.last.getValue(STRING);
                last = last.replace(""\\"", """");
            }

            if (isLike) {
                first = first.replace('%', WildcardQuery.WILDCARD_STRING);
                first = first.replace('_', WildcardQuery.WILDCARD_CHAR);

                int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);
                int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);
                int len = first.length();

                if (indexOfWS == len || indexOfWC == len) {
                    // remove trailing ""*"" for prefixquery
                    first = first.substring(0, first.length() - 1);
                    if (JCR_PATH.equals(name)) {
                        qs.add(new PrefixQuery(newPathTerm(first)));
                    } else {
                        qs.add(new PrefixQuery(new Term(name, first)));
                    }
                } else {
                    if (JCR_PATH.equals(name)) {
                        qs.add(new WildcardQuery(newPathTerm(first)));
                    } else {
                        qs.add(new WildcardQuery(new Term(name, first)));
                    }
                }
                continue;
            }

            if (first != null && first.equals(last) && pr.firstIncluding
                    && pr.lastIncluding) {
                if (JCR_PATH.equals(name)) {
                    qs.add(new TermQuery(newPathTerm(first)));
                } else {
                    if (""*"".equals(name)) {
                        addReferenceConstraint(first, qs, reader);
                    } else {
                        for (String t : tokenize(first, analyzer)) {
                            qs.add(new TermQuery(new Term(name, t)));
                        }
                    }
                }
                continue;
            }

            first = tokenizeAndPoll(first, analyzer);
            last = tokenizeAndPoll(last, analyzer);
            qs.add(TermRangeQuery.newStringRange(name, first, last,
                    pr.firstIncluding, pr.lastIncluding));
        }
    }",0,[0]
23557,bugs-dot-jar_OAK-1614_86edbffb,"@Override
    protected TokenStreamComponents createComponents(final String fieldName,
            final Reader reader) {
        WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);
        TokenStream tok = new LowerCaseFilter(matchVersion, src);
        tok = new WordDelimiterFilter(tok,
                WordDelimiterFilter.GENERATE_WORD_PARTS
                        | WordDelimiterFilter.STEM_ENGLISH_POSSESSIVE
                        | WordDelimiterFilter.GENERATE_NUMBER_PARTS, null);

        return new TokenStreamComponents(src, tok);
    }","@Override
    protected TokenStreamComponents createComponents(final String fieldName,
            final Reader reader) {
        ClassicTokenizer src = new ClassicTokenizer(matchVersion, reader);
        TokenStream tok = new LowerCaseFilter(matchVersion, src);
        tok = new WordDelimiterFilter(tok,
                WordDelimiterFilter.GENERATE_WORD_PARTS
                        | WordDelimiterFilter.STEM_ENGLISH_POSSESSIVE
                        | WordDelimiterFilter.GENERATE_NUMBER_PARTS, null);
        return new TokenStreamComponents(src, tok);
    }",1,[3]
16,bugs-dot-jar_OAK-1822_3e83a4c1,"@Nonnull
    public Map<Revision, String> getValueMap(@Nonnull String key) {
        if (IGNORE_ON_SPLIT.contains(key)) {
            return Collections.emptyMap();
        } else {
            return ValueMap.create(this, key);
        }
    }","@Nonnull
    public Map<Revision, String> getValueMap(@Nonnull String key) {
        if (IGNORE_ON_SPLIT.contains(key)) {
            return Collections.emptyMap();
        } else {
            return ValueMap.create(this, key);
        }
    }",0,[0]
9468,bugs-dot-jar_WICKET-5319_c863b032,"protected final IRequestMapper getWrappedMapper()
	{
		return wrappedMapper;
	}","protected final IRequestMapper getWrappedMapper()
	{
		return wrappedMapper;
	}",0,[0]
16676,bugs-dot-jar_WICKET-5689_2ac29d30,"private void bindSessionIfNeeded()
	{
		// check for session feedback messages only
		FeedbackCollector collector = new FeedbackCollector();
		List<FeedbackMessage> feedbackMessages = collector.collect();
		if (feedbackMessages.size() > 0)
		{
			Session.get().bind();
		}
	}","private void bindSessionIfNeeded()
	{
		// check for session feedback messages only
		FeedbackCollector collector = new FeedbackCollector();
		List<FeedbackMessage> feedbackMessages = collector.collect();
		if (feedbackMessages.size() > 0)
		{
			Session.get().bind();
		}
	}",0,[0]
6318,bugs-dot-jar_WICKET-2261_089303f4,"public ServletContext newServletContext(final String path)
	{
		return new MockServletContext(application, path);
	}","public ServletContext newServletContext(final String path)
	{
		return new MockServletContext(application, path);
	}",0,[0]
20470,bugs-dot-jar_WICKET-128_7e1000dd,"protected final void removeAttribute(String name)
	{
		RequestCycle cycle = RequestCycle.get();
		if (cycle != null)
		{
			getSessionStore().removeAttribute(cycle.getRequest(), name);
		}
	}","protected final void removeAttribute(String name)
	{
		RequestCycle cycle = RequestCycle.get();
		if (cycle != null)
		{
			getSessionStore().removeAttribute(cycle.getRequest(), name);
		}
	}",0,[0]
23982,bugs-dot-jar_OAK-579_7d72e6ed,"void prepare() {
        if (prepared) {
            return;
        }
        prepared = true;
        source.prepare();
    }","void prepare() {
        if (prepared) {
            return;
        }
        prepared = true;
        source.prepare();
    }",0,[0]
17217,bugs-dot-jar_MNG-1895_24db0eb9,"private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,
                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,
                          ArtifactFilter filter, List listeners )
        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException
    {
        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );

        // TODO: use as a conflict resolver
        Object key = node.getKey();
        if ( managedVersions.containsKey( key ) )
        {
            Artifact artifact = (Artifact) managedVersions.get( key );

            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );

            if ( artifact.getVersion() != null )
            {
                node.getArtifact().setVersion( artifact.getVersion() );
            }
            if ( artifact.getScope() != null )
            {
                node.getArtifact().setScope( artifact.getScope() );
            }
        }

        List previousNodes = (List) resolvedArtifacts.get( key );
        if ( previousNodes != null )
        {
            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )
            {
                ResolutionNode previous = (ResolutionNode) i.next();

                if ( previous.isActive() )
                {
                    // Version mediation
                    VersionRange previousRange = previous.getArtifact().getVersionRange();
                    VersionRange currentRange = node.getArtifact().getVersionRange();

                    // TODO: why do we force the version on it? what if they don't match?
                    if ( previousRange == null )
                    {
                        // version was already resolved
                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );
                    }
                    else if ( currentRange == null )
                    {
                        // version was already resolved
                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );
                    }
                    else
                    {
                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended
                        // version but the restriction is identical
                        VersionRange newRange = previousRange.restrict( currentRange );
                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct
                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )
                        {
                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),
                                       newRange );
                        }
                        previous.getArtifact().setVersionRange( newRange );
                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );

                        //Select an appropriate available version from the (now restricted) range
                        //Note this version was selected before to get the appropriate POM
                        //But it was reset by the call to setVersionRange on restricting the version
                        ResolutionNode[] resetNodes = {previous, node};
                        for ( int j = 0; j < 2; j++ )
                        {
                            Artifact resetArtifact = resetNodes[j].getArtifact();
                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&
                                resetArtifact.getAvailableVersions() != null )
                            {

                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(
                                    resetArtifact.getAvailableVersions() ).toString() );
                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );
                            }
                        }
                    }

                    // Conflict Resolution
                    // TODO: use as conflict resolver(s), chain

                    // TODO: should this be part of mediation?
                    // previous one is more dominant
                    ResolutionNode nearest, farthest;
                    if ( previous.getDepth() <= node.getDepth() )
                    {
                        nearest = previous;
                        farthest = node;
                    }
                    else
                    {
                        nearest = node;
                        farthest = previous;
                    }

                    /* if we need to update scope of nearest to use farthest scope */
                    if ( checkScopeUpdate( farthest, nearest, listeners ) )
                    {
                        fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );

                        // previously we cloned the artifact, but it is more effecient to just update the scope
                        // if problems are later discovered that the original object needs its original scope value, cloning may
                        // again be appropriate
                        nearest.getArtifact().setScope( farthest.getArtifact().getScope() );
                    }
                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );
                    farthest.disable();
                }
            }
        }
        else
        {
            previousNodes = new ArrayList();
            resolvedArtifacts.put( key, previousNodes );
        }
        previousNodes.add( node );

        if ( node.isActive() )
        {
            fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );
        }

        // don't pull in the transitive deps of a system-scoped dependency.
        if ( node.isActive() && !Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) )
        {
            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );

            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )
            {
                ResolutionNode child = (ResolutionNode) i.next();
                // We leave in optional ones, but don't pick up its dependencies
                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )
                {
                    Artifact artifact = child.getArtifact();
                    try
                    {
                        if ( artifact.getVersion() == null )
                        {
                            // set the recommended version
                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?
                            ArtifactVersion version;
                            if ( !artifact.isSelectedVersionKnown() )
                            {
                                List versions = artifact.getAvailableVersions();
                                if ( versions == null )
                                {
                                    versions = source.retrieveAvailableVersions( artifact, localRepository,
                                                                                 remoteRepositories );
                                    artifact.setAvailableVersions( versions );
                                }

                                VersionRange versionRange = artifact.getVersionRange();

                                version = versionRange.matchVersion( versions );

                                if ( version == null )
                                {
                                    if ( versions.isEmpty() )
                                    {
                                        throw new OverConstrainedVersionException(
                                            ""No versions are present in the repository for the artifact with a range "" +
                                                versionRange, artifact, remoteRepositories );
                                    }
                                    else
                                    {
                                        throw new OverConstrainedVersionException( ""Couldn't find a version in "" +
                                            versions + "" to match range "" + versionRange, artifact,
                                                                                          remoteRepositories );
                                    }
                                }
                            }
                            else
                            {
                                version = artifact.getSelectedVersion();
                            }

                            artifact.selectVersion( version.toString() );
                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );
                        }

                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );

                        //TODO might be better to have source.retreive() throw a specific exception for this situation
                        //and catch here rather than have it return null
                        if ( rGroup == null )
                        {
                            //relocated dependency artifact is declared excluded, no need to add and recurse further
                            continue;
                        }

                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );
                    }
                    catch ( CyclicDependencyException e )
                    {
                        // would like to throw this, but we have crappy stuff in the repo

                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,
                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );
                    }
                    catch ( ArtifactMetadataRetrievalException e )
                    {
                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        throw new ArtifactResolutionException(
                            ""Unable to get dependency information: "" + e.getMessage(), artifact, remoteRepositories,
                            e );
                    }

                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,
                             filter, listeners );
                }
            }

            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );
        }
    }","private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVersions,
                          ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,
                          ArtifactFilter filter, List listeners )
        throws CyclicDependencyException, ArtifactResolutionException, OverConstrainedVersionException
    {
        fireEvent( ResolutionListener.TEST_ARTIFACT, listeners, node );

        // TODO: use as a conflict resolver
        Object key = node.getKey();
        if ( managedVersions.containsKey( key ) )
        {
            Artifact artifact = (Artifact) managedVersions.get( key );

            fireEvent( ResolutionListener.MANAGE_ARTIFACT, listeners, node, artifact );

            if ( artifact.getVersion() != null )
            {
                node.getArtifact().setVersion( artifact.getVersion() );
            }
            if ( artifact.getScope() != null )
            {
                node.getArtifact().setScope( artifact.getScope() );
            }
        }

        List previousNodes = (List) resolvedArtifacts.get( key );
        if ( previousNodes != null )
        {
            for ( Iterator i = previousNodes.iterator(); i.hasNext(); )
            {
                ResolutionNode previous = (ResolutionNode) i.next();

                if ( previous.isActive() )
                {
                    // Version mediation
                    VersionRange previousRange = previous.getArtifact().getVersionRange();
                    VersionRange currentRange = node.getArtifact().getVersionRange();

                    // TODO: why do we force the version on it? what if they don't match?
                    if ( previousRange == null )
                    {
                        // version was already resolved
                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );
                    }
                    else if ( currentRange == null )
                    {
                        // version was already resolved
                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );
                    }
                    else
                    {
                        // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended
                        // version but the restriction is identical
                        VersionRange newRange = previousRange.restrict( currentRange );
                        // TODO: ick. this forces the OCE that should have come from the previous call. It is still correct
                        if ( newRange.isSelectedVersionKnown( previous.getArtifact() ) )
                        {
                            fireEvent( ResolutionListener.RESTRICT_RANGE, listeners, node, previous.getArtifact(),
                                       newRange );
                        }
                        previous.getArtifact().setVersionRange( newRange );
                        node.getArtifact().setVersionRange( currentRange.restrict( previousRange ) );

                        //Select an appropriate available version from the (now restricted) range
                        //Note this version was selected before to get the appropriate POM
                        //But it was reset by the call to setVersionRange on restricting the version
                        ResolutionNode[] resetNodes = {previous, node};
                        for ( int j = 0; j < 2; j++ )
                        {
                            Artifact resetArtifact = resetNodes[j].getArtifact();
                            if ( resetArtifact.getVersion() == null && resetArtifact.getVersionRange() != null &&
                                resetArtifact.getAvailableVersions() != null )
                            {

                                resetArtifact.selectVersion( resetArtifact.getVersionRange().matchVersion(
                                    resetArtifact.getAvailableVersions() ).toString() );
                                fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, resetNodes[j] );
                            }
                        }
                    }

                    // Conflict Resolution
                    // TODO: use as conflict resolver(s), chain

                    // TODO: should this be part of mediation?
                    // previous one is more dominant
                    ResolutionNode nearest, farthest;
                    if ( previous.getDepth() <= node.getDepth() )
                    {
                        nearest = previous;
                        farthest = node;
                    }
                    else
                    {
                        nearest = node;
                        farthest = previous;
                    }

                    /* if we need to update scope of nearest to use farthest scope */
                    if ( checkScopeUpdate( farthest, nearest, listeners ) )
                    {
                        fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );
                        /* we need nearest version but farthest scope */
                        nearest.disable();
                        farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );
                    }
                    else
                    {
                        farthest.disable();
                    }
                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );
                }
            }
        }
        else
        {
            previousNodes = new ArrayList();
            resolvedArtifacts.put( key, previousNodes );
        }
        previousNodes.add( node );

        if ( node.isActive() )
        {
            fireEvent( ResolutionListener.INCLUDE_ARTIFACT, listeners, node );
        }

        // don't pull in the transitive deps of a system-scoped dependency.
        if ( node.isActive() && !Artifact.SCOPE_SYSTEM.equals( node.getArtifact().getScope() ) )
        {
            fireEvent( ResolutionListener.PROCESS_CHILDREN, listeners, node );

            for ( Iterator i = node.getChildrenIterator(); i.hasNext(); )
            {
                ResolutionNode child = (ResolutionNode) i.next();
                // We leave in optional ones, but don't pick up its dependencies
                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )
                {
                    Artifact artifact = child.getArtifact();
                    try
                    {
                        if ( artifact.getVersion() == null )
                        {
                            // set the recommended version
                            // TODO: maybe its better to just pass the range through to retrieval and use a transformation?
                            ArtifactVersion version;
                            if ( !artifact.isSelectedVersionKnown() )
                            {
                                List versions = artifact.getAvailableVersions();
                                if ( versions == null )
                                {
                                    versions = source.retrieveAvailableVersions( artifact, localRepository,
                                                                                 remoteRepositories );
                                    artifact.setAvailableVersions( versions );
                                }

                                VersionRange versionRange = artifact.getVersionRange();

                                version = versionRange.matchVersion( versions );

                                if ( version == null )
                                {
                                    if ( versions.isEmpty() )
                                    {
                                        throw new OverConstrainedVersionException(
                                            ""No versions are present in the repository for the artifact with a range "" +
                                                versionRange, artifact, remoteRepositories );
                                    }
                                    else
                                    {
                                        throw new OverConstrainedVersionException( ""Couldn't find a version in "" +
                                            versions + "" to match range "" + versionRange, artifact,
                                                                                          remoteRepositories );
                                    }
                                }
                            }
                            else
                            {
                                version = artifact.getSelectedVersion();
                            }

                            artifact.selectVersion( version.toString() );
                            fireEvent( ResolutionListener.SELECT_VERSION_FROM_RANGE, listeners, child );
                        }

                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        ResolutionGroup rGroup = source.retrieve( artifact, localRepository, remoteRepositories );

                        //TODO might be better to have source.retreive() throw a specific exception for this situation
                        //and catch here rather than have it return null
                        if ( rGroup == null )
                        {
                            //relocated dependency artifact is declared excluded, no need to add and recurse further
                            continue;
                        }

                        child.addDependencies( rGroup.getArtifacts(), rGroup.getResolutionRepositories(), filter );
                    }
                    catch ( CyclicDependencyException e )
                    {
                        // would like to throw this, but we have crappy stuff in the repo

                        fireEvent( ResolutionListener.OMIT_FOR_CYCLE, listeners,
                                   new ResolutionNode( e.getArtifact(), remoteRepositories, child ) );
                    }
                    catch ( ArtifactMetadataRetrievalException e )
                    {
                        artifact.setDependencyTrail( node.getDependencyTrail() );
                        throw new ArtifactResolutionException(
                            ""Unable to get dependency information: "" + e.getMessage(), artifact, remoteRepositories,
                            e );
                    }

                    recurse( child, resolvedArtifacts, managedVersions, localRepository, remoteRepositories, source,
                             filter, listeners );
                }
            }

            fireEvent( ResolutionListener.FINISH_PROCESSING_CHILDREN, listeners, node );
        }
    }",1,"[103, 104, 105, 106, 109]"
1455,bugs-dot-jar_OAK-185_7fe28a0e,"@Override
    public boolean isNodeType(String nodeTypeName) throws RepositoryException {
        checkStatus();

        // TODO: might be expanded, need a better way for this
        NameMapper mapper = sessionDelegate.getNamePathMapper();
        String oakName = mapper.getOakName(nodeTypeName);
        if (oakName == null) {
            return false; // An unknown name can't belong to a valid type
        }
        String jcrName = mapper.getJcrName(oakName);

        // TODO: figure out the right place for this check
        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
        NodeType ntToCheck = ntm.getNodeType(jcrName); // throws on not found
        String nameToCheck = ntToCheck.getName();

        NodeType currentPrimaryType = getPrimaryNodeType();
        if (currentPrimaryType.isNodeType(nameToCheck)) {
            return true;
        }

        for (NodeType mixin : getMixinNodeTypes()) {
            if (mixin.isNodeType(nameToCheck)) {
                return true;
            }
        }
        // TODO: END

        return false;
    }","@Override
    public boolean isNodeType(String nodeTypeName) throws RepositoryException {
        checkStatus();

        // TODO: might be expanded, need a better way for this
        NameMapper mapper = sessionDelegate.getNamePathMapper();
        String oakName = mapper.getOakName(nodeTypeName);
        if (oakName == null) {
            return false; // An unknown name can't belong to a valid type
        }
        String jcrName = mapper.getJcrName(oakName);

        // TODO: figure out the right place for this check
        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
        NodeType ntToCheck = ntm.getNodeType(jcrName); // throws on not found
        String nameToCheck = ntToCheck.getName();

        NodeType currentPrimaryType = getPrimaryNodeType();
        if (currentPrimaryType.isNodeType(nameToCheck)) {
            return true;
        }

        for (NodeType mixin : getMixinNodeTypes()) {
            if (mixin.isNodeType(nameToCheck)) {
                return true;
            }
        }
        // TODO: END

        return false;
    }",0,[0]
2324,bugs-dot-jar_MNG-4918_691a03a7,"public List<String> getFilters()
    {
        return getBuild().getFilters();
    }","public List<String> getFilters()
    {
        return getBuild().getFilters();
    }",0,[0]
31797,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"public Mutation(TMutation tmutation) {
    this.row = ByteBufferUtil.toBytes(tmutation.row);
    this.data = ByteBufferUtil.toBytes(tmutation.data);
    this.entries = tmutation.entries;
    this.values = ByteBufferUtil.toBytesList(tmutation.values);

    if (this.row == null) {
      throw new IllegalArgumentException(""null row"");
    }
    if (this.data == null) {
      throw new IllegalArgumentException(""null serialized data"");
    }
  }","public Mutation(TMutation tmutation) {
    this.row = ByteBufferUtil.toBytes(tmutation.row);
    this.data = ByteBufferUtil.toBytes(tmutation.data);
    this.entries = tmutation.entries;
    this.values = ByteBufferUtil.toBytesList(tmutation.values);

    if (this.row == null) {
      throw new IllegalArgumentException(""null row"");
    }
    if (this.data == null) {
      throw new IllegalArgumentException(""null serialized data"");
    }
  }",0,[0]
1489,bugs-dot-jar_OAK-185_7fe28a0e,"private static int getTargetType(Value[] values, int type) {
        if (values == null || values.length == 0) {
            return PropertyType.STRING; // TODO: review again. rather use property definition
        } else {
            // TODO deal with values array containing a null value in the first position
            return getTargetType(values[0], type);
        }
    }","private static int getTargetType(Value[] values, int type) {
        if (values == null || values.length == 0) {
            return PropertyType.STRING; // TODO: review again. rather use property definition
        } else {
            // TODO deal with values array containing a null value in the first position
            return getTargetType(values[0], type);
        }
    }",0,[0]
4818,bugs-dot-jar_MATH-326_ce185345,"public OpenMapRealVector(OpenMapRealVector v) {
        virtualSize = v.getDimension();
        entries = new OpenIntToDoubleHashMap(v.getEntries());
        epsilon = v.epsilon;
    }","public OpenMapRealVector(OpenMapRealVector v) {
        virtualSize = v.getDimension();
        entries = new OpenIntToDoubleHashMap(v.getEntries());
        epsilon = v.epsilon;
    }",0,[0]
20839,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Deprecated
    public static String toString(File file) throws IOException {
        return toString(file, null);
    }","@Deprecated
    public static String toString(File file) throws IOException {
        return toString(file, null);
    }",0,[0]
31771,bugs-dot-jar_FLINK-1167_259f10c0,"@Override
	public String getName() {
		return ""Workset Iteration"";
	}","@Override
	public String getName() {
		return ""Workset Iteration"";
	}",0,[0]
22626,bugs-dot-jar_OAK-47_b62f1c26,"public String waitForCommit(String oldHeadRevision, long maxWaitMillis) throws InterruptedException {
        return gate.waitForCommit(oldHeadRevision, maxWaitMillis);
    }","public String waitForCommit(String oldHeadRevision, long maxWaitMillis) throws InterruptedException {
        return gate.waitForCommit(oldHeadRevision, maxWaitMillis);
    }",0,[0]
23766,bugs-dot-jar_LOG4J2-742_4b77622b,"private static void enableXInclude(final DocumentBuilderFactory factory) {
        try {
            // Alternative: We set if a system property on the command line is set, for example:
            // -DLog4j.XInclude=true
            factory.setXIncludeAware(true);
        } catch (final UnsupportedOperationException e) {
            LOGGER.warn(""The DocumentBuilderFactory does not support XInclude: {}"", factory, e);
        } catch (@SuppressWarnings(""ErrorNotRethrown"") final AbstractMethodError err) {
            LOGGER.warn(""The DocumentBuilderFactory is out of date and does not support XInclude: {}"", factory, err);
        }
        try {
            // Alternative: We could specify all features and values with system properties like:
            // -DLog4j.DocumentBuilderFactory.Feature=""http://apache.org/xml/features/xinclude/fixup-base-uris true""
            factory.setFeature(XINCLUDE_FIXUP_BASE_URIS, true);
        } catch (final ParserConfigurationException e) {
            LOGGER.warn(""The DocumentBuilderFactory [{}] does not support the feature [{}]."", factory,
                    XINCLUDE_FIXUP_BASE_URIS, e);
        } catch (@SuppressWarnings(""ErrorNotRethrown"") final AbstractMethodError err) {
            LOGGER.warn(""The DocumentBuilderFactory is out of date and does not support setFeature: {}"", factory, err);
        }
        try {
            factory.setFeature(XINCLUDE_FIXUP_LANGUAGE, true);
        } catch (final ParserConfigurationException e) {
            LOGGER.warn(""The DocumentBuilderFactory [{}] does not support the feature [{}]."", factory,
                    XINCLUDE_FIXUP_LANGUAGE, e);
        } catch (@SuppressWarnings(""ErrorNotRethrown"") final AbstractMethodError err) {
            LOGGER.warn(""The DocumentBuilderFactory is out of date and does not support setFeature: {}"", factory, err);
        }
    }","private static void enableXInclude(final DocumentBuilderFactory factory) {
        try {
            // Alternative: We set if a system property on the command line is set, for example:
            // -DLog4j.XInclude=true
            factory.setXIncludeAware(true);
        } catch (final UnsupportedOperationException e) {
            LOGGER.warn(""The DocumentBuilderFactory does not support XInclude: {}"", factory, e);
        } catch (@SuppressWarnings(""ErrorNotRethrown"") final AbstractMethodError err) {
            LOGGER.warn(""The DocumentBuilderFactory is out of date and does not support XInclude: {}"", factory, err);
        }
        try {
            // Alternative: We could specify all features and values with system properties like:
            // -DLog4j.DocumentBuilderFactory.Feature=""http://apache.org/xml/features/xinclude/fixup-base-uris true""
            factory.setFeature(XINCLUDE_FIXUP_BASE_URIS, true);
        } catch (final ParserConfigurationException e) {
            LOGGER.warn(""The DocumentBuilderFactory [{}] does not support the feature [{}]."", factory,
                    XINCLUDE_FIXUP_BASE_URIS, e);
        } catch (@SuppressWarnings(""ErrorNotRethrown"") final AbstractMethodError err) {
            LOGGER.warn(""The DocumentBuilderFactory is out of date and does not support setFeature: {}"", factory, err);
        }
        try {
            factory.setFeature(XINCLUDE_FIXUP_LANGUAGE, true);
        } catch (final ParserConfigurationException e) {
            LOGGER.warn(""The DocumentBuilderFactory [{}] does not support the feature [{}]."", factory,
                    XINCLUDE_FIXUP_LANGUAGE, e);
        } catch (@SuppressWarnings(""ErrorNotRethrown"") final AbstractMethodError err) {
            LOGGER.warn(""The DocumentBuilderFactory is out of date and does not support setFeature: {}"", factory, err);
        }
    }",0,[0]
15215,bugs-dot-jar_WICKET-4070_d450acb0,"public final void clearInput()
	{
		// Visit all the (visible) form components and clear the input on each.
		visitFormComponentsPostOrder(new IVisitor<FormComponent<?>, Void>()
		{
			public void component(final FormComponent<?> formComponent, IVisit<Void> visit)
			{
				if (formComponent.isVisibleInHierarchy())
				{
					// Clear input from form component
					formComponent.clearInput();
				}
			}

		});
	}","public final void clearInput()
	{
		// Visit all the (visible) form components and clear the input on each.
		visitFormComponentsPostOrder(new IVisitor<FormComponent<?>, Void>()
		{
			public void component(final FormComponent<?> formComponent, IVisit<Void> visit)
			{
				if (formComponent.isVisibleInHierarchy())
				{
					// Clear input from form component
					formComponent.clearInput();
				}
			}

		});
	}",0,[0]
252,bugs-dot-jar_OAK-2250_08b25cb0,"public boolean isStored(String name) {
        return storageEnabled;
    }","public boolean isStored(String name) {
        return storageEnabled;
    }",0,[0]
26421,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    public int getType() throws RepositoryException {
        return perform(new PropertyOperation<Integer>(dlg, ""getType"") {
            @Nonnull
            @Override
            public Integer perform() throws RepositoryException {
                return property.getPropertyState().getType().tag();
            }
        });
    }","@Override
    public int getType() throws RepositoryException {
        return perform(new PropertyOperation<Integer>(dlg, ""getType"") {
            @Nonnull
            @Override
            public Integer perform() throws RepositoryException {
                return property.getPropertyState().getType().tag();
            }
        });
    }",0,[0]
27346,bugs-dot-jar_OAK-1024_2b5d3afb,"@Override
    public boolean accept(FullTextVisitor v) {
        return v.visit(this);
    }","@Override
    public boolean accept(FullTextVisitor v) {
        return v.visit(this);
    }",0,[0]
1074,Bears-141,"public User(String firstName, String middleName, String lastName, String email, String password, String type) {
        this.firstName = firstName;
        this.middleName = middleName;
        this.lastName = lastName;
        this.email = email;
        this.type = type;
        setPassword(password);
    }","public User(String firstName, String middleName, String lastName, String email, String password, String type) {
        this.firstName = firstName;
        this.middleName = middleName;
        this.lastName = lastName;
        setEmail(email);
        this.type = type;
        setPassword(password);
    }",1,[4]
30129,bugs-dot-jar_ACCUMULO-1986_a5e3ed3b,"public String toStringNoTime() {
    return rowColumnStringBuilder().toString();
  }","public String toStringNoTime() {
    return rowColumnStringBuilder().toString();
  }",0,[0]
27964,bugs-dot-jar_CAMEL-8053_cac72b14,"protected synchronized void suspendRouteService(RouteService routeService) throws Exception {
        routeService.setRemovingRoutes(false);
        routeService.suspend();
        for (Route route : routeService.getRoutes()) {
            logRouteState(route, ""suspended"");
        }
    }","protected synchronized void suspendRouteService(RouteService routeService) throws Exception {
        routeService.setRemovingRoutes(false);
        routeService.suspend();
        for (Route route : routeService.getRoutes()) {
            logRouteState(route, ""suspended"");
        }
    }",0,[0]
33551,bugs-dot-jar_WICKET-4520_b91154ea,"public final void setSessionStoreProvider(final IProvider<ISessionStore> sessionStoreProvider)
	{
		this.sessionStoreProvider = sessionStoreProvider;
	}","public final void setSessionStoreProvider(final IProvider<ISessionStore> sessionStoreProvider)
	{
		this.sessionStoreProvider = sessionStoreProvider;
	}",0,[0]
12035,bugs-dot-jar_OAK-1793_16225d51,"VersionGarbageCollector(DocumentNodeStore nodeStore) {
        this.nodeStore = nodeStore;

        if(nodeStore.getDocumentStore() instanceof MongoDocumentStore){
            this.versionStore =
                    new MongoVersionGCSupport((MongoDocumentStore) nodeStore.getDocumentStore());
        }else {
            this.versionStore = new VersionGCSupport(nodeStore.getDocumentStore());
        }
    }","VersionGarbageCollector(DocumentNodeStore nodeStore) {
        this.nodeStore = nodeStore;

        if(nodeStore.getDocumentStore() instanceof MongoDocumentStore){
            this.versionStore =
                    new MongoVersionGCSupport((MongoDocumentStore) nodeStore.getDocumentStore());
        }else {
            this.versionStore = new VersionGCSupport(nodeStore.getDocumentStore());
        }
    }",0,[0]
2714,bugs-dot-jar_OAK-1932_913c2f53,"private synchronized RecordId writeValueRecord(
            long length, RecordId blocks) {
        RecordId valueId = prepare(
                RecordType.VALUE, 8, Collections.singleton(blocks));
        writeLong((length - Segment.MEDIUM_LIMIT) | (0x3L << 62));
        writeRecordId(blocks);
        return valueId;
    }","private synchronized RecordId writeValueRecord(
            long length, RecordId blocks) {
        RecordId valueId = prepare(
                RecordType.VALUE, 8, Collections.singleton(blocks));
        writeLong((length - Segment.MEDIUM_LIMIT) | (0x3L << 62));
        writeRecordId(blocks);
        return valueId;
    }",0,[0]
7378,bugs-dot-jar_MATH-657_97b440fc,"public Complex tanh() {
        if (isNaN) {
            return NaN;
        }

        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);

        return createComplex(MathUtils.sinh(real2) / d,
                             FastMath.sin(imaginary2) / d);
    }","public Complex tanh() {
        if (isNaN) {
            return NaN;
        }

        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);

        return createComplex(MathUtils.sinh(real2) / d,
                             FastMath.sin(imaginary2) / d);
    }",0,[0]
38899,bugs-dot-jar_OAK-4358_74cbba24,"public static String unshareString(String x) {
        return new String(x);
    }","public static String unshareString(String x) {
        return new String(x);
    }",0,[0]
1266,bugs-dot-jar_WICKET-5546_f1af9e03,"public final boolean isEnabledInHierarchy()
	{
		if (getRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_SET))
		{
			return getRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_VALUE);
		}

		final boolean state;
		Component parent = getParent();
		if (parent != null && !parent.isEnabledInHierarchy())
		{
			state = false;
		}
		else
		{
			state = isEnabled() && isEnableAllowed();
		}

		setRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_SET, true);
		setRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_VALUE, state);
		return state;
	}","public final boolean isEnabledInHierarchy()
	{
		if (getRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_SET))
		{
			return getRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_VALUE);
		}

		final boolean state;
		Component parent = getParent();
		if (parent != null && !parent.isEnabledInHierarchy())
		{
			state = false;
		}
		else
		{
			state = isEnabled() && isEnableAllowed();
		}

		setRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_SET, true);
		setRequestFlag(RFLAG_ENABLED_IN_HIERARCHY_VALUE, state);
		return state;
	}",0,[0]
836,bugs-dot-jar_WICKET-5964_86066852,"public Enclosure(final String id, final String childId)
	{
		super(id);

		if (childId == null)
		{
			throw new MarkupException(
				""You most likely forgot to register the EnclosureHandler with the MarkupParserFactory"");
		}

		this.childId = childId;
	}","public Enclosure(final String id, final String childId)
	{
		super(id);

		if (childId == null)
		{
			throw new MarkupException(
				""You most likely forgot to register the EnclosureHandler with the MarkupParserFactory"");
		}

		this.childId = childId;
	}",0,[0]
14204,bugs-dot-jar_LOG4J2-392_731c84b5,"public void setName(final String name) {
        this.name = name;
    }","public void setName(final String name) {
        this.name = name;
    }",0,[0]
6891,bugs-dot-jar_OAK-2062_5c4589bd,"public PropertyValue currentProperty(String propertyName) {
        String pn = normalizePropertyName(propertyName);
        return currentOakProperty(pn);
    }","public PropertyValue currentProperty(String propertyName) {
        String pn = normalizePropertyName(propertyName);
        return currentOakProperty(pn);
    }",0,[0]
24181,bugs-dot-jar_OAK-1719_c3773d53,"private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)
            throws NamespaceException {
        builder.setProperty(JCR_PRIMARYTYPE, NT_NODETYPE, NAME);

        // - jcr:nodeTypeName (NAME) protected mandatory
        builder.setProperty(JCR_NODETYPENAME, getOakName(def.getName()), NAME);
        // - jcr:supertypes (NAME) protected multiple
        Name[] supertypes = def.getSupertypes();
        if (supertypes != null && supertypes.length > 0) {
            List<String> names = newArrayListWithCapacity(supertypes.length);
            for (Name supertype : supertypes) {
                names.add(getOakName(supertype));
            }
            builder.setProperty(JCR_SUPERTYPES, names, NAMES);
        }
        // - jcr:isAbstract (BOOLEAN) protected mandatory
        builder.setProperty(JCR_IS_ABSTRACT, def.isAbstract());
        // - jcr:isQueryable (BOOLEAN) protected mandatory
        builder.setProperty(JCR_IS_QUERYABLE, def.isQueryable());
        // - jcr:isMixin (BOOLEAN) protected mandatory
        builder.setProperty(JCR_ISMIXIN, def.isMixin());
        // - jcr:hasOrderableChildNodes (BOOLEAN) protected mandatory
        builder.setProperty(
                JCR_HASORDERABLECHILDNODES, def.hasOrderableChildNodes());
        // - jcr:primaryItemName (NAME) protected
        Name primary = def.getPrimaryItemName();
        if (primary != null) {
            builder.setProperty(
                    JCR_PRIMARYITEMNAME, getOakName(primary), NAME);
        }

        // + jcr:propertyDefinition (nt:propertyDefinition) = nt:propertyDefinition protected sns
        QPropertyDefinition[] properties = def.getPropertyDefs();
        for (int i = 0; i < properties.length; i++) {
            String name = JCR_PROPERTYDEFINITION + '[' + (i + 1) + ']';
            copyPropertyDefinition(properties[i], builder.child(name));
        }

        // + jcr:childNodeDefinition (nt:childNodeDefinition) = nt:childNodeDefinition protected sns
        QNodeDefinition[] childNodes = def.getChildNodeDefs();
        for (int i = 0; i < childNodes.length; i++) {
            String name = JCR_CHILDNODEDEFINITION + '[' + (i + 1) + ']';
            copyChildNodeDefinition(childNodes[i], builder.child(name));
        }
    }","private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)
            throws NamespaceException {
        builder.setProperty(JCR_PRIMARYTYPE, NT_NODETYPE, NAME);

        // - jcr:nodeTypeName (NAME) protected mandatory
        builder.setProperty(JCR_NODETYPENAME, getOakName(def.getName()), NAME);
        // - jcr:supertypes (NAME) protected multiple
        Name[] supertypes = def.getSupertypes();
        if (supertypes != null && supertypes.length > 0) {
            List<String> names = newArrayListWithCapacity(supertypes.length);
            for (Name supertype : supertypes) {
                names.add(getOakName(supertype));
            }
            builder.setProperty(JCR_SUPERTYPES, names, NAMES);
        }
        // - jcr:isAbstract (BOOLEAN) protected mandatory
        builder.setProperty(JCR_IS_ABSTRACT, def.isAbstract());
        // - jcr:isQueryable (BOOLEAN) protected mandatory
        builder.setProperty(JCR_IS_QUERYABLE, def.isQueryable());
        // - jcr:isMixin (BOOLEAN) protected mandatory
        builder.setProperty(JCR_ISMIXIN, def.isMixin());
        // - jcr:hasOrderableChildNodes (BOOLEAN) protected mandatory
        builder.setProperty(
                JCR_HASORDERABLECHILDNODES, def.hasOrderableChildNodes());
        // - jcr:primaryItemName (NAME) protected
        Name primary = def.getPrimaryItemName();
        if (primary != null) {
            builder.setProperty(
                    JCR_PRIMARYITEMNAME, getOakName(primary), NAME);
        }

        // + jcr:propertyDefinition (nt:propertyDefinition) = nt:propertyDefinition protected sns
        QPropertyDefinition[] properties = def.getPropertyDefs();
        for (int i = 0; i < properties.length; i++) {
            String name = JCR_PROPERTYDEFINITION + '[' + (i + 1) + ']';
            copyPropertyDefinition(properties[i], builder.child(name));
        }

        // + jcr:childNodeDefinition (nt:childNodeDefinition) = nt:childNodeDefinition protected sns
        QNodeDefinition[] childNodes = def.getChildNodeDefs();
        for (int i = 0; i < childNodes.length; i++) {
            String name = JCR_CHILDNODEDEFINITION + '[' + (i + 1) + ']';
            copyChildNodeDefinition(childNodes[i], builder.child(name));
        }
    }",0,[0]
164,Bears-6,"@Override
    public AnnotatedMember getPrimaryMember() {
        if (_forSerialization) {
            return getAccessor();
        }
        return getMutator();
    }","@Override
    public AnnotatedMember getPrimaryMember() {
        if (_forSerialization) {
            return getAccessor();
        }
        return getMutator();
    }",0,[0]
23218,bugs-dot-jar_OAK-1020_83427028,"public void addMixin(String typeName) throws RepositoryException {
        TreeUtil.addMixin(getTree(), typeName, sessionDelegate.getRoot().getTree(NODE_TYPES_PATH), getUserID());
    }","public void addMixin(String typeName) throws RepositoryException {
        TreeUtil.addMixin(getTree(), typeName, sessionDelegate.getRoot().getTree(NODE_TYPES_PATH), getUserID());
    }",0,[0]
22551,bugs-dot-jar_FLINK-1820_39d526e6,"@Override
	public Double createValue() {
		return DOUBLE_INSTANCE;
	}","@Override
	public Double createValue() {
		return DOUBLE_INSTANCE;
	}",0,[0]
21951,bugs-dot-jar_MATH-370_495f04bc,"public static double round(double x, int scale, int roundingMethod) {
        try {
            return (new BigDecimal
                   (Double.toString(x))
                   .setScale(scale, roundingMethod))
                   .doubleValue();
        } catch (NumberFormatException ex) {
            if (Double.isInfinite(x)) {
                return x;
            } else {
                return Double.NaN;
            }
        }
    }","public static double round(double x, int scale, int roundingMethod) {
        try {
            return (new BigDecimal
                   (Double.toString(x))
                   .setScale(scale, roundingMethod))
                   .doubleValue();
        } catch (NumberFormatException ex) {
            if (Double.isInfinite(x)) {
                return x;
            } else {
                return Double.NaN;
            }
        }
    }",0,[0]
33554,bugs-dot-jar_WICKET-4520_b91154ea,"public final ICompoundRequestMapper getRootRequestMapperAsCompound()
	{
		IRequestMapper root = getRootRequestMapper();
		if (!(root instanceof ICompoundRequestMapper))
		{
			root = new CompoundRequestMapper().add(root);
			setRootRequestMapper(root);
		}
		return (ICompoundRequestMapper)root;
	}","public final ICompoundRequestMapper getRootRequestMapperAsCompound()
	{
		IRequestMapper root = getRootRequestMapper();
		if (!(root instanceof ICompoundRequestMapper))
		{
			root = new CompoundRequestMapper().add(root);
			setRootRequestMapper(root);
		}
		return (ICompoundRequestMapper)root;
	}",0,[0]
3154,bugs-dot-jar_MATH-631_c0b49542,"public RegulaFalsiSolver(final double relativeAccuracy,
                             final double absoluteAccuracy,
                             final double functionValueAccuracy) {
        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, Method.REGULA_FALSI);
    }","public RegulaFalsiSolver(final double relativeAccuracy,
                             final double absoluteAccuracy,
                             final double functionValueAccuracy) {
        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, Method.REGULA_FALSI);
    }",0,[0]
8722,bugs-dot-jar_WICKET-5883_cd3b9234,"private boolean anyFormComponentError()
	{
		// Check ALL children for error messages irrespective of FormComponents or not
		Boolean error = visitChildren(Component.class, new IVisitor<Component, Boolean>()
		{
			@Override
			public void component(final Component component, final IVisit<Boolean> visit)
			{
				if (component.hasErrorMessage())
				{
					visit.stop(true);
				}
			}
		});

		return (error != null) && error;
	}","private boolean anyFormComponentError()
	{
		// Check ALL children for error messages irrespective of FormComponents or not
		Boolean error = visitChildren(Component.class, new IVisitor<Component, Boolean>()
		{
			@Override
			public void component(final Component component, final IVisit<Boolean> visit)
			{
				if (component.isVisibleInHierarchy() && component.isEnabledInHierarchy() && component.hasErrorMessage())
				{
					visit.stop(true);
				}
			}
		});

		return (error != null) && error;
	}",1,[8]
837,bugs-dot-jar_WICKET-5964_86066852,"public final String getChildId()
	{
		return childId.toString();
	}","public final String getChildId()
	{
		return childId.toString();
	}",0,[0]
1593,bugs-dot-jar_WICKET-5345_3fc7234e,"public static Url parse(CharSequence _url, Charset charset, boolean isFullHint)
	{
		Args.notNull(_url, ""_url"");

		final Url result = new Url(charset);

		// the url object resolved the charset, use that
		charset = result.getCharset();

		String url = _url.toString();
		// extract query string part
		final String queryString;
		final String absoluteUrl;

		final int queryAt = url.indexOf('?');

		if (queryAt == -1)
		{
			queryString = """";
			absoluteUrl = url;
		}
		else
		{
			absoluteUrl = url.substring(0, queryAt);
			queryString = url.substring(queryAt + 1);
		}

		// get absolute / relative part of url
		String relativeUrl;

		final int idxOfFirstSlash = absoluteUrl.indexOf('/');
		final int protocolAt = absoluteUrl.indexOf(""://"");

		// full urls start either with a ""scheme://"" or with ""//""
		boolean protocolLess = absoluteUrl.startsWith(""//"");
		final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;

		if (isFull && isFullHint)
		{
			if (protocolLess == false)
			{
				result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
			}

			final String afterProto = absoluteUrl.substring(protocolAt + 3);
			final String hostAndPort;

			int relativeAt = afterProto.indexOf('/');
			if (relativeAt == -1)
			{
				relativeAt = afterProto.indexOf(';');
			}
			if (relativeAt == -1)
			{
				relativeUrl = """";
				hostAndPort = afterProto;
			}
			else
			{
				relativeUrl = afterProto.substring(relativeAt);
				hostAndPort = afterProto.substring(0, relativeAt);
			}

			final int credentialsAt = hostAndPort.lastIndexOf('@') + 1;
			final int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');

			if (portAt == -1)
			{
				result.host = hostAndPort;
				result.port = getDefaultPortForProtocol(result.protocol);
			}
			else
			{
				result.host = hostAndPort.substring(0, portAt + credentialsAt);
				result.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));
			}

			if (relativeAt < 0)
			{
				relativeUrl = ""/"";
			}
		}
		else
		{
			relativeUrl = absoluteUrl;
		}

		if (relativeUrl.length() > 0)
		{
			boolean removeLast = false;
			if (relativeUrl.endsWith(""/""))
			{
				// we need to append something and remove it after splitting
				// because otherwise the
				// trailing slashes will be lost
				relativeUrl += ""/x"";
				removeLast = true;
			}

			String segmentArray[] = Strings.split(relativeUrl, '/');

			if (removeLast)
			{
				segmentArray[segmentArray.length - 1] = null;
			}

			for (String s : segmentArray)
			{
				if (s != null)
				{
					result.segments.add(decodeSegment(s, charset));
				}
			}
		}

		if (queryString.length() > 0)
		{
			String queryArray[] = Strings.split(queryString, '&');
			for (String s : queryArray)
			{
				if (Strings.isEmpty(s) == false)
				{
					result.parameters.add(parseQueryParameter(s, charset));
				}
			}
		}

		return result;
	}","public static Url parse(CharSequence _url, Charset charset, boolean isFullHint)
	{
		Args.notNull(_url, ""_url"");

		final Url result = new Url(charset);

		// the url object resolved the charset, use that
		charset = result.getCharset();

		String url = _url.toString();
		// extract query string part
		final String queryString;
		final String absoluteUrl;

		final int queryAt = url.indexOf('?');

		if (queryAt == -1)
		{
			queryString = """";
			absoluteUrl = url;
		}
		else
		{
			absoluteUrl = url.substring(0, queryAt);
			queryString = url.substring(queryAt + 1);
		}

		// get absolute / relative part of url
		String relativeUrl;

		final int idxOfFirstSlash = absoluteUrl.indexOf('/');
		final int protocolAt = absoluteUrl.indexOf(""://"");

		// full urls start either with a ""scheme://"" or with ""//""
		boolean protocolLess = absoluteUrl.startsWith(""//"");
		final boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;

		if (isFull && isFullHint)
		{
			if (protocolLess == false)
			{
				result.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);
			}

			final String afterProto = absoluteUrl.substring(protocolAt + 3);
			final String hostAndPort;

			int relativeAt = afterProto.indexOf('/');
			if (relativeAt == -1)
			{
				relativeAt = afterProto.indexOf(';');
			}
			if (relativeAt == -1)
			{
				relativeUrl = """";
				hostAndPort = afterProto;
			}
			else
			{
				relativeUrl = afterProto.substring(relativeAt);
				hostAndPort = afterProto.substring(0, relativeAt);
			}

			final int credentialsAt = hostAndPort.lastIndexOf('@') + 1;
			final int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');

			if (portAt == -1)
			{
				result.host = hostAndPort;
				result.port = getDefaultPortForProtocol(result.protocol);
			}
			else
			{
				result.host = hostAndPort.substring(0, portAt + credentialsAt);
				result.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));
			}

			if (relativeAt < 0)
			{
				relativeUrl = ""/"";
			}
		}
		else
		{
			relativeUrl = absoluteUrl;
		}

		if (relativeUrl.length() > 0)
		{
			boolean removeLast = false;
			if (relativeUrl.endsWith(""/""))
			{
				// we need to append something and remove it after splitting
				// because otherwise the
				// trailing slashes will be lost
				relativeUrl += ""/x"";
				removeLast = true;
			}

			String segmentArray[] = Strings.split(relativeUrl, '/');

			if (removeLast)
			{
				segmentArray[segmentArray.length - 1] = null;
			}

			for (String s : segmentArray)
			{
				if (s != null)
				{
					result.segments.add(decodeSegment(s, charset));
				}
			}
		}

		if (queryString.length() > 0)
		{
			String queryArray[] = Strings.split(queryString, '&');
			for (String s : queryArray)
			{
				if (Strings.isEmpty(s) == false)
				{
					result.parameters.add(parseQueryParameter(s, charset));
				}
			}
		}

		return result;
	}",0,[0]
8014,bugs-dot-jar_ACCUMULO-3242_15e83709,"public static String putEphemeralSequential(ZooKeeperConnectionInfo info, String zPath, byte[] data) throws KeeperException, InterruptedException {
    final Retry retry = RETRY_FACTORY.create();
    while (true) {
      try {
        return getZooKeeper(info).create(zPath, data, ZooUtil.PUBLIC, CreateMode.EPHEMERAL_SEQUENTIAL);
      } catch (KeeperException e) {
        final Code c = e.code();
        if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {
          retryOrThrow(retry, e);
        } else {
          throw e;
        }
      }

      retry.waitForNextAttempt();
    }
  }","public static String putEphemeralSequential(ZooKeeperConnectionInfo info, String zPath, byte[] data) throws KeeperException, InterruptedException {
    final Retry retry = RETRY_FACTORY.create();
    while (true) {
      try {
        return getZooKeeper(info).create(zPath, data, ZooUtil.PUBLIC, CreateMode.EPHEMERAL_SEQUENTIAL);
      } catch (KeeperException e) {
        final Code c = e.code();
        if (c == Code.CONNECTIONLOSS || c == Code.OPERATIONTIMEOUT || c == Code.SESSIONEXPIRED) {
          retryOrThrow(retry, e);
        } else {
          throw e;
        }
      }

      retry.waitForNextAttempt();
    }
  }",0,[0]
13371,bugs-dot-jar_WICKET-4775_1ac05533,"@Override
	public PageParameters set(final String name, final Object value, final int index)
	{
		remove(name);

		if (value != null)
		{
			add(name, value, index);
		}
		return this;
	}","@Override
	public PageParameters set(final String name, final Object value, final int index)
	{
		remove(name);

		if (value != null)
		{
			add(name, value, index);
		}
		return this;
	}",0,[0]
1990,Bears-242,"@Override
  public void init() {
    pattern = Pattern.compile(format);
    subscribeTo(CxxGrammarImpl.functionDefinition);
  }","@Override
  public void init() {
    pattern = Pattern.compile(format);
    subscribeTo(CxxGrammarImpl.functionDefinition);
  }",0,[0]
38278,bugs-dot-jar_CAMEL-3314_4badd9c5,"public Type removeFaultHeader(String name) {
        return process(ProcessorBuilder.removeFaultHeader(name));
    }","public Type removeFaultHeader(String name) {
        return process(ProcessorBuilder.removeFaultHeader(name));
    }",0,[0]
7181,bugs-dot-jar_CAMEL-3545_050c542e,"public void setParameterType(Class parameterType) {
        this.parameterType = parameterType;
    }","public void setParameterType(Class parameterType) {
        this.parameterType = parameterType;
    }",0,[0]
7711,bugs-dot-jar_LOG4J2-310_3f1e0fdc,"protected void writeFooter(final Layout<?> layout, final OutputStream out) throws IOException {
        final byte[] footer = layout.getFooter();
        if (footer != null) {
            out.write(footer);
        }
    }","protected void writeFooter(final Layout<?> layout, final OutputStream out) throws IOException {
        final byte[] footer = layout.getFooter();
        if (footer != null) {
            out.write(footer);
        }
    }",0,[0]
6283,bugs-dot-jar_OAK-2439_beaca1a4,"public IndexPlanner(IndexNode indexNode,
                        String indexPath,
                        Filter filter, List<OrderEntry> sortOrder) {
        this.indexNode = indexNode;
        this.indexPath = indexPath;
        this.defn = indexNode.getDefinition();
        this.filter = filter;
        this.sortOrder = sortOrder;
    }","public IndexPlanner(IndexNode indexNode,
                        String indexPath,
                        Filter filter, List<OrderEntry> sortOrder) {
        this.indexNode = indexNode;
        this.indexPath = indexPath;
        this.defn = indexNode.getDefinition();
        this.filter = filter;
        this.sortOrder = sortOrder;
    }",0,[0]
32758,bugs-dot-jar_FLINK-1311_94c8e3fa,"public OptimizedPlan compile(Plan program) throws CompilerException {
		// -------------------- try to get the connection to the job manager ----------------------
		// --------------------------to obtain instance information --------------------------------
		final OptimizerPostPass postPasser = getPostPassFromPlan(program);
		return compile(program, postPasser);
	}","public OptimizedPlan compile(Plan program) throws CompilerException {
		// -------------------- try to get the connection to the job manager ----------------------
		// --------------------------to obtain instance information --------------------------------
		final OptimizerPostPass postPasser = getPostPassFromPlan(program);
		return compile(program, postPasser);
	}",0,[0]
26265,bugs-dot-jar_OAK-644_55a4f738,"@Nonnull
    @Override
    public RepositoryInitializer getRepositoryInitializer() {
        return new AccessControlInitializer();
    }","@Nonnull
    @Override
    public RepositoryInitializer getRepositoryInitializer() {
        return new AccessControlInitializer();
    }",0,[0]
26410,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    @Nonnull
    public Binary getBinary() throws RepositoryException {
        return getValue().getBinary();
    }","@Override
    @Nonnull
    public Binary getBinary() throws RepositoryException {
        return getValue().getBinary();
    }",0,[0]
34799,bugs-dot-jar_CAMEL-8964_ea8ee025,"public void setAsyncProcessorAwaitManager(AsyncProcessorAwaitManager asyncProcessorAwaitManager) {
        this.asyncProcessorAwaitManager = asyncProcessorAwaitManager;
    }","public void setAsyncProcessorAwaitManager(AsyncProcessorAwaitManager asyncProcessorAwaitManager) {
        this.asyncProcessorAwaitManager = asyncProcessorAwaitManager;
    }",0,[0]
35620,bugs-dot-jar_WICKET-16_6c5083b4,"public IRequestTargetUrlCodingStrategy[] listMounts()
	{
		return (IRequestTargetUrlCodingStrategy[])mountsOnPath.values().toArray(
				new IRequestTargetUrlCodingStrategy[mountsOnPath.size()]);
	}","public IRequestTargetUrlCodingStrategy[] listMounts()
	{
		return (IRequestTargetUrlCodingStrategy[])mountsOnPath.values().toArray(
				new IRequestTargetUrlCodingStrategy[mountsOnPath.size()]);
	}",0,[0]
21408,bugs-dot-jar_CAMEL-9672_84922699,"public Object getManagedObjectForEventNotifier(CamelContext context, EventNotifier eventNotifier) {
        ManagedEventNotifier men = new ManagedEventNotifier(context, eventNotifier);
        men.init(context.getManagementStrategy());
        return men;
    }","public Object getManagedObjectForEventNotifier(CamelContext context, EventNotifier eventNotifier) {
        ManagedEventNotifier men = new ManagedEventNotifier(context, eventNotifier);
        men.init(context.getManagementStrategy());
        return men;
    }",0,[0]
1279,Bears-156,"protected String getMappedBy(CollectionPersister persister) {
        if (persister instanceof CustomCollectionPersister) {
            return ((CustomCollectionPersister) persister).getMappedByProperty();
        }

        throw new IllegalStateException(""Custom persister configured that doesn't implement the CustomCollectionPersister interface: "" + persister);
    }","protected String getMappedBy(CollectionPersister persister) {
        if (persister instanceof CustomCollectionPersister) {
            return ((CustomCollectionPersister) persister).getMappedByProperty();
        }

        throw new IllegalStateException(""Custom persister configured that doesn't implement the CustomCollectionPersister interface: "" + persister);
    }",0,[0]
12361,bugs-dot-jar_WICKET-4841_ce172da8,"public ServletWebRequest(HttpServletRequest httpServletRequest, String filterPrefix, Url url)
	{
		Args.notNull(httpServletRequest, ""httpServletRequest"");
		Args.notNull(filterPrefix, ""filterPrefix"");

		this.httpServletRequest = httpServletRequest;

		errorAttributes = ErrorAttributes.of(httpServletRequest, filterPrefix);

		forwardAttributes = ForwardAttributes.of(httpServletRequest, filterPrefix);

		if (forwardAttributes != null || errorAttributes != null)
		{
			if (LOG.isDebugEnabled())
			{
				LOG.debug(""Setting filterPrefix('{}') to '' because there is either an error or a forward. {}, {}"",
						new Object[] {filterPrefix, forwardAttributes, errorAttributes});
			}
			// the filter prefix is not needed when the current request is internal
			// see WICKET-4387
			this.filterPrefix = """";
		} else
		{
			this.filterPrefix = filterPrefix;
		}

		if (url != null)
		{
			this.url = url;
		}
		else
		{
			this.url = getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);
		}
	}","public ServletWebRequest(HttpServletRequest httpServletRequest, String filterPrefix, Url url)
	{
		Args.notNull(httpServletRequest, ""httpServletRequest"");
		Args.notNull(filterPrefix, ""filterPrefix"");

		this.httpServletRequest = httpServletRequest;

		errorAttributes = ErrorAttributes.of(httpServletRequest, filterPrefix);

		forwardAttributes = ForwardAttributes.of(httpServletRequest, filterPrefix);

		if (forwardAttributes != null || errorAttributes != null)
		{
			if (LOG.isDebugEnabled())
			{
				LOG.debug(""Setting filterPrefix('{}') to '' because there is either an error or a forward. {}, {}"",
						new Object[] {filterPrefix, forwardAttributes, errorAttributes});
			}
			// the filter prefix is not needed when the current request is internal
			// see WICKET-4387
			this.filterPrefix = """";
		} else
		{
			this.filterPrefix = filterPrefix;
		}

		if (url != null)
		{
			this.url = url;
		}
		else
		{
			this.url = getContextRelativeUrl(httpServletRequest.getRequestURI(), filterPrefix);
		}
	}",0,[0]
23595,bugs-dot-jar_OAK-4423_08f0b280,"private SegmentNodeStore(SegmentNodeStoreBuilder builder) {
        if (COMMIT_FAIR_LOCK) {
            log.info(""initializing SegmentNodeStore with the commitFairLock option enabled."");
        }
        this.commitSemaphore = new Semaphore(1, COMMIT_FAIR_LOCK);
        this.revisions = builder.revisions;
        this.reader = builder.reader;
        this.writer = builder.writer;
        this.blobStore = builder.blobStore;
        this.head = new AtomicReference<SegmentNodeState>(reader.readHeadState());
        this.changeDispatcher = new ChangeDispatcher(getRoot());
    }","private SegmentNodeStore(SegmentNodeStoreBuilder builder) {
        if (COMMIT_FAIR_LOCK) {
            log.info(""initializing SegmentNodeStore with the commitFairLock option enabled."");
        }
        this.commitSemaphore = new Semaphore(1, COMMIT_FAIR_LOCK);
        this.revisions = builder.revisions;
        this.reader = builder.reader;
        this.writer = builder.writer;
        this.blobStore = builder.blobStore;
        this.head = new AtomicReference<SegmentNodeState>(reader.readHeadState());
        this.changeDispatcher = new ChangeDispatcher(getRoot());
    }",0,[0]
10144,bugs-dot-jar_WICKET-4753_21a47387,"private void recordHeaderItem(HeaderItem item, Set<HeaderItem> depsDone)
	{
		renderDependencies(item, depsDone);
		RecordedHeaderItem recordedItem = itemsToBeRendered.get(item);
		if (recordedItem == null)
		{
			recordedItem = new RecordedHeaderItem(item);
			itemsToBeRendered.put(item, recordedItem);
		}
		recordedItem.addLocation(renderBase, indexInRenderBase, indexInRequest);
		indexInRenderBase++;
		indexInRequest++;
	}","private void recordHeaderItem(HeaderItem item, Set<HeaderItem> depsDone)
	{
		renderDependencies(item, depsDone);
		RecordedHeaderItem recordedItem = itemsToBeRendered.get(item);
		if (recordedItem == null)
		{
			recordedItem = new RecordedHeaderItem(item);
			itemsToBeRendered.put(item, recordedItem);
		}
		recordedItem.addLocation(renderBase, indexInRenderBase, indexInRequest);
		indexInRenderBase++;
		indexInRequest++;
	}",0,[0]
33148,bugs-dot-jar_MATH-1123_a197ba85,"private void chopOffMinus(final Hyperplane<S> hyperplane) {
        if (cut != null) {
            cut = cut.split(hyperplane).getPlus();
            plus.chopOffMinus(hyperplane);
            minus.chopOffMinus(hyperplane);
        }
    }","private void chopOffMinus(final Hyperplane<S> hyperplane) {
        if (cut != null) {
            cut = cut.split(hyperplane).getPlus();
            plus.chopOffMinus(hyperplane);
            minus.chopOffMinus(hyperplane);
        }
    }",0,[0]
4244,bugs-dot-jar_CAMEL-4682_1e54865c,"public synchronized void stopRoute(String routeId) throws Exception {
        RouteService routeService = routeServices.get(routeId);
        if (routeService != null) {
            List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);
            RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);
            routes.add(order);

            getShutdownStrategy().shutdown(this, routes);
            // must stop route service as well
            stopRouteService(routeService, false);
        }
    }","public synchronized void stopRoute(String routeId) throws Exception {
        RouteService routeService = routeServices.get(routeId);
        if (routeService != null) {
            List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);
            RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);
            routes.add(order);

            getShutdownStrategy().shutdown(this, routes);
            // must stop route service as well
            stopRouteService(routeService, false);
        }
    }",0,[0]
38290,bugs-dot-jar_CAMEL-3314_4badd9c5,"@SuppressWarnings(""unchecked"")
    public Type pollEnrich(String resourceUri, AggregationStrategy aggregationStrategy) {
        addOutput(new PollEnrichDefinition(aggregationStrategy, resourceUri, 0));
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    public Type pollEnrich(String resourceUri, AggregationStrategy aggregationStrategy) {
        addOutput(new PollEnrichDefinition(aggregationStrategy, resourceUri, 0));
        return (Type) this;
    }",0,[0]
40578,bugs-dot-jar_WICKET-442_246d53c5,"public final void request(IRequestTarget target)
	{
		checkReuse();

		// set it as the current target, on the top of the stack
		requestTargets.push(target);

		// set start step
		currentStep = PROCESS_EVENTS;

		// loop through steps
		steps();
	}","public final void request(IRequestTarget target)
	{
		checkReuse();

		// set it as the current target, on the top of the stack
		requestTargets.push(target);

		// set start step
		currentStep = PROCESS_EVENTS;

		// loop through steps
		steps();
	}",0,[0]
12592,bugs-dot-jar_MATH-864_abe53a53,"private static int[] inverse(final int[] indices) {
        int[] inverse = new int[indices.length];
        for (int i = 0; i < indices.length; i++) {
            inverse[indices[i]] = i;
        }
        return inverse;
    }","private static int[] inverse(final int[] indices) {
        int[] inverse = new int[indices.length];
        for (int i = 0; i < indices.length; i++) {
            inverse[indices[i]] = i;
        }
        return inverse;
    }",0,[0]
17421,bugs-dot-jar_CAMEL-7018_3244c1e5,"private String getDescription(Object managedBean, String objectName) {
        ManagedResource mr = ObjectHelper.getAnnotation(managedBean, ManagedResource.class);
        return mr != null ? mr.description() : """";
    }","private String getDescription(Object managedBean, String objectName) {
        ManagedResource mr = ObjectHelper.getAnnotation(managedBean, ManagedResource.class);
        return mr != null ? mr.description() : """";
    }",0,[0]
758,bugs-dot-jar_WICKET-5891_2d9ebf9a,"private CreditCard isJCB(String creditCardNumber)
	{
		if (creditCardNumber.length() == 16)
		{
			int firstFourDigits = Integer.parseInt(creditCardNumber.substring(0, 4));
			if (firstFourDigits >= 3528 && firstFourDigits <= 3589)
			{
				return CreditCard.JCB;
			}
		}

		return CreditCard.INVALID;
	}","private CreditCard isJCB(String creditCardNumber)
	{
		if (creditCardNumber.length() == 16)
		{
			int firstFourDigits = Integer.parseInt(creditCardNumber.substring(0, 4));
			if (firstFourDigits >= 3528 && firstFourDigits <= 3589)
			{
				return CreditCard.JCB;
			}
		}

		return CreditCard.INVALID;
	}",0,[0]
10337,bugs-dot-jar_OAK-3897_94c6c575,"private ResetDiff(@Nonnull Revision revision,
                      @Nonnull String path,
                      @Nonnull Map<String, UpdateOp> operations) {
        this.revision = checkNotNull(revision);
        this.path = checkNotNull(path);
        this.operations = checkNotNull(operations);
    }","private ResetDiff(@Nonnull Revision revision,
                      @Nonnull String path,
                      @Nonnull Map<String, UpdateOp> operations) {
        this.revision = checkNotNull(revision);
        this.path = checkNotNull(path);
        this.operations = checkNotNull(operations);
    }",0,[0]
16427,bugs-dot-jar_CAMEL-7163_5f726d0b,"public Set<String> getBreakpoints() {
        return new LinkedHashSet<String>(breakpoints.keySet());
    }","public Set<String> getBreakpoints() {
        return new LinkedHashSet<String>(breakpoints.keySet());
    }",0,[0]
1457,bugs-dot-jar_OAK-185_7fe28a0e,"@Override
    public void addMixin(String mixinName) throws RepositoryException {
        checkStatus();
        // TODO: figure out the right place for this check
        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
        NodeType nt = ntm.getNodeType(mixinName); // throws on not found
        // TODO: END

        String jcrMixinTypes = sessionDelegate.getOakPathOrThrow(Property.JCR_MIXIN_TYPES);
        PropertyDelegate mixins = dlg.getProperty(jcrMixinTypes);

        CoreValue cv = ValueConverter.toCoreValue(mixinName, PropertyType.NAME, sessionDelegate);

        boolean nodeModified = false;

        if (mixins == null) {
            nodeModified = true;
            dlg.setProperty(jcrMixinTypes, Collections.singletonList(cv));
        } else {
            List<CoreValue> values = new ArrayList<CoreValue>();
            for (CoreValue existingValue : mixins.getValues()) {
                if (!values.contains(existingValue)) {
                    values.add(existingValue);
                }
            }
            if (!values.contains(cv)) {
                values.add(cv);
                nodeModified = true;
                dlg.setProperty(jcrMixinTypes, values);
            }
        }

        // TODO: hack -- make sure we assign a UUID
        if (nodeModified && nt.isNodeType(NodeType.MIX_REFERENCEABLE)) {
            String jcrUuid = sessionDelegate.getOakPathOrThrow(Property.JCR_UUID);
            dlg.setProperty(jcrUuid, ValueConverter.toCoreValue(UUID.randomUUID().toString(), PropertyType.STRING, sessionDelegate));
        }
    }","@Override
    public void addMixin(String mixinName) throws RepositoryException {
        checkStatus();
        // TODO: figure out the right place for this check
        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
        NodeType nt = ntm.getNodeType(mixinName); // throws on not found
        // TODO: END

        String jcrMixinTypes = sessionDelegate.getOakPathOrThrow(Property.JCR_MIXIN_TYPES);
        PropertyDelegate mixins = dlg.getProperty(jcrMixinTypes);

        CoreValue cv = ValueConverter.toCoreValue(mixinName, PropertyType.NAME, sessionDelegate);

        boolean nodeModified = false;

        if (mixins == null) {
            nodeModified = true;
            dlg.setProperty(jcrMixinTypes, Collections.singletonList(cv));
        } else {
            List<CoreValue> values = new ArrayList<CoreValue>();
            for (CoreValue existingValue : mixins.getValues()) {
                if (!values.contains(existingValue)) {
                    values.add(existingValue);
                }
            }
            if (!values.contains(cv)) {
                values.add(cv);
                nodeModified = true;
                dlg.setProperty(jcrMixinTypes, values);
            }
        }

        // TODO: hack -- make sure we assign a UUID
        if (nodeModified && nt.isNodeType(NodeType.MIX_REFERENCEABLE)) {
            String jcrUuid = sessionDelegate.getOakPathOrThrow(Property.JCR_UUID);
            dlg.setProperty(jcrUuid, ValueConverter.toCoreValue(UUID.randomUUID().toString(), PropertyType.STRING, sessionDelegate));
        }
    }",0,[0]
17084,bugs-dot-jar_MATH-949_f83bbc1d,"protected void parseOptimizationData(OptimizationData... optData) {
        // The existing values (as set by the previous call) are reused if
        // not provided in the argument list.
        for (OptimizationData data : optData) {
            if (data instanceof MaxEval) {
                evaluations.setMaximalCount(((MaxEval) data).getMaxEval());
                continue;
            }
            if (data instanceof MaxIter) {
                iterations.setMaximalCount(((MaxIter) data).getMaxIter());
                continue;
            }
        }
    }","protected void parseOptimizationData(OptimizationData... optData) {
        // The existing values (as set by the previous call) are reused if
        // not provided in the argument list.
        for (OptimizationData data : optData) {
            if (data instanceof MaxEval) {
                evaluations.setMaximalCount(((MaxEval) data).getMaxEval());
                continue;
            }
            if (data instanceof MaxIter) {
                iterations.setMaximalCount(((MaxIter) data).getMaxIter());
                continue;
            }
        }
    }",0,[0]
27015,bugs-dot-jar_LOG4J2-793_73400bfb,"@Override
    public void error(final String format, final Object o) {
        logger.logIfEnabled(FQCN, Level.ERROR, null, format, o);
    }","@Override
    public void error(final String format, final Object o) {
        logger.logIfEnabled(FQCN, Level.ERROR, null, format, o);
    }",0,[0]
219,bugs-dot-jar_WICKET-2368_fae1601b,"protected void configureResponse()
	{
		// Get the response and application
		final RequestCycle cycle = getRequestCycle();
		final Application application = cycle.getApplication();
		final Response response = cycle.getResponse();

		// Determine encoding
		final String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();

		// Set content type based on markup type for page
		response.setContentType(""text/"" + getMarkupType() + ""; charset="" + encoding);

		// Write out an xml declaration if the markup stream and settings allow
		final MarkupStream markupStream = findMarkupStream();
		if ((markupStream != null) && (markupStream.getXmlDeclaration() != null) &&
			(application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))
		{
			// Gwyn - Wed, 21 May 2008 12:23:41
			// If the xml declaration in the markup used double-quotes, use them in the output too
			// Whether it should be or not, sometimes it's significant...
			final String quoteChar = (markupStream.getXmlDeclaration().indexOf('\""') == -1) ? ""'""
				: ""\"""";

			response.write(""<?xml version="");
			response.write(quoteChar);
			response.write(""1.0"");
			response.write(quoteChar);
			response.write("" encoding="");
			response.write(quoteChar);
			response.write(encoding);
			response.write(quoteChar);
			response.write(""?>"");
		}

		// Set response locale from session locale
		response.setLocale(getSession().getLocale());
	}","protected void configureResponse()
	{
		// Get the response and application
		final RequestCycle cycle = getRequestCycle();
		final Application application = cycle.getApplication();
		final Response response = cycle.getResponse();

		// Determine encoding
		final String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();

		// Set content type based on markup type for page
		response.setContentType(""text/"" + getMarkupType() + ""; charset="" + encoding);

		// Write out an xml declaration if the markup stream and settings allow
		final MarkupStream markupStream = findMarkupStream();
		if ((markupStream != null) && (markupStream.getXmlDeclaration() != null) &&
			(application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))
		{
			// Gwyn - Wed, 21 May 2008 12:23:41
			// If the xml declaration in the markup used double-quotes, use them in the output too
			// Whether it should be or not, sometimes it's significant...
			final String quoteChar = (markupStream.getXmlDeclaration().indexOf('\""') == -1) ? ""'""
				: ""\"""";

			response.write(""<?xml version="");
			response.write(quoteChar);
			response.write(""1.0"");
			response.write(quoteChar);
			response.write("" encoding="");
			response.write(quoteChar);
			response.write(encoding);
			response.write(quoteChar);
			response.write(""?>"");
		}

		// Set response locale from session locale
		response.setLocale(getSession().getLocale());
	}",0,[0]
20215,bugs-dot-jar_MNG-5613_bef7fac6,"private Collection<AbstractMavenLifecycleParticipant> getLifecycleParticipants( Collection<MavenProject> projects )
    {
        Collection<AbstractMavenLifecycleParticipant> lifecycleListeners =
            new LinkedHashSet<AbstractMavenLifecycleParticipant>();

        ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            try
            {
                lifecycleListeners.addAll( container.lookupList( AbstractMavenLifecycleParticipant.class ) );
            }
            catch ( ComponentLookupException e )
            {
                // this is just silly, lookupList should return an empty list!
                logger.warn( ""Failed to lookup lifecycle participants: "" + e.getMessage() );
            }

            Collection<ClassLoader> scannedRealms = new HashSet<ClassLoader>();

            for ( MavenProject project : projects )
            {
                ClassLoader projectRealm = project.getClassRealm();

                if ( projectRealm != null && scannedRealms.add( projectRealm ) )
                {
                    Thread.currentThread().setContextClassLoader( projectRealm );

                    try
                    {
                        lifecycleListeners.addAll( container.lookupList( AbstractMavenLifecycleParticipant.class ) );
                    }
                    catch ( ComponentLookupException e )
                    {
                        // this is just silly, lookupList should return an empty list!
                        logger.warn( ""Failed to lookup lifecycle participants: "" + e.getMessage() );
                    }
                }
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( originalClassLoader );
        }

        return lifecycleListeners;
    }","private Collection<AbstractMavenLifecycleParticipant> getLifecycleParticipants( Collection<MavenProject> projects )
    {
        Collection<AbstractMavenLifecycleParticipant> lifecycleListeners =
            new LinkedHashSet<AbstractMavenLifecycleParticipant>();

        ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();
        try
        {
            try
            {
                lifecycleListeners.addAll( container.lookupList( AbstractMavenLifecycleParticipant.class ) );
            }
            catch ( ComponentLookupException e )
            {
                // this is just silly, lookupList should return an empty list!
                logger.warn( ""Failed to lookup lifecycle participants: "" + e.getMessage() );
            }

            Collection<ClassLoader> scannedRealms = new HashSet<ClassLoader>();

            for ( MavenProject project : projects )
            {
                ClassLoader projectRealm = project.getClassRealm();

                if ( projectRealm != null && scannedRealms.add( projectRealm ) )
                {
                    Thread.currentThread().setContextClassLoader( projectRealm );

                    try
                    {
                        lifecycleListeners.addAll( container.lookupList( AbstractMavenLifecycleParticipant.class ) );
                    }
                    catch ( ComponentLookupException e )
                    {
                        // this is just silly, lookupList should return an empty list!
                        logger.warn( ""Failed to lookup lifecycle participants: "" + e.getMessage() );
                    }
                }
            }
        }
        finally
        {
            Thread.currentThread().setContextClassLoader( originalClassLoader );
        }

        return lifecycleListeners;
    }",0,[0]
36476,bugs-dot-jar_MATH-705_645d642b,"public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {

    super(interpolator);

    if (interpolator.currentState != null) {
      final int dimension = currentState.length;

      yDotK = new double[interpolator.yDotK.length][];
      for (int k = 0; k < interpolator.yDotK.length; ++k) {
        yDotK[k] = new double[dimension];
        System.arraycopy(interpolator.yDotK[k], 0,
                         yDotK[k], 0, dimension);
      }

    } else {
      yDotK = null;
    }

    // we cannot keep any reference to the equations in the copy
    // the interpolator should have been finalized before
    integrator = null;

  }","public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {

    super(interpolator);

    if (interpolator.currentState != null) {

      previousState = interpolator.previousState.clone();

      yDotK = new double[interpolator.yDotK.length][];
      for (int k = 0; k < interpolator.yDotK.length; ++k) {
        yDotK[k] = interpolator.yDotK[k].clone();
      }

    } else {
      previousState = null;
      yDotK = null;
    }

    // we cannot keep any reference to the equations in the copy
    // the interpolator should have been finalized before
    integrator = null;

  }",1,"[5, 9, 10, 11]"
685,bugs-dot-jar_WICKET-5565_44f4782a,"private boolean isValidClassName(String className)
	{
		// darn simple check - feel free to enhance this method to your needs
		if (className == null)
		{
			return false;
		}
		// java class names never start with '.'
		if (className.startsWith("".""))
		{
			return false;
		}
		return true;
	}","private boolean isValidClassName(String className)
	{
		// darn simple check - feel free to enhance this method to your needs
		if (className == null)
		{
			return false;
		}
		// java class names never start with '.'
		if (className.startsWith("".""))
		{
			return false;
		}
		return true;
	}",0,[0]
35757,bugs-dot-jar_OAK-3763_ab1a0cc2,"@Override
    public String getString(String name) {
        return null;
    }","@Override
    public String getString(String name) {
        return null;
    }",0,[0]
5371,bugs-dot-jar_FLINK-3534_734ba01d,"public long getStatusTimestamp(JobStatus status) {
		return this.stateTimestamps[status.ordinal()];
	}","public long getStatusTimestamp(JobStatus status) {
		return this.stateTimestamps[status.ordinal()];
	}",0,[0]
176,bugs-dot-jar_WICKET-2368_fae1601b,"public void beforeCallComponent(final Component component,
		final RequestListenerInterface listener)
	{
	}","public void beforeCallComponent(final Component component,
		final RequestListenerInterface listener)
	{
	}",0,[0]
6320,bugs-dot-jar_WICKET-2261_089303f4,"public Page getLastRenderedPage()
	{
		return lastRenderedPage;
	}","public Page getLastRenderedPage()
	{
		return lastRenderedPage;
	}",0,[0]
23384,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public int size() {
        return list.size();
    }","@Override
    public int size() {
        return list.size();
    }",0,[0]
7555,bugs-dot-jar_WICKET-5441_8ccb1f6d,"@Override
	public void undecorateUrl(ResourceUrl url)
	{
		final INamedParameters parameters = url.getParameters();
		
		if (parameters != null)
		{
			// store the version in the request cycle
			StringValue versionValue = parameters.get(versionParameter);
			RequestCycle requestCycle = RequestCycle.get();
			if (versionValue.isEmpty() == false && requestCycle != null)
			{
				requestCycle.setMetaData(URL_VERSION, versionValue.toString());
			}

			// undecorate
			parameters.remove(versionParameter);
		}
	}","@Override
	public void undecorateUrl(ResourceUrl url)
	{
		final INamedParameters parameters = url.getParameters();
		
		if (parameters != null)
		{
			// store the version in the request cycle
			StringValue versionValue = parameters.get(versionParameter);
			RequestCycle requestCycle = RequestCycle.get();
			if (versionValue.isEmpty() == false && requestCycle != null)
			{
				requestCycle.setMetaData(URL_VERSION, versionValue.toString());
			}

			// undecorate
			parameters.remove(versionParameter);
		}
	}",0,[0]
39510,bugs-dot-jar_MATH-305_ef9b639a,"public static double distanceInf(double[] p1, double[] p2) {
        double max = 0;
        for (int i = 0; i < p1.length; i++) {
            max = Math.max(max, Math.abs(p1[i] - p2[i]));
        }
        return max;
    }","public static double distanceInf(double[] p1, double[] p2) {
        double max = 0;
        for (int i = 0; i < p1.length; i++) {
            max = Math.max(max, Math.abs(p1[i] - p2[i]));
        }
        return max;
    }",0,[0]
40452,bugs-dot-jar_WICKET-442_246d53c5,"public final void warn(final String message)
	{
		getPage().getFeedbackMessages().warn(this, message);
	}","public final void warn(final String message)
	{
		Session.get().getFeedbackMessages().warn(this, message);
	}",1,[2]
39198,bugs-dot-jar_OAK-4353_b0014b7d,"byte readByte(int offset) {
        return data.get(pos(offset, 1));
    }","byte readByte(int offset) {
        return data.get(pos(offset, 1));
    }",0,[0]
34912,bugs-dot-jar_CAMEL-5570_a57830ed,"public OnExceptionDefinition useExponentialBackOff() {
        getOrCreateRedeliveryPolicy().useExponentialBackOff();
        return this;
    }","public OnExceptionDefinition useExponentialBackOff() {
        getOrCreateRedeliveryPolicy().useExponentialBackOff();
        return this;
    }",0,[0]
164,bugs-dot-jar_WICKET-2065_9da430fb,"public PackageRequestTargetUrlCodingStrategy(final String path, PackageName packageName)
	{
		super(path);
		this.packageName = packageName;
	}","public PackageRequestTargetUrlCodingStrategy(final String path, PackageName packageName)
	{
		super(path);
		this.packageName = packageName;
	}",0,[0]
3417,bugs-dot-jar_LOG4J2-102_7f391872,"public Priority(Facility facility, Severity severity) {
        this.facility = facility;
        this.severity = severity;
    }","public Priority(Facility facility, Severity severity) {
        this.facility = facility;
        this.severity = severity;
    }",0,[0]
18697,bugs-dot-jar_ACCUMULO-3218_1b35d263,"public static ClientConfiguration deserialize(String serializedConfig) {
    PropertiesConfiguration propConfig = new PropertiesConfiguration();
    try {
      propConfig.load(new StringReader(serializedConfig));
    } catch (ConfigurationException e) {
      throw new IllegalArgumentException(""Error deserializing client configuration: "" + serializedConfig, e);
    }
    return new ClientConfiguration(propConfig);
  }","public static ClientConfiguration deserialize(String serializedConfig) {
    PropertiesConfiguration propConfig = new PropertiesConfiguration();
    try {
      propConfig.load(new StringReader(serializedConfig));
    } catch (ConfigurationException e) {
      throw new IllegalArgumentException(""Error deserializing client configuration: "" + serializedConfig, e);
    }
    return new ClientConfiguration(propConfig);
  }",0,[0]
2091,bugs-dot-jar_WICKET-2961_3d8c9d75,"public Component replaceWith(Component replacement)
	{
		if (replacement == null)
		{
			throw new IllegalArgumentException(""Argument [[replacement]] cannot be null."");
		}
		if (!getId().equals(replacement.getId()))
		{
			throw new IllegalArgumentException(
				""Replacement component must have the same id as the component it will replace. Replacement id [["" +
					replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null)
		{
			throw new IllegalStateException(
				""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
		return replacement;
	}","public Component replaceWith(Component replacement)
	{
		if (replacement == null)
		{
			throw new IllegalArgumentException(""Argument [[replacement]] cannot be null."");
		}
		if (!getId().equals(replacement.getId()))
		{
			throw new IllegalArgumentException(
				""Replacement component must have the same id as the component it will replace. Replacement id [["" +
					replacement.getId() + ""]], replaced id [["" + getId() + ""]]."");
		}
		if (parent == null)
		{
			throw new IllegalStateException(
				""This method can only be called on a component that has already been added to its parent."");
		}
		parent.replace(replacement);
		return replacement;
	}",0,[0]
37126,bugs-dot-jar_CAMEL-7239_ae419224,"public void setSchema(Schema schema) {
        this.schema = schema;
    }","public void setSchema(Schema schema) {
        this.schema = schema;
    }",0,[0]
40549,bugs-dot-jar_WICKET-442_246d53c5,"final void setPageMap(final IPageMap pageMap)
	{
		// Save transient reference to pagemap
		this.pageMap = pageMap;

		// Save name for restoring transient
		this.pageMapName = pageMap.getName();
	}","final void setPageMap(final IPageMap pageMap)
	{
		// Save transient reference to pagemap
		this.pageMap = pageMap;

		// Save name for restoring transient
		this.pageMapName = pageMap.getName();
	}",0,[0]
1532,bugs-dot-jar_MATH-290_b01fcc31,"SimplexTableau(final LinearObjectiveFunction f,
                   final Collection<LinearConstraint> constraints,
                   final GoalType goalType, final boolean restrictToNonNegative,
                   final double epsilon) {
        this.f                      = f;
        this.constraints            = constraints;
        this.restrictToNonNegative  = restrictToNonNegative;
        this.epsilon                = epsilon;
        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);
        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +
                                      getConstraintTypeCounts(Relationship.GEQ);
        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +
                                      getConstraintTypeCounts(Relationship.GEQ);
        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));
        initialize();
    }","SimplexTableau(final LinearObjectiveFunction f,
                   final Collection<LinearConstraint> constraints,
                   final GoalType goalType, final boolean restrictToNonNegative,
                   final double epsilon) {
        this.f                      = f;
        this.constraints            = normalizeConstraints(constraints);
        this.restrictToNonNegative  = restrictToNonNegative;
        this.epsilon                = epsilon;
        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);
        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +
                                      getConstraintTypeCounts(Relationship.GEQ);
        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +
                                      getConstraintTypeCounts(Relationship.GEQ);
        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));
        initialize();
    }",1,[5]
5176,bugs-dot-jar_ACCUMULO-3006_d6472040,"@Override
  public boolean delete(Path path) throws IOException {
    return getVolumeByPath(path).getFileSystem().delete(path, false);
  }","@Override
  public boolean delete(Path path) throws IOException {
    return getVolumeByPath(path).getFileSystem().delete(path, false);
  }",0,[0]
36465,bugs-dot-jar_MATH-705_645d642b,"public HighamHall54StepInterpolator() {
    super();
  }","public HighamHall54StepInterpolator() {
    super();
  }",0,[0]
27800,bugs-dot-jar_CAMEL-8053_cac72b14,"public void addErrorHandlers(RouteContext routeContext, OnExceptionDefinition exception) {
        // only add if we not already have it
        List<OnExceptionDefinition> list = onExceptions.get(routeContext);
        if (list == null) {
            list = new ArrayList<OnExceptionDefinition>();
            onExceptions.put(routeContext, list);
        }
        if (!list.contains(exception)) {
            list.add(exception);
        }
    }","public void addErrorHandlers(RouteContext routeContext, OnExceptionDefinition exception) {
        // only add if we not already have it
        List<OnExceptionDefinition> list = onExceptions.get(routeContext);
        if (list == null) {
            list = new ArrayList<OnExceptionDefinition>();
            onExceptions.put(routeContext, list);
        }
        if (!list.contains(exception)) {
            list.add(exception);
        }
    }",0,[0]
23365,bugs-dot-jar_LOG4J2-302_300bc575,"@Override
    public Iterator<String> iterator() {
        final List<String> immutable = stack.get();
        if (immutable == null) {
            final List<String> empty = Collections.emptyList();
            return empty.iterator();
        }
        return immutable.iterator();
    }","@Override
    public Iterator<String> iterator() {
        final List<String> immutable = stack.get();
        if (immutable == null) {
            final List<String> empty = Collections.emptyList();
            return empty.iterator();
        }
        return immutable.iterator();
    }",0,[0]
1585,Bears-192,"public RepairRun.RunState getState() {
    return state;
  }","public RepairRun.RunState getState() {
    return state;
  }",0,[0]
27938,bugs-dot-jar_CAMEL-8053_cac72b14,"public UnitOfWorkFactory getUnitOfWorkFactory() {
        return unitOfWorkFactory;
    }","public UnitOfWorkFactory getUnitOfWorkFactory() {
        return unitOfWorkFactory;
    }",0,[0]
39588,bugs-dot-jar_OAK-1674_073b814c,"@Override
    public boolean hasChild(String name) {
        return nodeBuilder.hasChildNode(name) && !isHidden(name);
    }","@Override
    public boolean hasChild(String name) {
        return nodeBuilder.hasChildNode(name) && !isHidden(name);
    }",0,[0]
32830,bugs-dot-jar_MATH-373_bfe4623c,"@Override
    public void clear() {
        value = 0d;
        n = 0;
    }","@Override
    public void clear() {
        value = 0d;
        n = 0;
    }",0,[0]
18443,bugs-dot-jar_OAK-1877_716e1237,"@Override @CheckForNull
    public Editor childNodeDeleted(String name, NodeState before)
            throws CommitFailedException {
        List<Editor> children = newArrayListWithCapacity(editors.size());
        for (Editor editor : editors) {
            Editor child = editor.childNodeDeleted(name, before);
            if (child != null) {
                children.add(child);
            }
        }
        return CompositeEditor.compose(children);
    }","@Override @CheckForNull
    public Editor childNodeDeleted(String name, NodeState before)
            throws CommitFailedException {
        List<Editor> children = newArrayListWithCapacity(editors.size());
        for (Editor editor : editors) {
            Editor child = editor.childNodeDeleted(name, before);
            if (child != null) {
                children.add(child);
            }
        }
        return CompositeEditor.compose(children);
    }",0,[0]
17246,bugs-dot-jar_OAK-2389_7c320b1e,"@Override
    public void setLineLength(int length) {
        lineLength = length;
    }","@Override
    public void setLineLength(int length) {
        lineLength = length;
    }",0,[0]
11281,bugs-dot-jar_OAK-395_e6c31270,"@Override
    public void remove() throws RepositoryException {
        checkStatus();
        checkProtected();

        sessionDelegate.perform(new SessionOperation<Void>() {
            @Override
            public Void perform() throws RepositoryException {
                if (dlg.isRoot()) {
                    throw new RepositoryException(""Cannot remove the root node"");
                }

                dlg.remove();
                return null;
            }
        });
    }","@Override
    public void remove() throws RepositoryException {
        checkStatus();
        checkProtected();

        sessionDelegate.perform(new SessionOperation<Void>() {
            @Override
            public Void perform() throws RepositoryException {
                if (dlg.isRoot()) {
                    throw new RepositoryException(""Cannot remove the root node"");
                }

                dlg.remove();
                return null;
            }
        });
    }",0,[0]
3093,bugs-dot-jar_CAMEL-5261_55c2e2d8,"void onStopped(SedaConsumer consumer) throws Exception {
        consumers.remove(consumer);
        if (isMultipleConsumers()) {
            updateMulticastProcessor();
        }
    }","void onStopped(SedaConsumer consumer) throws Exception {
        consumers.remove(consumer);
        if (isMultipleConsumers()) {
            updateMulticastProcessor();
        }
    }",0,[0]
38797,bugs-dot-jar_FLINK-2567_948b6e05,"protected void setFieldsGeneric(boolean[] includedMask, Class<?>[] fieldTypes) {
		Preconditions.checkNotNull(includedMask);
		Preconditions.checkNotNull(fieldTypes);

		ArrayList<Class<?>> types = new ArrayList<Class<?>>();

		// check if types are valid for included fields
		int typeIndex = 0;
		for (int i = 0; i < includedMask.length; i++) {

			if (includedMask[i]) {
				if (typeIndex > fieldTypes.length - 1) {
					throw new IllegalArgumentException(""Missing type for included field "" + i + ""."");
				}
				Class<?> type = fieldTypes[typeIndex++];

				if (type == null) {
					throw new IllegalArgumentException(""Type for included field "" + i + "" should not be null."");
				} else {
					// check if we support parsers for this type
					if (FieldParser.getParserForType(type) == null) {
						throw new IllegalArgumentException(""The type '"" + type.getName() + ""' is not supported for the CSV input format."");
					}
					types.add(type);
				}
			}
		}

		Class<?>[] denseTypeArray = (Class<?>[]) types.toArray(new Class[types.size()]);
		this.fieldTypes = denseTypeArray;
		this.fieldIncluded = includedMask;
	}","protected void setFieldsGeneric(boolean[] includedMask, Class<?>[] fieldTypes) {
		Preconditions.checkNotNull(includedMask);
		Preconditions.checkNotNull(fieldTypes);

		ArrayList<Class<?>> types = new ArrayList<Class<?>>();

		// check if types are valid for included fields
		int typeIndex = 0;
		for (int i = 0; i < includedMask.length; i++) {

			if (includedMask[i]) {
				if (typeIndex > fieldTypes.length - 1) {
					throw new IllegalArgumentException(""Missing type for included field "" + i + ""."");
				}
				Class<?> type = fieldTypes[typeIndex++];

				if (type == null) {
					throw new IllegalArgumentException(""Type for included field "" + i + "" should not be null."");
				} else {
					// check if we support parsers for this type
					if (FieldParser.getParserForType(type) == null) {
						throw new IllegalArgumentException(""The type '"" + type.getName() + ""' is not supported for the CSV input format."");
					}
					types.add(type);
				}
			}
		}

		Class<?>[] denseTypeArray = (Class<?>[]) types.toArray(new Class[types.size()]);
		this.fieldTypes = denseTypeArray;
		this.fieldIncluded = includedMask;
	}",0,[0]
2449,bugs-dot-jar_CAMEL-8137_53b4e90c,"public boolean hasMethod(String methodName) {
        return getOperations(methodName) != null;
    }","public boolean hasMethod(String methodName) {
        return getOperations(methodName) != null;
    }",0,[0]
39437,bugs-dot-jar_FLINK-3760_494212b3,"protected StateDescriptor(String name, TypeInformation<T> typeInfo, T defaultValue) {
		this.name = requireNonNull(name, ""name must not be null"");
		this.typeInfo = requireNonNull(typeInfo, ""type information must not be null"");
		this.defaultValue = defaultValue;
	}","protected StateDescriptor(String name, TypeInformation<T> typeInfo, T defaultValue) {
		this.name = requireNonNull(name, ""name must not be null"");
		this.typeInfo = requireNonNull(typeInfo, ""type information must not be null"");
		this.defaultValue = defaultValue;
	}",0,[0]
32485,bugs-dot-jar_OAK-926_e1ae968c,"public static void setCommitRoot(@Nonnull UpdateOp op,
                                     @Nonnull Revision revision,
                                     int commitRootDepth) {
        checkNotNull(op).setMapEntry(COMMIT_ROOT,
                checkNotNull(revision).toString(), String.valueOf(commitRootDepth));
    }","public static void setCommitRoot(@Nonnull UpdateOp op,
                                     @Nonnull Revision revision,
                                     int commitRootDepth) {
        checkNotNull(op).setMapEntry(COMMIT_ROOT,
                checkNotNull(revision).toString(), String.valueOf(commitRootDepth));
    }",0,[0]
7769,bugs-dot-jar_ACCUMULO-843_65390f8c,"@Override
  public Set<Range> splitRangeByTablets(String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException,
      TableNotFoundException {
    return Collections.singleton(range);
  }","@Override
  public Set<Range> splitRangeByTablets(String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException,
      TableNotFoundException {
    if (!exists(tableName))
      throw new TableNotFoundException(tableName, tableName, """");
    return Collections.singleton(range);
  }",1,[]
34572,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"public LoggerOperation minorCompactionStarted(int seq, int tid, String fqfn) throws IOException {
    LogFileKey key = new LogFileKey();
    key.event = COMPACTION_START;
    key.seq = seq;
    key.tid = tid;
    key.filename = fqfn;
    return logFileData(Collections.singletonList(new Pair<LogFileKey,LogFileValue>(key, EMPTY)));
  }","public LoggerOperation minorCompactionStarted(int seq, int tid, String fqfn) throws IOException {
    LogFileKey key = new LogFileKey();
    key.event = COMPACTION_START;
    key.seq = seq;
    key.tid = tid;
    key.filename = fqfn;
    return logFileData(Collections.singletonList(new Pair<LogFileKey,LogFileValue>(key, EMPTY)));
  }",0,[0]
305,Bears-14,"protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanDeserializerBuilder builder,
            List<BeanPropertyDefinition> propDefsIn,
            Set<String> ignored)
        throws JsonMappingException
    {
        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(
                Math.max(4, propDefsIn.size()));
        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();
        // These are all valid setters, but we do need to introspect bit more
        for (BeanPropertyDefinition property : propDefsIn) {
            String name = property.getName();
            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries
                continue;
            }
            if (!property.hasConstructorParameter()) { // never skip constructor params
                Class<?> rawPropertyType = null;
                if (property.hasSetter()) {
                    rawPropertyType = property.getSetter().getRawParameterType(0);
                } else if (property.hasField()) {
                    rawPropertyType = property.getField().getRawType();
                }

                // [JACKSON-429] Some types are declared as ignorable as well
                if ((rawPropertyType != null)
                        && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) {
                    // important: make ignorable, to avoid errors if value is actually seen
                    builder.addIgnorable(name);
                    continue;
                }
            }
            result.add(property);
        }
        return result;
    }","protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,
            BeanDescription beanDesc, BeanDeserializerBuilder builder,
            List<BeanPropertyDefinition> propDefsIn,
            Set<String> ignored)
        throws JsonMappingException
    {
        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(
                Math.max(4, propDefsIn.size()));
        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();
        // These are all valid setters, but we do need to introspect bit more
        for (BeanPropertyDefinition property : propDefsIn) {
            String name = property.getName();
            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries
                continue;
            }
            if (!property.hasConstructorParameter()) { // never skip constructor params
                Class<?> rawPropertyType = null;
                if (property.hasSetter()) {
                    rawPropertyType = property.getSetter().getRawParameterType(0);
                } else if (property.hasField()) {
                    rawPropertyType = property.getField().getRawType();
                }

                // [JACKSON-429] Some types are declared as ignorable as well
                if ((rawPropertyType != null)
                        && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) {
                    // important: make ignorable, to avoid errors if value is actually seen
                    builder.addIgnorable(name);
                    continue;
                }
            }
            result.add(property);
        }
        return result;
    }",0,[0]
20293,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"public TCredentials toThrift(Instance instance) {
    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());
  }","public TCredentials toThrift(Instance instance) {
    TCredentials tCreds = new TCredentials(getPrincipal(), getToken().getClass().getName(),
        ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(getToken())), instance.getInstanceID());
    if (getToken().isDestroyed())
      throw new RuntimeException(""Token has been destroyed"", new AccumuloSecurityException(getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED));
    return tCreds;
  }",1,[1]
8579,bugs-dot-jar_WICKET-3309_debca73b,"public final void markNodeChildrenDirty(Object node)
	{
		TreeItem item = nodeToItemMap.get(node);
		if (item != null)
		{
			visitItemChildren(item, new IItemCallback()
			{
				public void visitItem(TreeItem item)
				{
					invalidateNode(item.getModelObject(), false);
				}
			});
		}
	}","public final void markNodeChildrenDirty(Object node)
	{
		TreeItem item = nodeToItemMap.get(node);
		if (item != null)
		{
			visitItemChildren(item, new IItemCallback()
			{
				public void visitItem(TreeItem item)
				{
					invalidateNode(item.getModelObject(), false);
				}
			});
		}
	}",0,[0]
25951,bugs-dot-jar_WICKET-5071_faaae8d3,"private boolean matches(final Request request)
	{
		boolean matches = false;
		Url url = request.getUrl();
		Url baseUrl = request.getClientUrl();
		String namespace = getContext().getNamespace();
		String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();
		String pageIdentifier = getContext().getPageIdentifier();

		if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier))
		{
			matches = true;
		}
		// baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
		else if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))
		{
			matches = true;
		}
		// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
		else if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))
		{
			matches = true;
		}

		return matches;
	}","private boolean matches(final Request request)
	{
		boolean matches = false;
		Url url = request.getUrl();
		Url baseUrl = request.getClientUrl();
		String namespace = getContext().getNamespace();
		String bookmarkableIdentifier = getContext().getBookmarkableIdentifier();
		String pageIdentifier = getContext().getPageIdentifier();

		if (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier))
		{
			matches = true;
		}
		// baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
		else if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))
		{
			matches = true;
		}
		// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'
		else if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier) && url.getSegments().size() == 2 && urlStartsWith(url, bookmarkableIdentifier))
		{
			matches = true;
		}
		// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'
		else if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))
		{
			matches = true;
		}

		return matches;
	}",1,[]
21043,bugs-dot-jar_OAK-846_7acb091a,"Node.Children readChildren(String path, Revision rev, int limit) {
        String from = PathUtils.concat(path, ""a"");
        from = Utils.getIdFromPath(from);
        from = from.substring(0, from.length() - 1);
        String to = PathUtils.concat(path, ""z"");
        to = Utils.getIdFromPath(to);
        to = to.substring(0, to.length() - 2) + ""0"";
        List<Map<String, Object>> list = store.query(DocumentStore.Collection.NODES, from, to, limit);
        Children c = new Children(path, rev);
        Set<Revision> validRevisions = new HashSet<Revision>();
        for (Map<String, Object> e : list) {
            // filter out deleted children
            if (getLiveRevision(e, rev, validRevisions) == null) {
                continue;
            }
            // TODO put the whole node in the cache
            String id = e.get(UpdateOp.ID).toString();
            String p = Utils.getPathFromId(id);
            c.children.add(p);
        }
        return c;
    }","Node.Children readChildren(String path, Revision rev, int limit) {
        String from = PathUtils.concat(path, ""a"");
        from = Utils.getIdFromPath(from);
        from = from.substring(0, from.length() - 1);
        String to = PathUtils.concat(path, ""z"");
        to = Utils.getIdFromPath(to);
        to = to.substring(0, to.length() - 2) + ""0"";
        List<Map<String, Object>> list = store.query(DocumentStore.Collection.NODES, from, to, limit);
        Children c = new Children(path, rev);
        Set<Revision> validRevisions = new HashSet<Revision>();
        for (Map<String, Object> e : list) {
            // filter out deleted children
            if (getLiveRevision(e, rev, validRevisions) == null) {
                continue;
            }
            // TODO put the whole node in the cache
            String id = e.get(UpdateOp.ID).toString();
            String p = Utils.getPathFromId(id);
            c.children.add(p);
        }
        return c;
    }",0,[0]
36708,bugs-dot-jar_ACCUMULO-3424_27d4ee21,"public void execCommand(String input, boolean ignoreAuthTimeout, boolean echoPrompt) throws IOException {
    audit.log(Level.INFO, getDefaultPrompt() + input);
    if (echoPrompt) {
      reader.print(getDefaultPrompt());
      reader.println(input);
    }

    if (input.startsWith(COMMENT_PREFIX)) {
      return;
    }

    String fields[];
    try {
      fields = new QuotedStringTokenizer(input).getTokens();
    } catch (BadArgumentException e) {
      printException(e);
      ++exitCode;
      return;
    }
    if (fields.length == 0)
      return;

    String command = fields[0];
    fields = fields.length > 1 ? Arrays.copyOfRange(fields, 1, fields.length) : new String[] {};

    Command sc = null;
    if (command.length() > 0) {
      try {
        // Obtain the command from the command table
        sc = commandFactory.get(command);
        if (sc == null) {
          reader.println(String.format(""Unknown command \""%s\"".  Enter \""help\"" for a list possible commands."", command));
          reader.flush();
          return;
        }

        long duration = System.nanoTime() - lastUserActivity;
        if (!(sc instanceof ExitCommand) && !ignoreAuthTimeout && (duration < 0 || duration > authTimeout)) {
          reader.println(""Shell has been idle for too long. Please re-authenticate."");
          boolean authFailed = true;
          do {
            String pwd = readMaskedLine(""Enter current password for '"" + connector.whoami() + ""': "", '*');
            if (pwd == null) {
              reader.println();
              return;
            } // user canceled

            try {
              authFailed = !connector.securityOperations().authenticateUser(connector.whoami(), new PasswordToken(pwd));
            } catch (Exception e) {
              ++exitCode;
              printException(e);
            }

            if (authFailed)
              reader.print(""Invalid password. "");
          } while (authFailed);
          lastUserActivity = System.nanoTime();
        }

        // Get the options from the command on how to parse the string
        Options parseOpts = sc.getOptionsWithHelp();

        // Parse the string using the given options
        CommandLine cl = new BasicParser().parse(parseOpts, fields);

        int actualArgLen = cl.getArgs().length;
        int expectedArgLen = sc.numArgs();
        if (cl.hasOption(helpOption)) {
          // Display help if asked to; otherwise execute the command
          sc.printHelp(this);
        } else if (expectedArgLen != NO_FIXED_ARG_LENGTH_CHECK && actualArgLen != expectedArgLen) {
          ++exitCode;
          // Check for valid number of fixed arguments (if not
          // negative; negative means it is not checked, for
          // vararg-like commands)
          printException(new IllegalArgumentException(String.format(""Expected %d argument%s. There %s %d."", expectedArgLen, expectedArgLen == 1 ? """" : ""s"",
              actualArgLen == 1 ? ""was"" : ""were"", actualArgLen)));
          sc.printHelp(this);
        } else {
          int tmpCode = sc.execute(input, cl, this);
          exitCode += tmpCode;
          reader.flush();
        }

      } catch (ConstraintViolationException e) {
        ++exitCode;
        printConstraintViolationException(e);
      } catch (TableNotFoundException e) {
        ++exitCode;
        if (getTableName().equals(e.getTableName()))
          setTableName("""");
        printException(e);
      } catch (ParseException e) {
        // not really an error if the exception is a missing required
        // option when the user is asking for help
        if (!(e instanceof MissingOptionException && (Arrays.asList(fields).contains(""-"" + helpOption) || Arrays.asList(fields).contains(""--"" + helpLongOption)))) {
          ++exitCode;
          printException(e);
        }
        if (sc != null)
          sc.printHelp(this);
      } catch (UserInterruptException e) {
        ++exitCode;
      } catch (Exception e) {
        ++exitCode;
        printException(e);
      }
    } else {
      ++exitCode;
      printException(new BadArgumentException(""Unrecognized empty command"", command, -1));
    }
    reader.flush();
  }","public void execCommand(String input, boolean ignoreAuthTimeout, boolean echoPrompt) throws IOException {
    audit.log(Level.INFO, getDefaultPrompt() + input);
    if (echoPrompt) {
      reader.print(getDefaultPrompt());
      reader.println(input);
    }

    if (input.startsWith(COMMENT_PREFIX)) {
      return;
    }

    String fields[];
    try {
      fields = new QuotedStringTokenizer(input).getTokens();
    } catch (BadArgumentException e) {
      printException(e);
      ++exitCode;
      return;
    }
    if (fields.length == 0)
      return;

    String command = fields[0];
    fields = fields.length > 1 ? Arrays.copyOfRange(fields, 1, fields.length) : new String[] {};

    Command sc = null;
    if (command.length() > 0) {
      try {
        // Obtain the command from the command table
        sc = commandFactory.get(command);
        if (sc == null) {
          reader.println(String.format(""Unknown command \""%s\"".  Enter \""help\"" for a list possible commands."", command));
          reader.flush();
          return;
        }

        long duration = System.nanoTime() - lastUserActivity;
        if (!(sc instanceof ExitCommand) && !ignoreAuthTimeout && (duration < 0 || duration > authTimeout)) {
          reader.println(""Shell has been idle for too long. Please re-authenticate."");
          boolean authFailed = true;
          do {
            String pwd = readMaskedLine(""Enter current password for '"" + connector.whoami() + ""': "", '*');
            if (pwd == null) {
              reader.println();
              return;
            } // user canceled

            try {
              authFailed = !connector.securityOperations().authenticateUser(connector.whoami(), new PasswordToken(pwd));
            } catch (Exception e) {
              ++exitCode;
              printException(e);
            }

            if (authFailed)
              reader.print(""Invalid password. "");
          } while (authFailed);
          lastUserActivity = System.nanoTime();
        }

        // Get the options from the command on how to parse the string
        Options parseOpts = sc.getOptionsWithHelp();

        // Parse the string using the given options
        CommandLine cl = new BasicParser().parse(parseOpts, fields);

        int actualArgLen = cl.getArgs().length;
        int expectedArgLen = sc.numArgs();
        if (cl.hasOption(helpOption)) {
          // Display help if asked to; otherwise execute the command
          sc.printHelp(this);
        } else if (expectedArgLen != NO_FIXED_ARG_LENGTH_CHECK && actualArgLen != expectedArgLen) {
          ++exitCode;
          // Check for valid number of fixed arguments (if not
          // negative; negative means it is not checked, for
          // vararg-like commands)
          printException(new IllegalArgumentException(String.format(""Expected %d argument%s. There %s %d."", expectedArgLen, expectedArgLen == 1 ? """" : ""s"",
              actualArgLen == 1 ? ""was"" : ""were"", actualArgLen)));
          sc.printHelp(this);
        } else {
          int tmpCode = sc.execute(input, cl, this);
          exitCode += tmpCode;
          reader.flush();
        }

      } catch (ConstraintViolationException e) {
        ++exitCode;
        printConstraintViolationException(e);
      } catch (TableNotFoundException e) {
        ++exitCode;
        if (getTableName().equals(e.getTableName()))
          setTableName("""");
        printException(e);
      } catch (ParseException e) {
        // not really an error if the exception is a missing required
        // option when the user is asking for help
        if (!(e instanceof MissingOptionException && (Arrays.asList(fields).contains(""-"" + helpOption) || Arrays.asList(fields).contains(""--"" + helpLongOption)))) {
          ++exitCode;
          printException(e);
        }
        if (sc != null)
          sc.printHelp(this);
      } catch (UserInterruptException e) {
        ++exitCode;
      } catch (Exception e) {
        ++exitCode;
        printException(e);
      }
    } else {
      ++exitCode;
      printException(new BadArgumentException(""Unrecognized empty command"", command, -1));
    }
    reader.flush();
  }",0,[0]
8930,bugs-dot-jar_OAK-1761_f37ce716,"private String diffImpl(DocumentNodeState from, DocumentNodeState to)
            throws MicroKernelException {
        JsopWriter w = new JsopStream();
        // TODO this does not work well for large child node lists
        // use a document store index instead
        int max = MANY_CHILDREN_THRESHOLD;
        DocumentNodeState.Children fromChildren, toChildren;
        fromChildren = getChildren(from, null, max);
        toChildren = getChildren(to, null, max);
        if (!fromChildren.hasMore && !toChildren.hasMore) {
            diffFewChildren(w, from.getPath(), fromChildren,
                    from.getLastRevision(), toChildren, to.getLastRevision());
        } else {
            if (FAST_DIFF) {
                diffManyChildren(w, from.getPath(),
                        from.getLastRevision(), to.getLastRevision());
            } else {
                max = Integer.MAX_VALUE;
                fromChildren = getChildren(from, null, max);
                toChildren = getChildren(to, null, max);
                diffFewChildren(w, from.getPath(), fromChildren,
                        from.getLastRevision(), toChildren, to.getLastRevision());
            }
        }
        return w.toString();
    }","private String diffImpl(DocumentNodeState from, DocumentNodeState to)
            throws MicroKernelException {
        JsopWriter w = new JsopStream();
        // TODO this does not work well for large child node lists
        // use a document store index instead
        int max = MANY_CHILDREN_THRESHOLD;
        DocumentNodeState.Children fromChildren, toChildren;
        fromChildren = getChildren(from, null, max);
        toChildren = getChildren(to, null, max);
        if (!fromChildren.hasMore && !toChildren.hasMore) {
            diffFewChildren(w, from.getPath(), fromChildren,
                    from.getLastRevision(), toChildren, to.getLastRevision());
        } else {
            if (FAST_DIFF) {
                diffManyChildren(w, from.getPath(),
                        from.getLastRevision(), to.getLastRevision());
            } else {
                max = Integer.MAX_VALUE;
                fromChildren = getChildren(from, null, max);
                toChildren = getChildren(to, null, max);
                diffFewChildren(w, from.getPath(), fromChildren,
                        from.getLastRevision(), toChildren, to.getLastRevision());
            }
        }
        return w.toString();
    }",0,[0]
25128,bugs-dot-jar_OAK-3549_9772f5b2,"public DocumentNodeStore(DocumentMK.Builder builder) {
        this.blobStore = builder.getBlobStore();
        if (builder.isUseSimpleRevision()) {
            this.simpleRevisionCounter = new AtomicInteger(0);
        }
        DocumentStore s = builder.getDocumentStore();
        if (builder.getTiming()) {
            s = new TimingDocumentStoreWrapper(s);
        }
        if (builder.getLogging()) {
            s = new LoggingDocumentStoreWrapper(s);
        }
        this.changes = Collection.JOURNAL.newDocument(s);
        this.executor = builder.getExecutor();
        this.clock = builder.getClock();

        int cid = builder.getClusterId();
        cid = Integer.getInteger(""oak.documentMK.clusterId"", cid);
        clusterNodeInfo = ClusterNodeInfo.getInstance(s, cid);
        // TODO we should ensure revisions generated from now on
        // are never ""older"" than revisions already in the repository for
        // this cluster id
        cid = clusterNodeInfo.getId();

        if (builder.getLeaseCheck()) {
            s = new LeaseCheckDocumentStoreWrapper(s, clusterNodeInfo);
            clusterNodeInfo.setLeaseFailureHandler(builder.getLeaseFailureHandler());
        }
        this.store = s;
        this.clusterId = cid;
        this.revisionComparator = new Revision.RevisionComparator(clusterId);
        this.branches = new UnmergedBranches(getRevisionComparator());
        this.asyncDelay = builder.getAsyncDelay();
        this.versionGarbageCollector = new VersionGarbageCollector(
                this, builder.createVersionGCSupport());
        this.journalGarbageCollector = new JournalGarbageCollector(this);
        this.referencedBlobs = builder.createReferencedBlobs(this);
        this.lastRevRecoveryAgent = new LastRevRecoveryAgent(this,
                builder.createMissingLastRevSeeker());
        this.disableBranches = builder.isDisableBranches();
        this.missing = new DocumentNodeState(this, ""MISSING"", new Revision(0, 0, 0)) {
            @Override
            public int getMemory() {
                return 8;
            }
        };

        //TODO Make stats collection configurable as it add slight overhead

        nodeCache = builder.buildNodeCache(this);
        nodeCacheStats = new CacheStats(nodeCache, ""Document-NodeState"",
                builder.getWeigher(), builder.getNodeCacheSize());

        nodeChildrenCache = builder.buildChildrenCache();
        nodeChildrenCacheStats = new CacheStats(nodeChildrenCache, ""Document-NodeChildren"",
                builder.getWeigher(), builder.getChildrenCacheSize());

        docChildrenCache = builder.buildDocChildrenCache();
        docChildrenCacheStats = new CacheStats(docChildrenCache, ""Document-DocChildren"",
                builder.getWeigher(), builder.getDocChildrenCacheSize());

        diffCache = builder.getDiffCache();
        checkpoints = new Checkpoints(this);

        // check if root node exists
        NodeDocument rootDoc = store.find(NODES, Utils.getIdFromPath(""/""));
        if (rootDoc == null) {
            // root node is missing: repository is not initialized
            Revision head = newRevision();
            Commit commit = new Commit(this, head, null, null);
            DocumentNodeState n = new DocumentNodeState(this, ""/"", head);
            commit.addNode(n);
            commit.applyToDocumentStore();
            // use dummy Revision as before
            commit.applyToCache(new Revision(0, 0, clusterId), false);
            setHeadRevision(commit.getRevision());
            // make sure _lastRev is written back to store
            backgroundWrite();
        } else {
            // initialize branchCommits
            branches.init(store, this);
            // initial reading of the revisions of other cluster nodes
            backgroundRead(false);
            if (headRevision == null) {
                // no revision read from other cluster nodes
                setHeadRevision(newRevision());
            }
            // check if _lastRev for our clusterId exists
            if (!rootDoc.getLastRev().containsKey(clusterId)) {
                unsavedLastRevisions.put(""/"", headRevision);
                backgroundWrite();
            }
        }
        checkLastRevRecovery();
        // Renew the lease because it may have been stale
        renewClusterIdLease();

        getRevisionComparator().add(headRevision, Revision.newRevision(0));

        dispatcher = new ChangeDispatcher(getRoot());
        commitQueue = new CommitQueue(this);
        String threadNamePostfix = ""("" + clusterId + "")"";
        batchCommitQueue = new BatchCommitQueue(store, revisionComparator);
        backgroundReadThread = new Thread(
                new BackgroundReadOperation(this, isDisposed),
                ""DocumentNodeStore background read thread "" + threadNamePostfix);
        backgroundReadThread.setDaemon(true);
        backgroundUpdateThread = new Thread(
                new BackgroundOperation(this, isDisposed),
                ""DocumentNodeStore background update thread "" + threadNamePostfix);
        backgroundUpdateThread.setDaemon(true);

        backgroundReadThread.start();
        backgroundUpdateThread.start();

        leaseUpdateThread = new Thread(new BackgroundLeaseUpdate(this, isDisposed),
                ""DocumentNodeStore lease update thread "" + threadNamePostfix);
        leaseUpdateThread.setDaemon(true);
        // OAK-3398 : make lease updating more robust by ensuring it
        // has higher likelihood of succeeding than other threads
        // on a very busy machine - so as to prevent lease timeout.
        leaseUpdateThread.setPriority(Thread.MAX_PRIORITY);
        leaseUpdateThread.start();

        this.mbean = createMBean();
        LOG.info(""Initialized DocumentNodeStore with clusterNodeId: {} ({})"", clusterId,
                getClusterNodeInfoDisplayString());
    }","public DocumentNodeStore(DocumentMK.Builder builder) {
        this.blobStore = builder.getBlobStore();
        if (builder.isUseSimpleRevision()) {
            this.simpleRevisionCounter = new AtomicInteger(0);
        }
        DocumentStore s = builder.getDocumentStore();
        if (builder.getTiming()) {
            s = new TimingDocumentStoreWrapper(s);
        }
        if (builder.getLogging()) {
            s = new LoggingDocumentStoreWrapper(s);
        }
        this.changes = Collection.JOURNAL.newDocument(s);
        this.executor = builder.getExecutor();
        this.clock = builder.getClock();

        int cid = builder.getClusterId();
        cid = Integer.getInteger(""oak.documentMK.clusterId"", cid);
        clusterNodeInfo = ClusterNodeInfo.getInstance(s, cid);
        // TODO we should ensure revisions generated from now on
        // are never ""older"" than revisions already in the repository for
        // this cluster id
        cid = clusterNodeInfo.getId();

        if (builder.getLeaseCheck()) {
            s = new LeaseCheckDocumentStoreWrapper(s, clusterNodeInfo);
            clusterNodeInfo.setLeaseFailureHandler(builder.getLeaseFailureHandler());
        }
        this.store = s;
        this.clusterId = cid;
        this.revisionComparator = new Revision.RevisionComparator(clusterId);
        this.branches = new UnmergedBranches(getRevisionComparator());
        this.asyncDelay = builder.getAsyncDelay();
        this.versionGarbageCollector = new VersionGarbageCollector(
                this, builder.createVersionGCSupport());
        this.journalGarbageCollector = new JournalGarbageCollector(this);
        this.referencedBlobs = builder.createReferencedBlobs(this);
        this.lastRevRecoveryAgent = new LastRevRecoveryAgent(this,
                builder.createMissingLastRevSeeker());
        this.disableBranches = builder.isDisableBranches();
        this.missing = new DocumentNodeState(this, ""MISSING"", new Revision(0, 0, 0)) {
            @Override
            public int getMemory() {
                return 8;
            }
        };

        //TODO Make stats collection configurable as it add slight overhead

        nodeCache = builder.buildNodeCache(this);
        nodeCacheStats = new CacheStats(nodeCache, ""Document-NodeState"",
                builder.getWeigher(), builder.getNodeCacheSize());

        nodeChildrenCache = builder.buildChildrenCache();
        nodeChildrenCacheStats = new CacheStats(nodeChildrenCache, ""Document-NodeChildren"",
                builder.getWeigher(), builder.getChildrenCacheSize());

        docChildrenCache = builder.buildDocChildrenCache();
        docChildrenCacheStats = new CacheStats(docChildrenCache, ""Document-DocChildren"",
                builder.getWeigher(), builder.getDocChildrenCacheSize());

        diffCache = builder.getDiffCache();
        checkpoints = new Checkpoints(this);

        // check if root node exists
        NodeDocument rootDoc = store.find(NODES, Utils.getIdFromPath(""/""));
        if (rootDoc == null) {
            // root node is missing: repository is not initialized
            Revision head = newRevision();
            Commit commit = new Commit(this, head, null, null);
            DocumentNodeState n = new DocumentNodeState(this, ""/"", head);
            commit.addNode(n);
            commit.applyToDocumentStore();
            // use dummy Revision as before
            commit.applyToCache(new Revision(0, 0, clusterId), false);
            setHeadRevision(commit.getRevision());
            // make sure _lastRev is written back to store
            backgroundWrite();
            rootDoc = store.find(NODES, Utils.getIdFromPath(""/""));
            // at this point the root document must exist
            if (rootDoc == null) {
                throw new IllegalStateException(""Root document does not exist"");
            }
        } else {
            checkLastRevRecovery();
            initializeHeadRevision(rootDoc);
            // check if _lastRev for our clusterId exists
            if (!rootDoc.getLastRev().containsKey(clusterId)) {
                unsavedLastRevisions.put(""/"", headRevision);
                backgroundWrite();
            }
        }

        // Renew the lease because it may have been stale
        renewClusterIdLease();

        getRevisionComparator().add(headRevision, Revision.newRevision(0));

        // initialize branchCommits
        branches.init(store, this);

        dispatcher = new ChangeDispatcher(getRoot());
        commitQueue = new CommitQueue(this);
        String threadNamePostfix = ""("" + clusterId + "")"";
        batchCommitQueue = new BatchCommitQueue(store, revisionComparator);
        backgroundReadThread = new Thread(
                new BackgroundReadOperation(this, isDisposed),
                ""DocumentNodeStore background read thread "" + threadNamePostfix);
        backgroundReadThread.setDaemon(true);
        backgroundUpdateThread = new Thread(
                new BackgroundOperation(this, isDisposed),
                ""DocumentNodeStore background update thread "" + threadNamePostfix);
        backgroundUpdateThread.setDaemon(true);

        backgroundReadThread.start();
        backgroundUpdateThread.start();

        leaseUpdateThread = new Thread(new BackgroundLeaseUpdate(this, isDisposed),
                ""DocumentNodeStore lease update thread "" + threadNamePostfix);
        leaseUpdateThread.setDaemon(true);
        // OAK-3398 : make lease updating more robust by ensuring it
        // has higher likelihood of succeeding than other threads
        // on a very busy machine - so as to prevent lease timeout.
        leaseUpdateThread.setPriority(Thread.MAX_PRIORITY);
        leaseUpdateThread.start();

        this.mbean = createMBean();
        LOG.info(""Initialized DocumentNodeStore with clusterNodeId: {} ({})"", clusterId,
                getClusterNodeInfoDisplayString());
    }",1,"[78, 79, 80, 81, 82, 83, 84, 85, 93]"
18806,bugs-dot-jar_OAK-2427_e6d4f9a6,"public void setColumnSelector(Selector columnSelector) {
        this.columnSelector = columnSelector;
    }","public void setColumnSelector(Selector columnSelector) {
        this.columnSelector = columnSelector;
    }",0,[0]
39988,bugs-dot-jar_MATH-405_784e4f69,"public void setCostRelativeTolerance(double costRelativeTolerance) {
        this.costRelativeTolerance = costRelativeTolerance;
    }","public void setCostRelativeTolerance(double costRelativeTolerance) {
        this.costRelativeTolerance = costRelativeTolerance;
    }",0,[0]
40561,bugs-dot-jar_WICKET-442_246d53c5,"protected RequestCycle(final Session session, final Request request, final Response response)
	{
		this.application = session.getApplication();
		this.session = session;
		this.request = request;
		this.response = response;
		this.originalResponse = response;
		this.processor = safeGetRequestProcessor();

		// Set this RequestCycle into ThreadLocal variable
		current.set(this);
	}","protected RequestCycle(final Session session, final Request request, final Response response)
	{
		this.application = session.getApplication();
		this.session = session;
		this.request = request;
		this.response = response;
		this.originalResponse = response;
		this.processor = safeGetRequestProcessor();

		// Set this RequestCycle into ThreadLocal variable
		current.set(this);
	}",0,[0]
38673,bugs-dot-jar_ACCUMULO-2487_f2920c26,"public Value() {
    super();
  }","public Value() {
    this(EMPTY, false);
  }",1,[1]
8359,bugs-dot-jar_ACCUMULO-366_db4a291f,public ArticleExtractor() {},public ArticleExtractor() {},0,[0]
31825,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"public void putDelete(CharSequence columnFamily, CharSequence columnQualifier, long timestamp) {
    put(columnFamily, columnQualifier, EMPTY_BYTES, true, timestamp, true, EMPTY_BYTES);
  }","public void putDelete(CharSequence columnFamily, CharSequence columnQualifier, long timestamp) {
    put(columnFamily, columnQualifier, EMPTY_BYTES, true, timestamp, true, EMPTY_BYTES);
  }",0,[0]
26886,bugs-dot-jar_WICKET-5724_b92591f6,"public final boolean getFlag(final int flag)
	{
		return (flags & flag) != 0;
	}","public final boolean getFlag(final int flag)
	{
		return (flags & flag) != 0;
	}",0,[0]
40696,bugs-dot-jar_WICKET-442_246d53c5,"public void updateFeedback()
	{
		// Get the messages for the current page
		visible = getPage().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;
	}","public void updateFeedback()
	{
		// Get the messages for the current page
		visible = Session.get().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;
	}",1,[3]
1526,Bears-180,"@Override
	public String getDescription() {
		return this.location;
	}","@Override
	public String getDescription() {
		return this.location;
	}",0,[0]
40322,bugs-dot-jar_LOG4J2-219_ed951c76,"@Override
    public void stop() {
        // Stop the appenders in reverse order in case they still have activity.
        final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);
        for (int i = array.length - 1; i >= 0; --i) {
            array[i].stop();
        }
        for (final LoggerConfig logger : loggers.values()) {
            logger.clearAppenders();
            logger.stopFilter();
        }
        root.stopFilter();
        stopFilter();
    }","@Override
    public void stop() {
        // Stop the appenders in reverse order in case they still have activity.
        final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);
        for (int i = array.length - 1; i >= 0; --i) {
            array[i].stop();
        }
        for (final LoggerConfig logger : loggers.values()) {
            logger.clearAppenders();
            logger.stopFilter();
        }
        root.stopFilter();
        stopFilter();
    }",0,[0]
20456,bugs-dot-jar_WICKET-128_7e1000dd,"public final void touch(Page page)
	{
		// Touch the page in its pagemap.
		page.getPageMap().put(page);
	}","public final void touch(Page page)
	{
		// Touch the page in its pagemap.
		page.getPageMap().put(page);
	}",0,[0]
4281,bugs-dot-jar_CAMEL-4682_1e54865c,"public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {
        this.interceptStrategies = interceptStrategies;
    }","public void setInterceptStrategies(List<InterceptStrategy> interceptStrategies) {
        this.interceptStrategies = interceptStrategies;
    }",0,[0]
29065,bugs-dot-jar_ACCUMULO-1514_fb25913c,"public static FileSystemManager generateVfs() throws FileSystemException {
    DefaultFileSystemManager vfs = new FinalCloseDefaultFileSystemManager();
    vfs.addProvider(""res"", new org.apache.commons.vfs2.provider.res.ResourceFileProvider());
    vfs.addProvider(""zip"", new org.apache.commons.vfs2.provider.zip.ZipFileProvider());
    vfs.addProvider(""gz"", new org.apache.commons.vfs2.provider.gzip.GzipFileProvider());
    vfs.addProvider(""ram"", new org.apache.commons.vfs2.provider.ram.RamFileProvider());
    vfs.addProvider(""file"", new org.apache.commons.vfs2.provider.local.DefaultLocalFileProvider());
    vfs.addProvider(""jar"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""http"", new org.apache.commons.vfs2.provider.http.HttpFileProvider());
    vfs.addProvider(""https"", new org.apache.commons.vfs2.provider.https.HttpsFileProvider());
    vfs.addProvider(""ftp"", new org.apache.commons.vfs2.provider.ftp.FtpFileProvider());
    vfs.addProvider(""ftps"", new org.apache.commons.vfs2.provider.ftps.FtpsFileProvider());
    vfs.addProvider(""war"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""par"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""ear"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""sar"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""ejb3"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""tmp"", new org.apache.commons.vfs2.provider.temp.TemporaryFileProvider());
    vfs.addProvider(""tar"", new org.apache.commons.vfs2.provider.tar.TarFileProvider());
    vfs.addProvider(""tbz2"", new org.apache.commons.vfs2.provider.tar.TarFileProvider());
    vfs.addProvider(""tgz"", new org.apache.commons.vfs2.provider.tar.TarFileProvider());
    vfs.addProvider(""bz2"", new org.apache.commons.vfs2.provider.bzip2.Bzip2FileProvider());
    vfs.addProvider(""hdfs"", new HdfsFileProvider());
    vfs.addExtensionMap(""jar"", ""jar"");
    vfs.addExtensionMap(""zip"", ""zip"");
    vfs.addExtensionMap(""gz"", ""gz"");
    vfs.addExtensionMap(""tar"", ""tar"");
    vfs.addExtensionMap(""tbz2"", ""tar"");
    vfs.addExtensionMap(""tgz"", ""tar"");
    vfs.addExtensionMap(""bz2"", ""bz2"");
    vfs.addMimeTypeMap(""application/x-tar"", ""tar"");
    vfs.addMimeTypeMap(""application/x-gzip"", ""gz"");
    vfs.addMimeTypeMap(""application/zip"", ""zip"");
    vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());
    vfs.setFilesCache(new SoftRefFilesCache());
    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, """");
    File cacheDir = new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + System.getProperty(""user.name"", ""nouser""));
    if (!("""".equals(cacheDirPath)))
      cacheDir = new File(cacheDirPath);
    vfs.setReplicator(new UniqueFileReplicator(cacheDir));
    vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);
    vfs.init();
    vfsInstances.add(new WeakReference<DefaultFileSystemManager>(vfs));
    return vfs;
  }","public static FileSystemManager generateVfs() throws FileSystemException {
    DefaultFileSystemManager vfs = new FinalCloseDefaultFileSystemManager();
    vfs.addProvider(""res"", new org.apache.commons.vfs2.provider.res.ResourceFileProvider());
    vfs.addProvider(""zip"", new org.apache.commons.vfs2.provider.zip.ZipFileProvider());
    vfs.addProvider(""gz"", new org.apache.commons.vfs2.provider.gzip.GzipFileProvider());
    vfs.addProvider(""ram"", new org.apache.commons.vfs2.provider.ram.RamFileProvider());
    vfs.addProvider(""file"", new org.apache.commons.vfs2.provider.local.DefaultLocalFileProvider());
    vfs.addProvider(""jar"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""http"", new org.apache.commons.vfs2.provider.http.HttpFileProvider());
    vfs.addProvider(""https"", new org.apache.commons.vfs2.provider.https.HttpsFileProvider());
    vfs.addProvider(""ftp"", new org.apache.commons.vfs2.provider.ftp.FtpFileProvider());
    vfs.addProvider(""ftps"", new org.apache.commons.vfs2.provider.ftps.FtpsFileProvider());
    vfs.addProvider(""war"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""par"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""ear"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""sar"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""ejb3"", new org.apache.commons.vfs2.provider.jar.JarFileProvider());
    vfs.addProvider(""tmp"", new org.apache.commons.vfs2.provider.temp.TemporaryFileProvider());
    vfs.addProvider(""tar"", new org.apache.commons.vfs2.provider.tar.TarFileProvider());
    vfs.addProvider(""tbz2"", new org.apache.commons.vfs2.provider.tar.TarFileProvider());
    vfs.addProvider(""tgz"", new org.apache.commons.vfs2.provider.tar.TarFileProvider());
    vfs.addProvider(""bz2"", new org.apache.commons.vfs2.provider.bzip2.Bzip2FileProvider());
    vfs.addProvider(""hdfs"", new HdfsFileProvider());
    vfs.addExtensionMap(""jar"", ""jar"");
    vfs.addExtensionMap(""zip"", ""zip"");
    vfs.addExtensionMap(""gz"", ""gz"");
    vfs.addExtensionMap(""tar"", ""tar"");
    vfs.addExtensionMap(""tbz2"", ""tar"");
    vfs.addExtensionMap(""tgz"", ""tar"");
    vfs.addExtensionMap(""bz2"", ""bz2"");
    vfs.addMimeTypeMap(""application/x-tar"", ""tar"");
    vfs.addMimeTypeMap(""application/x-gzip"", ""gz"");
    vfs.addMimeTypeMap(""application/zip"", ""zip"");
    vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());
    vfs.setFilesCache(new SoftRefFilesCache());
    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, """");
    File cacheDir = new File(System.getProperty(""java.io.tmpdir""), ""accumulo-vfs-cache-"" + System.getProperty(""user.name"", ""nouser""));
    if (!("""".equals(cacheDirPath)))
      cacheDir = new File(cacheDirPath);
    vfs.setReplicator(new UniqueFileReplicator(cacheDir));
    vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);
    vfs.init();
    vfsInstances.add(new WeakReference<DefaultFileSystemManager>(vfs));
    return vfs;
  }",0,[0]
1715,Bears-197,"public URIBuilder setEncode(boolean encode) {
        this.encode = encode;
        return this;
    }","public URIBuilder setEncode(boolean encode) {
        this.encode = encode;
        return this;
    }",0,[0]
30628,bugs-dot-jar_CAMEL-3531_41e4b5b9,"public static String getDefaultCharacterSet() {
        return Charset.defaultCharset().name();
    }","public static String getDefaultCharacterSet() {
        return Charset.defaultCharset().name();
    }",0,[0]
1708,Bears-197,"private static boolean isIPv6Address(final String input) {
        return IPV6_STD_PATTERN.matcher(input).matches();
    }","private static boolean isIPv6Address(final String input) {
        return IPV6_STD_PATTERN.matcher(input).matches();
    }",0,[0]
1698,Bears-197,"public static int toInt(final String str, final int defaultValue) {
        if(str == null) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(str);
        } catch (final NumberFormatException nfe) {
            return defaultValue;
        }
    }","public static int toInt(final String str, final int defaultValue) {
        if(str == null) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(str);
        } catch (final NumberFormatException nfe) {
            return defaultValue;
        }
    }",0,[0]
37645,bugs-dot-jar_MATH-288_38983e82,"@Override
    public RealPointValuePair doOptimize()
        throws OptimizationException {
        final SimplexTableau tableau =
            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
        solvePhase1(tableau);
        tableau.discardArtificialVariables();
        while (!isOptimal(tableau)) {
            doIteration(tableau);
        }
        return tableau.getSolution();
    }","@Override
    public RealPointValuePair doOptimize()
        throws OptimizationException {
        final SimplexTableau tableau =
            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
        solvePhase1(tableau);
        tableau.discardArtificialVariables();
        while (!isOptimal(tableau)) {
            doIteration(tableau);
        }
        return tableau.getSolution();
    }",0,[0]
27792,bugs-dot-jar_CAMEL-8053_cac72b14,"@Override
    public ErrorHandlerBuilder cloneBuilder() {
        ErrorHandlerBuilderRef answer = new ErrorHandlerBuilderRef(ref);
        cloneBuilder(answer);
        return answer;
    }","@Override
    public ErrorHandlerBuilder cloneBuilder() {
        ErrorHandlerBuilderRef answer = new ErrorHandlerBuilderRef(ref);
        cloneBuilder(answer);
        return answer;
    }",0,[0]
39189,bugs-dot-jar_OAK-4353_b0014b7d,"public RecordType getRootType(int index) {
        int refCount = getRefCount();
        checkArgument(index < getRootCount());
        return RecordType.values()[data.get(data.position() + refCount * 16 + index * 3) & 0xff];
    }","public RecordType getRootType(int index) {
        int refCount = getRefCount();
        checkArgument(index < getRootCount());
        return RecordType.values()[data.get(data.position() + refCount * 16 + index * 3) & 0xff];
    }",0,[0]
22657,bugs-dot-jar_WICKET-5204_9e6efa61,"protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel)
	{
		return DateTextField.forShortStyle(id, dateFieldModel, false);
	}","protected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel)
	{
		return DateTextField.forShortStyle(id, dateFieldModel, false);
	}",0,[0]
957,Bears-126,"private void sendPhotoRequest(Channel channel, int pictureId) {
        if (channel != null) {
            ChannelBuffer photo = photos.get(pictureId);
            ChannelBuffer response = ChannelBuffers.dynamicBuffer();
            response.writeShort(0x7878); // header
            response.writeByte(15); // size
            response.writeByte(MSG_X1_PHOTO_DATA);
            response.writeInt(pictureId);
            response.writeInt(photo.writerIndex());
            response.writeShort(Math.min(photo.writableBytes(), 1024));
            response.writeShort(++serverIndex);
            response.writeShort(Checksum.crc16(Checksum.CRC16_X25,
                    response.toByteBuffer(2, response.writerIndex() - 2)));
            response.writeByte('\r'); response.writeByte('\n'); // ending
            channel.write(response);
        }
    }","private void sendPhotoRequest(Channel channel, int pictureId) {
        if (channel != null) {
            ChannelBuffer photo = photos.get(pictureId);
            ChannelBuffer response = ChannelBuffers.dynamicBuffer();
            response.writeShort(0x7878); // header
            response.writeByte(15); // size
            response.writeByte(MSG_X1_PHOTO_DATA);
            response.writeInt(pictureId);
            response.writeInt(photo.writerIndex());
            response.writeShort(Math.min(photo.writableBytes(), 1024));
            response.writeShort(++serverIndex);
            response.writeShort(Checksum.crc16(Checksum.CRC16_X25,
                    response.toByteBuffer(2, response.writerIndex() - 2)));
            response.writeByte('\r'); response.writeByte('\n'); // ending
            channel.write(response);
        }
    }",0,[0]
276,bugs-dot-jar_OAK-2250_08b25cb0,"private static Set<String> toLowerCase(Set<String> values){
        Set<String> result = newHashSet();
        for(String val : values){
            result.add(val.toLowerCase());
        }
        return ImmutableSet.copyOf(result);
    }","private static Set<String> toLowerCase(Set<String> values){
        Set<String> result = newHashSet();
        for(String val : values){
            result.add(val.toLowerCase());
        }
        return ImmutableSet.copyOf(result);
    }",0,[0]
1306,Bears-158,"private Cell getOrCreateCell(ColumnType type) {
        Integer index = mapping.getIndex(type);
        if (index == null)
            return null;
        Cell cell = row.getCell(index);
        if (cell == null) {
            cell = row.createCell(index, type.getCellType());

            if(type.equals(Time)) {
                Workbook workbook = row.getSheet().getWorkbook();
                CellStyle cellStyle = workbook.createCellStyle();
                CreationHelper createHelper = workbook.getCreationHelper();
                cellStyle.setDataFormat(createHelper.createDataFormat().getFormat(""m/d/yy h:mm""));
                cell.setCellStyle(cellStyle);
            }
        }
        return cell;
    }","private Cell getOrCreateCell(ColumnType type) {
        Integer index = mapping.getIndex(type);
        if (index == null)
            return null;
        Cell cell = row.getCell(index);
        if (cell == null) {
            cell = row.createCell(index, type.getCellType());

            if(type.equals(Time)) {
                Workbook workbook = row.getSheet().getWorkbook();
                CellStyle cellStyle = workbook.createCellStyle();
                CreationHelper createHelper = workbook.getCreationHelper();
                cellStyle.setDataFormat(createHelper.createDataFormat().getFormat(""m/d/yy h:mm""));
                cell.setCellStyle(cellStyle);
            }
        }
        return cell;
    }",0,[0]
39569,bugs-dot-jar_OAK-1674_073b814c,"@Nonnull
    public NodeState getNodeState() {
        return nodeBuilder.getNodeState();
    }","@Nonnull
    public NodeState getNodeState() {
        return nodeBuilder.getNodeState();
    }",0,[0]
17909,bugs-dot-jar_WICKET-3304_7e7ab76c,"public final FormComponent<T> setConvertEmptyInputStringToNull(boolean flag)
	{
		setFlag(FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL, flag);
		return this;
	}","public final FormComponent<T> setConvertEmptyInputStringToNull(boolean flag)
	{
		setFlag(FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL, flag);
		return this;
	}",0,[0]
25856,bugs-dot-jar_CAMEL-6723_b92d6237,"public static Exchange copyExchangeAndSetCamelContext(Exchange exchange, CamelContext context, boolean handover) {
        DefaultExchange answer = new DefaultExchange(context, exchange.getPattern());
        if (exchange.hasProperties()) {
            answer.setProperties(safeCopy(exchange.getProperties()));
        }
        if (handover) {
            // Need to hand over the completion for async invocation
            exchange.handoverCompletions(answer);
        }
        answer.setIn(exchange.getIn().copy());
        if (exchange.hasOut()) {
            answer.setOut(exchange.getOut().copy());
        }
        answer.setException(exchange.getException());
        return answer;
    }","public static Exchange copyExchangeAndSetCamelContext(Exchange exchange, CamelContext context, boolean handover) {
        DefaultExchange answer = new DefaultExchange(context, exchange.getPattern());
        if (exchange.hasProperties()) {
            answer.setProperties(safeCopy(exchange.getProperties()));
        }
        if (handover) {
            // Need to hand over the completion for async invocation
            exchange.handoverCompletions(answer);
        }
        answer.setIn(exchange.getIn().copy());
        if (exchange.hasOut()) {
            answer.setOut(exchange.getOut().copy());
        }
        answer.setException(exchange.getException());
        return answer;
    }",0,[0]
1369,Bears-160,"protected void parseAlterUnknown(Marker start) {
        consumeRemainingStatement(start);
        debugSkipped(start);
    }","protected void parseAlterUnknown(Marker start) {
        consumeRemainingStatement(start);
        debugSkipped(start);
    }",0,[0]
28679,bugs-dot-jar_FLINK-2734_8b40bb7a,"public StreamExecutionEnvironment setStateHandleProvider(StateHandleProvider<?> provider) {
		this.stateHandleProvider = provider;
		return this;
	}","public StreamExecutionEnvironment setStateHandleProvider(StateHandleProvider<?> provider) {
		this.stateHandleProvider = provider;
		return this;
	}",0,[0]
3185,bugs-dot-jar_WICKET-3767_84c3baac,"public static final <R> R visitComponentsPostOrder(Component component,
		final org.apache.wicket.util.visit.IVisitor<Component, R> visitor)
	{
		if (visitor == null)
		{
			throw new IllegalArgumentException(""Argument `visitor` cannot be null"");
		}

		return Visits.visitPostOrder(component, visitor, new IVisitFilter()
		{
			public boolean visitObject(Object object)
			{
				return true;
			}

			public boolean visitChildren(Object object)
			{
				if (object instanceof IFormVisitorParticipant)
				{
					return ((IFormVisitorParticipant)object).processChildren();
				}
				return true;
			}

		});
	}","public static final <R> R visitComponentsPostOrder(Component component,
		final org.apache.wicket.util.visit.IVisitor<Component, R> visitor)
	{
		if (visitor == null)
		{
			throw new IllegalArgumentException(""Argument `visitor` cannot be null"");
		}

		return Visits.visitPostOrder(component, visitor, new IVisitFilter()
		{
			public boolean visitObject(Object object)
			{
				return true;
			}

			public boolean visitChildren(Object object)
			{
				if (object instanceof IFormVisitorParticipant)
				{
					return ((IFormVisitorParticipant)object).processChildren();
				}
				return true;
			}

		});
	}",0,[0]
39564,bugs-dot-jar_OAK-1111_459bd065,"public void copy(NodeId id, NodeBuilder builder)
            throws RepositoryException, IOException {
        try {
            NodeState node = source.load(id);
            copy(node, builder);

            for (ChildNodeEntry entry : node.getChildNodeEntries()) {
                NodeId childId = entry.getId();
                if (!exclude.contains(childId)) {
                    exclude.add(childId);
                    String name = getOakName(entry.getName());
                    copy(childId, builder.child(name));
                    exclude.remove(childId);
                }
            }
        } catch (ItemStateException e) {
            throw new RepositoryException(""Unable to copy "" + id, e);
        }
    }","public void copy(NodeId id, NodeBuilder builder)
            throws RepositoryException, IOException {
        try {
            NodeState node = source.load(id);
            copy(node, builder);

            for (ChildNodeEntry entry : node.getChildNodeEntries()) {
                NodeId childId = entry.getId();
                if (!exclude.contains(childId)) {
                    exclude.add(childId);
                    String name = getOakName(entry.getName());
                    copy(childId, builder.child(name));
                    exclude.remove(childId);
                }
            }
        } catch (ItemStateException e) {
            throw new RepositoryException(""Unable to copy "" + id, e);
        }
    }",0,[0]
7722,bugs-dot-jar_OAK-1104_7ae92779,"public int getHash() {
        return MapRecord.getHash(name);
    }","public int getHash() {
        return MapRecord.getHash(name);
    }",0,[0]
32466,bugs-dot-jar_OAK-926_e1ae968c,"public SortedMap<Revision, Revision> getUncommittedRevisions(RevisionContext context) {
        // only look at revisions in this document.
        // uncommitted revisions are not split off
        Map<String, String> valueMap = getLocalRevisions();
        SortedMap<Revision, Revision> revisions =
                new TreeMap<Revision, Revision>(context.getRevisionComparator());
        for (Map.Entry<String, String> commit : valueMap.entrySet()) {
            if (!Utils.isCommitted(commit.getValue())) {
                Revision r = Revision.fromString(commit.getKey());
                if (r.getClusterId() == context.getClusterId()) {
                    Revision b = Revision.fromString(commit.getValue());
                    revisions.put(r, b);
                }
            }
        }
        return revisions;
    }","public SortedMap<Revision, Revision> getUncommittedRevisions(RevisionContext context) {
        // only look at revisions in this document.
        // uncommitted revisions are not split off
        Map<String, String> valueMap = getLocalRevisions();
        SortedMap<Revision, Revision> revisions =
                new TreeMap<Revision, Revision>(context.getRevisionComparator());
        for (Map.Entry<String, String> commit : valueMap.entrySet()) {
            if (!Utils.isCommitted(commit.getValue())) {
                Revision r = Revision.fromString(commit.getKey());
                if (r.getClusterId() == context.getClusterId()) {
                    Revision b = Revision.fromString(commit.getValue());
                    revisions.put(r, b);
                }
            }
        }
        return revisions;
    }",0,[0]
977,bugs-dot-jar_LOG4J2-1067_4786a739,"private void formatElements(final StringBuilder sb, final int commonCount, final StackTraceElement[] causedTrace,
            final ExtendedStackTraceElement[] extStackTrace, final List<String> ignorePackages) {
        if (ignorePackages == null || ignorePackages.isEmpty()) {
            for (final ExtendedStackTraceElement element : extStackTrace) {
                this.formatEntry(element, sb);
            }
        } else {
            int count = 0;
            for (int i = 0; i < extStackTrace.length; ++i) {
                if (!this.ignoreElement(causedTrace[i], ignorePackages)) {
                    if (count > 0) {
                        appendSuppressedCount(sb, count);
                        count = 0;
                    }
                    this.formatEntry(extStackTrace[i], sb);
                } else {
                    ++count;
                }
            }
            if (count > 0) {
                appendSuppressedCount(sb, count);
            }
        }
        if (commonCount != 0) {
            sb.append(""\t... "").append(commonCount).append("" more"").append(EOL);
        }
    }","private void formatElements(final StringBuilder sb, final int commonCount, final StackTraceElement[] causedTrace,
            final ExtendedStackTraceElement[] extStackTrace, final List<String> ignorePackages) {
        if (ignorePackages == null || ignorePackages.isEmpty()) {
            for (final ExtendedStackTraceElement element : extStackTrace) {
                this.formatEntry(element, sb);
            }
        } else {
            int count = 0;
            for (int i = 0; i < extStackTrace.length; ++i) {
                if (!this.ignoreElement(causedTrace[i], ignorePackages)) {
                    if (count > 0) {
                        appendSuppressedCount(sb, count);
                        count = 0;
                    }
                    this.formatEntry(extStackTrace[i], sb);
                } else {
                    ++count;
                }
            }
            if (count > 0) {
                appendSuppressedCount(sb, count);
            }
        }
        if (commonCount != 0) {
            sb.append(""\t... "").append(commonCount).append("" more"").append(EOL);
        }
    }",0,[0]
23997,bugs-dot-jar_OAK-579_7d72e6ed,"@Override
    public String toString() {
        StringBuilder buff = new StringBuilder();
        buff.append(""select "");
        int i = 0;
        for (ColumnImpl c : columns) {
            if (i++ > 0) {
                buff.append("", "");
            }
            buff.append(c);
        }
        buff.append("" from "").append(source);
        if (constraint != null) {
            buff.append("" where "").append(constraint);
        }
        if (orderings != null) {
            buff.append("" order by "");
            i = 0;
            for (OrderingImpl o : orderings) {
                if (i++ > 0) {
                    buff.append("", "");
                }
                buff.append(o);
            }
        }
        return buff.toString();
    }","@Override
    public String toString() {
        StringBuilder buff = new StringBuilder();
        buff.append(""select "");
        int i = 0;
        for (ColumnImpl c : columns) {
            if (i++ > 0) {
                buff.append("", "");
            }
            buff.append(c);
        }
        buff.append("" from "").append(source);
        if (constraint != null) {
            buff.append("" where "").append(constraint);
        }
        if (orderings != null) {
            buff.append("" order by "");
            i = 0;
            for (OrderingImpl o : orderings) {
                if (i++ > 0) {
                    buff.append("", "");
                }
                buff.append(o);
            }
        }
        return buff.toString();
    }",0,[0]
14424,bugs-dot-jar_CAMEL-8954_7b1253db,"private boolean sleep() {
        LOG.trace(""Exclusive read lock not granted. Sleeping for {} millis."", checkInterval);
        try {
            Thread.sleep(checkInterval);
            return false;
        } catch (InterruptedException e) {
            LOG.debug(""Sleep interrupted while waiting for exclusive read lock, so breaking out"");
            return true;
        }
    }","private boolean sleep() {
        LOG.trace(""Exclusive read lock not granted. Sleeping for {} millis."", checkInterval);
        try {
            Thread.sleep(checkInterval);
            return false;
        } catch (InterruptedException e) {
            LOG.debug(""Sleep interrupted while waiting for exclusive read lock, so breaking out"");
            return true;
        }
    }",0,[0]
1995,Bears-245,"private ParameterSpec(Builder builder) {
    this.name = checkNotNull(builder.name, ""name == null"");
    this.annotations = Util.immutableList(builder.annotations);
    this.modifiers = Util.immutableSet(builder.modifiers);
    this.type = checkNotNull(builder.type, ""type == null"");
  }","private ParameterSpec(Builder builder) {
    this.name = checkNotNull(builder.name, ""name == null"");
    this.annotations = Util.immutableList(builder.annotations);
    this.modifiers = Util.immutableSet(builder.modifiers);
    this.type = checkNotNull(builder.type, ""type == null"");
  }",0,[0]
2113,bugs-dot-jar_WICKET-2961_3d8c9d75,"public final <C extends Page> CharSequence urlFor(final Class<C> pageClass,
		final PageParameters parameters)
	{
		IRequestHandler handler = new BookmarkablePageRequestHandler(new PageProvider(pageClass,
			parameters));
		return getRequestCycle().renderUrlFor(handler);
	}","public final <C extends Page> CharSequence urlFor(final Class<C> pageClass,
		final PageParameters parameters)
	{
		IRequestHandler handler = new BookmarkablePageRequestHandler(new PageProvider(pageClass,
			parameters));
		return getRequestCycle().renderUrlFor(handler);
	}",0,[0]
9814,bugs-dot-jar_OAK-3634_90ad50da,"@Override
    public <T extends Document> T getIfCached(Collection<T> collection, String key) {
        if (collection != Collection.NODES) {
            return null;
        }
        @SuppressWarnings(""unchecked"")
        T doc = (T) nodesCache.getIfPresent(key);
        return doc;
    }","@Override
    public <T extends Document> T getIfCached(Collection<T> collection, String key) {
        if (collection != Collection.NODES) {
            return null;
        }
        @SuppressWarnings(""unchecked"")
        T doc = (T) nodesCache.getIfPresent(key);
        return doc;
    }",0,[0]
35973,bugs-dot-jar_CAMEL-9444_baece126,"public MulticastDefinition aggregationStrategyMethodName(String methodName) {
        setStrategyMethodName(methodName);
        return this;
    }","public MulticastDefinition aggregationStrategyMethodName(String methodName) {
        setStrategyMethodName(methodName);
        return this;
    }",0,[0]
39443,bugs-dot-jar_FLINK-3760_494212b3,"public boolean isSerializerInitialized() {
		return serializer != null;
	}","public boolean isSerializerInitialized() {
		return serializer != null;
	}",0,[0]
21040,bugs-dot-jar_OAK-846_7acb091a,"boolean isValidRevision(@Nonnull Revision rev,
                            @Nonnull Revision readRevision,
                            @Nonnull Map<String, Object> nodeMap,
                            @Nonnull Set<Revision> validRevisions) {
        if (validRevisions.contains(rev)) {
            return true;
        }
        @SuppressWarnings(""unchecked"")
        Map<String, String> revisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);
        if (isCommitted(rev, readRevision, revisions)) {
            validRevisions.add(rev);
            return true;
        } else if (revisions != null && revisions.containsKey(rev.toString())) {
            // rev is in revisions map of this node, but not committed
            // no need to check _commitRoot field
            return false;
        }
        // check commit root
        @SuppressWarnings(""unchecked"")
        Map<String, Integer> commitRoot = (Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT);
        String commitRootPath = null;
        if (commitRoot != null) {
            Integer depth = commitRoot.get(rev.toString());
            if (depth != null) {
                String p = Utils.getPathFromId((String) nodeMap.get(UpdateOp.ID));
                commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);
            }
        }
        if (commitRootPath == null) {
            // shouldn't happen, either node is commit root for a revision
            // or has a reference to the commit root
            LOG.warn(""Node {} does not have commit root reference for revision {}"",
                    nodeMap.get(UpdateOp.ID), rev);
            LOG.warn(nodeMap.toString());
            return false;
        }
        // get root of commit
        nodeMap = store.find(DocumentStore.Collection.NODES, 
                Utils.getIdFromPath(commitRootPath));
        if (nodeMap == null) {
            return false;
        }
        @SuppressWarnings(""unchecked"")
        Map<String, String> rootRevisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);
        if (isCommitted(rev, readRevision, rootRevisions)) {
            validRevisions.add(rev);
            return true;
        }
        return false;
    }","boolean isValidRevision(@Nonnull Revision rev,
                            @Nonnull Revision readRevision,
                            @Nonnull Map<String, Object> nodeMap,
                            @Nonnull Set<Revision> validRevisions) {
        if (validRevisions.contains(rev)) {
            return true;
        }
        @SuppressWarnings(""unchecked"")
        Map<String, String> revisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);
        if (isCommitted(rev, readRevision, revisions)) {
            validRevisions.add(rev);
            return true;
        } else if (revisions != null && revisions.containsKey(rev.toString())) {
            // rev is in revisions map of this node, but not committed
            // no need to check _commitRoot field
            return false;
        }
        // check commit root
        @SuppressWarnings(""unchecked"")
        Map<String, Integer> commitRoot = (Map<String, Integer>) nodeMap.get(UpdateOp.COMMIT_ROOT);
        String commitRootPath = null;
        if (commitRoot != null) {
            Integer depth = commitRoot.get(rev.toString());
            if (depth != null) {
                String p = Utils.getPathFromId((String) nodeMap.get(UpdateOp.ID));
                commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);
            }
        }
        if (commitRootPath == null) {
            // shouldn't happen, either node is commit root for a revision
            // or has a reference to the commit root
            LOG.warn(""Node {} does not have commit root reference for revision {}"",
                    nodeMap.get(UpdateOp.ID), rev);
            LOG.warn(nodeMap.toString());
            return false;
        }
        // get root of commit
        nodeMap = store.find(DocumentStore.Collection.NODES, 
                Utils.getIdFromPath(commitRootPath));
        if (nodeMap == null) {
            return false;
        }
        @SuppressWarnings(""unchecked"")
        Map<String, String> rootRevisions = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);
        if (isCommitted(rev, readRevision, rootRevisions)) {
            validRevisions.add(rev);
            return true;
        }
        return false;
    }",0,[0]
8474,bugs-dot-jar_ACCUMULO-366_db4a291f,"public void addLoggersToMetadata(List<RemoteLogger> logs, KeyExtent extent, int id) {
    log.info(""Adding "" + logs.size() + "" logs for extent "" + extent + "" as alias "" + id);
    
    List<MetadataTable.LogEntry> entries = new ArrayList<MetadataTable.LogEntry>();
    long now = RelativeTime.currentTimeMillis();
    List<String> logSet = new ArrayList<String>();
    for (RemoteLogger log : logs)
      logSet.add(log.toString());
    for (RemoteLogger log : logs) {
      MetadataTable.LogEntry entry = new MetadataTable.LogEntry();
      entry.extent = extent;
      entry.tabletId = id;
      entry.timestamp = now;
      entry.server = log.getLogger();
      entry.filename = log.getFileName();
      entry.logSet = logSet;
      entries.add(entry);
    }
    MetadataTable.addLogEntries(SecurityConstants.getSystemCredentials(), entries, getLock());
  }","public void addLoggersToMetadata(List<RemoteLogger> logs, KeyExtent extent, int id) {
    log.info(""Adding "" + logs.size() + "" logs for extent "" + extent + "" as alias "" + id);
    
    List<MetadataTable.LogEntry> entries = new ArrayList<MetadataTable.LogEntry>();
    long now = RelativeTime.currentTimeMillis();
    List<String> logSet = new ArrayList<String>();
    for (RemoteLogger log : logs)
      logSet.add(log.toString());
    for (RemoteLogger log : logs) {
      MetadataTable.LogEntry entry = new MetadataTable.LogEntry();
      entry.extent = extent;
      entry.tabletId = id;
      entry.timestamp = now;
      entry.server = log.getLogger();
      entry.filename = log.getFileName();
      entry.logSet = logSet;
      entries.add(entry);
    }
    MetadataTable.addLogEntries(SecurityConstants.getSystemCredentials(), entries, getLock());
  }",0,[0]
21056,bugs-dot-jar_OAK-846_7acb091a,"private void moveNode(String sourcePath, String targetPath, Revision baseRev, Commit commit) {
        moveOrCopyNode(true, sourcePath, targetPath, baseRev, commit);
    }","private void moveNode(String sourcePath, String targetPath, Revision baseRev, Commit commit) {
        moveOrCopyNode(true, sourcePath, targetPath, baseRev, commit);
    }",0,[0]
40861,bugs-dot-jar_CAMEL-7622_faa20255,"public static AdviceWithTask replaceByType(final RouteDefinition route, final Class<?> type, final ProcessorDefinition<?> replace,
                                               boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchByType(type);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doReplace(route, matchBy, replace, it);
    }","public static AdviceWithTask replaceByType(final RouteDefinition route, final Class<?> type, final ProcessorDefinition<?> replace,
                                               boolean selectFirst, boolean selectLast, int selectFrom, int selectTo) {
        MatchBy matchBy = new MatchByType(type);
        Iterator<ProcessorDefinition<?>> it = AdviceWithTasks.createMatchByIterator(route, matchBy, selectFirst, selectLast, selectFrom, selectTo);
        return doReplace(route, matchBy, replace, it);
    }",0,[0]
18835,bugs-dot-jar_MATH-935_48dde378,"public void expm1(final double[] operand, final int operandOffset,
                      final double[] result, final int resultOffset) {

        // create the function value and derivatives
        double[] function = new double[1 + order];
        function[0] = FastMath.expm1(operand[operandOffset]);
        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }","public void expm1(final double[] operand, final int operandOffset,
                      final double[] result, final int resultOffset) {

        // create the function value and derivatives
        double[] function = new double[1 + order];
        function[0] = FastMath.expm1(operand[operandOffset]);
        Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));

        // apply function composition
        compose(operand, operandOffset, function, result, resultOffset);

    }",0,[0]
27733,bugs-dot-jar_OAK-3630_fcd64766,"public static Blob getBlob(NodeState state, String resourceName){
        NodeState contentNode = state.getChildNode(JcrConstants.JCR_CONTENT);
        checkArgument(contentNode.exists(), ""Was expecting to find jcr:content node to read resource %s"", resourceName);
        return contentNode.getProperty(JcrConstants.JCR_DATA).getValue(Type.BINARY);
    }","public static Blob getBlob(NodeState state, String resourceName){
        NodeState contentNode = state.getChildNode(JcrConstants.JCR_CONTENT);
        checkArgument(contentNode.exists(), ""Was expecting to find jcr:content node to read resource %s"", resourceName);
        return contentNode.getProperty(JcrConstants.JCR_DATA).getValue(Type.BINARY);
    }",0,[0]
18391,bugs-dot-jar_LOG4J2-832_411dad65,"private void formatEntry(final ExtendedStackTraceElement extStackTraceElement, final StringBuilder sb) {
        sb.append(""\tat "");
        sb.append(extStackTraceElement);
        sb.append('\n');
    }","private void formatEntry(final ExtendedStackTraceElement extStackTraceElement, final StringBuilder sb) {
        sb.append(""\tat "");
        sb.append(extStackTraceElement);
        sb.append('\n');
    }",0,[0]
1578,Bears-192,"public void setId(UUID id) {
    this.id = id;
  }","public void setId(UUID id) {
    this.id = id;
  }",0,[0]
1380,bugs-dot-jar_WICKET-4109_8f7805f8,"public Integer getPageId()
	{
		return pageId;
	}","public Integer getPageId()
	{
		return pageId;
	}",0,[0]
7622,bugs-dot-jar_OAK-1178_f2bb1a17,"KernelNodeBuilder(MemoryNodeBuilder parent, String name, KernelRootBuilder root) {
        super(parent, name);
        this.root = checkNotNull(root);
    }","KernelNodeBuilder(MemoryNodeBuilder parent, String name, KernelRootBuilder root) {
        super(parent, name);
        this.root = checkNotNull(root);
    }",0,[0]
11405,bugs-dot-jar_CAMEL-7344_91228815,"public Component getComponent() {
        return component;
    }","public Component getComponent() {
        return component;
    }",0,[0]
7034,bugs-dot-jar_LOG4J2-763_97203de8,"@Override
    public String getFormat() {
        return Strings.EMPTY;
    }","@Override
    public String getFormat() {
        return Strings.EMPTY;
    }",0,[0]
29326,bugs-dot-jar_WICKET-3539_a4459ef4,"private void depth(final ComponentEvent<?> event)
	{
		IEventSink sink = event.getSink();

		boolean targetsApplication = sink instanceof Application;
		boolean targetsSession = targetsApplication || sink instanceof Session;
		boolean targetsCycle = targetsSession || sink instanceof RequestCycle;
		boolean targetsComponnet = sink instanceof Component;

		if (!targetsComponnet && !targetsCycle)
		{
			dispatcher.dispatchEvent(sink, event);
			return;
		}

		Component cursor = (targetsCycle) ? source.getPage() : (Component)sink;

		if (cursor instanceof MarkupContainer)
		{
			Visits.visitPostOrder(cursor, new ComponentEventVisitor(event, dispatcher));
		}
		if (event.isStop())
		{
			return;
		}
		if (targetsCycle)
		{
			dispatcher.dispatchEvent(source.getRequestCycle(), event);
		}
		if (event.isStop())
		{
			return;
		}
		if (targetsSession)
		{
			dispatcher.dispatchEvent(source.getSession(), event);
		}
		if (event.isStop())
		{
			return;
		}
		if (targetsApplication)
		{
			dispatcher.dispatchEvent(source.getApplication(), event);
		}
	}","private void depth(final ComponentEvent<?> event)
	{
		IEventSink sink = event.getSink();

		boolean targetsApplication = sink instanceof Application;
		boolean targetsSession = targetsApplication || sink instanceof Session;
		boolean targetsCycle = targetsSession || sink instanceof RequestCycle;
		boolean targetsComponnet = sink instanceof Component;

		if (!targetsComponnet && !targetsCycle)
		{
			dispatcher.dispatchEvent(sink, event);
			return;
		}

		Component cursor = (targetsCycle) ? source.getPage() : (Component)sink;

		if (cursor instanceof MarkupContainer)
		{
			Visits.visitPostOrder(cursor, new ComponentEventVisitor(event, dispatcher));
		}
		else
		{
			dispatcher.dispatchEvent(cursor, event);
		}
		if (event.isStop())
		{
			return;
		}
		if (targetsCycle)
		{
			dispatcher.dispatchEvent(source.getRequestCycle(), event);
		}
		if (event.isStop())
		{
			return;
		}
		if (targetsSession)
		{
			dispatcher.dispatchEvent(source.getSession(), event);
		}
		if (event.isStop())
		{
			return;
		}
		if (targetsApplication)
		{
			dispatcher.dispatchEvent(source.getApplication(), event);
		}
	}",1,[]
15300,bugs-dot-jar_FLINK-3314_8fc7e7af,"public Object getCheckpointLock() {
		return lock;
	}","public Object getCheckpointLock() {
		return lock;
	}",0,[0]
20943,bugs-dot-jar_MATH-1080_b285f170,"public LinearConstraintSet(Collection<LinearConstraint> constraints) {
        linearConstraints.addAll(constraints);
    }","public LinearConstraintSet(Collection<LinearConstraint> constraints) {
        linearConstraints.addAll(constraints);
    }",0,[0]
33245,bugs-dot-jar_WICKET-2202_24ac1a35,"public static Form<?> findForm(Component component)
	{
		class FindFormVisitor implements Component.IVisitor<Form<?>>
		{
			Form<?> form = null;

			public Object component(Form<?> component)
			{
				form = component;
				return Component.IVisitor.STOP_TRAVERSAL;
			}
		}

		Form<?> form = component.findParent(Form.class);
		if (form == null)
		{
			// check whether the form is a child of a surrounding border
			final Border border = component.findParent(Border.class);
			if (border != null)
			{
				FindFormVisitor formVisitor = new FindFormVisitor();
				border.visitChildren(Form.class, formVisitor);
				form = formVisitor.form;
			}
		}
		return form;

	}","public static Form<?> findForm(Component component)
	{
		class FindFormVisitor implements Component.IVisitor<Form<?>>
		{
			Form<?> form = null;

			public Object component(Form<?> component)
			{
				form = component;
				return Component.IVisitor.STOP_TRAVERSAL;
			}
		}

		Form<?> form = component.findParent(Form.class);
		if (form == null)
		{
			// check whether the form is a child of a surrounding border
			final Border border = component.findParent(Border.class);
			if (border != null)
			{
				FindFormVisitor formVisitor = new FindFormVisitor();
				border.visitChildren(Form.class, formVisitor);
				form = formVisitor.form;
			}
		}
		return form;

	}",0,[0]
1990,bugs-dot-jar_WICKET-2961_3d8c9d75,"private final Object data_set(int index, Object object)
	{
		if (index > data_length() - 1)
		{
			throw new IndexOutOfBoundsException();
		}
		else if (index == 0 && !(data instanceof Object[] && !(data instanceof MetaDataEntry<?>[])))
		{
			Object old = data;
			data = object;
			return old;
		}
		else
		{
			Object[] array = (Object[])data;
			Object old = array[index];
			array[index] = object;
			return old;
		}
	}","private final Object data_set(int index, Object object)
	{
		if (index > data_length() - 1)
		{
			throw new IndexOutOfBoundsException();
		}
		else if (index == 0 && !(data instanceof Object[] && !(data instanceof MetaDataEntry<?>[])))
		{
			Object old = data;
			data = object;
			return old;
		}
		else
		{
			Object[] array = (Object[])data;
			Object old = array[index];
			array[index] = object;
			return old;
		}
	}",0,[0]
15532,bugs-dot-jar_WICKET-3428_ffc0cae9,"public RequestCycleListenerCollection getListeners()
	{
		return listeners;
	}","public RequestCycleListenerCollection getListeners()
	{
		return listeners;
	}",0,[0]
91,Bears-5,"protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic
        //   ""empty"" POJOs deserialized from XML, where empty XML tag synthesizes a
        //   `VALUE_NULL` token.
        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...
            @SuppressWarnings(""resource"")
            TokenBuffer tb = new TokenBuffer(p, ctxt);
            tb.writeEndObject();
            JsonParser p2 = tb.asParser(p);
            p2.nextToken(); // to point to END_OBJECT
            // note: don't have ObjectId to consider at this point, so:
            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)
                    : deserializeFromObject(p2, ctxt);
            p2.close();
            return ob;
        }
        throw ctxt.mappingException(handledType());
    }","protected Object deserializeFromNull(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // 17-Dec-2015, tatu: Highly specialized case, mainly to support polymorphic
        //   ""empty"" POJOs deserialized from XML, where empty XML tag synthesizes a
        //   `VALUE_NULL` token.
        if (p.requiresCustomCodec()) { // not only XML module, but mostly it...
            @SuppressWarnings(""resource"")
            TokenBuffer tb = new TokenBuffer(p, ctxt);
            tb.writeEndObject();
            JsonParser p2 = tb.asParser(p);
            p2.nextToken(); // to point to END_OBJECT
            // note: don't have ObjectId to consider at this point, so:
            Object ob = _vanillaProcessing ? vanillaDeserialize(p2, ctxt, JsonToken.END_OBJECT)
                    : deserializeFromObject(p2, ctxt);
            p2.close();
            return ob;
        }
        throw ctxt.mappingException(handledType());
    }",0,[0]
18573,bugs-dot-jar_OAK-395_4ed7bc8e,"@Override
    @CheckForNull
    public Property setProperty(String name, String value, int type) throws RepositoryException {
        Value v = (value == null) ? null : getValueFactory().createValue(value, type);
        return setProperty(name, v, type);
    }","@Override
    @CheckForNull
    public Property setProperty(String name, String value, int type) throws RepositoryException {
        Value v = (value == null) ? null : getValueFactory().createValue(value, type);
        return setProperty(name, v, type);
    }",0,[0]
21947,bugs-dot-jar_MATH-370_495f04bc,"public static double scalb(final double d, final int scaleFactor) {

        // handling of some important special cases
        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
            return d;
        }

        // split the double in raw components
        final long bits     = Double.doubleToLongBits(d);
        final long exponent = bits & 0x7ff0000000000000L;
        final long rest     = bits & 0x800fffffffffffffL;

        // shift the exponent
        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
        return Double.longBitsToDouble(newBits);

    }","public static double scalb(final double d, final int scaleFactor) {

        // handling of some important special cases
        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {
            return d;
        }

        // split the double in raw components
        final long bits     = Double.doubleToLongBits(d);
        final long exponent = bits & 0x7ff0000000000000L;
        final long rest     = bits & 0x800fffffffffffffL;

        // shift the exponent
        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));
        return Double.longBitsToDouble(newBits);

    }",0,[0]
23493,bugs-dot-jar_LOG4J2-127_029e79da,"public void info(Message msg) {
        if (isEnabled(Level.INFO, null, msg, null)) {
            log(null, FQCN, Level.INFO, msg, null);
        }
    }","public void info(Message msg) {
        if (isEnabled(Level.INFO, null, msg, null)) {
            log(null, FQCN, Level.INFO, msg, null);
        }
    }",0,[0]
28412,bugs-dot-jar_WICKET-2172_ea4a3f8a,"public StringValue getStringValue(final String key)
	{
		return StringValue.valueOf(getString(key));
	}","public StringValue getStringValue(final String key)
	{
		return StringValue.valueOf(getString(key));
	}",0,[0]
482,bugs-dot-jar_CAMEL-4370_7345fefc,"public String getFileNameOnly() {
        return fileNameOnly;
    }","public String getFileNameOnly() {
        return fileNameOnly;
    }",0,[0]
23889,bugs-dot-jar_ACCUMULO-3077_17654199,"private static void initZooKeeper(Opts opts, String uuid, String instanceNamePath, Path rootTablet) throws KeeperException, InterruptedException {
    // setup basic data in zookeeper
    ZooUtil.putPersistentData(zoo.getZooKeeper(), Constants.ZROOT, new byte[0], -1, NodeExistsPolicy.SKIP, Ids.OPEN_ACL_UNSAFE);
    ZooUtil.putPersistentData(zoo.getZooKeeper(), Constants.ZROOT + Constants.ZINSTANCES, new byte[0], -1, NodeExistsPolicy.SKIP, Ids.OPEN_ACL_UNSAFE);

    // setup instance name
    if (opts.clearInstanceName)
      zoo.recursiveDelete(instanceNamePath, NodeMissingPolicy.SKIP);
    zoo.putPersistentData(instanceNamePath, uuid.getBytes(StandardCharsets.UTF_8), NodeExistsPolicy.FAIL);

    final byte[] EMPTY_BYTE_ARRAY = new byte[0], ZERO_CHAR_ARRAY = new byte[] {'0'};

    // setup the instance
    String zkInstanceRoot = Constants.ZROOT + ""/"" + uuid;
    zoo.putPersistentData(zkInstanceRoot, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTABLES, Constants.ZTABLES_INITIAL_ID, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZNAMESPACES, new byte[0], NodeExistsPolicy.FAIL);
    TableManager.prepareNewNamespaceState(uuid, Namespaces.DEFAULT_NAMESPACE_ID, Namespaces.DEFAULT_NAMESPACE, NodeExistsPolicy.FAIL);
    TableManager.prepareNewNamespaceState(uuid, Namespaces.ACCUMULO_NAMESPACE_ID, Namespaces.ACCUMULO_NAMESPACE, NodeExistsPolicy.FAIL);
    TableManager.prepareNewTableState(uuid, RootTable.ID, Namespaces.ACCUMULO_NAMESPACE_ID, RootTable.NAME, TableState.ONLINE, NodeExistsPolicy.FAIL);
    TableManager.prepareNewTableState(uuid, MetadataTable.ID, Namespaces.ACCUMULO_NAMESPACE_ID, MetadataTable.NAME, TableState.ONLINE, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTSERVERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZPROBLEMS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET_WALOGS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET_PATH, rootTablet.toString().getBytes(), NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTRACERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTER_LOCK, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTER_GOAL_STATE, MasterGoalState.NORMAL.toString().getBytes(StandardCharsets.UTF_8), NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZGC, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZGC_LOCK, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZCONFIG, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTABLE_LOCKS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZHDFS_RESERVATIONS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZNEXT_FILE, ZERO_CHAR_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZRECOVERY, ZERO_CHAR_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMONITOR, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMONITOR_LOCK, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + ReplicationConstants.ZOO_BASE, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + ReplicationConstants.ZOO_TSERVERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
  }","private static void initZooKeeper(Opts opts, String uuid, String instanceNamePath, Path rootTablet) throws KeeperException, InterruptedException {
    // setup basic data in zookeeper
    ZooUtil.putPersistentData(zoo.getZooKeeper(), Constants.ZROOT, new byte[0], -1, NodeExistsPolicy.SKIP, Ids.OPEN_ACL_UNSAFE);
    ZooUtil.putPersistentData(zoo.getZooKeeper(), Constants.ZROOT + Constants.ZINSTANCES, new byte[0], -1, NodeExistsPolicy.SKIP, Ids.OPEN_ACL_UNSAFE);

    // setup instance name
    if (opts.clearInstanceName)
      zoo.recursiveDelete(instanceNamePath, NodeMissingPolicy.SKIP);
    zoo.putPersistentData(instanceNamePath, uuid.getBytes(StandardCharsets.UTF_8), NodeExistsPolicy.FAIL);

    final byte[] EMPTY_BYTE_ARRAY = new byte[0], ZERO_CHAR_ARRAY = new byte[] {'0'};

    // setup the instance
    String zkInstanceRoot = Constants.ZROOT + ""/"" + uuid;
    zoo.putPersistentData(zkInstanceRoot, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTABLES, Constants.ZTABLES_INITIAL_ID, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZNAMESPACES, new byte[0], NodeExistsPolicy.FAIL);
    TableManager.prepareNewNamespaceState(uuid, Namespaces.DEFAULT_NAMESPACE_ID, Namespaces.DEFAULT_NAMESPACE, NodeExistsPolicy.FAIL);
    TableManager.prepareNewNamespaceState(uuid, Namespaces.ACCUMULO_NAMESPACE_ID, Namespaces.ACCUMULO_NAMESPACE, NodeExistsPolicy.FAIL);
    TableManager.prepareNewTableState(uuid, RootTable.ID, Namespaces.ACCUMULO_NAMESPACE_ID, RootTable.NAME, TableState.ONLINE, NodeExistsPolicy.FAIL);
    TableManager.prepareNewTableState(uuid, MetadataTable.ID, Namespaces.ACCUMULO_NAMESPACE_ID, MetadataTable.NAME, TableState.ONLINE, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTSERVERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZPROBLEMS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET_WALOGS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET_PATH, rootTablet.toString().getBytes(), NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTRACERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTER_LOCK, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTER_GOAL_STATE, MasterGoalState.NORMAL.toString().getBytes(StandardCharsets.UTF_8), NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZGC, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZGC_LOCK, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZCONFIG, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZTABLE_LOCKS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZHDFS_RESERVATIONS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZNEXT_FILE, ZERO_CHAR_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZRECOVERY, ZERO_CHAR_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMONITOR, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + Constants.ZMONITOR_LOCK, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + ReplicationConstants.ZOO_BASE, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
    zoo.putPersistentData(zkInstanceRoot + ReplicationConstants.ZOO_TSERVERS, EMPTY_BYTE_ARRAY, NodeExistsPolicy.FAIL);
  }",0,[0]
20208,bugs-dot-jar_MNG-5613_bef7fac6,"public MavenExecutionResult execute( MavenExecutionRequest request )
    {
        MavenExecutionResult result;

        try
        {
            result = doExecute( populator.populateDefaults( request ) );
        }
        catch ( OutOfMemoryError e )
        {
            result = addExceptionToResult( new DefaultMavenExecutionResult(), e );
        }
        catch ( MavenExecutionRequestPopulationException e )
        {
            result = addExceptionToResult( new DefaultMavenExecutionResult(), e );
        }
        catch ( RuntimeException e )
        {
            result =
                addExceptionToResult( new DefaultMavenExecutionResult(), new InternalErrorException( ""Internal error: ""
                    + e, e ) );
        }
        finally
        {
            legacySupport.setSession( null );
        }

        return result;
    }","public MavenExecutionResult execute( MavenExecutionRequest request )
    {
        MavenExecutionResult result;

        try
        {
            result = doExecute( populator.populateDefaults( request ) );
        }
        catch ( OutOfMemoryError e )
        {
            result = addExceptionToResult( new DefaultMavenExecutionResult(), e );
        }
        catch ( MavenExecutionRequestPopulationException e )
        {
            result = addExceptionToResult( new DefaultMavenExecutionResult(), e );
        }
        catch ( RuntimeException e )
        {
            result =
                addExceptionToResult( new DefaultMavenExecutionResult(), new InternalErrorException( ""Internal error: ""
                    + e, e ) );
        }
        finally
        {
            legacySupport.setSession( null );
        }

        return result;
    }",0,[0]
27739,bugs-dot-jar_OAK-1848_093b9128,"@Override
    public SyncedIdentity findIdentity(@Nonnull UserManager userManager, @Nonnull String id)
            throws RepositoryException {
        return createSyncedIdentity(userManager.getAuthorizable(id));
    }","@Override
    public SyncedIdentity findIdentity(@Nonnull UserManager userManager, @Nonnull String id)
            throws RepositoryException {
        return createSyncedIdentity(userManager.getAuthorizable(id));
    }",0,[0]
32438,bugs-dot-jar_CAMEL-3878_b9094cb5,"protected boolean isDone(Exchange exchange) {
        boolean answer = isCancelledOrInterrupted(exchange);

        // only done if the exchange hasn't failed
        // and it has not been handled by the failure processor
        // or we are exhausted
        if (!answer) {
            answer = exchange.getException() == null
                || ExchangeHelper.isFailureHandled(exchange)
                || ExchangeHelper.isRedeliveryExhausted(exchange);
        }

        log.trace(""Is exchangeId: {} done? {}"", exchange.getExchangeId(), answer);
        return answer;
    }","protected boolean isDone(Exchange exchange) {
        boolean answer = isCancelledOrInterrupted(exchange);

        // only done if the exchange hasn't failed
        // and it has not been handled by the failure processor
        // or we are exhausted
        if (!answer) {
            answer = exchange.getException() == null
                || ExchangeHelper.isFailureHandled(exchange)
                || ExchangeHelper.isRedeliveryExhausted(exchange);
        }

        log.trace(""Is exchangeId: {} done? {}"", exchange.getExchangeId(), answer);
        return answer;
    }",0,[0]
1312,bugs-dot-jar_WICKET-5546_f1af9e03,"@Override
	protected void onAfterRender()
	{
		super.onAfterRender();

		// Check rendering if it happened fully
		checkRendering(this);

		// clean up debug meta data if component check is on
		if (getApplication().getDebugSettings().getComponentUseCheck())
		{
			visitChildren(new IVisitor<Component, Void>()
			{
				@Override
				public void component(final Component component, final IVisit<Void> visit)
				{
					component.setMetaData(Component.CONSTRUCTED_AT_KEY, null);
					component.setMetaData(Component.ADDED_AT_KEY, null);
				}
			});
		}

		if (!isPageStateless())
		{
			// trigger creation of the actual session in case it was deferred
			getSession().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);

			// Add/touch the response page in the session.
			getSession().getPageManager().touchPage(this);
		}

		if (getApplication().getDebugSettings().isOutputMarkupContainerClassName())
		{
			String className = Classes.name(getClass());
			getResponse().write(""<!-- Page Class "");
			getResponse().write(className);
			getResponse().write("" END -->\n"");
		}
	}","@Override
	protected void onAfterRender()
	{
		super.onAfterRender();

		// Check rendering if it happened fully
		checkRendering(this);

		// clean up debug meta data if component check is on
		if (getApplication().getDebugSettings().getComponentUseCheck())
		{
			visitChildren(new IVisitor<Component, Void>()
			{
				@Override
				public void component(final Component component, final IVisit<Void> visit)
				{
					component.setMetaData(Component.CONSTRUCTED_AT_KEY, null);
					component.setMetaData(Component.ADDED_AT_KEY, null);
				}
			});
		}

		if (!isPageStateless())
		{
			// trigger creation of the actual session in case it was deferred
			getSession().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);

			// Add/touch the response page in the session.
			getSession().getPageManager().touchPage(this);
		}

		if (getApplication().getDebugSettings().isOutputMarkupContainerClassName())
		{
			String className = Classes.name(getClass());
			getResponse().write(""<!-- Page Class "");
			getResponse().write(className);
			getResponse().write("" END -->\n"");
		}
	}",0,[0]
30630,bugs-dot-jar_CAMEL-3531_41e4b5b9,"public static boolean hasAnnotation(Annotation[] annotations, Class<?> type) {
        for (Annotation annotation : annotations) {
            if (type.isInstance(annotation)) {
                return true;
            }
        }
        return false;
    }","public static boolean hasAnnotation(Annotation[] annotations, Class<?> type) {
        for (Annotation annotation : annotations) {
            if (type.isInstance(annotation)) {
                return true;
            }
        }
        return false;
    }",0,[0]
21636,bugs-dot-jar_ACCUMULO-1518_df4b1985,"public abstract FileSKVIterator openIndex(String file, FileSystem fs, Configuration conf, AccumuloConfiguration acuconf) throws IOException;","public abstract FileSKVIterator openIndex(String file, FileSystem fs, Configuration conf, AccumuloConfiguration acuconf) throws IOException;",0,[0]
1629,bugs-dot-jar_WICKET-5345_3fc7234e,"public String getHost()
	{
		return host;
	}","public String getHost()
	{
		return host;
	}",0,[0]
30933,bugs-dot-jar_LOG4J2-410_8f0c4871,"@Override
    public boolean isTraceEnabled(final Marker marker) {
        return logger.isTraceEnabled((org.apache.logging.log4j.Marker) marker);
    }","@Override
    public boolean isTraceEnabled(final Marker marker) {
        return logger.isTraceEnabled((org.apache.logging.log4j.Marker) marker);
    }",0,[0]
23934,bugs-dot-jar_ACCUMULO-3077_17654199,"void unreserveMergingMinorCompactionFile(FileRef file) {
    if ((file == null && mergingMinorCompactionFile != null) || (file != null && mergingMinorCompactionFile == null)
        || (file != null && mergingMinorCompactionFile != null && !file.equals(mergingMinorCompactionFile)))
      throw new IllegalStateException(""Disagreement "" + file + "" "" + mergingMinorCompactionFile);

    mergingMinorCompactionFile = null;
  }","void unreserveMergingMinorCompactionFile(FileRef file) {
    if ((file == null && mergingMinorCompactionFile != null) || (file != null && mergingMinorCompactionFile == null)
        || (file != null && mergingMinorCompactionFile != null && !file.equals(mergingMinorCompactionFile)))
      throw new IllegalStateException(""Disagreement "" + file + "" "" + mergingMinorCompactionFile);

    mergingMinorCompactionFile = null;
  }",0,[0]
33138,bugs-dot-jar_MATH-1123_a197ba85,"@Deprecated
    public BSPTree<S> getCell(final Vector<S> point) {
        return getCell((Point<S>) point, 1.0e-10);
    }","@Deprecated
    public BSPTree<S> getCell(final Vector<S> point) {
        return getCell((Point<S>) point, 1.0e-10);
    }",0,[0]
38553,bugs-dot-jar_CAMEL-9124_9da2c05a,"public String getExchangeFormatterRef() {
        return exchangeFormatterRef;
    }","public String getExchangeFormatterRef() {
        return exchangeFormatterRef;
    }",0,[0]
12772,bugs-dot-jar_OAK-4067_56accddf,"public static AnalyzingInfixSuggester getLookup(final Directory suggestDirectory, Analyzer analyzer,
                                                    final File tempDir) throws IOException {
        return new AnalyzingInfixSuggester(Version.LUCENE_47, tempDir, analyzer, analyzer, 3) {
            @Override
            protected Directory getDirectory(File path) throws IOException {
                if (tempDir == null || tempDir.getAbsolutePath().equals(path.getAbsolutePath())) {
                    return suggestDirectory; // use oak directory for writing suggest index
                } else {
                    return FSDirectory.open(path); // use FS for temp index used at build time
                }
            }
        };
    }","public static AnalyzingInfixSuggester getLookup(final Directory suggestDirectory, Analyzer analyzer,
                                                    final File tempDir) throws IOException {
        return new AnalyzingInfixSuggester(Version.LUCENE_47, tempDir, analyzer, analyzer, 3) {
            @Override
            protected Directory getDirectory(File path) throws IOException {
                if (tempDir == null || tempDir.getAbsolutePath().equals(path.getAbsolutePath())) {
                    return suggestDirectory; // use oak directory for writing suggest index
                } else {
                    return FSDirectory.open(path); // use FS for temp index used at build time
                }
            }
        };
    }",0,[0]
37133,bugs-dot-jar_CAMEL-7239_ae419224,"public File getSchemaFile() {
        return schemaFile;
    }","public File getSchemaFile() {
        return schemaFile;
    }",0,[0]
17862,bugs-dot-jar_OAK-1075_79467350,"public boolean testPath(String path) {
        if (isAlwaysFalse()) {
            return false;
        }
        switch (pathRestriction) {
        case NO_RESTRICTION:
            return true;
        case EXACT:
            return path.matches(this.path);
        case PARENT:
            return PathUtils.isAncestor(path, this.path);
        case DIRECT_CHILDREN:
            return PathUtils.getParentPath(path).equals(this.path);
        case ALL_CHILDREN:
            return PathUtils.isAncestor(this.path, path);
        default:
            throw new IllegalArgumentException(""Unknown path restriction: "" + pathRestriction);
        }
    }","public boolean testPath(String path) {
        if (isAlwaysFalse()) {
            return false;
        }
        switch (pathRestriction) {
        case NO_RESTRICTION:
            return true;
        case EXACT:
            return path.matches(this.path);
        case PARENT:
            return PathUtils.isAncestor(path, this.path);
        case DIRECT_CHILDREN:
            return PathUtils.getParentPath(path).equals(this.path);
        case ALL_CHILDREN:
            return PathUtils.isAncestor(this.path, path);
        default:
            throw new IllegalArgumentException(""Unknown path restriction: "" + pathRestriction);
        }
    }",0,[0]
39580,bugs-dot-jar_OAK-1674_073b814c,"@Override
    public Status getStatus() {
        if (nodeBuilder.isNew()) {
            return NEW;
        } else if (nodeBuilder.isModified()) {
            return MODIFIED;
        } else {
            return UNCHANGED;
        }
    }","@Override
    public Status getStatus() {
        if (nodeBuilder.isNew() || nodeBuilder.isReplaced()) {
            return NEW;
        } else if (nodeBuilder.isModified()) {
            return MODIFIED;
        } else {
            return UNCHANGED;
        }
    }",1,[2]
16203,bugs-dot-jar_CAMEL-6687_617eab1c,"public Class<?> getBodyParameterType() {
        if (bodyParameters.isEmpty()) {
            return null;
        }
        ParameterInfo parameterInfo = bodyParameters.get(0);
        return parameterInfo.getType();
    }","public Class<?> getBodyParameterType() {
        if (bodyParameters.isEmpty()) {
            return null;
        }
        ParameterInfo parameterInfo = bodyParameters.get(0);
        return parameterInfo.getType();
    }",0,[0]
839,Bears-110,"private Position decodeText(String sentence, Channel channel, SocketAddress remoteAddress) {

        Parser parser = new Parser(PATTERN, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());
        position.setDeviceId(deviceSession.getDeviceId());

        DateBuilder dateBuilder = new DateBuilder();
        if (parser.hasNext(3)) {
            dateBuilder.setTime(parser.nextInt(), parser.nextInt(), parser.nextInt());
        }

        if (parser.hasNext()) {
            position.setValid(parser.next().equals(""A""));
        }

        if (parser.hasNext(2)) {
            position.setLatitude(-parser.nextCoordinate());
        }
        if (parser.hasNext(2)) {
            position.setLatitude(parser.nextCoordinate());
        }

        if (parser.hasNext(2)) {
            position.setLongitude(-parser.nextCoordinate());
        }
        if (parser.hasNext(2)) {
            position.setLongitude(parser.nextCoordinate());
        }

        position.setSpeed(parser.nextDouble());
        position.setCourse(parser.nextDouble());

        if (parser.hasNext(3)) {
            dateBuilder.setDateReverse(parser.nextInt(), parser.nextInt(), parser.nextInt());
            position.setTime(dateBuilder.getDate());
        } else {
            position.setTime(new Date());
        }

        processStatus(position, parser.nextLong(16));

        if (parser.hasNext(6)) {
            position.set(Position.KEY_ODOMETER, parser.nextInt());
            position.set(Position.PREFIX_TEMP + 1, parser.nextInt());
            position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble());

            position.setAltitude(parser.nextInt());

            position.setNetwork(new Network(CellTower.fromLacCid(parser.nextInt(16), parser.nextInt(16))));
        }

        if (parser.hasNext(4)) {
            for (int i = 1; i <= 4; i++) {
                position.set(Position.PREFIX_IO + i, parser.nextInt());
            }
        }

        return position;
    }","private Position decodeText(String sentence, Channel channel, SocketAddress remoteAddress) {

        Parser parser = new Parser(PATTERN, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());
        position.setDeviceId(deviceSession.getDeviceId());

        DateBuilder dateBuilder = new DateBuilder();
        if (parser.hasNext(3)) {
            dateBuilder.setTime(parser.nextInt(), parser.nextInt(), parser.nextInt());
        }

        if (parser.hasNext()) {
            position.setValid(parser.next().equals(""A""));
        }

        if (parser.hasNext(2)) {
            position.setLatitude(-parser.nextCoordinate());
        }
        if (parser.hasNext(2)) {
            position.setLatitude(parser.nextCoordinate());
        }

        if (parser.hasNext(2)) {
            position.setLongitude(-parser.nextCoordinate());
        }
        if (parser.hasNext(2)) {
            position.setLongitude(parser.nextCoordinate());
        }

        position.setSpeed(parser.nextDouble());
        position.setCourse(parser.nextDouble());

        if (parser.hasNext(3)) {
            dateBuilder.setDateReverse(parser.nextInt(), parser.nextInt(), parser.nextInt());
            position.setTime(dateBuilder.getDate());
        } else {
            position.setTime(new Date());
        }

        processStatus(position, parser.nextLong(16));

        if (parser.hasNext(6)) {
            position.set(Position.KEY_ODOMETER, parser.nextInt());
            position.set(Position.PREFIX_TEMP + 1, parser.nextInt());
            position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble());

            position.setAltitude(parser.nextInt());

            position.setNetwork(new Network(CellTower.fromLacCid(parser.nextInt(16), parser.nextInt(16))));
        }

        if (parser.hasNext(4)) {
            for (int i = 1; i <= 4; i++) {
                position.set(Position.PREFIX_IO + i, parser.nextInt());
            }
        }

        return position;
    }",0,[0]
22722,bugs-dot-jar_MATH-778_5b9302d5,"public Dfp getZero() {
        return field.getZero();
    }","public Dfp getZero() {
        return field.getZero();
    }",0,[0]
3652,bugs-dot-jar_WICKET-3715_557de7bc,"public final void closeStreams()
	{
		if (inputStreamsToClose != null)
		{
			for (InputStream inputStream : inputStreamsToClose)
			{
				IOUtils.closeQuietly(inputStream);
			}

			// Reset the list
			inputStreamsToClose = null;
		}
	}","public final void closeStreams()
	{
		if (inputStreamsToClose != null)
		{
			for (InputStream inputStream : inputStreamsToClose)
			{
				IOUtils.closeQuietly(inputStream);
			}

			// Reset the list
			inputStreamsToClose = null;
		}
	}",0,[0]
22645,bugs-dot-jar_WICKET-5204_9e6efa61,"public final Integer getHours()
	{
		return hours;
	}","public final Integer getHours()
	{
		return hours;
	}",0,[0]
20724,bugs-dot-jar_OAK-3817_2a02a138,"@SuppressWarnings(""deprecation"")
    private static Version parseLuceneVersionString(final String matchVersion) {
        final Version version = Version.parseLeniently(matchVersion);
        if (version == Version.LUCENE_CURRENT && !versionWarningAlreadyLogged.getAndSet(true)) {
            log.warn(
                    ""You should not use LATEST as luceneMatchVersion property: ""+
                            ""if you use this setting, and then Solr upgrades to a newer release of Lucene, ""+
                            ""sizable changes may happen. If precise back compatibility is important ""+
                            ""then you should instead explicitly specify an actual Lucene version.""
            );
        }
        return version;
    }","@SuppressWarnings(""deprecation"")
    private static Version parseLuceneVersionString(final String matchVersion) {
        final Version version = Version.parseLeniently(matchVersion);
        if (version == Version.LUCENE_CURRENT && !versionWarningAlreadyLogged.getAndSet(true)) {
            log.warn(
                    ""You should not use LATEST as luceneMatchVersion property: ""+
                            ""if you use this setting, and then Solr upgrades to a newer release of Lucene, ""+
                            ""sizable changes may happen. If precise back compatibility is important ""+
                            ""then you should instead explicitly specify an actual Lucene version.""
            );
        }
        return version;
    }",0,[0]
1086,bugs-dot-jar_WICKET-5546_f1af9e03,"public final String getMarkupIdFromMarkup()
	{
		ComponentTag tag = getMarkupTag();
		if (tag != null)
		{
			String id = tag.getAttribute(""id"");
			if (Strings.isEmpty(id) == false)
			{
				return id.trim();
			}
		}

		return null;
	}","public final String getMarkupIdFromMarkup()
	{
		ComponentTag tag = getMarkupTag();
		if (tag != null)
		{
			String id = tag.getAttribute(""id"");
			if (Strings.isEmpty(id) == false)
			{
				return id.trim();
			}
		}

		return null;
	}",0,[0]
211,bugs-dot-jar_WICKET-2368_fae1601b,"private final void init()
	{
		final RequestCycle cycle = getRequestCycle();
		String pageMapName = null;
		if (cycle != null)
		{
			RequestParameters parameters = getRequest().getRequestParameters();
			pageMapName = parameters.getPageMapName();
		}

		final IPageMap pageMap = PageMap.forName(pageMapName);
		init(pageMap);
	}","private final void init()
	{
		final RequestCycle cycle = getRequestCycle();
		String pageMapName = null;
		if (cycle != null)
		{
			RequestParameters parameters = getRequest().getRequestParameters();
			pageMapName = parameters.getPageMapName();
		}

		final IPageMap pageMap = PageMap.forName(pageMapName);
		init(pageMap);
	}",0,[0]
39188,bugs-dot-jar_OAK-4353_b0014b7d,"public int getGcGen() {
        return getGcGen(data);
    }","public int getGcGen() {
        return getGcGen(data, id.asUUID());
    }",1,[1]
35909,bugs-dot-jar_OAK-3377_00b9bc52,"FullTextExpression parseOr() throws ParseException {
        ArrayList<FullTextExpression> list = new ArrayList<FullTextExpression>();
        list.add(parseAnd());
        while (parseIndex < text.length()) {
            if (text.substring(parseIndex).startsWith(""OR "")) {
                parseIndex += 3;
                list.add(parseAnd());
            } else {
                break;
            }
        }
        FullTextOr or = new FullTextOr(list);
        return or.simplify();
    }","FullTextExpression parseOr() throws ParseException {
        ArrayList<FullTextExpression> list = new ArrayList<FullTextExpression>();
        list.add(parseAnd());
        while (parseIndex < text.length()) {
            if (text.substring(parseIndex).startsWith(""OR "")) {
                parseIndex += 3;
                list.add(parseAnd());
            } else {
                break;
            }
        }
        FullTextOr or = new FullTextOr(list);
        return or.simplify();
    }",0,[0]
16945,bugs-dot-jar_WICKET-5728_3cc3fe95,"protected boolean renderNext(final MarkupStream markupStream)
	{
		// Get the current markup element
		final MarkupElement element = markupStream.get();

		// If it's a tag like <wicket..> or <span wicket:id=""..."" >
		if ((element instanceof ComponentTag) && !markupStream.atCloseTag())
		{
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);
			if (component == null)
			{
				component = ComponentResolvers.resolve(this, markupStream, tag, null);
				if ((component != null) && (component.getParent() == null))
				{
					autoAdd(component, markupStream);
				}
				else if (component != null)
				{
					component.setMarkup(markupStream.getMarkupFragment());
				}
			}

			// Failed to find it?
			if (component != null)
			{
				component.render();
			}
			else if (tag.getFlag(ComponentTag.RENDER_RAW))
			{
				// No component found, but ""render as raw markup"" flag found
				getResponse().write(element.toCharSequence());
				return true;
			}
			else
			{
				if (tag instanceof WicketTag)
				{
					if (((WicketTag)tag).isChildTag())
					{
						markupStream.throwMarkupException(""Found "" + tag.toString() +
							"" but no <wicket:extend>. Container: "" + toString());
					}
					else
					{
						markupStream.throwMarkupException(""Failed to handle: "" +
							tag.toString() +
							"". It might be that no resolver has been registered to handle this special tag. "" +
							"" But it also could be that you declared wicket:id="" + id +
							"" in your markup, but that you either did not add the "" +
							""component to your page at all, or that the hierarchy does not match. "" +
							""Container: "" + toString());
					}
				}

				List<String> names = findSimilarComponents(id);

				// No one was able to handle the component id
				StringBuilder msg = new StringBuilder(500);
				msg.append(""Unable to find component with id '"");
				msg.append(id);
				msg.append(""' in "");
				msg.append(this.toString());
				msg.append(""\n\tExpected: '"");
				msg.append(getPageRelativePath());
				msg.append(PATH_SEPARATOR);
				msg.append(id);
				msg.append(""'.\n\tFound with similar names: '"");
				msg.append(Strings.join(""', "", names));
				msg.append('\'');

				log.error(msg.toString());
				markupStream.throwMarkupException(msg.toString());
			}
		}
		else
		{
			// Render as raw markup
			getResponse().write(element.toCharSequence());
			return true;
		}

		return false;
	}","protected boolean renderNext(final MarkupStream markupStream)
	{
		// Get the current markup element
		final MarkupElement element = markupStream.get();

		// If it's a tag like <wicket..> or <span wicket:id=""..."" >
		if ((element instanceof ComponentTag) && !markupStream.atCloseTag())
		{
			// Get element as tag
			final ComponentTag tag = (ComponentTag)element;

			// Get component id
			final String id = tag.getId();

			// Get the component for the id from the given container
			Component component = get(id);
			if (component == null)
			{
				component = ComponentResolvers.resolve(this, markupStream, tag, null);
				if ((component != null) && (component.getParent() == null))
				{
					autoAdd(component, markupStream);
				}
				else if (component != null)
				{
					component.setMarkup(markupStream.getMarkupFragment());
				}
			}

			// Failed to find it?
			if (component != null)
			{
				component.render();
			}
			else if (tag.getFlag(ComponentTag.RENDER_RAW))
			{
				// No component found, but ""render as raw markup"" flag found
				getResponse().write(element.toCharSequence());
				return true;
			}
			else
			{
				if (tag instanceof WicketTag)
				{
					if (((WicketTag)tag).isChildTag())
					{
						markupStream.throwMarkupException(""Found "" + tag.toString() +
							"" but no <wicket:extend>. Container: "" + toString());
					}
					else
					{
						markupStream.throwMarkupException(""Failed to handle: "" +
							tag.toString() +
							"". It might be that no resolver has been registered to handle this special tag. "" +
							"" But it also could be that you declared wicket:id="" + id +
							"" in your markup, but that you either did not add the "" +
							""component to your page at all, or that the hierarchy does not match. "" +
							""Container: "" + toString());
					}
				}

				List<String> names = findSimilarComponents(id);

				// No one was able to handle the component id
				StringBuilder msg = new StringBuilder(500);
				msg.append(""Unable to find component with id '"");
				msg.append(id);
				msg.append(""' in "");
				msg.append(this.toString());
				msg.append(""\n\tExpected: '"");
				msg.append(getPageRelativePath());
				msg.append(PATH_SEPARATOR);
				msg.append(id);
				msg.append(""'.\n\tFound with similar names: '"");
				msg.append(Strings.join(""', "", names));
				msg.append('\'');

				log.error(msg.toString());
				markupStream.throwMarkupException(msg.toString());
			}
		}
		else
		{
			// Render as raw markup
			getResponse().write(element.toCharSequence());
			return true;
		}

		return false;
	}",0,[0]
35578,bugs-dot-jar_OAK-621_00b4b8a0,"private PropertyState internalGetProperty(String propertyName) {
        return getNodeBuilder().getProperty(propertyName);
    }","private PropertyState internalGetProperty(String propertyName) {
        return nodeBuilder.getProperty(propertyName);
    }",1,[1]
188,bugs-dot-jar_WICKET-2368_fae1601b,"public final IPageMap getPageMap()
	{
		// If the transient needs to be restored
		if (pageMap == null)
		{
			// Look the page map up in the session
			pageMap = PageMap.forName(pageMapName);
		}
		return pageMap;
	}","public final IPageMap getPageMap()
	{
		// If the transient needs to be restored
		if (pageMap == null)
		{
			// Look the page map up in the session
			pageMap = PageMap.forName(pageMapName);
		}
		return pageMap;
	}",0,[0]
1580,bugs-dot-jar_ACCUMULO-4113_27300d81,"public static ByteBuffer toByteBuffers(ByteSequence bs) {
    if (bs == null)
      return null;

    if (bs.isBackedByArray()) {
      return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());
    } else {
      // TODO create more efficient impl
      return ByteBuffer.wrap(bs.toArray());
    }
  }","public static ByteBuffer toByteBuffers(ByteSequence bs) {
    if (bs == null)
      return null;

    if (bs.isBackedByArray()) {
      return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());
    } else {
      return ByteBuffer.wrap(bs.toArray());
    }
  }",1,[7]
4452,bugs-dot-jar_WICKET-2350_cd281092,"public final FormComponent<T> setPersistent(final boolean persistent)
	{
		if (supportsPersistence())
		{
			setFlag(FLAG_PERSISTENT, persistent);
		}
		else
		{
			throw new UnsupportedOperationException(""FormComponent "" + getClass() +
				"" does not support cookies"");
		}
		return this;
	}","public final FormComponent<T> setPersistent(final boolean persistent)
	{
		if (supportsPersistence())
		{
			setFlag(FLAG_PERSISTENT, persistent);
		}
		else
		{
			throw new UnsupportedOperationException(""FormComponent "" + getClass() +
				"" does not support cookies"");
		}
		return this;
	}",0,[0]
28602,bugs-dot-jar_MATH-704_3f645310,"public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                }

                double sumWts = 0;
                for (int i = 0; i < weights.length; i++) {
                    sumWts += weights[i];
                }

                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }","public double evaluate(final double[] values, final double[] weights,
                           final double mean, final int begin, final int length) {

        double var = Double.NaN;

        if (test(values, weights, begin, length)) {
            if (length == 1) {
                var = 0.0;
            } else if (length > 1) {
                double accum = 0.0;
                double dev = 0.0;
                double accum2 = 0.0;
                for (int i = begin; i < begin + length; i++) {
                    dev = values[i] - mean;
                    accum += weights[i] * (dev * dev);
                    accum2 += weights[i] * dev;
                }

                double sumWts = 0;
                for (int i = begin; i < begin + length; i++) {
                    sumWts += weights[i];
                }

                if (isBiasCorrected) {
                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
                } else {
                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
                }
            }
        }
        return var;
    }",1,[19]
726,Bears-23,"protected void _clearFormats() {
        _formatRFC1123 = null;
        _formatISO8601 = null;
        _formatISO8601_z = null;
        _formatPlain = null;
    }","protected void _clearFormats() {
        _formatRFC1123 = null;
        _formatISO8601 = null;
        _formatISO8601_z = null;
        _formatISO8601_noTz = null;

        _formatPlain = null;
    }",1,[]
15937,bugs-dot-jar_MATH-1058_4ebd967c,"public LogNormalDistribution(RandomGenerator rng,
                                 double scale,
                                 double shape,
                                 double inverseCumAccuracy)
        throws NotStrictlyPositiveException {
        super(rng);

        if (shape <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);
        }

        this.scale = scale;
        this.shape = shape;
        this.logShapePlusHalfLog2Pi = FastMath.log(shape) + 0.5 * FastMath.log(2 * FastMath.PI);
        this.solverAbsoluteAccuracy = inverseCumAccuracy;
    }","public LogNormalDistribution(RandomGenerator rng,
                                 double scale,
                                 double shape,
                                 double inverseCumAccuracy)
        throws NotStrictlyPositiveException {
        super(rng);

        if (shape <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);
        }

        this.scale = scale;
        this.shape = shape;
        this.logShapePlusHalfLog2Pi = FastMath.log(shape) + 0.5 * FastMath.log(2 * FastMath.PI);
        this.solverAbsoluteAccuracy = inverseCumAccuracy;
    }",0,[0]
20097,bugs-dot-jar_ACCUMULO-1183_cfbf5999,"private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {
    BatchWriterConfig cfg = new BatchWriterConfig();
    if (opts != null) {
      if (opts.maxMemory != 0)
        cfg.setMaxMemory(opts.maxMemory);
      if (opts.threads != 0)
        cfg.setMaxWriteThreads(opts.threads);
      if (opts.timeoutMs != 0)
        cfg.setTimeout(opts.timeoutMs, TimeUnit.MILLISECONDS);
      if (opts.latencyMs != 0)
        cfg.setMaxLatency(opts.latencyMs, TimeUnit.MILLISECONDS);
    }
    return getConnector(login).createBatchWriter(tableName, cfg);
  }","private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {
    BatchWriterConfig cfg = new BatchWriterConfig();
    if (opts != null) {
      if (opts.maxMemory != 0)
        cfg.setMaxMemory(opts.maxMemory);
      if (opts.threads != 0)
        cfg.setMaxWriteThreads(opts.threads);
      if (opts.timeoutMs != 0)
        cfg.setTimeout(opts.timeoutMs, TimeUnit.MILLISECONDS);
      if (opts.latencyMs != 0)
        cfg.setMaxLatency(opts.latencyMs, TimeUnit.MILLISECONDS);
    }
    return getConnector(login).createBatchWriter(tableName, cfg);
  }",0,[0]
7992,bugs-dot-jar_ACCUMULO-3242_15e83709,"private synchronized void put(String zPath, byte[] data, Stat stat) {
    cache.put(zPath, data);
    statCache.put(zPath, stat);
  }","private synchronized void put(String zPath, byte[] data, Stat stat) {
    cache.put(zPath, data);
    statCache.put(zPath, stat);
  }",0,[0]
8055,bugs-dot-jar_OAK-1655_c91bfa54,"@Override
    public DataRecord getRecordFromReference(String reference) throws DataStoreException {
        return delegate.getRecordFromReference(reference);
    }","@Override
    public DataRecord getRecordFromReference(String reference) throws DataStoreException {
        return delegate.getRecordFromReference(reference);
    }",0,[0]
39373,bugs-dot-jar_WICKET-3597_5e2c6702,"public static void writeOpenTag(final Response response, String id)
	{
		response.write(""<script type=\""text/javascript\"" "");
		if (id != null)
		{
			response.write(""id=\"""" + id + ""\"""");
		}
		response.write("">"");
		response.write(SCRIPT_CONTENT_PREFIX);
	}","public static void writeOpenTag(final Response response, String id)
	{
		response.write(""<script type=\""text/javascript\"" "");
		if (id != null)
		{
			response.write(""id=\"""" + id + ""\"""");
		}
		response.write("">"");
		response.write(SCRIPT_CONTENT_PREFIX);
	}",0,[0]
23604,bugs-dot-jar_OAK-4423_08f0b280,"@Override @Nonnull
    public NodeState rebase(@Nonnull NodeBuilder builder) {
        checkArgument(builder instanceof SegmentNodeBuilder);

        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;

        NodeState root = getRoot();
        NodeState before = snb.getBaseState();
        if (!SegmentNodeState.fastEquals(before, root)) {
            SegmentNodeState after = snb.getNodeState();
            snb.reset(root);
            after.compareAgainstBaseState(
                    before, new ConflictAnnotatingRebaseDiff(snb));
        }

        return snb.getNodeState();
    }","@Override @Nonnull
    public NodeState rebase(@Nonnull NodeBuilder builder) {
        checkArgument(builder instanceof SegmentNodeBuilder);

        SegmentNodeBuilder snb = (SegmentNodeBuilder) builder;

        NodeState root = getRoot();
        NodeState before = snb.getBaseState();
        if (!SegmentNodeState.fastEquals(before, root)) {
            SegmentNodeState after = snb.getNodeState();
            snb.reset(root);
            after.compareAgainstBaseState(
                    before, new ConflictAnnotatingRebaseDiff(snb));
        }

        return snb.getNodeState();
    }",0,[0]
16128,bugs-dot-jar_WICKET-4816_66bfc885,"public static String[] split(final String s, final char c)
	{
		if (s == null || s.length() == 0)
		{
			return NO_STRINGS;
		}
		final List<String> strings = new ArrayList<String>();
		int pos = 0;
		while (true)
		{
			int next = s.indexOf(c, pos);
			if (next == -1)
			{
				strings.add(s.substring(pos));
				break;
			}
			else
			{
				strings.add(s.substring(pos, next));
			}
			pos = next + 1;
		}
		final String[] result = new String[strings.size()];
		strings.toArray(result);
		return result;
	}","public static String[] split(final String s, final char c)
	{
		if (s == null || s.length() == 0)
		{
			return NO_STRINGS;
		}
		final List<String> strings = new ArrayList<String>();
		int pos = 0;
		while (true)
		{
			int next = s.indexOf(c, pos);
			if (next == -1)
			{
				strings.add(s.substring(pos));
				break;
			}
			else
			{
				strings.add(s.substring(pos, next));
			}
			pos = next + 1;
		}
		final String[] result = new String[strings.size()];
		strings.toArray(result);
		return result;
	}",0,[0]
17003,bugs-dot-jar_OAK-766_6fc5ea9d,"@Override
    public long getChildrenCount() {
        // TODO: make sure cnt respects access control
        enter();
        return nodeBuilder.getChildNodeCount();
    }","@Override
    public long getChildrenCount() {
        // TODO: make sure cnt respects access control
        enter();
        return nodeBuilder.getChildNodeCount();
    }",0,[0]
881,bugs-dot-jar_WICKET-4572_dfc56674,"public int getTotalSize()
	{
		return totalSize;
	}","public int getTotalSize()
	{
		return totalSize;
	}",0,[0]
2795,bugs-dot-jar_OAK-2174_5931a4a7,"public AsyncIndexUpdate(@Nonnull String name, @Nonnull NodeStore store,
            @Nonnull IndexEditorProvider provider) {
        this(name, store, provider, false);
    }","public AsyncIndexUpdate(@Nonnull String name, @Nonnull NodeStore store,
            @Nonnull IndexEditorProvider provider) {
        this(name, store, provider, false);
    }",0,[0]
1393,bugs-dot-jar_OAK-185_7fe28a0e,"@Nonnull
    public Iterator<PropertyDelegate> getProperties() throws InvalidItemStateException {
        return propertyDelegateIterator(getTree().getProperties().iterator());
    }","@Nonnull
    public Iterator<PropertyDelegate> getProperties() throws InvalidItemStateException {
        return propertyDelegateIterator(getTree().getProperties().iterator());
    }",0,[0]
4414,bugs-dot-jar_OAK-4291_cdb34ffc,"@Override
    public RecordId execute(WriteOperation writeOperation) throws IOException {
        SegmentBufferWriter writer = borrowWriter(currentThread());
        try {
            return writeOperation.execute(writer);
        } finally {
            returnWriter(currentThread(), writer);
        }
    }","@Override
    public RecordId execute(WriteOperation writeOperation) throws IOException {
        SegmentBufferWriter writer = borrowWriter(currentThread());
        try {
            return writeOperation.execute(writer);
        } finally {
            returnWriter(currentThread(), writer);
        }
    }",0,[0]
17879,bugs-dot-jar_OAK-1075_79467350,"@CheckForNull
    public static PropertyState create(PropertyValue value) {
        if (value == null) {
            return null;
        }
        if (value instanceof PropertyStateValue) {
            return ((PropertyStateValue) value).unwrap();
        }
        return null;
    }","@CheckForNull
    public static PropertyState create(PropertyValue value) {
        if (value == null) {
            return null;
        }
        if (value instanceof PropertyStateValue) {
            return ((PropertyStateValue) value).unwrap();
        }
        return null;
    }",0,[0]
17355,bugs-dot-jar_CAMEL-7018_3244c1e5,"public SedaEndpoint(String endpointUri, Component component, BlockingQueue<Exchange> queue, int concurrentConsumers) {
        this(endpointUri, component, concurrentConsumers);
        this.queue = queue;
        if (queue != null) {
            this.size = queue.remainingCapacity();
        }
        queueFactory = new LinkedBlockingQueueFactory<Exchange>();
        getComponent().registerQueue(this, queue);
    }","public SedaEndpoint(String endpointUri, Component component, BlockingQueue<Exchange> queue, int concurrentConsumers) {
        this(endpointUri, component, concurrentConsumers);
        this.queue = queue;
        if (queue != null) {
            this.size = queue.remainingCapacity();
        }
        queueFactory = new LinkedBlockingQueueFactory<Exchange>();
        getComponent().registerQueue(this, queue);
    }",0,[0]
18534,bugs-dot-jar_CAMEL-9666_da035952,"public <T> T getException(Class<T> type) {
        return ObjectHelper.getException(type, exception);
    }","public <T> T getException(Class<T> type) {
        return ObjectHelper.getException(type, exception);
    }",0,[0]
31883,bugs-dot-jar_LOG4J2-1406_a523dcd5,"@Override
    public String toString() {
        return ""ReusableParameterizedMessage[messagePattern="" + getFormat() + "", stringArgs="" +
                Arrays.toString(getParameters()) + "", throwable="" + getThrowable() + ']';
    }","@Override
    public String toString() {
        return ""ReusableParameterizedMessage[messagePattern="" + getFormat() + "", stringArgs="" +
                Arrays.toString(getParameters()) + "", throwable="" + getThrowable() + ']';
    }",0,[0]
869,bugs-dot-jar_WICKET-4572_dfc56674,"private int getWindowIndex(int pageId)
	{
		if (idToWindowIndex == null)
		{
			rebuildIndices();
		}

		Integer result = idToWindowIndex.get(pageId);
		return result != null ? result : -1;
	}","private int getWindowIndex(int pageId)
	{
		if (idToWindowIndex == null)
		{
			rebuildIndices();
		}

		Integer result = idToWindowIndex.get(pageId);
		return result != null ? result : -1;
	}",0,[0]
17575,bugs-dot-jar_WICKET-4715_4fc82e35,"public final void onFormSubmitted(IFormSubmitter submitter)
	{
		markFormsSubmitted();

		if (handleMultiPart())
		{
			// Tells FormComponents that a new user input has come
			inputChanged();

			String url = getRequest().getRequestParameters()
				.getParameterValue(getHiddenFieldId())
				.toString();
			if (!Strings.isEmpty(url))
			{
				dispatchEvent(getPage(), url);
			}
			else
			{
				// First, see if the processing was triggered by a Wicket IFormSubmittingComponent
				if (submitter == null)
				{
					submitter = findSubmittingButton();
				}

				// When processing was triggered by a Wicket IFormSubmittingComponent and that
				// component indicates it wants to be called immediately
				// (without processing), call the IFormSubmittingComponent.onSubmit* methods right
				// away.
				if (submitter != null && !submitter.getDefaultFormProcessing())
				{
					submitter.onSubmit();
					submitter.onAfterSubmit();
				}
				else
				{
					// the submit request might be for one of the nested forms, so let's
					// find the right one:
					final Form<?> formToProcess = findFormToProcess(submitter);

					// process the form for this request
					formToProcess.process(submitter);
				}
			}
		}
		// If multi part did fail check if an error is registered and call
		// onError
		else if (hasError())
		{
			callOnError(submitter);
		}
	}","public final void onFormSubmitted(IFormSubmitter submitter)
	{
		markFormsSubmitted();

		if (handleMultiPart())
		{
			// Tells FormComponents that a new user input has come
			inputChanged();

			String url = getRequest().getRequestParameters()
				.getParameterValue(getHiddenFieldId())
				.toString();
			if (!Strings.isEmpty(url))
			{
				dispatchEvent(getPage(), url);
			}
			else
			{
				// First, see if the processing was triggered by a Wicket IFormSubmittingComponent
				if (submitter == null)
				{
					submitter = findSubmittingButton();
				}

				// When processing was triggered by a Wicket IFormSubmittingComponent and that
				// component indicates it wants to be called immediately
				// (without processing), call the IFormSubmittingComponent.onSubmit* methods right
				// away.
				if (submitter != null && !submitter.getDefaultFormProcessing())
				{
					submitter.onSubmit();
					submitter.onAfterSubmit();
				}
				else
				{
					// the submit request might be for one of the nested forms, so let's
					// find the right one:
					final Form<?> formToProcess = findFormToProcess(submitter);

					// process the form for this request
					formToProcess.process(submitter);
				}
			}
		}
		// If multi part did fail check if an error is registered and call
		// onError
		else if (hasError())
		{
			callOnError(submitter);
		}
	}",0,[0]
705,Bears-23,"public StdDateFormat withLocale(Locale loc) {
        if (loc.equals(_locale)) {
            return this;
        }
        return new StdDateFormat(_timezone, loc, _lenient);
    }","public StdDateFormat withLocale(Locale loc) {
        if (loc.equals(_locale)) {
            return this;
        }
        return new StdDateFormat(_timezone, loc, _lenient);
    }",0,[0]
383,bugs-dot-jar_FLINK-2874_17e7b423,"public static <IN1, IN2, OUT> TypeInformation<OUT> getCoGroupReturnTypes(CoGroupFunction<IN1, IN2, OUT> coGroupInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type)
	{
		return getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);
	}","public static <IN1, IN2, OUT> TypeInformation<OUT> getCoGroupReturnTypes(CoGroupFunction<IN1, IN2, OUT> coGroupInterface,
			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type)
	{
		return getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);
	}",0,[0]
1352,bugs-dot-jar_MATH-1252_09fe956a,"public int getCapacity() {
        return internalArray.length;
    }","public int getCapacity() {
        return internalArray.length;
    }",0,[0]
13761,bugs-dot-jar_CAMEL-6936_4954d573,"public GenericFileConsumer(GenericFileEndpoint<T> endpoint, Processor processor, GenericFileOperations<T> operations) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.operations = operations;
    }","public GenericFileConsumer(GenericFileEndpoint<T> endpoint, Processor processor, GenericFileOperations<T> operations) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.operations = operations;
    }",0,[0]
8866,bugs-dot-jar_CAMEL-7275_44cad623,"protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {
        Object stop = exchange.getProperty(Exchange.ROUTE_STOP);
        if (stop != null) {
            boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);
            if (doStop) {
                LOG.debug(""Exchange is marked to stop routing: {}"", exchange);
                return false;
            }
        }

        // continue if there are more processors to route
        return it.hasNext();
    }","protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {
        Object stop = exchange.getProperty(Exchange.ROUTE_STOP);
        if (stop != null) {
            boolean doStop = exchange.getContext().getTypeConverter().convertTo(Boolean.class, stop);
            if (doStop) {
                LOG.debug(""Exchange is marked to stop routing: {}"", exchange);
                return false;
            }
        }

        // continue if there are more processors to route
        return it.hasNext();
    }",0,[0]
4334,bugs-dot-jar_CAMEL-4682_1e54865c,"protected ManagementMBeanAssembler createManagementMBeanAssembler() {
        return new DefaultManagementMBeanAssembler();
    }","protected ManagementMBeanAssembler createManagementMBeanAssembler() {
        return new DefaultManagementMBeanAssembler();
    }",0,[0]
15238,bugs-dot-jar_WICKET-4070_d450acb0,"private boolean anyFormComponentError()
	{
		// Check ALL children for error messages irrespective of FormComponents or not
		Boolean error = visitChildren(Component.class, new IVisitor<Component, Boolean>()
		{
			public void component(final Component component, final IVisit<Boolean> visit)
			{
				if (component.hasErrorMessage())
				{
					visit.stop(true);
				}
			}
		});

		return (error != null) && error;
	}","private boolean anyFormComponentError()
	{
		// Check ALL children for error messages irrespective of FormComponents or not
		Boolean error = visitChildren(Component.class, new IVisitor<Component, Boolean>()
		{
			public void component(final Component component, final IVisit<Boolean> visit)
			{
				if (component.hasErrorMessage())
				{
					visit.stop(true);
				}
			}
		});

		return (error != null) && error;
	}",0,[0]
672,bugs-dot-jar_FLINK-2515_06e2da35,"private void dropSubsumedCheckpoints(long timestamp) {
		Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator();
		while (entries.hasNext()) {
			PendingCheckpoint p = entries.next().getValue();
			if (p.getCheckpointTimestamp() < timestamp) {
				rememberRecentCheckpointId(p.getCheckpointId());

				p.discard(userClassLoader, true);

				entries.remove();
			}
		}
	}","private void dropSubsumedCheckpoints(long timestamp) {
		Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator();
		while (entries.hasNext()) {
			PendingCheckpoint p = entries.next().getValue();
			if (p.getCheckpointTimestamp() < timestamp) {
				rememberRecentCheckpointId(p.getCheckpointId());

				p.discard(userClassLoader, true);

				entries.remove();
			}
		}
	}",0,[0]
5437,bugs-dot-jar_OAK-1186_52372042,"@Nonnull
    Revision apply(@Nonnull Commit commit) throws MicroKernelException {
        checkNotNull(commit);
        boolean success = false;
        Revision baseRev = commit.getBaseRevision();
        boolean isBranch = baseRev != null && baseRev.isBranch();
        Revision rev = commit.getRevision();
        if (isBranch) {
            rev = rev.asBranchRevision();
            // remember branch commit
            Branch b = getBranches().getBranch(baseRev);
            if (b == null) {
                // baseRev is marker for new branch
                b = getBranches().create(baseRev.asTrunkRevision(), rev);
            } else {
                b.addCommit(rev);
            }
            try {
                // prepare commit
                commit.prepare(baseRev);
                success = true;
            } finally {
                if (!success) {
                    b.removeCommit(rev);
                    if (!b.hasCommits()) {
                        getBranches().remove(b);
                    }
                }
            }
        } else {
            commit.apply();
        }
        return rev;
    }","@Nonnull
    Revision apply(@Nonnull Commit commit) throws MicroKernelException {
        checkNotNull(commit);
        boolean success = false;
        Revision baseRev = commit.getBaseRevision();
        boolean isBranch = baseRev != null && baseRev.isBranch();
        Revision rev = commit.getRevision();
        if (isBranch) {
            rev = rev.asBranchRevision();
            // remember branch commit
            Branch b = getBranches().getBranch(baseRev);
            if (b == null) {
                // baseRev is marker for new branch
                b = getBranches().create(baseRev.asTrunkRevision(), rev);
            } else {
                b.addCommit(rev);
            }
            try {
                // prepare commit
                commit.prepare(baseRev);
                success = true;
            } finally {
                if (!success) {
                    b.removeCommit(rev);
                    if (!b.hasCommits()) {
                        getBranches().remove(b);
                    }
                }
            }
        } else {
            commit.apply();
        }
        return rev;
    }",0,[0]
4861,bugs-dot-jar_MATH-326_ce185345,"public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {
        checkVectorDimensions(v.length);
        OpenMapRealVector res = new OpenMapRealVector(this);
        for (int i = 0; i < v.length; i++) {
            if (entries.containsKey(i)) {
                res.setEntry(i, entries.get(i) - v[i]);
            } else {
                res.setEntry(i, -v[i]);
            }
        }
        return res;
    }","public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {
        checkVectorDimensions(v.length);
        OpenMapRealVector res = new OpenMapRealVector(this);
        for (int i = 0; i < v.length; i++) {
            if (entries.containsKey(i)) {
                res.setEntry(i, entries.get(i) - v[i]);
            } else {
                res.setEntry(i, -v[i]);
            }
        }
        return res;
    }",0,[0]
18049,bugs-dot-jar_OAK-3249_64712735,"private NodeDefinitionTemplate createNodeDefinitionTemplate(NodeTypeManager ntMgr, QNodeDefinition def) throws RepositoryException {
        NodeDefinitionTemplate tmpl = ntMgr.createNodeDefinitionTemplate();

        Name name = def.getName();
        if (name != null) {
            tmpl.setName(getOakName(name));
        }
        tmpl.setAutoCreated(def.isAutoCreated());
        tmpl.setMandatory(def.isMandatory());
        tmpl.setOnParentVersion(def.getOnParentVersion());
        tmpl.setProtected(def.isProtected());
        tmpl.setSameNameSiblings(def.allowsSameNameSiblings());

        List<String> names = newArrayListWithCapacity(def.getRequiredPrimaryTypes().length);
        for (Name type : def.getRequiredPrimaryTypes()) {
            names.add(getOakName(type));
        }
        tmpl.setRequiredPrimaryTypeNames(names.toArray(new String[names.size()]));

        Name type = def.getDefaultPrimaryType();
        if (type != null) {
            tmpl.setDefaultPrimaryTypeName(getOakName(type));
        }

        return tmpl;
    }","private NodeDefinitionTemplate createNodeDefinitionTemplate(NodeTypeManager ntMgr, QNodeDefinition def) throws RepositoryException {
        NodeDefinitionTemplate tmpl = ntMgr.createNodeDefinitionTemplate();

        Name name = def.getName();
        if (name != null) {
            tmpl.setName(getOakName(name));
        }
        tmpl.setAutoCreated(def.isAutoCreated());
        tmpl.setMandatory(def.isMandatory());
        tmpl.setOnParentVersion(def.getOnParentVersion());
        tmpl.setProtected(def.isProtected());
        tmpl.setSameNameSiblings(def.allowsSameNameSiblings());

        List<String> names = newArrayListWithCapacity(def.getRequiredPrimaryTypes().length);
        for (Name type : def.getRequiredPrimaryTypes()) {
            names.add(getOakName(type));
        }
        tmpl.setRequiredPrimaryTypeNames(names.toArray(new String[names.size()]));

        Name type = def.getDefaultPrimaryType();
        if (type != null) {
            tmpl.setDefaultPrimaryTypeName(getOakName(type));
        }

        return tmpl;
    }",0,[0]
666,Bears-20,"public static Class<?>[] types() {
        return new Class<?>[] {
            File.class,
            URL.class,
            URI.class,
            Class.class,
            JavaType.class,
            Currency.class,
            Pattern.class,
            Locale.class,
            Charset.class,
            TimeZone.class,
            InetAddress.class,
            InetSocketAddress.class,
            StringBuilder.class,
        };
    }","public static Class<?>[] types() {
        return new Class<?>[] {
            File.class,
            URL.class,
            URI.class,
            Class.class,
            JavaType.class,
            Currency.class,
            Pattern.class,
            Locale.class,
            Charset.class,
            TimeZone.class,
            InetAddress.class,
            InetSocketAddress.class,
            StringBuilder.class,
        };
    }",0,[0]
4162,bugs-dot-jar_OAK-1789_9f7c1df0,"@Override
    public boolean hasProperty(String name) {
        return properties.containsKey(name);
    }","@Override
    public boolean hasProperty(String name) {
        return properties.containsKey(name);
    }",0,[0]
8781,bugs-dot-jar_MNG-4474_269c956e,"public void putArtifactMetadata( File source, ArtifactMetadata artifactMetadata, ArtifactRepository repository )
        throws TransferFailedException
    {
        logger.info( ""Uploading "" + artifactMetadata );
        putRemoteFile( repository, source, repository.pathOfRemoteRepositoryMetadata( artifactMetadata ), null );
    }","public void putArtifactMetadata( File source, ArtifactMetadata artifactMetadata, ArtifactRepository repository )
        throws TransferFailedException
    {
        logger.info( ""Uploading "" + artifactMetadata );
        putRemoteFile( repository, source, repository.pathOfRemoteRepositoryMetadata( artifactMetadata ), null );
    }",0,[0]
8504,bugs-dot-jar_ACCUMULO-366_db4a291f,"@Override
  public String getName() {
    if (this.isEnabled())
      return getClientAddressString();
    return """";
  }","@Override
  public String getName() {
    if (this.isEnabled())
      return getClientAddressString();
    return """";
  }",0,[0]
83,bugs-dot-jar_OAK-1822_3e83a4c1,"static UpdateOp combine(String id, Iterable<UpdateOp> ops) {
        Map<Key, Operation> changes = Maps.newHashMap();
        for (UpdateOp op : ops) {
            changes.putAll(op.getChanges());
        }
        return new UpdateOp(id, false, false, changes);
    }","static UpdateOp combine(String id, Iterable<UpdateOp> ops) {
        Map<Key, Operation> changes = Maps.newHashMap();
        for (UpdateOp op : ops) {
            changes.putAll(op.getChanges());
        }
        return new UpdateOp(id, false, false, changes);
    }",0,[0]
10662,bugs-dot-jar_MATH-349_4cc9a49d,"@Override
    protected int getDomainUpperBound(double p) {
        return Integer.MAX_VALUE;
    }","@Override
    protected int getDomainUpperBound(double p) {
        return Integer.MAX_VALUE;
    }",0,[0]
7880,bugs-dot-jar_MATH-812_6eb46555,"@Override
    public double getLInfDistance(RealVector v) {
        checkVectorDimensions(v.getDimension());
        if (v instanceof OpenMapRealVector) {
            return getLInfDistance((OpenMapRealVector) v);
        } else {
            return super.getLInfDistance(v);
        }
    }","@Override
    public double getLInfDistance(RealVector v) {
        checkVectorDimensions(v.getDimension());
        if (v instanceof OpenMapRealVector) {
            return getLInfDistance((OpenMapRealVector) v);
        } else {
            return super.getLInfDistance(v);
        }
    }",0,[0]
34253,bugs-dot-jar_WICKET-4184_a0150366,"public AppendingStringBuffer(final CharSequence str)
	{
		this(str.length() + 16);
		append(str);
	}","public AppendingStringBuffer(final CharSequence str)
	{
		this(str.length() + 16);
		append(str);
	}",0,[0]
15524,bugs-dot-jar_WICKET-3428_ffc0cae9,"public void setResponsePage(Class<? extends IRequestablePage> pageClass)
	{
		IPageProvider provider = new PageProvider(pageClass, null);
		scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider,
			RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));
	}","public void setResponsePage(Class<? extends IRequestablePage> pageClass)
	{
		IPageProvider provider = new PageProvider(pageClass, null);
		scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider,
			RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));
	}",0,[0]
358,Bears-15,"@Override
    @Deprecated
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)
    {
        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.keyAs());
    }","@Override
    @Deprecated
    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)
    {
        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);
        return (ann == null) ? null : _classIfExplicit(ann.keyAs());
    }",0,[0]
3071,bugs-dot-jar_CAMEL-5261_55c2e2d8,"public void setWaitForTaskToComplete(WaitForTaskToComplete waitForTaskToComplete) {
        this.waitForTaskToComplete = waitForTaskToComplete;
    }","public void setWaitForTaskToComplete(WaitForTaskToComplete waitForTaskToComplete) {
        this.waitForTaskToComplete = waitForTaskToComplete;
    }",0,[0]
1307,bugs-dot-jar_WICKET-5546_f1af9e03,"private void setNextAvailableId()
	{
		setNumericId(getSession().nextPageId());
	}","private void setNextAvailableId()
	{
		setNumericId(getSession().nextPageId());
	}",0,[0]
19683,bugs-dot-jar_WICKET-4259_1f128536,"public final AjaxEditableLabel<T> setRequired(final boolean required)
	{
		getEditor().setRequired(required);
		return this;
	}","public final AjaxEditableLabel<T> setRequired(final boolean required)
	{
		getEditor().setRequired(required);
		return this;
	}",0,[0]
2192,bugs-dot-jar_MNG-4918_691a03a7,"public MavenProject getParent()
    {
        if ( parent == null )
        {
            /*
             * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently
             * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.
             */
            if ( parentFile != null )
            {
                checkProjectBuildingRequest();
                ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );
                request.setRemoteRepositories( getRemoteArtifactRepositories() );

                try
                {
                    parent = mavenProjectBuilder.build( parentFile, request ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    if ( logger != null )
                    {
                        logger.debug( ""Failed to build parent project for "" + getId(), e );
                    }
                }
            }
            else if ( model.getParent() != null )
            {
                checkProjectBuildingRequest();
                ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );
                request.setRemoteRepositories( getRemoteArtifactRepositories() );

                try
                {
                    parent = mavenProjectBuilder.build( getParentArtifact(), request ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    if ( logger != null )
                    {
                        logger.debug( ""Failed to build parent project for "" + getId(), e );
                    }
                }
            }
        }
        return parent;
    }","public MavenProject getParent()
    {
        if ( parent == null )
        {
            /*
             * TODO: This is suboptimal. Without a cache in the project builder, rebuilding the parent chain currently
             * causes O(n^2) parser invocations for an inheritance hierarchy of depth n.
             */
            if ( parentFile != null )
            {
                checkProjectBuildingRequest();
                ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );
                request.setRemoteRepositories( getRemoteArtifactRepositories() );

                try
                {
                    parent = mavenProjectBuilder.build( parentFile, request ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    if ( logger != null )
                    {
                        logger.debug( ""Failed to build parent project for "" + getId(), e );
                    }
                }
            }
            else if ( model.getParent() != null )
            {
                checkProjectBuildingRequest();
                ProjectBuildingRequest request = new DefaultProjectBuildingRequest( projectBuilderConfiguration );
                request.setRemoteRepositories( getRemoteArtifactRepositories() );

                try
                {
                    parent = mavenProjectBuilder.build( getParentArtifact(), request ).getProject();
                }
                catch ( ProjectBuildingException e )
                {
                    if ( logger != null )
                    {
                        logger.debug( ""Failed to build parent project for "" + getId(), e );
                    }
                }
            }
        }
        return parent;
    }",0,[0]
34964,bugs-dot-jar_WICKET-3065_b293b75c,"public Url mapHandler(IRequestHandler requestHandler)
	{
		return null;
	}","public Url mapHandler(IRequestHandler requestHandler)
	{
		return null;
	}",0,[0]
22205,bugs-dot-jar_OAK-2311_ca85ecce,"public synchronized void runBackgroundOperations() {
        if (isDisposed.get()) {
            return;
        }
        if (simpleRevisionCounter != null) {
            // only when using timestamp
            return;
        }
        if (!ENABLE_BACKGROUND_OPS) {
            return;
        }
        try {
            long start = clock.getTime();
            long time = start;
            // split documents (does not create new revisions)
            backgroundSplit();
            long splitTime = clock.getTime() - time;
            time = clock.getTime();
            // write back pending updates to _lastRev
            backgroundWrite();
            long writeTime = clock.getTime() - time;
            time = clock.getTime();
            // pull in changes from other cluster nodes
            backgroundRead(true);
            long readTime = clock.getTime() - time;
            String msg = ""Background operations stats (split:{}, write:{}, read:{})"";
            if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {
                // log as info if it took more than 10 seconds
                LOG.info(msg, splitTime, writeTime, readTime);
            } else {
                LOG.debug(msg, splitTime, writeTime, readTime);
            }
        } catch (RuntimeException e) {
            if (isDisposed.get()) {
                return;
            }
            throw e;
        }
    }","public synchronized void runBackgroundOperations() {
        if (isDisposed.get()) {
            return;
        }
        if (simpleRevisionCounter != null) {
            // only when using timestamp
            return;
        }
        if (!ENABLE_BACKGROUND_OPS) {
            return;
        }
        try {
            long start = clock.getTime();
            long time = start;
            // split documents (does not create new revisions)
            backgroundSplit();
            long splitTime = clock.getTime() - time;
            time = clock.getTime();
            // write back pending updates to _lastRev
            backgroundWrite();
            long writeTime = clock.getTime() - time;
            time = clock.getTime();
            // pull in changes from other cluster nodes
            backgroundRead(true);
            long readTime = clock.getTime() - time;
            String msg = ""Background operations stats (split:{}, write:{}, read:{})"";
            if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {
                // log as info if it took more than 10 seconds
                LOG.info(msg, splitTime, writeTime, readTime);
            } else {
                LOG.debug(msg, splitTime, writeTime, readTime);
            }
        } catch (RuntimeException e) {
            if (isDisposed.get()) {
                return;
            }
            throw e;
        }
    }",0,[0]
8860,bugs-dot-jar_CAMEL-7275_44cad623,"public TryProcessor(Processor tryProcessor, List<Processor> catchClauses, Processor finallyProcessor) {
        this.tryProcessor = tryProcessor;
        this.catchClauses = catchClauses;
        this.finallyProcessor = finallyProcessor;
    }","public TryProcessor(Processor tryProcessor, List<Processor> catchClauses, Processor finallyProcessor) {
        this.tryProcessor = tryProcessor;
        this.catchClauses = catchClauses;
        this.finallyProcessor = finallyProcessor;
    }",0,[0]
24552,bugs-dot-jar_CAMEL-6593_7f8a295a,"@Required
    public void setExpression(String expression) {
        this.expression = expression;
    }","@Required
    public void setExpression(String expression) {
        this.expression = expression;
    }",0,[0]
5231,bugs-dot-jar_ACCUMULO-3475_7651b777,"private final void printException(Exception e, String msg) {
    logError(e.getClass().getName() + (msg != null ? "": "" + msg : """"));
    log.debug(e.getClass().getName() + (msg != null ? "": "" + msg : """"), e);
  }","private final void printException(Exception e, String msg) {
    logError(e.getClass().getName() + (msg != null ? "": "" + msg : """"));
    log.debug(e.getClass().getName() + (msg != null ? "": "" + msg : """"), e);
  }",0,[0]
35278,bugs-dot-jar_ACCUMULO-1732_941e3cb1,"@Override
  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {
    log.setLevel(getLogLevel(job));
    validateOptions(job);

    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();
    Map<String,BatchScanConfig> tableConfigs = getBatchScanConfigs(job);
    for (Map.Entry<String,BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {
      String tableName = tableConfigEntry.getKey();
      BatchScanConfig tableConfig = tableConfigEntry.getValue();
      boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();
      String tableId = null;
      List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();
      if (ranges.isEmpty()) {
        ranges = new ArrayList<Range>(1);
        ranges.add(new Range());
      }

      // get the metadata information for these ranges
      Map<String,Map<KeyExtent,List<Range>>> binnedRanges = new HashMap<String,Map<KeyExtent,List<Range>>>();
      TabletLocator tl;
      try {
        // resolve table name to id once, and use id from this point forward
        tableId = Tables.getTableId(getInstance(job), tableName);
        if (tableConfig.isOfflineScan()) {
          binnedRanges = binOfflineTable(job, tableId, ranges);
          while (binnedRanges == null) {
            // Some tablets were still online, try again
            UtilWaitThread.sleep(100 + (int) (Math.random() * 100)); // sleep randomly between 100 and 200 ms
            binnedRanges = binOfflineTable(job, tableId, ranges);
          }
        } else {
          Instance instance = getInstance(job);
          tl = getTabletLocator(job, tableId);
          // its possible that the cache could contain complete, but old information about a tables tablets... so clear it
          tl.invalidateCache();
          Credentials creds = new Credentials(getPrincipal(job), getAuthenticationToken(job));

          while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {
            if (!(instance instanceof MockInstance)) {
              if (!Tables.exists(instance, tableId))
                throw new TableDeletedException(tableId);
              if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)
                throw new TableOfflineException(instance, tableId);
            }
            binnedRanges.clear();
            log.warn(""Unable to locate bins for specified ranges. Retrying."");
            UtilWaitThread.sleep(100 + (int) (Math.random() * 100)); // sleep randomly between 100 and 200 ms
            tl.invalidateCache();
          }
        }
      } catch (Exception e) {
        throw new IOException(e);
      }

      HashMap<Range,ArrayList<String>> splitsToAdd = null;

      if (!autoAdjust)
        splitsToAdd = new HashMap<Range,ArrayList<String>>();

      HashMap<String,String> hostNameCache = new HashMap<String,String>();
      for (Map.Entry<String,Map<KeyExtent,List<Range>>> tserverBin : binnedRanges.entrySet()) {
        String ip = tserverBin.getKey().split("":"", 2)[0];
        String location = hostNameCache.get(ip);
        if (location == null) {
          InetAddress inetAddress = InetAddress.getByName(ip);
          location = inetAddress.getHostName();
          hostNameCache.put(ip, location);
        }
        for (Map.Entry<KeyExtent,List<Range>> extentRanges : tserverBin.getValue().entrySet()) {
          Range ke = extentRanges.getKey().toDataRange();
          for (Range r : extentRanges.getValue()) {
            if (autoAdjust) {
              // divide ranges into smaller ranges, based on the tablets
              splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] {location}));
            } else {
              // don't divide ranges
              ArrayList<String> locations = splitsToAdd.get(r);
              if (locations == null)
                locations = new ArrayList<String>(1);
              locations.add(location);
              splitsToAdd.put(r, locations);
            }
          }
        }
      }

      if (!autoAdjust)
        for (Map.Entry<Range,ArrayList<String>> entry : splitsToAdd.entrySet())
          splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));
    }

    return splits.toArray(new InputSplit[splits.size()]);
  }","@Override
  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {
    log.setLevel(getLogLevel(job));
    validateOptions(job);

    LinkedList<InputSplit> splits = new LinkedList<InputSplit>();
    Map<String,BatchScanConfig> tableConfigs = getBatchScanConfigs(job);
    for (Map.Entry<String,BatchScanConfig> tableConfigEntry : tableConfigs.entrySet()) {
      String tableName = tableConfigEntry.getKey();
      BatchScanConfig tableConfig = tableConfigEntry.getValue();
      boolean autoAdjust = tableConfig.shouldAutoAdjustRanges();
      String tableId = null;
      List<Range> ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges();
      if (ranges.isEmpty()) {
        ranges = new ArrayList<Range>(1);
        ranges.add(new Range());
      }

      // get the metadata information for these ranges
      Map<String,Map<KeyExtent,List<Range>>> binnedRanges = new HashMap<String,Map<KeyExtent,List<Range>>>();
      TabletLocator tl;
      try {
        // resolve table name to id once, and use id from this point forward
        Instance instance = getInstance(job);
        if (instance instanceof MockInstance)
          tableId = """";
        else
          tableId = Tables.getTableId(instance, tableName);
        if (tableConfig.isOfflineScan()) {
          binnedRanges = binOfflineTable(job, tableId, ranges);
          while (binnedRanges == null) {
            // Some tablets were still online, try again
            UtilWaitThread.sleep(100 + (int) (Math.random() * 100)); // sleep randomly between 100 and 200 ms
            binnedRanges = binOfflineTable(job, tableId, ranges);
          }
        } else {
          tl = getTabletLocator(job, tableId);
          // its possible that the cache could contain complete, but old information about a tables tablets... so clear it
          tl.invalidateCache();
          Credentials creds = new Credentials(getPrincipal(job), getAuthenticationToken(job));

          while (!tl.binRanges(creds, ranges, binnedRanges).isEmpty()) {
            if (!(instance instanceof MockInstance)) {
              if (!Tables.exists(instance, tableId))
                throw new TableDeletedException(tableId);
              if (Tables.getTableState(instance, tableId) == TableState.OFFLINE)
                throw new TableOfflineException(instance, tableId);
            }
            binnedRanges.clear();
            log.warn(""Unable to locate bins for specified ranges. Retrying."");
            UtilWaitThread.sleep(100 + (int) (Math.random() * 100)); // sleep randomly between 100 and 200 ms
            tl.invalidateCache();
          }
        }
      } catch (Exception e) {
        throw new IOException(e);
      }

      HashMap<Range,ArrayList<String>> splitsToAdd = null;

      if (!autoAdjust)
        splitsToAdd = new HashMap<Range,ArrayList<String>>();

      HashMap<String,String> hostNameCache = new HashMap<String,String>();
      for (Map.Entry<String,Map<KeyExtent,List<Range>>> tserverBin : binnedRanges.entrySet()) {
        String ip = tserverBin.getKey().split("":"", 2)[0];
        String location = hostNameCache.get(ip);
        if (location == null) {
          InetAddress inetAddress = InetAddress.getByName(ip);
          location = inetAddress.getHostName();
          hostNameCache.put(ip, location);
        }
        for (Map.Entry<KeyExtent,List<Range>> extentRanges : tserverBin.getValue().entrySet()) {
          Range ke = extentRanges.getKey().toDataRange();
          for (Range r : extentRanges.getValue()) {
            if (autoAdjust) {
              // divide ranges into smaller ranges, based on the tablets
              splits.add(new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] {location}));
            } else {
              // don't divide ranges
              ArrayList<String> locations = splitsToAdd.get(r);
              if (locations == null)
                locations = new ArrayList<String>(1);
              locations.add(location);
              splitsToAdd.put(r, locations);
            }
          }
        }
      }

      if (!autoAdjust)
        for (Map.Entry<Range,ArrayList<String>> entry : splitsToAdd.entrySet())
          splits.add(new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])));
    }

    return splits.toArray(new InputSplit[splits.size()]);
  }",1,"[23, 32]"
24561,bugs-dot-jar_CAMEL-6593_7f8a295a,"public boolean isTrim() {
        // trim by default
        return trim == null || trim;
    }","public boolean isTrim() {
        // trim by default
        return trim == null || trim;
    }",0,[0]
823,bugs-dot-jar_ACCUMULO-412_5594b2e0,"@Override
  public Repo<Master> call(final long tid, Master master) throws Exception {
    
    FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),
        ServerConfiguration.getSiteConfiguration()));
    List<FileStatus> files = new ArrayList<FileStatus>();
    for (FileStatus entry : fs.listStatus(new Path(bulk))) {
      files.add(entry);
    }
    log.debug(""tid "" + tid + "" importing "" + files.size() + "" files"");
    
    Path writable = new Path(this.errorDir, "".iswritable"");
    if (!fs.createNewFile(writable)) {
      // Maybe this is a re-try... clear the flag and try again
      fs.delete(writable, false);
      if (!fs.createNewFile(writable))
        throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.BULK_BAD_ERROR_DIRECTORY,
            ""Unable to write to "" + this.errorDir);
    }
    fs.delete(writable, false);
    
    // group files into N-sized chunks, send the chunks to random servers
    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers()
        .size());
    
    log.debug(""tid "" + tid + "" using "" + SERVERS_TO_USE + "" servers"");
    // wait for success, repeat failures R times
    final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());
    for (FileStatus f : files)
      filesToLoad.add(f.getPath().toString());
    
    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));
    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {
      List<Future<?>> results = new ArrayList<Future<?>>();
      for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {
        final List<String> attempt = chunk;
        results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {
          @Override
          public void run() {
            ClientService.Iface client = null;
            try {
              client = ServerClient.getConnection(HdfsZooInstance.getInstance());
              List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
              attempt.removeAll(fail);
              filesToLoad.removeAll(attempt);
            } catch (Exception ex) {
              log.error(ex, ex);
            } finally {
              ServerClient.close(client);
            }
          }
        })));
      }
      for (Future<?> f : results)
        f.get();
      if (filesToLoad.size() > 0) {
        log.debug(""tid "" + tid + "" attempt "" + (i + 1) + "" "" + filesToLoad + "" failed"");
        UtilWaitThread.sleep(100);
      }
    }
    // Copy/Create failed file markers
    for (String f : filesToLoad) {
      Path orig = new Path(f);
      Path dest = new Path(errorDir, orig.getName());
      try {
        FileUtil.copy(fs, orig, fs, dest, false, true, CachedConfiguration.getInstance());
        log.debug(""tid "" + tid + "" copied "" + orig + "" to "" + dest + "": failed"");
      } catch (IOException ex) {
        try {
          fs.create(dest).close();
          log.debug(""tid "" + tid + "" marked "" + dest + "" failed"");
        } catch (IOException e) {
          log.error(""Unable to create failure flag file "" + dest, e);
        }
      }
    }
    
    // return the next step, which will perform cleanup
    return new CompleteBulkImport(tableId, source, bulk, errorDir);
  }","@Override
  public Repo<Master> call(final long tid, Master master) throws Exception {
    final SiteConfiguration conf = ServerConfiguration.getSiteConfiguration();
    FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),
        ServerConfiguration.getSiteConfiguration()));
    List<FileStatus> files = new ArrayList<FileStatus>();
    for (FileStatus entry : fs.listStatus(new Path(bulk))) {
      files.add(entry);
    }
    log.debug(""tid "" + tid + "" importing "" + files.size() + "" files"");
    
    Path writable = new Path(this.errorDir, "".iswritable"");
    if (!fs.createNewFile(writable)) {
      // Maybe this is a re-try... clear the flag and try again
      fs.delete(writable, false);
      if (!fs.createNewFile(writable))
        throw new ThriftTableOperationException(tableId, null, TableOperation.BULK_IMPORT, TableOperationExceptionType.BULK_BAD_ERROR_DIRECTORY,
            ""Unable to write to "" + this.errorDir);
    }
    fs.delete(writable, false);
    
    final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());
    for (FileStatus f : files)
      filesToLoad.add(f.getPath().toString());
    

    final int RETRIES = Math.max(1, conf.getCount(Property.MASTER_BULK_RETRIES));
    for (int attempt = 0; attempt < RETRIES && filesToLoad.size() > 0; attempt++) {
      List<Future<List<String>>> results = new ArrayList<Future<List<String>>>();
      
      // Figure out which files will be sent to which server
      Set<TServerInstance> currentServers = Collections.synchronizedSet(new HashSet<TServerInstance>(master.onlineTabletServers()));
      Map<String,List<String>> loadAssignments = new HashMap<String,List<String>>();
      for (TServerInstance server : currentServers) {
        loadAssignments.put(server.hostPort(), new ArrayList<String>());
      }
      int i = 0;
      List<Entry<String,List<String>>> entries = new ArrayList<Entry<String,List<String>>>(loadAssignments.entrySet());
      for (String file : filesToLoad) {
        entries.get(i % entries.size()).getValue().add(file);
        i++;
      }
      
      // Use the threadpool to assign files one-at-a-time to the server
      for (Entry<String,List<String>> entry : entries) {
        if (entry.getValue().isEmpty()) {
          continue;
        }
        final Entry<String,List<String>> finalEntry = entry;
        results.add(threadPool.submit(new Callable<List<String>>() {
          @Override
          public List<String> call() {
            if (log.isDebugEnabled()) {
              log.debug(""Asking "" + finalEntry.getKey() + "" to load "" + sampleList(finalEntry.getValue(), 10));
            }
            List<String> failures = new ArrayList<String>();
            ClientService.Iface client = null;
            try {
              client = ThriftUtil.getTServerClient(finalEntry.getKey(), conf);
              for (String file : finalEntry.getValue()) {
                List<String> attempt = Collections.singletonList(file);
                log.debug(""Asking "" + finalEntry.getKey() + "" to bulk import "" + file);
                List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
                if (fail.isEmpty()) {
                  filesToLoad.remove(file);
                } else {
                  failures.addAll(fail);
                }
              }
            } catch (Exception ex) {
              log.error(ex, ex);
            } finally {
              ServerClient.close(client);
            }
            return failures;
          }
        }));
      }
      Set<String> failures = new HashSet<String>();
      for (Future<List<String>> f : results)
        failures.addAll(f.get());
      if (filesToLoad.size() > 0) {
        log.debug(""tid "" + tid + "" attempt "" + (i + 1) + "" "" + sampleList(filesToLoad, 10) + "" failed"");
        UtilWaitThread.sleep(100);
      }
    }
    // Copy/Create failed file markers
    for (String f : filesToLoad) {
      Path orig = new Path(f);
      Path dest = new Path(errorDir, orig.getName());
      try {
        FileUtil.copy(fs, orig, fs, dest, false, true, CachedConfiguration.getInstance());
        log.debug(""tid "" + tid + "" copied "" + orig + "" to "" + dest + "": failed"");
      } catch (IOException ex) {
        try {
          fs.create(dest).close();
          log.debug(""tid "" + tid + "" marked "" + dest + "" failed"");
        } catch (IOException e) {
          log.error(""Unable to create failure flag file "" + dest, e);
        }
      }
    }
    
    // return the next step, which will perform cleanup
    return new CompleteBulkImport(tableId, source, bulk, errorDir);
  }",1,"[21, 22, 23, 25, 26, 31, 32, 33, 34, 35, 36, 38, 41, 42, 43, 44, 51, 53, 54, 56]"
3816,bugs-dot-jar_FLINK-2460_a17d4e82,"@Override
	public boolean registerListener(NotificationListener listener) throws IOException {
		return false;
	}","@Override
	public boolean registerListener(NotificationListener listener) throws IOException {
		return false;
	}",0,[0]
17861,bugs-dot-jar_OAK-1075_79467350,"@Override
    public PropertyRestriction getPropertyRestriction(String propertyName) {
        return propertyRestrictions.get(propertyName);
    }","@Override
    public PropertyRestriction getPropertyRestriction(String propertyName) {
        return propertyRestrictions.get(propertyName);
    }",0,[0]
12178,bugs-dot-jar_OAK-554_3f51fb09,"private static int compareAsDate(String p1, String p2) {
        Calendar c1 = Conversions.convert(p1).toCalendar();
        Calendar c2 = Conversions.convert(p1).toCalendar();
        return c1 != null && c2 != null
                ? c1.compareTo(c2)
                : p1.compareTo(p2);
    }","private static int compareAsDate(String p1, String p2) {
        Calendar c1 = Conversions.convert(p1).toCalendar();
        Calendar c2 = Conversions.convert(p1).toCalendar();
        return c1 != null && c2 != null
                ? c1.compareTo(c2)
                : p1.compareTo(p2);
    }",0,[0]
8078,bugs-dot-jar_OAK-1655_c91bfa54,"@Override
    public Iterator<String> resolveChunks(String blobId) throws IOException {
        return Iterators.singletonIterator(blobId);
    }","@Override
    public Iterator<String> resolveChunks(String blobId) throws IOException {
        return Iterators.singletonIterator(blobId);
    }",0,[0]
929,Bears-123,"private static boolean isMoving(ArrayList<Position> positions, int index,
            TripsConfig tripsConfig, double speedThreshold) {
        if (tripsConfig.getMinimalNoDataDuration() > 0) {
            boolean beforeGap = index < positions.size() - 1
                    && positions.get(index + 1).getFixTime().getTime() - positions.get(index).getFixTime().getTime()
                    >= tripsConfig.getMinimalNoDataDuration();
            boolean afterGap = index > 0
                    && positions.get(index).getFixTime().getTime() - positions.get(index - 1).getFixTime().getTime()
                    >= tripsConfig.getMinimalNoDataDuration();
            if (beforeGap || afterGap) {
                return false;
            }
        }
        if (positions.get(index).getAttributes().containsKey(Position.KEY_MOTION)
                && positions.get(index).getAttributes().get(Position.KEY_MOTION) instanceof Boolean) {
            return positions.get(index).getBoolean(Position.KEY_MOTION);
        } else {
            return positions.get(index).getSpeed() > speedThreshold;
        }
    }","private static boolean isMoving(ArrayList<Position> positions, int index,
            TripsConfig tripsConfig, double speedThreshold) {
        if (tripsConfig.getMinimalNoDataDuration() > 0) {
            boolean beforeGap = index < positions.size() - 1
                    && positions.get(index + 1).getFixTime().getTime() - positions.get(index).getFixTime().getTime()
                    >= tripsConfig.getMinimalNoDataDuration();
            boolean afterGap = index > 0
                    && positions.get(index).getFixTime().getTime() - positions.get(index - 1).getFixTime().getTime()
                    >= tripsConfig.getMinimalNoDataDuration();
            if (beforeGap || afterGap) {
                return false;
            }
        }
        if (positions.get(index).getAttributes().containsKey(Position.KEY_MOTION)
                && positions.get(index).getAttributes().get(Position.KEY_MOTION) instanceof Boolean) {
            return positions.get(index).getBoolean(Position.KEY_MOTION);
        } else {
            return positions.get(index).getSpeed() > speedThreshold;
        }
    }",0,[0]
32895,bugs-dot-jar_OAK-4036_f4324736,"protected void unbindNodeAggregator(NodeAggregator aggregator) {
        this.nodeAggregator = null;
        initialize();
    }","protected void unbindNodeAggregator(NodeAggregator aggregator) {
        this.nodeAggregator = null;
        initialize();
    }",0,[0]
1512,bugs-dot-jar_OAK-4307_f303c916,"MapRecord writeMap(final MapRecord base, final Map<String, RecordId> changes) throws IOException {
        return new MapRecord(
            writeOperationHandler.execute(new SegmentWriteOperation() {
                @Override
                public RecordId execute(SegmentBufferWriter writer) throws IOException {
                    return with(writer).writeMap(base, changes);
                }
            }));
    }","MapRecord writeMap(final MapRecord base, final Map<String, RecordId> changes) throws IOException {
        return new MapRecord(
            writeOperationHandler.execute(new SegmentWriteOperation() {
                @Override
                public RecordId execute(SegmentBufferWriter writer) throws IOException {
                    return with(writer).writeMap(base, changes);
                }
            }));
    }",0,[0]
707,bugs-dot-jar_WICKET-4594_556a2236,"public PageProvider(Class<? extends IRequestablePage> pageClass)
	{
		this(pageClass, null);
	}","public PageProvider(Class<? extends IRequestablePage> pageClass)
	{
		this(pageClass, null);
	}",0,[0]
20199,bugs-dot-jar_CAMEL-4388_f39bc60d,"@Override
    public String toString() {
        return ""Log["" + expression + ""]"";
    }","@Override
    public String toString() {
        return ""Log["" + expression + ""]"";
    }",0,[0]
21076,bugs-dot-jar_OAK-846_7acb091a,"public int getPendingWriteCount() {
        return unsavedLastRevisions.size();
    }","public int getPendingWriteCount() {
        return unsavedLastRevisions.size();
    }",0,[0]
37144,bugs-dot-jar_CAMEL-7239_ae419224,"public void setUseSharedSchema(boolean useSharedSchema) {
        this.useSharedSchema = useSharedSchema;
    }","public void setUseSharedSchema(boolean useSharedSchema) {
        this.useSharedSchema = useSharedSchema;
    }",0,[0]
33658,bugs-dot-jar_WICKET-4659_ccd74641,"private boolean isProcessingAjaxRequest()
	{

		RequestCycle rc = RequestCycle.get();
		Request request = rc.getRequest();
		if (request instanceof WebRequest)
		{
			return ((WebRequest)request).isAjax();
		}
		return false;
	}","private boolean isProcessingAjaxRequest()
	{

		RequestCycle rc = RequestCycle.get();
		Request request = rc.getRequest();
		if (request instanceof WebRequest)
		{
			return ((WebRequest)request).isAjax();
		}
		return false;
	}",0,[0]
20473,bugs-dot-jar_WICKET-128_7e1000dd,"final void cleanupFeedbackMessages()
	{
		int size = feedbackMessages.size();
		feedbackMessages.clearRendered();
		// mark the session as dirty when the feedback messages have been
		// altered.
		if (size != feedbackMessages.size())
		{
			dirty();
		}
	}","final void cleanupFeedbackMessages()
	{
		int size = feedbackMessages.size();
		feedbackMessages.clearRendered();
		// mark the session as dirty when the feedback messages have been
		// altered.
		if (size != feedbackMessages.size())
		{
			dirty();
		}
	}",0,[0]
36627,bugs-dot-jar_MATH-904_6844aba9,"public static double tanh(double x) {
      boolean negate = false;

      if (x != x) {
          return x;
      }

      // tanh[z] = sinh[z] / cosh[z]
      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
      // = (exp(2x) - 1) / (exp(2x) + 1)

      // for magnitude > 20, sinh[z] == cosh[z] in double precision

      if (x > 20.0) {
          return 1.0;
      }

      if (x < -20) {
          return -1.0;
      }

      if (x == 0) {
          return x;
      }

      if (x < 0.0) {
          x = -x;
          negate = true;
      }

      double result;
      if (x >= 0.5) {
          double hiPrec[] = new double[2];
          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
          exp(x*2.0, 0.0, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          /* Numerator */
          double na = -1.0 + ya;
          double nb = -(na + 1.0 - ya);
          double temp = na + yb;
          nb += -(temp - na - yb);
          na = temp;

          /* Denominator */
          double da = 1.0 + ya;
          double db = -(da - 1.0 - ya);
          temp = da + yb;
          db += -(temp - da - yb);
          da = temp;

          temp = da * HEX_40000000;
          double daa = da + temp - temp;
          double dab = da - daa;

          // ratio = na/da
          double ratio = na/da;
          temp = ratio * HEX_40000000;
          double ratioa = ratio + temp - temp;
          double ratiob = ratio - ratioa;

          // Correct for rounding in division
          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;

          // Account for nb
          ratiob += nb / da;
          // Account for db
          ratiob += -db * na / da / da;

          result = ratioa + ratiob;
      }
      else {
          double hiPrec[] = new double[2];
          // tanh(x) = expm1(2x) / (expm1(2x) + 2)
          expm1(x*2.0, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          /* Numerator */
          double na = ya;
          double nb = yb;

          /* Denominator */
          double da = 2.0 + ya;
          double db = -(da - 2.0 - ya);
          double temp = da + yb;
          db += -(temp - da - yb);
          da = temp;

          temp = da * HEX_40000000;
          double daa = da + temp - temp;
          double dab = da - daa;

          // ratio = na/da
          double ratio = na/da;
          temp = ratio * HEX_40000000;
          double ratioa = ratio + temp - temp;
          double ratiob = ratio - ratioa;

          // Correct for rounding in division
          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;

          // Account for nb
          ratiob += nb / da;
          // Account for db
          ratiob += -db * na / da / da;

          result = ratioa + ratiob;
      }

      if (negate) {
          result = -result;
      }

      return result;
    }","public static double tanh(double x) {
      boolean negate = false;

      if (x != x) {
          return x;
      }

      // tanh[z] = sinh[z] / cosh[z]
      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
      // = (exp(2x) - 1) / (exp(2x) + 1)

      // for magnitude > 20, sinh[z] == cosh[z] in double precision

      if (x > 20.0) {
          return 1.0;
      }

      if (x < -20) {
          return -1.0;
      }

      if (x == 0) {
          return x;
      }

      if (x < 0.0) {
          x = -x;
          negate = true;
      }

      double result;
      if (x >= 0.5) {
          double hiPrec[] = new double[2];
          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
          exp(x*2.0, 0.0, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          /* Numerator */
          double na = -1.0 + ya;
          double nb = -(na + 1.0 - ya);
          double temp = na + yb;
          nb += -(temp - na - yb);
          na = temp;

          /* Denominator */
          double da = 1.0 + ya;
          double db = -(da - 1.0 - ya);
          temp = da + yb;
          db += -(temp - da - yb);
          da = temp;

          temp = da * HEX_40000000;
          double daa = da + temp - temp;
          double dab = da - daa;

          // ratio = na/da
          double ratio = na/da;
          temp = ratio * HEX_40000000;
          double ratioa = ratio + temp - temp;
          double ratiob = ratio - ratioa;

          // Correct for rounding in division
          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;

          // Account for nb
          ratiob += nb / da;
          // Account for db
          ratiob += -db * na / da / da;

          result = ratioa + ratiob;
      }
      else {
          double hiPrec[] = new double[2];
          // tanh(x) = expm1(2x) / (expm1(2x) + 2)
          expm1(x*2.0, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          /* Numerator */
          double na = ya;
          double nb = yb;

          /* Denominator */
          double da = 2.0 + ya;
          double db = -(da - 2.0 - ya);
          double temp = da + yb;
          db += -(temp - da - yb);
          da = temp;

          temp = da * HEX_40000000;
          double daa = da + temp - temp;
          double dab = da - daa;

          // ratio = na/da
          double ratio = na/da;
          temp = ratio * HEX_40000000;
          double ratioa = ratio + temp - temp;
          double ratiob = ratio - ratioa;

          // Correct for rounding in division
          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;

          // Account for nb
          ratiob += nb / da;
          // Account for db
          ratiob += -db * na / da / da;

          result = ratioa + ratiob;
      }

      if (negate) {
          result = -result;
      }

      return result;
    }",0,[0]
17240,bugs-dot-jar_CAMEL-4474_06a8489a,"public void setFile(File file) {
        this.file = file;
        // update configuration as well
        getConfiguration().setDirectory(file.getPath());
    }","public void setFile(File file) {
        this.file = file;
        // update configuration as well
        getConfiguration().setDirectory(file.getPath());
    }",0,[0]
10441,bugs-dot-jar_WICKET-5230_9c8f658a,"@Override
	protected final void onEvent(final AjaxRequestTarget target)
	{
		final FormComponent<?> formComponent = getFormComponent();

		if (""blur"".equals(getEvent().toLowerCase()) && disableFocusOnBlur())
		{
			target.focusComponent(null);
		}

		try
		{
			formComponent.inputChanged();
			formComponent.validate();
			if (formComponent.hasErrorMessage())
			{
				formComponent.invalid();

				onError(target, null);
			}
			else
			{
				formComponent.valid();
				if (getUpdateModel())
				{
					formComponent.updateModel();
				}

				onUpdate(target);
			}
		}
		catch (RuntimeException e)
		{
			onError(target, e);

		}
	}","@Override
	protected final void onEvent(final AjaxRequestTarget target)
	{
		final FormComponent<?> formComponent = getFormComponent();

		if (""blur"".equals(getEvent().toLowerCase()) && disableFocusOnBlur())
		{
			target.focusComponent(null);
		}

		try
		{
			formComponent.inputChanged();
			formComponent.validate();
			if (formComponent.isValid())
			{
				formComponent.valid();
				if (getUpdateModel())
				{
					formComponent.updateModel();
				}

				onUpdate(target);
			}
			else
			{
				formComponent.invalid();

				onError(target, null);
			}
		}
		catch (RuntimeException e)
		{
			onError(target, e);

		}
	}",1,"[14, 15, 16, 18, 19, 20]"
5442,bugs-dot-jar_OAK-1186_52372042,"@Nonnull
    @Override
    public NodeState rebase(@Nonnull NodeBuilder builder) {
        return asMongoRootBuilder(builder).rebase();
    }","@Nonnull
    @Override
    public NodeState rebase(@Nonnull NodeBuilder builder) {
        return asMongoRootBuilder(builder).rebase();
    }",0,[0]
814,bugs-dot-jar_ACCUMULO-412_5594b2e0,"private Path createNewBulkDir(FileSystem fs, String tableId) throws IOException {
    Path directory = new Path(ServerConstants.getTablesDir() + ""/"" + tableId);
    fs.mkdirs(directory);
    
    // only one should be able to create the lock file
    // the purpose of the lock file is to avoid a race
    // condition between the call to fs.exists() and
    // fs.mkdirs()... if only hadoop had a mkdir() function
    // that failed when the dir existed
    
    UniqueNameAllocator namer = UniqueNameAllocator.getInstance();
    
    while (true) {
      Path newBulkDir = new Path(directory, Constants.BULK_PREFIX + namer.getNextName());
      if (fs.exists(newBulkDir)) // sanity check
        throw new IllegalStateException(""Dir exist when it should not "" + newBulkDir);
      if (fs.mkdirs(newBulkDir))
        return newBulkDir;
      log.warn(""Failed to create "" + newBulkDir + "" for unknown reason"");
      
      UtilWaitThread.sleep(3000);
    }
  }","private Path createNewBulkDir(FileSystem fs, String tableId) throws IOException {
    Path directory = new Path(ServerConstants.getTablesDir() + ""/"" + tableId);
    fs.mkdirs(directory);
    
    // only one should be able to create the lock file
    // the purpose of the lock file is to avoid a race
    // condition between the call to fs.exists() and
    // fs.mkdirs()... if only hadoop had a mkdir() function
    // that failed when the dir existed
    
    UniqueNameAllocator namer = UniqueNameAllocator.getInstance();
    
    while (true) {
      Path newBulkDir = new Path(directory, Constants.BULK_PREFIX + namer.getNextName());
      if (fs.exists(newBulkDir)) // sanity check
        throw new IllegalStateException(""Dir exist when it should not "" + newBulkDir);
      if (fs.mkdirs(newBulkDir))
        return newBulkDir;
      log.warn(""Failed to create "" + newBulkDir + "" for unknown reason"");
      
      UtilWaitThread.sleep(3000);
    }
  }",0,[0]
30493,bugs-dot-jar_CAMEL-8626_d063f471,"public void reset(boolean includeProcessors) throws Exception {
        reset();

        // and now reset all processors for this route
        if (includeProcessors) {
            MBeanServer server = getContext().getManagementStrategy().getManagementAgent().getMBeanServer();
            if (server != null) {
                // get all the processor mbeans and sort them accordingly to their index
                String prefix = getContext().getManagementStrategy().getManagementAgent().getIncludeHostName() ? ""*/"" : """";
                ObjectName query = ObjectName.getInstance(""org.apache.camel:context="" + prefix + getContext().getManagementName() + "",type=processors,*"");
                QueryExp queryExp = Query.match(new AttributeValueExp(""RouteId""), new StringValueExp(getRouteId()));
                Set<ObjectName> names = server.queryNames(query, queryExp);
                for (ObjectName name : names) {
                    server.invoke(name, ""reset"", null, null);
                }
            }
        }
    }","public void reset(boolean includeProcessors) throws Exception {
        reset();

        // and now reset all processors for this route
        if (includeProcessors) {
            MBeanServer server = getContext().getManagementStrategy().getManagementAgent().getMBeanServer();
            if (server != null) {
                // get all the processor mbeans and sort them accordingly to their index
                String prefix = getContext().getManagementStrategy().getManagementAgent().getIncludeHostName() ? ""*/"" : """";
                ObjectName query = ObjectName.getInstance(""org.apache.camel:context="" + prefix + getContext().getManagementName() + "",type=processors,*"");
                QueryExp queryExp = Query.match(new AttributeValueExp(""RouteId""), new StringValueExp(getRouteId()));
                Set<ObjectName> names = server.queryNames(query, queryExp);
                for (ObjectName name : names) {
                    server.invoke(name, ""reset"", null, null);
                }
            }
        }
    }",0,[0]
22675,bugs-dot-jar_WICKET-428_4a6a573b,"public void clear()
	{
		for (int i = 0; i < keys.length; i++)
		{
			keys[i] = null;
			values[i] = null;
		}

		size = 0;
	}","public void clear()
	{
		for (int i = 0; i < keys.length; i++)
		{
			keys[i] = null;
			values[i] = null;
		}

		size = 0;
	}",0,[0]
26226,bugs-dot-jar_LOG4J2-430_238ce8aa,"@Override
    public String toSerializable(final LogEvent event) {
        final StringBuilder buf = new StringBuilder();
        appendPriority(buf, event.getLevel());
        appendTimestamp(buf, event.getMillis());
        appendSpace(buf);
        appendHostName(buf);
        appendSpace(buf);
        appendAppName(buf);
        appendSpace(buf);
        appendProcessId(buf);
        appendSpace(buf);
        appendMessageId(buf, event.getMessage());
        appendSpace(buf);
        appendStructuredElements(buf, event);
        appendMessage(buf, event);
        if (useTLSMessageFormat) {
            return new TLSSyslogFrame(buf.toString()).toString();
        }
        return buf.toString();
    }","@Override
    public String toSerializable(final LogEvent event) {
        final StringBuilder buf = new StringBuilder();
        appendPriority(buf, event.getLevel());
        appendTimestamp(buf, event.getMillis());
        appendSpace(buf);
        appendHostName(buf);
        appendSpace(buf);
        appendAppName(buf);
        appendSpace(buf);
        appendProcessId(buf);
        appendSpace(buf);
        appendMessageId(buf, event.getMessage());
        appendSpace(buf);
        appendStructuredElements(buf, event);
        appendMessage(buf, event);
        if (useTLSMessageFormat) {
            return new TLSSyslogFrame(buf.toString()).toString();
        }
        return buf.toString();
    }",0,[0]
14977,bugs-dot-jar_MNG-5075_2eb419ed,"public String getModulePathAdjustment( MavenProject moduleProject )
        throws IOException
    {
        // FIXME: This is hacky. What if module directory doesn't match artifactid, and parent
        // is coming from the repository??
        String module = moduleProject.getArtifactId();

        File moduleFile = moduleProject.getFile();

        if ( moduleFile != null )
        {
            File moduleDir = moduleFile.getCanonicalFile().getParentFile();

            module = moduleDir.getName();
        }

        if ( moduleAdjustments == null )
        {
            moduleAdjustments = new HashMap<String, String>();

            List<String> modules = getModules();
            if ( modules != null )
            {
                for ( String modulePath : modules )
                {
                    String moduleName = modulePath;

                    if ( moduleName.endsWith( ""/"" ) || moduleName.endsWith( ""\\"" ) )
                    {
                        moduleName = moduleName.substring( 0, moduleName.length() - 1 );
                    }

                    int lastSlash = moduleName.lastIndexOf( '/' );

                    if ( lastSlash < 0 )
                    {
                        lastSlash = moduleName.lastIndexOf( '\\' );
                    }

                    String adjustment = null;

                    if ( lastSlash > -1 )
                    {
                        moduleName = moduleName.substring( lastSlash + 1 );
                        adjustment = modulePath.substring( 0, lastSlash );
                    }

                    moduleAdjustments.put( moduleName, adjustment );
                }
            }
        }

        return moduleAdjustments.get( module );
    }","public String getModulePathAdjustment( MavenProject moduleProject )
        throws IOException
    {
        // FIXME: This is hacky. What if module directory doesn't match artifactid, and parent
        // is coming from the repository??
        String module = moduleProject.getArtifactId();

        File moduleFile = moduleProject.getFile();

        if ( moduleFile != null )
        {
            File moduleDir = moduleFile.getCanonicalFile().getParentFile();

            module = moduleDir.getName();
        }

        if ( moduleAdjustments == null )
        {
            moduleAdjustments = new HashMap<String, String>();

            List<String> modules = getModules();
            if ( modules != null )
            {
                for ( String modulePath : modules )
                {
                    String moduleName = modulePath;

                    if ( moduleName.endsWith( ""/"" ) || moduleName.endsWith( ""\\"" ) )
                    {
                        moduleName = moduleName.substring( 0, moduleName.length() - 1 );
                    }

                    int lastSlash = moduleName.lastIndexOf( '/' );

                    if ( lastSlash < 0 )
                    {
                        lastSlash = moduleName.lastIndexOf( '\\' );
                    }

                    String adjustment = null;

                    if ( lastSlash > -1 )
                    {
                        moduleName = moduleName.substring( lastSlash + 1 );
                        adjustment = modulePath.substring( 0, lastSlash );
                    }

                    moduleAdjustments.put( moduleName, adjustment );
                }
            }
        }

        return moduleAdjustments.get( module );
    }",0,[0]
1764,Bears-202,"public ClassGraph ignoreFieldVisibility() {
        enableClassInfo();
        enableFieldInfo();
        scanSpec.ignoreFieldVisibility = true;
        return this;
    }","public ClassGraph ignoreFieldVisibility() {
        enableClassInfo();
        enableFieldInfo();
        scanSpec.ignoreFieldVisibility = true;
        return this;
    }",0,[0]
7605,bugs-dot-jar_OAK-1178_f2bb1a17,"@Override
    public <T> void setProperty(String name, T value, Type<T> type) {
        beforeWrite();
        nodeBuilder.setProperty(name, value, type);
        root.updated();
    }","@Override
    public <T> void setProperty(String name, T value, Type<T> type) {
        beforeWrite();
        nodeBuilder.setProperty(name, value, type);
        root.updated();
    }",0,[0]
35726,bugs-dot-jar_FLINK-1978_0078c44e,"@Override
	@SuppressWarnings({""unchecked"", ""rawtypes""})
	public T deserialize(DataInputView source) throws IOException {
		int flags = source.readByte();
		if((flags & IS_NULL) != 0) {
			return null;
		}

		T target;

		Class<?> actualSubclass = null;
		TypeSerializer subclassSerializer = null;

		if ((flags & IS_SUBCLASS) != 0) {
			String subclassName = source.readUTF();
			try {
				actualSubclass = Class.forName(subclassName, true, cl);
			} catch (ClassNotFoundException e) {
				throw new RuntimeException(""Cannot instantiate class."", e);
			}
			subclassSerializer = getSubclassSerializer(actualSubclass);
			target = (T) subclassSerializer.createInstance();
			// also initialize fields for which the subclass serializer is not responsible
			initializeFields(target);
		} else if ((flags & IS_TAGGED_SUBCLASS) != 0) {

			int subclassTag = source.readByte();
			subclassSerializer = registeredSerializers[subclassTag];
			target = (T) subclassSerializer.createInstance();
			// also initialize fields for which the subclass serializer is not responsible
			initializeFields(target);
		} else {
			target = createInstance();
		}

		if ((flags & NO_SUBCLASS) != 0) {
			try {
				for (int i = 0; i < numFields; i++) {
					boolean isNull = source.readBoolean();
					if (isNull) {
						fields[i].set(target, null);
					} else {
						Object field = fieldSerializers[i].deserialize(source);
						fields[i].set(target, field);
					}
				}
			} catch (IllegalAccessException e) {
				throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields"" + ""before."");

			}
		} else {
			if (subclassSerializer != null) {
				target = (T) subclassSerializer.deserialize(target, source);
			}
		}
		return target;
	}","@Override
	@SuppressWarnings({""unchecked"", ""rawtypes""})
	public T deserialize(DataInputView source) throws IOException {
		int flags = source.readByte();
		if((flags & IS_NULL) != 0) {
			return null;
		}

		T target;

		Class<?> actualSubclass = null;
		TypeSerializer subclassSerializer = null;

		if ((flags & IS_SUBCLASS) != 0) {
			String subclassName = source.readUTF();
			try {
				actualSubclass = Class.forName(subclassName, true, cl);
			} catch (ClassNotFoundException e) {
				throw new RuntimeException(""Cannot instantiate class."", e);
			}
			subclassSerializer = getSubclassSerializer(actualSubclass);
			target = (T) subclassSerializer.createInstance();
			// also initialize fields for which the subclass serializer is not responsible
			initializeFields(target);
		} else if ((flags & IS_TAGGED_SUBCLASS) != 0) {

			int subclassTag = source.readByte();
			subclassSerializer = registeredSerializers[subclassTag];
			target = (T) subclassSerializer.createInstance();
			// also initialize fields for which the subclass serializer is not responsible
			initializeFields(target);
		} else {
			target = createInstance();
		}

		if ((flags & NO_SUBCLASS) != 0) {
			try {
				for (int i = 0; i < numFields; i++) {
					boolean isNull = source.readBoolean();
					if (isNull) {
						fields[i].set(target, null);
					} else {
						Object field = fieldSerializers[i].deserialize(source);
						fields[i].set(target, field);
					}
				}
			} catch (IllegalAccessException e) {
				throw new RuntimeException(""Error during POJO copy, this should not happen since we check the fields"" + ""before."");

			}
		} else {
			if (subclassSerializer != null) {
				target = (T) subclassSerializer.deserialize(target, source);
			}
		}
		return target;
	}",0,[0]
26083,bugs-dot-jar_ACCUMULO-334_9d8cc45d,"@Override
  public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    
    if (options == null)
      throw new IllegalArgumentException(""start and/or end must be set for "" + TimestampFilter.class.getName());
    
    hasStart = false;
    hasEnd = false;
    startInclusive = true;
    endInclusive = true;
    
    if (options.containsKey(START))
      hasStart = true;
    if (options.containsKey(END))
      hasEnd = true;
    if (!hasStart && !hasEnd)
      throw new IllegalArgumentException(""must have either start or end for "" + TimestampFilter.class.getName());
    
    try {
      if (hasStart)
        start = dateParser.parse(options.get(START)).getTime();
      if (hasEnd)
        end = dateParser.parse(options.get(END)).getTime();
    } catch (Exception e) {
      throw new IllegalArgumentException(e);
    }
    if (options.get(START_INCL) != null)
      startInclusive = Boolean.parseBoolean(options.get(START_INCL));
    if (options.get(END_INCL) != null)
      endInclusive = Boolean.parseBoolean(options.get(END_INCL));
  }","@Override
  public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> options, IteratorEnvironment env) throws IOException {
    super.init(source, options, env);
    
    if (options == null)
      throw new IllegalArgumentException(""start and/or end must be set for "" + TimestampFilter.class.getName());
    
    hasStart = false;
    hasEnd = false;
    startInclusive = true;
    endInclusive = true;
    
    if (options.containsKey(START))
      hasStart = true;
    if (options.containsKey(END))
      hasEnd = true;
    if (!hasStart && !hasEnd)
      throw new IllegalArgumentException(""must have either start or end for "" + TimestampFilter.class.getName());
    
    try {
      if (hasStart)
        start = dateParser.parse(options.get(START)).getTime();
      if (hasEnd)
        end = dateParser.parse(options.get(END)).getTime();
    } catch (Exception e) {
      throw new IllegalArgumentException(e);
    }
    if (options.get(START_INCL) != null)
      startInclusive = Boolean.parseBoolean(options.get(START_INCL));
    if (options.get(END_INCL) != null)
      endInclusive = Boolean.parseBoolean(options.get(END_INCL));
  }",0,[0]
26905,bugs-dot-jar_WICKET-5724_b92591f6,"public final boolean isOpenClose()
	{
		return xmlTag.isOpenClose();
	}","public final boolean isOpenClose()
	{
		return xmlTag.isOpenClose();
	}",0,[0]
1113,Bears-149,"public URL getUrl() {
        return url;
    }","public URL getUrl() {
        return url;
    }",0,[0]
37076,bugs-dot-jar_WICKET-172_99e22ce4,"public final Object visitChildren(final IVisitor visitor)
	{
		return visitChildren(null, visitor);
	}","public final Object visitChildren(final IVisitor visitor)
	{
		return visitChildren(null, visitor);
	}",0,[0]
4771,bugs-dot-jar_MATH-326_ce185345,"public double getDistance(RealVector v)
        throws IllegalArgumentException {
        if (v instanceof ArrayRealVector) {
            return getDistance((ArrayRealVector) v);
        } else {
            checkVectorDimensions(v);
            double sum = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i);
                sum += delta * delta;
            }
            return Math.sqrt(sum);
        }
    }","public double getDistance(RealVector v)
        throws IllegalArgumentException {
        if (v instanceof ArrayRealVector) {
            return getDistance((ArrayRealVector) v);
        } else {
            checkVectorDimensions(v);
            double sum = 0;
            for (int i = 0; i < data.length; ++i) {
                final double delta = data[i] - v.getEntry(i);
                sum += delta * delta;
            }
            return Math.sqrt(sum);
        }
    }",0,[0]
17224,bugs-dot-jar_OAK-4432_c9765c21,"@Override
    protected byte[] getOrCreateReferenceKey() throws DataStoreException {
        if (referenceKey != null) {
            return referenceKey;
        }
        return super.getOrCreateReferenceKey();
    }","@Override
    protected byte[] getOrCreateReferenceKey() throws DataStoreException {
        if (referenceKey != null) {
            return referenceKey;
        }
        return super.getOrCreateReferenceKey();
    }",0,[0]
20449,bugs-dot-jar_WICKET-128_7e1000dd,"public final IPageMap newPageMap(final String name)
	{
		// Check that session doesn't have too many page maps already
		final int maxPageMaps = getApplication().getSessionSettings().getMaxPageMaps();
		if (usedPageMaps.size() >= maxPageMaps)
		{
			IPageMap pm = usedPageMaps.getFirst();
			pm.remove();
		}

		// Create new page map
		final IPageMap pageMap = getSessionStore().createPageMap(name, this);
		setAttribute(attributeForPageMapName(name), pageMap);
		dirty();
		return pageMap;
	}","public final IPageMap newPageMap(final String name)
	{
		// Check that session doesn't have too many page maps already
		final int maxPageMaps = getApplication().getSessionSettings().getMaxPageMaps();
		if (usedPageMaps.size() >= maxPageMaps)
		{
			IPageMap pm = usedPageMaps.getFirst();
			pm.remove();
		}

		// Create new page map
		final IPageMap pageMap = getSessionStore().createPageMap(name, this);
		setAttribute(attributeForPageMapName(name), pageMap);
		dirty();
		return pageMap;
	}",0,[0]
8677,bugs-dot-jar_CAMEL-7448_35bde2b2,"@Override
    public String toString() {
        return ""Throttler[requests: "" + maxRequestsPerPeriodExpression + "" per: "" + timePeriodMillis + "" (ms) to: ""
               + getProcessor() + ""]"";
    }","@Override
    public String toString() {
        return ""Throttler[requests: "" + maxRequestsPerPeriodExpression + "" per: "" + timePeriodMillis + "" (ms) to: ""
               + getProcessor() + ""]"";
    }",0,[0]
1995,bugs-dot-jar_WICKET-2961_3d8c9d75,"public Component(final String id, final IModel<?> model)
	{
		setId(id);
		getApplication().notifyComponentInstantiationListeners(this);

		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.isLinePreciseReportingOnNewComponentEnabled())
		{
			setMetaData(CONSTRUCTED_AT_KEY,
				ComponentStrings.toString(this, new MarkupException(""constructed"")));
		}

		if (model != null)
		{
			setModelImpl(wrap(model));
		}
	}","public Component(final String id, final IModel<?> model)
	{
		setId(id);
		getApplication().notifyComponentInstantiationListeners(this);

		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.isLinePreciseReportingOnNewComponentEnabled())
		{
			setMetaData(CONSTRUCTED_AT_KEY,
				ComponentStrings.toString(this, new MarkupException(""constructed"")));
		}

		if (model != null)
		{
			setModelImpl(wrap(model));
		}
	}",0,[0]
7924,bugs-dot-jar_MATH-812_6eb46555,"public double getL1Distance(RealVector v) {
        checkVectorDimensions(v);
        double d = 0;
        Iterator<Entry> it = iterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex()));
        }
        return d;
    }","public double getL1Distance(RealVector v) {
        checkVectorDimensions(v);
        double d = 0;
        Iterator<Entry> it = iterator();
        while (it.hasNext()) {
            final Entry e = it.next();
            d += FastMath.abs(e.getValue() - v.getEntry(e.getIndex()));
        }
        return d;
    }",0,[0]
15467,bugs-dot-jar_MATH-555_328513f3,"public static short sign(final short x) {
        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
    }","public static short sign(final short x) {
        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;
    }",0,[0]
14428,bugs-dot-jar_CAMEL-8954_7b1253db,"@Override
    public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {
        this.readLockLoggingLevel = readLockLoggingLevel;
    }","@Override
    public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {
        this.readLockLoggingLevel = readLockLoggingLevel;
    }",0,[0]
27488,bugs-dot-jar_WICKET-4072_7d5b8645,"public void resolveRelative(final Url relative)
	{
		// strip the first non-folder segment
		getSegments().remove(getSegments().size() - 1);

		// remove all './' (current folder) from the relative url
		if (!relative.getSegments().isEmpty() && ""."".equals(relative.getSegments().get(0)))
		{
			relative.getSegments().remove(0);
		}

		// process any ../ segments in the relative url
		while (!relative.getSegments().isEmpty() && "".."".equals(relative.getSegments().get(0)))
		{
			relative.getSegments().remove(0);
			getSegments().remove(getSegments().size() - 1);
		}

		// append the remaining relative segments
		getSegments().addAll(relative.getSegments());

		// replace query params with the ones from relative
		parameters.clear();
		parameters.addAll(relative.getQueryParameters());
	}","public void resolveRelative(final Url relative)
	{
		if (getSegments().size() > 0)
		{
			// strip the first non-folder segment
			getSegments().remove(getSegments().size() - 1);
		}
		// remove all './' (current folder) from the relative url
		if (!relative.getSegments().isEmpty() && ""."".equals(relative.getSegments().get(0)))
		{
			relative.getSegments().remove(0);
		}

		// process any ../ segments in the relative url
		while (!relative.getSegments().isEmpty() && "".."".equals(relative.getSegments().get(0)))
		{
			relative.getSegments().remove(0);
			getSegments().remove(getSegments().size() - 1);
		}

		// append the remaining relative segments
		getSegments().addAll(relative.getSegments());

		// replace query params with the ones from relative
		parameters.clear();
		parameters.addAll(relative.getQueryParameters());
	}",1,"[2, 3]"
7150,bugs-dot-jar_OAK-4387_ca05fd06,"private Expression.Property readProperty() throws ParseException {
        if (readIf(""*"")) {
            return new Expression.Property(currentSelector, ""*"", false);
        }
        return new Expression.Property(currentSelector, readPathSegment(), false);
    }","private Expression.Property readProperty() throws ParseException {
        if (readIf(""*"")) {
            return new Expression.Property(currentSelector, ""*"", false);
        }
        return new Expression.Property(currentSelector, readPathSegment(), false);
    }",0,[0]
19862,bugs-dot-jar_WICKET-1718_bb7f9cf5,"private void validateHeaders()
	{
		// search for HtmlHeaderContainer in the first level of children or deeper
		// if there are transparent resolvers used
		HtmlHeaderContainer header = visitChildren(new IVisitor<Component, HtmlHeaderContainer>()
		{
			@Override
			public void component(final Component component, final IVisit<HtmlHeaderContainer> visit)
			{
				if (component instanceof HtmlHeaderContainer)
				{
					visit.stop((HtmlHeaderContainer)component);
				}
				else if (component instanceof TransparentWebMarkupContainer == false)
				{
					visit.dontGoDeeper();
				}
			}
		});

		if (header == null)
		{
			// the markup must at least contain a <body> tag for wicket to automatically
			// create a HtmlHeaderContainer. Log an error if no header container
			// was created but any of the components or behaviors want to contribute
			// something to the header.
			header = new HtmlHeaderContainer(HtmlHeaderSectionHandler.HEADER_ID);
			add(header);

			RequestCycle requestCycle = getRequestCycle();
			Response orgResponse = requestCycle.getResponse();
			try
			{
				StringResponse tempResponse = new StringResponse();
				requestCycle.setResponse(tempResponse);

				// Render all header sections of all components on the page
				AbstractHeaderRenderStrategy.get().renderHeader(header, null, getPage());

				IHeaderResponse headerResponse = header.getHeaderResponse();
				headerResponse.close();
				CharSequence collectedHeaderOutput = tempResponse.getBuffer();
				if (collectedHeaderOutput.length() > 0)
				{
					reportMissingHead(collectedHeaderOutput);
				}
			}
			catch (Exception e)
			{
				// just swallow this exception, there isn't much we can do about.
				log.error(""header/body check throws exception"", e);
			}
			finally
			{
				this.remove(header);
				requestCycle.setResponse(orgResponse);
			}
		}
	}","private void validateHeaders()
	{
		// search for HtmlHeaderContainer in the first level of children or deeper
		// if there are transparent resolvers used
		HtmlHeaderContainer header = visitChildren(new IVisitor<Component, HtmlHeaderContainer>()
		{
			@Override
			public void component(final Component component, final IVisit<HtmlHeaderContainer> visit)
			{
				if (component instanceof HtmlHeaderContainer)
				{
					visit.stop((HtmlHeaderContainer)component);
				}
				else if (component instanceof TransparentWebMarkupContainer == false)
				{
					visit.dontGoDeeper();
				}
			}
		});

		if (header == null)
		{
			// the markup must at least contain a <body> tag for wicket to automatically
			// create a HtmlHeaderContainer. Log an error if no header container
			// was created but any of the components or behaviors want to contribute
			// something to the header.
			header = new HtmlHeaderContainer(HtmlHeaderSectionHandler.HEADER_ID);
			add(header);

			RequestCycle requestCycle = getRequestCycle();
			Response orgResponse = requestCycle.getResponse();
			try
			{
				StringResponse tempResponse = new StringResponse();
				requestCycle.setResponse(tempResponse);

				// Render all header sections of all components on the page
				AbstractHeaderRenderStrategy.get().renderHeader(header, null, getPage());

				IHeaderResponse headerResponse = header.getHeaderResponse();
				headerResponse.close();
				CharSequence collectedHeaderOutput = tempResponse.getBuffer();
				if (collectedHeaderOutput.length() > 0)
				{
					reportMissingHead(collectedHeaderOutput);
				}
			}
			catch (Exception e)
			{
				// just swallow this exception, there isn't much we can do about.
				log.error(""header/body check throws exception"", e);
			}
			finally
			{
				this.remove(header);
				requestCycle.setResponse(orgResponse);
			}
		}
	}",0,[0]
6344,bugs-dot-jar_WICKET-5072_381b90fd,"private Cookies()
	{}","private Cookies()
	{}",0,[0]
32972,bugs-dot-jar_WICKET-3333_ddf7e8a2,"@Override
	protected void onComponentTag(final ComponentTag tag)
	{
		// Default handling for tag
		super.onComponentTag(tag);

		// Set href to link to this link's linkClicked method
		CharSequence url = getURL();

		// append any anchor
		url = appendAnchor(tag, url);

		// If we're disabled
		if (!isLinkEnabled())
		{
			disableLink(tag);
		}
		else
		{
			// if the tag is an anchor proper
			if (tag.getName().equalsIgnoreCase(""a"") || tag.getName().equalsIgnoreCase(""link"") ||
				tag.getName().equalsIgnoreCase(""area""))
			{
				// generate the href attribute
				tag.put(""href"", Strings.replaceAll(url, ""&"", ""&amp;""));

				// Add any popup script
				if (popupSettings != null)
				{
					// NOTE: don't encode to HTML as that is not valid
					// JavaScript
					tag.put(""onclick"", popupSettings.getPopupJavaScript());
				}
			}
			else if (tag.getName().equalsIgnoreCase(""script"") ||
				tag.getName().equalsIgnoreCase(""style""))
			{
				tag.put(""src"", Strings.replaceAll(url, ""&"", ""&amp;""));
			}
			else
			{
				// generate a popup script by asking popup settings for one
				if (popupSettings != null)
				{
					popupSettings.setTarget(""'"" + url + ""'"");
					String popupScript = popupSettings.getPopupJavaScript();
					tag.put(""onclick"", popupScript);
				}
				else
				{
					// or generate an onclick JS handler directly
					// in firefox when the element is quickly clicked 3 times a second request is
					// generated during page load. This check ensures that the click is ignored
					tag.put(
						""onclick"",
						""var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; "" +
							""if (win == window) { window.location.href='"" +
							Strings.replaceAll(url, ""&"", ""&amp;"") + ""'; } ;return false"");
				}
			}


			// If the subclass specified javascript, use that
			final CharSequence onClickJavaScript = getOnClickScript(url);
			if (onClickJavaScript != null)
			{
				tag.put(""onclick"", onClickJavaScript);
			}
		}

	}","@Override
	protected void onComponentTag(final ComponentTag tag)
	{
		// Default handling for tag
		super.onComponentTag(tag);

		// Set href to link to this link's linkClicked method
		CharSequence url = getURL();

		// append any anchor
		url = appendAnchor(tag, url);

		// If we're disabled
		if (!isLinkEnabled())
		{
			disableLink(tag);
		}
		else
		{
			// if the tag is an anchor proper
			if (tag.getName().equalsIgnoreCase(""a"") || tag.getName().equalsIgnoreCase(""link"") ||
				tag.getName().equalsIgnoreCase(""area""))
			{
				// generate the href attribute
				tag.put(""href"", url);

				// Add any popup script
				if (popupSettings != null)
				{
					// NOTE: don't encode to HTML as that is not valid
					// JavaScript
					tag.put(""onclick"", popupSettings.getPopupJavaScript());
				}
			}
			else if (tag.getName().equalsIgnoreCase(""script"") ||
				tag.getName().equalsIgnoreCase(""style""))
			{
				tag.put(""src"", url);
			}
			else
			{
				// generate a popup script by asking popup settings for one
				if (popupSettings != null)
				{
					popupSettings.setTarget(""'"" + url + ""'"");
					String popupScript = popupSettings.getPopupJavaScript();
					tag.put(""onclick"", popupScript);
				}
				else
				{
					// or generate an onclick JS handler directly
					// in firefox when the element is quickly clicked 3 times a second request is
					// generated during page load. This check ensures that the click is ignored
					tag.put(
						""onclick"",
						""var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; "" +
							""if (win == window) { window.location.href='"" +
							url +
							""'; } ;return false"");
				}
			}


			// If the subclass specified javascript, use that
			final CharSequence onClickJavaScript = getOnClickScript(url);
			if (onClickJavaScript != null)
			{
				tag.put(""onclick"", onClickJavaScript);
			}
		}

	}",1,"[24, 37, 57]"
25851,bugs-dot-jar_CAMEL-6723_b92d6237,"private static <T> T doExtractFutureBody(CamelContext context, Object result, Class<T> type) {
        if (result == null) {
            return null;
        }
        if (type.isAssignableFrom(result.getClass())) {
            return type.cast(result);
        }
        if (result instanceof Exchange) {
            Exchange exchange = (Exchange) result;
            Object answer = ExchangeHelper.extractResultBody(exchange, exchange.getPattern());
            return context.getTypeConverter().convertTo(type, exchange, answer);
        }
        return context.getTypeConverter().convertTo(type, result);
    }","private static <T> T doExtractFutureBody(CamelContext context, Object result, Class<T> type) {
        if (result == null) {
            return null;
        }
        if (type.isAssignableFrom(result.getClass())) {
            return type.cast(result);
        }
        if (result instanceof Exchange) {
            Exchange exchange = (Exchange) result;
            Object answer = ExchangeHelper.extractResultBody(exchange, exchange.getPattern());
            return context.getTypeConverter().convertTo(type, exchange, answer);
        }
        return context.getTypeConverter().convertTo(type, result);
    }",0,[0]
9878,bugs-dot-jar_OAK-3634_90ad50da,"private <T extends Document> boolean updateDocument(@Nonnull Collection<T> collection, @Nonnull T document,
            @Nonnull UpdateOp update, Long oldmodcount) {
        Connection connection = null;
        RDBTableMetaData tmd = getTable(collection);
        String data = null;
        try {
            connection = this.ch.getRWConnection();
            Operation modOperation = update.getChanges().get(MODIFIEDKEY);
            long modified = getModifiedFromOperation(modOperation);
            boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;
            Number flagB = (Number) document.get(NodeDocument.HAS_BINARY_FLAG);
            Boolean hasBinary = flagB != null && flagB.intValue() == NodeDocument.HAS_BINARY_VAL;
            Boolean flagD = (Boolean) document.get(NodeDocument.DELETED_ONCE);
            Boolean deletedOnce = flagD != null && flagD.booleanValue();
            Long modcount = (Long) document.get(MODCOUNT);
            Long cmodcount = (Long) document.get(COLLISIONSMODCOUNT);
            boolean success = false;
            boolean shouldRetry = true;

            // every 16th update is a full rewrite
            if (isAppendableUpdate(update) && modcount % 16 != 0) {
                String appendData = ser.asString(update);
                if (appendData.length() < tmd.getDataLimitInOctets() / CHAR2OCTETRATIO) {
                    try {
                        success = db.appendingUpdate(connection, tmd, document.getId(), modified, modifiedIsConditional, hasBinary,
                                deletedOnce, modcount, cmodcount, oldmodcount, appendData);
                        // if we get here, a retry is not going to help (the SQL
                        // operation succeeded but simply did not select a row
                        // that could be updated, likely because of the check on
                        // MODCOUNT
                        shouldRetry = false;
                        connection.commit();
                    } catch (SQLException ex) {
                        continueIfStringOverflow(ex);
                        this.ch.rollbackConnection(connection);
                        success = false;
                    }
                }
            }
            if (!success && shouldRetry) {
                data = ser.asString(document);
                success = db.update(connection, tmd, document.getId(), modified, hasBinary, deletedOnce, modcount, cmodcount,
                        oldmodcount, data);
                connection.commit();
            }
            return success;
        } catch (SQLException ex) {
            this.ch.rollbackConnection(connection);
            String addDiags = """";
            if (RDBJDBCTools.matchesSQLState(ex, ""22"", ""72"")) {
                byte[] bytes = asBytes(data);
                addDiags = String.format("" (DATA size in Java characters: %d, in octets: %d, computed character limit: %d)"",
                        data.length(), bytes.length, tmd.getDataLimitInOctets() / CHAR2OCTETRATIO);
            }
            String message = String.format(""Update for %s failed%s"", document.getId(), addDiags);
            LOG.debug(message, ex);
            throw new DocumentStoreException(message, ex);
        } finally {
            this.ch.closeConnection(connection);
        }
    }","private <T extends Document> boolean updateDocument(@Nonnull Collection<T> collection, @Nonnull T document,
            @Nonnull UpdateOp update, Long oldmodcount) {
        Connection connection = null;
        RDBTableMetaData tmd = getTable(collection);
        String data = null;
        try {
            connection = this.ch.getRWConnection();
            Operation modOperation = update.getChanges().get(MODIFIEDKEY);
            long modified = getModifiedFromOperation(modOperation);
            boolean modifiedIsConditional = modOperation == null || modOperation.type != UpdateOp.Operation.Type.SET;
            Number flagB = (Number) document.get(NodeDocument.HAS_BINARY_FLAG);
            Boolean hasBinary = flagB != null && flagB.intValue() == NodeDocument.HAS_BINARY_VAL;
            Boolean flagD = (Boolean) document.get(NodeDocument.DELETED_ONCE);
            Boolean deletedOnce = flagD != null && flagD.booleanValue();
            Long modcount = (Long) document.get(MODCOUNT);
            Long cmodcount = (Long) document.get(COLLISIONSMODCOUNT);
            boolean success = false;
            boolean shouldRetry = true;

            // every 16th update is a full rewrite
            if (isAppendableUpdate(update) && modcount % 16 != 0) {
                String appendData = ser.asString(update);
                if (appendData.length() < tmd.getDataLimitInOctets() / CHAR2OCTETRATIO) {
                    try {
                        success = db.appendingUpdate(connection, tmd, document.getId(), modified, modifiedIsConditional, hasBinary,
                                deletedOnce, modcount, cmodcount, oldmodcount, appendData);
                        // if we get here, a retry is not going to help (the SQL
                        // operation succeeded but simply did not select a row
                        // that could be updated, likely because of the check on
                        // MODCOUNT
                        shouldRetry = false;
                        connection.commit();
                    } catch (SQLException ex) {
                        continueIfStringOverflow(ex);
                        this.ch.rollbackConnection(connection);
                        success = false;
                    }
                }
            }
            if (!success && shouldRetry) {
                data = ser.asString(document);
                success = db.update(connection, tmd, document.getId(), modified, hasBinary, deletedOnce, modcount, cmodcount,
                        oldmodcount, data);
                connection.commit();
            }
            return success;
        } catch (SQLException ex) {
            this.ch.rollbackConnection(connection);
            String addDiags = """";
            if (RDBJDBCTools.matchesSQLState(ex, ""22"", ""72"")) {
                byte[] bytes = asBytes(data);
                addDiags = String.format("" (DATA size in Java characters: %d, in octets: %d, computed character limit: %d)"",
                        data.length(), bytes.length, tmd.getDataLimitInOctets() / CHAR2OCTETRATIO);
            }
            String message = String.format(""Update for %s failed%s"", document.getId(), addDiags);
            LOG.debug(message, ex);
            throw new DocumentStoreException(message, ex);
        } finally {
            this.ch.closeConnection(connection);
        }
    }",0,[0]
4915,bugs-dot-jar_OAK-1467_dde7de85,"private void checkConflicts(@Nonnull UpdateOp op,
                                @Nullable NodeDocument before) {
        DocumentStore store = nodeStore.getDocumentStore();
        collisions.clear();
        if (baseRevision != null) {
            Revision newestRev = null;
            if (before != null) {
                newestRev = before.getNewestRevision(nodeStore, revision,
                        new CollisionHandler() {
                            @Override
                            void concurrentModification(Revision other) {
                                collisions.add(other);
                            }
                        });
            }
            String conflictMessage = null;
            if (newestRev == null) {
                if (op.isDelete() || !op.isNew()) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" does not exist or is already deleted"";
                }
            } else {
                if (op.isNew()) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was already added in revision\n"" +
                            newestRev;
                } else if (nodeStore.isRevisionNewer(newestRev, baseRevision)
                        && (op.isDelete() || isConflicting(before, op))) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was changed in revision\n"" + newestRev +
                            "", which was applied after the base revision\n"" +
                            baseRevision;
                }
            }
            if (conflictMessage == null) {
                // the modification was successful
                // -> check for collisions and conflict (concurrent updates
                // on a node are possible if property updates do not overlap)
                // TODO: unify above conflict detection and isConflicting()
                if (!collisions.isEmpty() && isConflicting(before, op)) {
                    for (Revision r : collisions) {
                        // mark collisions on commit root
                        Collision c = new Collision(before, r, op, revision, nodeStore);
                        if (c.mark(store).equals(revision)) {
                            // our revision was marked
                            if (baseRevision.isBranch()) {
                                // this is a branch commit. do not fail immediately
                                // merging this branch will fail later.
                            } else {
                                // fail immediately
                                conflictMessage = ""The node "" +
                                        op.getId() + "" was changed in revision\n"" + r +
                                        "", which was applied after the base revision\n"" +
                                        baseRevision;
                            }
                        }
                    }
                }
            }
            if (conflictMessage != null) {
                conflictMessage += "", before\n"" + revision +
                        ""; document:\n"" + (before == null ? """" : before.format()) +
                        "",\nrevision order:\n"" + nodeStore.getRevisionComparator();
                throw new MicroKernelException(conflictMessage);
            }
        }
    }","private void checkConflicts(@Nonnull UpdateOp op,
                                @Nullable NodeDocument before) {
        DocumentStore store = nodeStore.getDocumentStore();
        collisions.clear();
        if (baseRevision != null) {
            Revision newestRev = null;
            if (before != null) {
                newestRev = before.getNewestRevision(nodeStore, revision,
                        new CollisionHandler() {
                            @Override
                            void concurrentModification(Revision other) {
                                collisions.add(other);
                            }
                        });
            }
            String conflictMessage = null;
            if (newestRev == null) {
                if (op.isDelete() || !op.isNew()) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" does not exist or is already deleted"";
                }
            } else {
                if (op.isNew()) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was already added in revision\n"" +
                            newestRev;
                } else if (nodeStore.isRevisionNewer(newestRev, baseRevision)
                        && (op.isDelete() || isConflicting(before, op))) {
                    conflictMessage = ""The node "" +
                            op.getId() + "" was changed in revision\n"" + newestRev +
                            "", which was applied after the base revision\n"" +
                            baseRevision;
                }
            }
            if (conflictMessage == null) {
                // the modification was successful
                // -> check for collisions and conflict (concurrent updates
                // on a node are possible if property updates do not overlap)
                // TODO: unify above conflict detection and isConflicting()
                if (!collisions.isEmpty() && isConflicting(before, op)) {
                    for (Revision r : collisions) {
                        // mark collisions on commit root
                        Collision c = new Collision(before, r, op, revision, nodeStore);
                        if (c.mark(store).equals(revision)) {
                            // our revision was marked
                            if (baseRevision.isBranch()) {
                                // this is a branch commit. do not fail immediately
                                // merging this branch will fail later.
                            } else {
                                // fail immediately
                                conflictMessage = ""The node "" +
                                        op.getId() + "" was changed in revision\n"" + r +
                                        "", which was applied after the base revision\n"" +
                                        baseRevision;
                            }
                        }
                    }
                }
            }
            if (conflictMessage != null) {
                conflictMessage += "", before\n"" + revision +
                        ""; document:\n"" + (before == null ? """" : before.format()) +
                        "",\nrevision order:\n"" + nodeStore.getRevisionComparator();
                throw new MicroKernelException(conflictMessage);
            }
        }
    }",0,[0]
3751,bugs-dot-jar_ACCUMULO-209_76d727f0,"private boolean matches(Matcher matcher, ByteSequence bs) {
    if (matcher != null) {
      babcs.set(bs);
      matcher.reset(babcs);
      return matcher.matches();
    }
    
    return !orFields;
  }","private boolean matches(Matcher matcher, ByteSequence bs) {
    if (matcher != null) {
      try {
        matcher.reset(new String(bs.getBackingArray(), bs.offset(), bs.length(), encoding));
        return matcher.matches();
      } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
      }
    }
    return !orFields;
  }",1,"[2, 3, 4]"
34449,bugs-dot-jar_ACCUMULO-2899_31aea2ad,"GarbageCollectWriteAheadLogs(Instance instance, VolumeManager fs, boolean useTrash) throws IOException {
    this.instance = instance;
    this.fs = fs;
    this.useTrash = useTrash;
  }","GarbageCollectWriteAheadLogs(Instance instance, VolumeManager fs, boolean useTrash) throws IOException {
    this.instance = instance;
    this.fs = fs;
    this.useTrash = useTrash;
  }",0,[0]
11397,bugs-dot-jar_CAMEL-7344_91228815,"@Override
    public boolean equals(Object object) {
        if (object instanceof DefaultEndpoint) {
            DefaultEndpoint that = (DefaultEndpoint)object;
            return ObjectHelper.equal(this.getEndpointUri(), that.getEndpointUri());
        }
        return false;
    }","@Override
    public boolean equals(Object object) {
        if (object instanceof DefaultEndpoint) {
            DefaultEndpoint that = (DefaultEndpoint)object;
            return ObjectHelper.equal(this.getEndpointUri(), that.getEndpointUri());
        }
        return false;
    }",0,[0]
30485,bugs-dot-jar_CAMEL-8626_d063f471,"public void stop(long timeout) throws Exception {
        if (!context.getStatus().isStarted()) {
            throw new IllegalArgumentException(""CamelContext is not started"");
        }
        context.stopRoute(getRouteId(), timeout, TimeUnit.SECONDS);
    }","public void stop(long timeout) throws Exception {
        if (!context.getStatus().isStarted()) {
            throw new IllegalArgumentException(""CamelContext is not started"");
        }
        context.stopRoute(getRouteId(), timeout, TimeUnit.SECONDS);
    }",0,[0]
1326,Bears-160,"@Override
    protected void initializeKeywords(TokenSet keywords) {
    }","@Override
    protected void initializeKeywords(TokenSet keywords) {
    }",0,[0]
26806,bugs-dot-jar_OAK-3020_147515ae,"private boolean indexAggregatedNode(String path, List<Field> fields, Aggregate.NodeIncludeResult result)
            throws CommitFailedException {
        //rule for node being aggregated might be null if such nodes
        //are not indexed on there own. In such cases we rely in current
        //rule for some checks
        IndexDefinition.IndexingRule ruleAggNode = context.getDefinition()
                .getApplicableIndexingRule(getPrimaryTypeName(result.nodeState));
        boolean dirty = false;

        for (PropertyState property : result.nodeState.getProperties()){
            String pname = property.getName();

            if (!isVisible(pname)) {
                continue;
            }

            //Check if type is indexed
            int type = property.getType().tag();
            if (ruleAggNode != null ) {
                if (!ruleAggNode.includePropertyType(type)) {
                    continue;
                }
            } else if (!indexingRule.includePropertyType(type)){
                continue;
            }

            if (Type.BINARY == property.getType()) {
                String aggreagtedNodePath = PathUtils.concat(path, result.nodePath);
                //Here the fulltext is being created for aggregate root hence nodePath passed
                //should be null
                String nodePath = result.isRelativeNode() ? result.rootIncludePath : null;
                fields.addAll(newBinary(property, result.nodeState, nodePath, aggreagtedNodePath + ""@"" + pname));
                dirty = true;
            } else {
                PropertyDefinition pd = null;
                if (ruleAggNode != null){
                    pd = ruleAggNode.getConfig(pname);
                }

                if (pd != null && !pd.nodeScopeIndex){
                    continue;
                }

                for (String value : property.getValue(Type.STRINGS)) {
                    Field field = result.isRelativeNode() ?
                            newFulltextField(result.rootIncludePath, value) : newFulltextField(value) ;
                    if (pd != null) {
                        field.setBoost(pd.boost);
                    }
                    fields.add(field);
                    dirty = true;
                }
            }
        }
        return dirty;
    }","private boolean indexAggregatedNode(String path, List<Field> fields, Aggregate.NodeIncludeResult result)
            throws CommitFailedException {
        //rule for node being aggregated might be null if such nodes
        //are not indexed on there own. In such cases we rely in current
        //rule for some checks
        IndexDefinition.IndexingRule ruleAggNode = context.getDefinition()
                .getApplicableIndexingRule(getPrimaryTypeName(result.nodeState));
        boolean dirty = false;

        for (PropertyState property : result.nodeState.getProperties()){
            String pname = property.getName();

            if (!isVisible(pname)) {
                continue;
            }

            //Check if type is indexed
            int type = property.getType().tag();
            if (ruleAggNode != null ) {
                if (!ruleAggNode.includePropertyType(type)) {
                    continue;
                }
            } else if (!indexingRule.includePropertyType(type)){
                continue;
            }

            if (Type.BINARY == property.getType()) {
                String aggreagtedNodePath = PathUtils.concat(path, result.nodePath);
                //Here the fulltext is being created for aggregate root hence nodePath passed
                //should be null
                String nodePath = result.isRelativeNode() ? result.rootIncludePath : null;
                fields.addAll(newBinary(property, result.nodeState, nodePath, aggreagtedNodePath + ""@"" + pname));
                dirty = true;
            } else {
                PropertyDefinition pd = null;
                if (ruleAggNode != null){
                    pd = ruleAggNode.getConfig(pname);
                }

                if (pd != null && !pd.nodeScopeIndex){
                    continue;
                }

                for (String value : property.getValue(Type.STRINGS)) {
                    Field field = result.isRelativeNode() ?
                            newFulltextField(result.rootIncludePath, value) : newFulltextField(value) ;
                    if (pd != null) {
                        field.setBoost(pd.boost);
                    }
                    fields.add(field);
                    dirty = true;
                }
            }
        }
        return dirty;
    }",0,[0]
17721,bugs-dot-jar_MATH-836_d7c0f27e,"@Override
    public String toString() {
        String str = null;
        if (denominator == 1) {
            str = Integer.toString(numerator);
        } else if (numerator == 0) {
            str = ""0"";
        } else {
            str = numerator + "" / "" + denominator;
        }
        return str;
    }","@Override
    public String toString() {
        String str = null;
        if (denominator == 1) {
            str = Integer.toString(numerator);
        } else if (numerator == 0) {
            str = ""0"";
        } else {
            str = numerator + "" / "" + denominator;
        }
        return str;
    }",0,[0]
20931,bugs-dot-jar_WICKET-5784_b6259e5f,"private Object getSessionInfo(Session session)
	{
		if (session instanceof ISessionLogInfo)
		{
			return ((ISessionLogInfo)session).getSessionInfo();
		}
		return """";
	}","private Object getSessionInfo(Session session)
	{
		if (session instanceof ISessionLogInfo)
		{
			return ((ISessionLogInfo)session).getSessionInfo();
		}
		return """";
	}",0,[0]
31756,bugs-dot-jar_FLINK-1167_259f10c0,"@Override
	protected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, 
			List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq)
	{
		// NOTES ON THE ENUMERATION OF THE STEP FUNCTION PLANS:
		// Whenever we instantiate the iteration, we enumerate new candidates for the step function.
		// That way, we make sure we have an appropriate plan for each candidate for the initial partial solution,
		// we have a fitting candidate for the step function (often, work is pushed out of the step function).
		// Among the candidates of the step function, we keep only those that meet the requested properties of the
		// current candidate initial partial solution. That makes sure these properties exist at the beginning of
		// the successive iteration.
		
		// 1) Because we enumerate multiple times, we may need to clean the cached plans
		//    before starting another enumeration
		this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);
		if (this.terminationCriterion != null) {
			this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);
		}
		
		// 2) Give the partial solution the properties of the current candidate for the initial partial solution
		this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);
		final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode();
		
		// 3) Get the alternative plans
		List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator);
		
		// 4) Make sure that the beginning of the step function does not assume properties that 
		//    are not also produced by the end of the step function.

		{
			List<PlanNode> newCandidates = new ArrayList<PlanNode>();
			
			for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {
				PlanNode candidate = planDeleter.next();
				
				GlobalProperties atEndGlobal = candidate.getGlobalProperties();
				LocalProperties atEndLocal = candidate.getLocalProperties();
				
				FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);
				if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
					; // depends only through broadcast variable on the partial solution
				}
				else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
					// attach a no-op node through which we create the properties of the original input
					Channel toNoOp = new Channel(candidate);
					globPropsReq.parameterizeChannel(toNoOp, false);
					locPropsReq.parameterizeChannel(toNoOp);
					
					UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(""Rebuild Partial Solution Properties"", FieldList.EMPTY_LIST);
					rebuildPropertiesNode.setDegreeOfParallelism(candidate.getDegreeOfParallelism());
					
					SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, ""Rebuild Partial Solution Properties"", toNoOp, DriverStrategy.UNARY_NO_OP);
					rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());
					estimator.costOperator(rebuildPropertiesPlanNode);
						
					GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();
					LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();
						
					if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {
						FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);
						
						if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
							newCandidates.add(rebuildPropertiesPlanNode);
						}
					}
					
					planDeleter.remove();
				}
			}
		}
		
		if (candidates.isEmpty()) {
			return;
		}
		
		// 5) Create a candidate for the Iteration Node for every remaining plan of the step function.
		if (terminationCriterion == null) {
			for (PlanNode candidate : candidates) {
				BulkIterationPlanNode node = new BulkIterationPlanNode(this, ""BulkIteration (""+this.getPactContract().getName()+"")"", in, pspn, candidate);
				GlobalProperties gProps = candidate.getGlobalProperties().clone();
				LocalProperties lProps = candidate.getLocalProperties().clone();
				node.initProperties(gProps, lProps);
				target.add(node);
			}
		}
		else if (candidates.size() > 0) {
			List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);

			SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;
			
			for (PlanNode candidate : candidates) {
				for (PlanNode terminationCandidate : terminationCriterionCandidates) {
					if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {
						BulkIterationPlanNode node = new BulkIterationPlanNode(this, ""BulkIteration (""+this.getPactContract().getName()+"")"", in, pspn, candidate, terminationCandidate);
						GlobalProperties gProps = candidate.getGlobalProperties().clone();
						LocalProperties lProps = candidate.getLocalProperties().clone();
						node.initProperties(gProps, lProps);
						target.add(node);
						
					}
				}
			}
			
		}
	}","@Override
	protected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, 
			List<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq)
	{
		// NOTES ON THE ENUMERATION OF THE STEP FUNCTION PLANS:
		// Whenever we instantiate the iteration, we enumerate new candidates for the step function.
		// That way, we make sure we have an appropriate plan for each candidate for the initial partial solution,
		// we have a fitting candidate for the step function (often, work is pushed out of the step function).
		// Among the candidates of the step function, we keep only those that meet the requested properties of the
		// current candidate initial partial solution. That makes sure these properties exist at the beginning of
		// the successive iteration.
		
		// 1) Because we enumerate multiple times, we may need to clean the cached plans
		//    before starting another enumeration
		this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);
		if (this.terminationCriterion != null) {
			this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);
		}
		
		// 2) Give the partial solution the properties of the current candidate for the initial partial solution
		this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);
		final BulkPartialSolutionPlanNode pspn = this.partialSolution.getCurrentPartialSolutionPlanNode();
		
		// 3) Get the alternative plans
		List<PlanNode> candidates = this.nextPartialSolution.getAlternativePlans(estimator);
		
		// 4) Make sure that the beginning of the step function does not assume properties that 
		//    are not also produced by the end of the step function.

		{
			List<PlanNode> newCandidates = new ArrayList<PlanNode>();
			
			for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {
				PlanNode candidate = planDeleter.next();
				
				GlobalProperties atEndGlobal = candidate.getGlobalProperties();
				LocalProperties atEndLocal = candidate.getLocalProperties();
				
				FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);
				if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
					; // depends only through broadcast variable on the partial solution
				}
				else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
					// attach a no-op node through which we create the properties of the original input
					Channel toNoOp = new Channel(candidate);
					globPropsReq.parameterizeChannel(toNoOp, false);
					locPropsReq.parameterizeChannel(toNoOp);
					
					UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(""Rebuild Partial Solution Properties"", FieldList.EMPTY_LIST);
					rebuildPropertiesNode.setDegreeOfParallelism(candidate.getDegreeOfParallelism());
					
					SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, ""Rebuild Partial Solution Properties"", toNoOp, DriverStrategy.UNARY_NO_OP);
					rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());
					estimator.costOperator(rebuildPropertiesPlanNode);
						
					GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();
					LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();
						
					if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {
						FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);
						
						if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
							newCandidates.add(rebuildPropertiesPlanNode);
						}
					}
					
					planDeleter.remove();
				}
			}
		}
		
		if (candidates.isEmpty()) {
			return;
		}
		
		// 5) Create a candidate for the Iteration Node for every remaining plan of the step function.
		if (terminationCriterion == null) {
			for (PlanNode candidate : candidates) {
				BulkIterationPlanNode node = new BulkIterationPlanNode(this, ""BulkIteration (""+this.getPactContract().getName()+"")"", in, pspn, candidate);
				GlobalProperties gProps = candidate.getGlobalProperties().clone();
				LocalProperties lProps = candidate.getLocalProperties().clone();
				node.initProperties(gProps, lProps);
				target.add(node);
			}
		}
		else if (candidates.size() > 0) {
			List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);

			SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;
			
			for (PlanNode candidate : candidates) {
				for (PlanNode terminationCandidate : terminationCriterionCandidates) {
					if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {
						BulkIterationPlanNode node = new BulkIterationPlanNode(this, ""BulkIteration (""+this.getPactContract().getName()+"")"", in, pspn, candidate, terminationCandidate);
						GlobalProperties gProps = candidate.getGlobalProperties().clone();
						LocalProperties lProps = candidate.getLocalProperties().clone();
						node.initProperties(gProps, lProps);
						target.add(node);
						
					}
				}
			}
			
		}
	}",0,[0]
20865,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Deprecated
    public static void validateCharset(String charset) throws UnsupportedCharsetException {
        IOHelper.validateCharset(charset);
    }","@Deprecated
    public static void validateCharset(String charset) throws UnsupportedCharsetException {
        IOHelper.validateCharset(charset);
    }",0,[0]
16951,bugs-dot-jar_WICKET-5728_3cc3fe95,"private void renderComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)
	{
		if ((markupStream != null) && (markupStream.getCurrentIndex() > 0))
		{
			// If the original tag has been changed from open-close to open-body-close, than we are
			// done. Other components, e.g. BorderBody, rely on this method being called.
			ComponentTag origOpenTag = (ComponentTag)markupStream.get(markupStream.getCurrentIndex() - 1);
			if (origOpenTag.isOpenClose())
			{
				return;
			}
		}

		// If the open tag requires a close tag
		boolean render = openTag.requiresCloseTag();
		if (render == false)
		{
			// Tags like <p> do not require a close tag, but they may have.
			render = !openTag.hasNoCloseTag();
		}

		if (render)
		{
			renderAll(markupStream, openTag);
		}
	}","private void renderComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)
	{
		if ((markupStream != null) && (markupStream.getCurrentIndex() > 0))
		{
			// If the original tag has been changed from open-close to open-body-close, than we are
			// done. Other components, e.g. BorderBody, rely on this method being called.
			ComponentTag origOpenTag = (ComponentTag)markupStream.get(markupStream.getCurrentIndex() - 1);
			if (origOpenTag.isOpenClose())
			{
				return;
			}
		}

		// If the open tag requires a close tag
		boolean render = openTag.requiresCloseTag();
		if (render == false)
		{
			// Tags like <p> do not require a close tag, but they may have.
			render = !openTag.hasNoCloseTag();
		}

		if (render)
		{
			renderAll(markupStream, openTag);
		}
	}",0,[0]
2288,bugs-dot-jar_MNG-4918_691a03a7,"private Build getModelBuild()
    {
        Build build = getModel().getBuild();

        if ( build == null )
        {
            build = new Build();

            getModel().setBuild( build );
        }

        return build;
    }","private Build getModelBuild()
    {
        Build build = getModel().getBuild();

        if ( build == null )
        {
            build = new Build();

            getModel().setBuild( build );
        }

        return build;
    }",0,[0]
40553,bugs-dot-jar_WICKET-442_246d53c5,"private final void checkRendering(final MarkupContainer renderedContainer)
	{
		// If the application wants component uses checked and
		// the response is not a redirect
		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect())
		{
			final Count unrenderedComponents = new Count();
			final List unrenderedAutoComponents = new ArrayList();
			final StringBuffer buffer = new StringBuffer();
			renderedContainer.visitChildren(new IVisitor()
			{
				public Object component(final Component component)
				{
					// If component never rendered
					if (renderedComponents == null || !renderedComponents.contains(component))
					{
						// If auto component ...
						if (component.isAuto())
						{
							// Add to list of unrendered auto components to
							// delete below
							unrenderedAutoComponents.add(component);
						}
						else if (component.isVisibleInHierarchy())
						{
							// Increase number of unrendered components
							unrenderedComponents.increment();

							// Add to explanatory string to buffer
							buffer.append(Integer.toString(unrenderedComponents.getCount()) + "". ""
									+ component + ""\n"");
						}
						else
						{
							// if the component is not visible in hierarchy we
							// should not visit its children since they are also
							// not visible
							return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
						}
					}
					return CONTINUE_TRAVERSAL;
				}
			});

			// Remove any unrendered auto components since versioning couldn't
			// do it. We can't remove the component in the above visitChildren
			// callback because we're traversing the list at that time.
			for (int i = 0; i < unrenderedAutoComponents.size(); i++)
			{
				((Component)unrenderedAutoComponents.get(i)).remove();
			}

			// Throw exception if any errors were found
			if (unrenderedComponents.getCount() > 0)
			{
				// Get rid of set
				renderedComponents = null;

				// Throw exception
				throw new WicketRuntimeException(
						""The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\n\n""
								+ buffer.toString());
			}
		}

		// Get rid of set
		renderedComponents = null;
	}","private final void checkRendering(final MarkupContainer renderedContainer)
	{
		// If the application wants component uses checked and
		// the response is not a redirect
		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect())
		{
			final Count unrenderedComponents = new Count();
			final List unrenderedAutoComponents = new ArrayList();
			final StringBuffer buffer = new StringBuffer();
			renderedContainer.visitChildren(new IVisitor()
			{
				public Object component(final Component component)
				{
					// If component never rendered
					if (renderedComponents == null || !renderedComponents.contains(component))
					{
						// If auto component ...
						if (component.isAuto())
						{
							// Add to list of unrendered auto components to
							// delete below
							unrenderedAutoComponents.add(component);
						}
						else if (component.isVisibleInHierarchy())
						{
							// Increase number of unrendered components
							unrenderedComponents.increment();

							// Add to explanatory string to buffer
							buffer.append(Integer.toString(unrenderedComponents.getCount()) + "". ""
									+ component + ""\n"");
						}
						else
						{
							// if the component is not visible in hierarchy we
							// should not visit its children since they are also
							// not visible
							return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
						}
					}
					return CONTINUE_TRAVERSAL;
				}
			});

			// Remove any unrendered auto components since versioning couldn't
			// do it. We can't remove the component in the above visitChildren
			// callback because we're traversing the list at that time.
			for (int i = 0; i < unrenderedAutoComponents.size(); i++)
			{
				((Component)unrenderedAutoComponents.get(i)).remove();
			}

			// Throw exception if any errors were found
			if (unrenderedComponents.getCount() > 0)
			{
				// Get rid of set
				renderedComponents = null;

				// Throw exception
				throw new WicketRuntimeException(
						""The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\n\n""
								+ buffer.toString());
			}
		}

		// Get rid of set
		renderedComponents = null;
	}",0,[0]
4703,bugs-dot-jar_MATH-326_ce185345,"public void unitize() {
        mapDivideToSelf(getNorm());
    }","public void unitize() {
        mapDivideToSelf(getNorm());
    }",0,[0]
12745,bugs-dot-jar_MNG-4383_0f3d4d24,"private boolean validateNotNull( String fieldName, ModelProblemCollector problems, boolean warning, Object object, String sourceHint )
    {
        if ( object != null )
        {
            return true;
        }

        if ( sourceHint != null )
        {
            addViolation( problems, warning, ""'"" + fieldName + ""' is missing for "" + sourceHint );
        }
        else
        {
            addViolation( problems, warning, ""'"" + fieldName + ""' is missing."" );
        }

        return false;
    }","private boolean validateNotNull( String fieldName, ModelProblemCollector problems, boolean warning, Object object, String sourceHint )
    {
        if ( object != null )
        {
            return true;
        }

        if ( sourceHint != null )
        {
            addViolation( problems, warning, ""'"" + fieldName + ""' is missing for "" + sourceHint );
        }
        else
        {
            addViolation( problems, warning, ""'"" + fieldName + ""' is missing."" );
        }

        return false;
    }",0,[0]
33693,bugs-dot-jar_WICKET-5981_eb125865,"@Override
	public String toString(final boolean detailed)
	{
		final StringBuilder buffer = new StringBuilder();
		buffer.append('[').append(Classes.simpleName(this.getClass())).append(' ');
		buffer.append(super.toString(detailed));
		if (detailed && children_size() != 0)
		{

			buffer.append("", children = "");

			// Loop through child components
			boolean first = true;
			for (Component child : this)
			{
				if (first)
				{
					buffer.append(' ');
					first = false;
				}
				buffer.append(child.toString());
			}

		}
		buffer.append(']');
		return buffer.toString();
	}","@Override
	public String toString(final boolean detailed)
	{
		final StringBuilder buffer = new StringBuilder();
		buffer.append('[').append(Classes.simpleName(this.getClass())).append(' ');
		buffer.append(super.toString(detailed));
		if (detailed && children_size() != 0)
		{

			buffer.append("", children = "");

			// Loop through child components
			boolean first = true;
			for (Component child : this)
			{
				if (first)
				{
					buffer.append(' ');
					first = false;
				}
				buffer.append(child.toString());
			}

		}
		buffer.append(']');
		return buffer.toString();
	}",0,[0]
16145,bugs-dot-jar_WICKET-4816_66bfc885,"public static String toHexString(byte[] bytes)
	{
		Args.notNull(bytes, ""bytes"");

		final StringBuilder hex = new StringBuilder(bytes.length << 1);

		for (final byte b : bytes)
		{
			hex.append(toHex(b >> 4));
			hex.append(toHex(b));
		}
		return hex.toString();
	}","public static String toHexString(byte[] bytes)
	{
		Args.notNull(bytes, ""bytes"");

		final StringBuilder hex = new StringBuilder(bytes.length << 1);

		for (final byte b : bytes)
		{
			hex.append(toHex(b >> 4));
			hex.append(toHex(b));
		}
		return hex.toString();
	}",0,[0]
1812,bugs-dot-jar_MATH-482_6d6649ef,"public static double max(final double a, final double b) {
        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
    }","public static double max(final double a, final double b) {
        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
    }",0,[0]
8477,bugs-dot-jar_ACCUMULO-366_db4a291f,"private MasterClientService.Iface masterConnection(String address) {
    try {
      if (address == null) {
        return null;
      }
      MasterClientService.Iface client = ThriftUtil.getClient(new MasterClientService.Client.Factory(), address, Property.MASTER_CLIENTPORT,
          Property.GENERAL_RPC_TIMEOUT, ServerConfiguration.getSystemConfiguration());
      // log.info(""Listener API to master has been opened"");
      return client;
    } catch (Exception e) {
      log.warn(""Issue with masterConnection ("" + address + "") "" + e, e);
    }
    return null;
  }","private MasterClientService.Iface masterConnection(String address) {
    try {
      if (address == null) {
        return null;
      }
      MasterClientService.Iface client = ThriftUtil.getClient(new MasterClientService.Client.Factory(), address, Property.MASTER_CLIENTPORT,
          Property.GENERAL_RPC_TIMEOUT, ServerConfiguration.getSystemConfiguration());
      // log.info(""Listener API to master has been opened"");
      return client;
    } catch (Exception e) {
      log.warn(""Issue with masterConnection ("" + address + "") "" + e, e);
    }
    return null;
  }",0,[0]
20300,bugs-dot-jar_LOG4J2-378_ef8517e4,"public Interpolator() {
        this((Map<String, String>) null);
    }","public Interpolator() {
        this((Map<String, String>) null);
    }",0,[0]
26238,bugs-dot-jar_LOG4J2-430_238ce8aa,"protected List<String> getMdcExcludes() {
        return mdcExcludes;
    }","protected List<String> getMdcExcludes() {
        return mdcExcludes;
    }",0,[0]
891,Bears-119,"private Position decodeLbs(String sentence, Channel channel, SocketAddress remoteAddress) {

        Parser parser = new Parser(PATTERN_NBR, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());
        position.setDeviceId(deviceSession.getDeviceId());

        DateBuilder dateBuilder = new DateBuilder()
                .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));

        Network network = new Network();
        int mcc = parser.nextInt(0);
        int mnc = parser.nextInt(0);

        String[] cells = parser.next().split("","");
        for (int i = 0; i < cells.length / 3; i++) {
            network.addCellTower(CellTower.from(mcc, mnc, Integer.parseInt(cells[i * 3]),
                    Integer.parseInt(cells[i * 3 + 1]), Integer.parseInt(cells[i * 3 + 2])));
        }

        position.setNetwork(network);

        dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));

        getLastLocation(position, dateBuilder.getDate());

        processStatus(position, parser.nextLong(16, 0));

        return position;
    }","private Position decodeLbs(String sentence, Channel channel, SocketAddress remoteAddress) {

        Parser parser = new Parser(PATTERN_NBR, sentence);
        if (!parser.matches()) {
            return null;
        }

        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());
        if (deviceSession == null) {
            return null;
        }

        Position position = new Position();
        position.setProtocol(getProtocolName());
        position.setDeviceId(deviceSession.getDeviceId());

        DateBuilder dateBuilder = new DateBuilder()
                .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));

        Network network = new Network();
        int mcc = parser.nextInt(0);
        int mnc = parser.nextInt(0);

        String[] cells = parser.next().split("","");
        for (int i = 0; i < cells.length / 3; i++) {
            network.addCellTower(CellTower.from(mcc, mnc, Integer.parseInt(cells[i * 3]),
                    Integer.parseInt(cells[i * 3 + 1]), Integer.parseInt(cells[i * 3 + 2])));
        }

        position.setNetwork(network);

        dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));

        getLastLocation(position, dateBuilder.getDate());

        processStatus(position, parser.nextLong(16, 0));

        return position;
    }",0,[0]
40591,bugs-dot-jar_WICKET-442_246d53c5,"public final CharSequence urlFor(final Page page)
	{
		IRequestTarget target = new PageRequestTarget(page);
		Session.get().touch(((IPageRequestTarget)target).getPage());
		return urlFor(target);
	}","public final CharSequence urlFor(final Page page)
	{
		IRequestTarget target = new PageRequestTarget(page);
		Session.get().touch(((IPageRequestTarget)target).getPage());
		return urlFor(target);
	}",0,[0]
38070,bugs-dot-jar_CAMEL-7213_336663c9,"@Converter
    public static ByteBuffer toByteBuffer(Short value) {
        ByteBuffer buf = ByteBuffer.allocate(2);
        buf.putShort(value);
        return buf;
    }","@Converter
    public static ByteBuffer toByteBuffer(Short value) {
        ByteBuffer buf = ByteBuffer.allocate(2);
        buf.putShort(value);
        buf.flip();
        return buf;
    }",1,[]
36340,bugs-dot-jar_CAMEL-9444_baece126,"public Boolean isStopOnException() {
        return stopOnException != null && stopOnException;
    }","public Boolean isStopOnException() {
        return stopOnException != null && stopOnException;
    }",0,[0]
19190,bugs-dot-jar_WICKET-4119_bb7a6995,"public Set<String> getResourcePaths(String name)
	{
		if (webappRoot == null)
		{
			return new HashSet<String>();
		}

		if (name.startsWith(""/""))
		{
			name = name.substring(1);
		}
		if (name.endsWith(""/""))
		{
			name = name.substring(0, name.length() - 1);
		}
		String[] elements = null;
		if (name.trim().length() == 0)
		{
			elements = new String[0];
		}
		else
		{
			elements = name.split(""/"");
		}

		File current = webappRoot;
		for (String element : elements)
		{
			File[] files = current.listFiles();
			boolean match = false;
			for (File file : files)
			{
				if (file.getName().equals(element) && file.isDirectory())
				{
					current = file;
					match = true;
					break;
				}
			}
			if (!match)
			{
				return null;
			}
		}

		File[] files = current.listFiles();
		Set<String> result = new HashSet<String>();
		int stripLength = webappRoot.getPath().length();
		for (File file : files)
		{
			String s = file.getPath().substring(stripLength).replace('\\', '/');
			if (file.isDirectory())
			{
				s = s + ""/"";
			}
			result.add(s);
		}
		return result;
	}","public Set<String> getResourcePaths(String name)
	{
		if (webappRoot == null)
		{
			return new HashSet<String>();
		}

		if (name.startsWith(""/""))
		{
			name = name.substring(1);
		}
		if (name.endsWith(""/""))
		{
			name = name.substring(0, name.length() - 1);
		}
		String[] elements = null;
		if (name.trim().length() == 0)
		{
			elements = new String[0];
		}
		else
		{
			elements = name.split(""/"");
		}

		File current = webappRoot;
		for (String element : elements)
		{
			File[] files = current.listFiles();
			boolean match = false;
			for (File file : files)
			{
				if (file.getName().equals(element) && file.isDirectory())
				{
					current = file;
					match = true;
					break;
				}
			}
			if (!match)
			{
				return null;
			}
		}

		File[] files = current.listFiles();
		Set<String> result = new HashSet<String>();
		int stripLength = webappRoot.getPath().length();
		for (File file : files)
		{
			String s = file.getPath().substring(stripLength).replace('\\', '/');
			if (file.isDirectory())
			{
				s = s + ""/"";
			}
			result.add(s);
		}
		return result;
	}",0,[0]
5391,bugs-dot-jar_FLINK-3534_734ba01d,"private void postRunCleanup() {
		try {
			CheckpointCoordinator coord = this.checkpointCoordinator;
			this.checkpointCoordinator = null;
			if (coord != null) {
				coord.shutdown();
			}

			// We don't clean the checkpoint stats tracker, because we want
			// it to be available after the job has terminated.
		} catch (Exception e) {
			LOG.error(""Error while cleaning up after execution"", e);
		}

		try {
			CheckpointCoordinator coord = this.savepointCoordinator;
			this.savepointCoordinator = null;
			if (coord != null) {
				coord.shutdown();
			}
		} catch (Exception e) {
			LOG.error(""Error while cleaning up after execution"", e);
		}
	}","private void postRunCleanup() {
		try {
			CheckpointCoordinator coord = this.checkpointCoordinator;
			this.checkpointCoordinator = null;
			if (coord != null) {
				coord.shutdown();
			}

			// We don't clean the checkpoint stats tracker, because we want
			// it to be available after the job has terminated.
		} catch (Exception e) {
			LOG.error(""Error while cleaning up after execution"", e);
		}

		try {
			CheckpointCoordinator coord = this.savepointCoordinator;
			this.savepointCoordinator = null;
			if (coord != null) {
				coord.shutdown();
			}
		} catch (Exception e) {
			LOG.error(""Error while cleaning up after execution"", e);
		}
	}",0,[0]
28377,bugs-dot-jar_MATH-1121_5a6ccd58,"@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).
        UnivariatePointValuePair best = current;

        int iter = 0;
        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
                best = best(best,
                            best(previous,
                                 current,
                                 isMinim),
                            isMinim);

                if (checker != null && checker.converged(iter, previous, current)) {
                    return best;
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                    }
                }
            } else { // Default termination (Brent's criterion).
                return best(best,
                            best(previous,
                                 current,
                                 isMinim),
                            isMinim);
            }
            ++iter;
        }
    }","@Override
    protected UnivariatePointValuePair doOptimize() {
        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final double lo = getMin();
        final double mid = getStartValue();
        final double hi = getMax();

        // Optional additional convergence criteria.
        final ConvergenceChecker<UnivariatePointValuePair> checker
            = getConvergenceChecker();

        double a;
        double b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
        double w = x;
        double d = 0;
        double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
            fx = -fx;
        }
        double fv = fx;
        double fw = fx;

        UnivariatePointValuePair previous = null;
        UnivariatePointValuePair current
            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
        // Best point encountered so far (which is the initial guess).
        UnivariatePointValuePair best = current;

        while (true) {
            final double m = 0.5 * (a + b);
            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
            final double tol2 = 2 * tol1;

            // Default stopping criterion.
            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
            if (!stop) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (FastMath.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x) &&
                        p < q * (b - x) &&
                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2 || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (FastMath.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                    fu = -fu;
                }

                // User-defined convergence checker.
                previous = current;
                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
                best = best(best,
                            best(previous,
                                 current,
                                 isMinim),
                            isMinim);

                if (checker != null && checker.converged(getIterations(), previous, current)) {
                    return best;
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw ||
                        Precision.equals(w, x)) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv ||
                               Precision.equals(v, x) ||
                               Precision.equals(v, w)) {
                        v = u;
                        fv = fu;
                    }
                }
            } else { // Default termination (Brent's criterion).
                return best(best,
                            best(previous,
                                 current,
                                 isMinim),
                            isMinim);
            }

            incrementIterationCount();
        }
    }",1,"[39, 127, 170]"
186,Bears-6,"public void trimByVisibility()
    {
        _fields = _trimByVisibility(_fields);
        _getters = _trimByVisibility(_getters);
        _setters = _trimByVisibility(_setters);
        _ctorParameters = _trimByVisibility(_ctorParameters);
    }","public void trimByVisibility()
    {
        _fields = _trimByVisibility(_fields);
        _getters = _trimByVisibility(_getters);
        _setters = _trimByVisibility(_setters);
        _ctorParameters = _trimByVisibility(_ctorParameters);
    }",0,[0]
19216,bugs-dot-jar_WICKET-4119_bb7a6995,"protected byte[] processResponse(final Attributes attributes, final byte[] original)
	{
		return original;
	}","protected byte[] processResponse(final Attributes attributes, final byte[] original)
	{
		return original;
	}",0,[0]
25841,bugs-dot-jar_CAMEL-6723_b92d6237,"public static boolean isUnitOfWorkExhausted(Exchange exchange) {
        return exchange.getProperty(Exchange.UNIT_OF_WORK_EXHAUSTED, false, Boolean.class);
    }","public static boolean isUnitOfWorkExhausted(Exchange exchange) {
        return exchange.getProperty(Exchange.UNIT_OF_WORK_EXHAUSTED, false, Boolean.class);
    }",0,[0]
40441,bugs-dot-jar_WICKET-442_246d53c5,"public final Component setVisible(final boolean visible)
	{
		// Is new visibility state a change?
		if (visible != getFlag(FLAG_VISIBLE))
		{
			// record component's visibility change
			addStateChange(new VisibilityChange(this));

			// Change visibility
			setFlag(FLAG_VISIBLE, visible);
		}
		return this;
	}","public final Component setVisible(final boolean visible)
	{
		// Is new visibility state a change?
		if (visible != getFlag(FLAG_VISIBLE))
		{
			// record component's visibility change
			addStateChange(new VisibilityChange(this));

			// Change visibility
			setFlag(FLAG_VISIBLE, visible);
		}
		return this;
	}",0,[0]
31800,bugs-dot-jar_ACCUMULO-3718_73ce9cfb,"private void put(byte b[]) {
    put(b, b.length);
  }","private void put(byte b[]) {
    put(b, b.length);
  }",0,[0]
2517,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static Expression regexReplaceAll(final Expression expression,
                                             final String regex, final Expression replacementExpression) {

        final Pattern pattern = Pattern.compile(regex);
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                String text = expression.evaluate(exchange, String.class);
                String replacement = replacementExpression.evaluate(exchange, String.class);
                if (text == null || replacement == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }

            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }","public static Expression regexReplaceAll(final Expression expression,
                                             final String regex, final Expression replacementExpression) {

        final Pattern pattern = Pattern.compile(regex);
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                String text = expression.evaluate(exchange, String.class);
                String replacement = replacementExpression.evaluate(exchange, String.class);
                if (text == null || replacement == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }

            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }",0,[0]
121,Bears-6,"protected void _addSetterMethod(Map<String, POJOPropertyBuilder> props,
            AnnotatedMethod m, AnnotationIntrospector ai)
    {
        String implName; // from naming convention
        boolean visible;
        PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);
        boolean nameExplicit = (pn != null);
        if (!nameExplicit) { // no explicit name; must follow naming convention
            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);
            if (implName == null) {
                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);
            }
            if (implName == null) { // if not, must skip
            	return;
            }
            visible = _visibilityChecker.isSetterVisible(m);
        } else { // explicit indication of inclusion, but may be empty
            // we still need implicit name to link with other pieces
            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);
            if (implName == null) {
                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);
            }
            // if not regular getter name, use method name as is
            if (implName == null) {
                implName = m.getName();
            }
            if (pn.isEmpty()) {
                // !!! TODO: use PropertyName for implicit names too
                pn = _propNameFromSimple(implName);
                nameExplicit = false;
            }
            visible = true;
        }
        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);
        _property(props, implName).addSetter(m, pn, nameExplicit, visible, ignore);
    }","protected void _addSetterMethod(Map<String, POJOPropertyBuilder> props,
            AnnotatedMethod m, AnnotationIntrospector ai)
    {
        String implName; // from naming convention
        boolean visible;
        PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);
        boolean nameExplicit = (pn != null);
        if (!nameExplicit) { // no explicit name; must follow naming convention
            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);
            if (implName == null) {
                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);
            }
            if (implName == null) { // if not, must skip
            	return;
            }
            visible = _visibilityChecker.isSetterVisible(m);
        } else { // explicit indication of inclusion, but may be empty
            // we still need implicit name to link with other pieces
            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);
            if (implName == null) {
                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);
            }
            // if not regular getter name, use method name as is
            if (implName == null) {
                implName = m.getName();
            }
            if (pn.isEmpty()) {
                // !!! TODO: use PropertyName for implicit names too
                pn = _propNameFromSimple(implName);
                nameExplicit = false;
            }
            visible = true;
        }
        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);
        _property(props, implName).addSetter(m, pn, nameExplicit, visible, ignore);
    }",0,[0]
33641,bugs-dot-jar_WICKET-3845_afc7034d,"public void setHeader(String name, String value)
	{
		// remove previous values
		removeHeader(name);

		// add new values
		addHeader(name, value);
	}","public void setHeader(String name, String value)
	{
		// remove previous values
		removeHeader(name);

		// add new values
		addHeader(name, value);
	}",0,[0]
28420,bugs-dot-jar_WICKET-2172_ea4a3f8a,"@Override
	public String toString()
	{
		final StringBuffer buffer = new StringBuffer();
		for (final Iterator iterator = entrySet().iterator(); iterator.hasNext();)
		{
			final Map.Entry entry = (Map.Entry)iterator.next();
			buffer.append(entry.getKey());
			buffer.append("" = \"""");
			final Object value = entry.getValue();
			if (value == null)
			{
				buffer.append(""null"");
			}
			else if (value.getClass().isArray())
			{
				buffer.append(Arrays.asList((Object[])value));
			}
			else
			{
				buffer.append(value);
			}

			buffer.append('\""');
			if (iterator.hasNext())
			{
				buffer.append(' ');
			}
		}
		return buffer.toString();
	}","@Override
	public String toString()
	{
		final StringBuffer buffer = new StringBuffer();
		boolean first = true;
		for (Map.Entry<String, Object> entry : entrySet())
		{
			if (first == false)
			{
				buffer.append(' ');
			}
			first = false;

			buffer.append(entry.getKey());
			buffer.append("" = \"""");
			final Object value = entry.getValue();
			if (value == null)
			{
				buffer.append(""null"");
			}
			else if (value.getClass().isArray())
			{
				buffer.append(Arrays.asList((Object[])value));
			}
			else
			{
				buffer.append(value);
			}

			buffer.append('\""');
		}
		return buffer.toString();
	}",1,"[4, 6, 24, 25, 26, 27]"
2661,bugs-dot-jar_OAK-3872_c13708e3,"@Override
    protected void mark(BlockId blockId) throws Exception {
        Connection con = this.ch.getRWConnection();
        PreparedStatement prep = null;
        try {
            if (minLastModified == 0) {
                return;
            }
            String id = StringUtils.convertBytesToHex(blockId.getDigest());
            prep = con.prepareStatement(""update "" + this.tnMeta + "" set LASTMOD = ? where ID = ? and LASTMOD < ?"");
            prep.setLong(1, System.currentTimeMillis());
            prep.setString(2, id);
            prep.setLong(3, minLastModified);
            prep.executeUpdate();
            prep.close();
        } finally {
            closeStatement(prep);
            con.commit();
            this.ch.closeConnection(con);
        }
    }","@Override
    protected void mark(BlockId blockId) throws Exception {
        Connection con = this.ch.getRWConnection();
        PreparedStatement prep = null;
        try {
            if (minLastModified == 0) {
                return;
            }
            String id = StringUtils.convertBytesToHex(blockId.getDigest());
            prep = con.prepareStatement(""update "" + this.tnMeta + "" set LASTMOD = ? where ID = ? and LASTMOD < ?"");
            prep.setLong(1, System.currentTimeMillis());
            prep.setString(2, id);
            prep.setLong(3, minLastModified);
            prep.executeUpdate();
            prep.close();
        } finally {
            closeStatement(prep);
            con.commit();
            this.ch.closeConnection(con);
        }
    }",0,[0]
25066,bugs-dot-jar_OAK-1227_117b0a3d,"@Override
    public void removeMixin(final String mixinName) throws RepositoryException {
        final String oakTypeName = getOakName(checkNotNull(mixinName));
        perform(new ItemWriteOperation<Void>() {
            @Override
            public void checkPreconditions() throws RepositoryException {
                super.checkPreconditions();
                if (!isCheckedOut()) {
                    throw new VersionException(
                            ""Cannot remove mixin type. Node is checked in."");
                }

                // check for NODE_TYPE_MANAGEMENT permission here as we cannot
                // distinguish between a combination of removeMixin and addMixin
                // and Node#remove plus subsequent addNode when it comes to
                // autocreated properties like jcr:create, jcr:uuid and so forth.
                Set<String> mixins = newLinkedHashSet(getNames(dlg.getTree(), JCR_MIXINTYPES));
                if (!mixins.isEmpty() && mixins.remove(getOakName(mixinName))) {
                    PropertyState prop = PropertyStates.createProperty(JCR_MIXINTYPES, mixins, NAMES);
                    sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);
                }
            }
            @Override
            public Void perform() throws RepositoryException {
                dlg.removeMixin(oakTypeName);
                return null;
            }
        });
    }","@Override
    public void removeMixin(final String mixinName) throws RepositoryException {
        final String oakTypeName = getOakName(checkNotNull(mixinName));
        perform(new ItemWriteOperation<Void>() {
            @Override
            public void checkPreconditions() throws RepositoryException {
                super.checkPreconditions();
                if (!isCheckedOut()) {
                    throw new VersionException(
                            ""Cannot remove mixin type. Node is checked in."");
                }

                // check for NODE_TYPE_MANAGEMENT permission here as we cannot
                // distinguish between a combination of removeMixin and addMixin
                // and Node#remove plus subsequent addNode when it comes to
                // autocreated properties like jcr:create, jcr:uuid and so forth.
                Set<String> mixins = newLinkedHashSet(getNames(dlg.getTree(), JCR_MIXINTYPES));
                if (!mixins.isEmpty() && mixins.remove(getOakName(mixinName))) {
                    PropertyState prop = PropertyStates.createProperty(JCR_MIXINTYPES, mixins, NAMES);
                    sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);
                }
            }
            @Override
            public Void perform() throws RepositoryException {
                dlg.removeMixin(oakTypeName);
                return null;
            }
        });
    }",0,[0]
2432,bugs-dot-jar_CAMEL-8137_53b4e90c,"protected List<Annotation>[] collectParameterAnnotations(Class<?> c, Method m) {
        @SuppressWarnings(""unchecked"")
        List<Annotation>[] annotations = new List[m.getParameterTypes().length];
        for (int i = 0; i < annotations.length; i++) {
            annotations[i] = new ArrayList<Annotation>();
        }
        collectParameterAnnotations(c, m, annotations);
        return annotations;
    }","protected List<Annotation>[] collectParameterAnnotations(Class<?> c, Method m) {
        @SuppressWarnings(""unchecked"")
        List<Annotation>[] annotations = new List[m.getParameterTypes().length];
        for (int i = 0; i < annotations.length; i++) {
            annotations[i] = new ArrayList<Annotation>();
        }
        collectParameterAnnotations(c, m, annotations);
        return annotations;
    }",0,[0]
35940,bugs-dot-jar_CAMEL-7016_4ed448c7,"public String getLoad05() {
        return String.format(""%.2f"", load.getLoad5());
    }","public String getLoad05() {
        return String.format(""%.2f"", load.getLoad5());
    }",0,[0]
1093,Bears-141,"public Set<Role> getRoles() {
        return roles;
    }","public Set<Role> getRoles() {
        return roles;
    }",0,[0]
30955,bugs-dot-jar_LOG4J2-410_8f0c4871,"@Override
    public void info(final String format, final Throwable t) {
        if (logger.isInfoEnabled()) {
            logger.log(null, FQCN, Level.INFO, new SimpleMessage(format), t);
        }
    }","@Override
    public void info(final String format, final Throwable t) {
        if (logger.isInfoEnabled()) {
            logger.log(null, FQCN, Level.INFO, new SimpleMessage(format), t);
        }
    }",0,[0]
2863,bugs-dot-jar_OAK-1364_05c89637,"boolean containsValue(Object value) {
        for (Segment<K, V> s : segments) {
            for (K k : s.keySet()) {
                V v = find(k).value;
                if (v != null && v.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }","boolean containsValue(Object value) {
        for (Segment<K, V> s : segments) {
            for (K k : s.keySet()) {
                V v = peek(k);
                if (v != null && v.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }",1,[3]
30845,bugs-dot-jar_OAK-2695_0598498e,"private boolean dispatch(@Nonnull String jsonDiff,
                             @Nonnull DocumentNodeState node,
                             @Nonnull DocumentNodeState base,
                             @Nonnull NodeStateDiff diff,
                             boolean useReadRevision) {
        if (jsonDiff.trim().isEmpty()) {
            return true;
        }
        Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();
        Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();
        JsopTokenizer t = new JsopTokenizer(jsonDiff);
        boolean continueComparison = true;
        while (continueComparison) {
            int r = t.read();
            if (r == JsopReader.END) {
                break;
            }
            switch (r) {
                case '+': {
                    String name = unshareString(t.readString());
                    t.read(':');
                    t.read('{');
                    while (t.read() != '}') {
                        // skip properties
                    }
                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);
                    continueComparison = diff.childNodeAdded(name, child);
                    break;
                }
                case '-': {
                    String name = unshareString(t.readString());
                    NodeState child = getNode(concat(base.getPath(), name), baseRev);
                    continueComparison = diff.childNodeDeleted(name, child);
                    break;
                }
                case '^': {
                    String name = unshareString(t.readString());
                    t.read(':');
                    if (t.matches('{')) {
                        t.read('}');
                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);
                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);
                        continueComparison = diff.childNodeChanged(
                                name, baseChild, nodeChild);
                    } else if (t.matches('[')) {
                        // ignore multi valued property
                        while (t.read() != ']') {
                            // skip values
                        }
                    } else {
                        // ignore single valued property
                        t.read();
                    }
                    break;
                }
                default:
                    throw new IllegalArgumentException(""jsonDiff: illegal token '""
                            + t.getToken() + ""' at pos: "" + t.getLastPos() + ' ' + jsonDiff);
            }
        }
        return continueComparison;
    }","private boolean dispatch(@Nonnull String jsonDiff,
                             @Nonnull DocumentNodeState node,
                             @Nonnull DocumentNodeState base,
                             @Nonnull NodeStateDiff diff,
                             boolean useReadRevision) {
        if (jsonDiff.trim().isEmpty()) {
            return true;
        }
        Revision nodeRev = useReadRevision ? node.getRevision() : node.getLastRevision();
        Revision baseRev = useReadRevision ? base.getRevision() : base.getLastRevision();
        JsopTokenizer t = new JsopTokenizer(jsonDiff);
        boolean continueComparison = true;
        while (continueComparison) {
            int r = t.read();
            if (r == JsopReader.END) {
                break;
            }
            switch (r) {
                case '+': {
                    String name = unshareString(t.readString());
                    t.read(':');
                    t.read('{');
                    while (t.read() != '}') {
                        // skip properties
                    }
                    continueComparison = diff.childNodeAdded(name,
                            node.getChildNode(name, nodeRev));
                    break;
                }
                case '-': {
                    String name = unshareString(t.readString());
                    continueComparison = diff.childNodeDeleted(name,
                            base.getChildNode(name, baseRev));
                    break;
                }
                case '^': {
                    String name = unshareString(t.readString());
                    t.read(':');
                    if (t.matches('{')) {
                        t.read('}');
                        continueComparison = diff.childNodeChanged(name,
                                base.getChildNode(name, baseRev),
                                node.getChildNode(name, nodeRev));
                    } else if (t.matches('[')) {
                        // ignore multi valued property
                        while (t.read() != ']') {
                            // skip values
                        }
                    } else {
                        // ignore single valued property
                        t.read();
                    }
                    break;
                }
                default:
                    throw new IllegalArgumentException(""jsonDiff: illegal token '""
                            + t.getToken() + ""' at pos: "" + t.getLastPos() + ' ' + jsonDiff);
            }
        }
        return continueComparison;
    }",1,"[25, 26, 31, 32, 40, 41, 42, 43]"
20254,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Override
  public String whoami() {
    return username;
  }","@Override
  public String whoami() {
    return username;
  }",0,[0]
19771,bugs-dot-jar_LOG4J2-470_50340d0c,"public LoggerContext(final String name, final Object externalContext, final String configLocn) {
        this.name = name;
        this.externalContext = externalContext;
        if (configLocn != null) {
            URI uri;
            try {
                uri = new File(configLocn).toURI();
            } catch (final Exception ex) {
                uri = null;
            }
            configLocation = uri;
        } else {
            configLocation = null;
        }
    }","public LoggerContext(final String name, final Object externalContext, final String configLocn) {
        this.name = name;
        this.externalContext = externalContext;
        if (configLocn != null) {
            URI uri;
            try {
                uri = new File(configLocn).toURI();
            } catch (final Exception ex) {
                uri = null;
            }
            configLocation = uri;
        } else {
            configLocation = null;
        }
    }",0,[0]
30529,bugs-dot-jar_CAMEL-4211_4efddb3f,"public static String stripPrefix(String value, String prefix) {
        if (value.startsWith(prefix)) {
            return value.substring(prefix.length());
        }
        return value;
    }","public static String stripPrefix(String value, String prefix) {
        if (value.startsWith(prefix)) {
            return value.substring(prefix.length());
        }
        return value;
    }",0,[0]
33576,bugs-dot-jar_WICKET-4520_b91154ea,"public final void setJavaScriptLibrarySettings(
		final IJavaScriptLibrarySettings javaScriptLibrarySettings)
	{
		this.javaScriptLibrarySettings = javaScriptLibrarySettings;
	}","public final void setJavaScriptLibrarySettings(
		final IJavaScriptLibrarySettings javaScriptLibrarySettings)
	{
		this.javaScriptLibrarySettings = javaScriptLibrarySettings;
	}",0,[0]
17696,bugs-dot-jar_MATH-836_d7c0f27e,"public Fraction(int num) {
        this(num, 1);
    }","public Fraction(int num) {
        this(num, 1);
    }",0,[0]
1607,bugs-dot-jar_WICKET-5345_3fc7234e,"public QueryParameter getQueryParameter(final String name)
	{
		for (QueryParameter parameter : parameters)
		{
			if (Objects.equal(name, parameter.getName()))
			{
				return parameter;
			}
		}
		return null;
	}","public QueryParameter getQueryParameter(final String name)
	{
		for (QueryParameter parameter : parameters)
		{
			if (Objects.equal(name, parameter.getName()))
			{
				return parameter;
			}
		}
		return null;
	}",0,[0]
20240,bugs-dot-jar_ACCUMULO-1312_d9ab8449,"@Override
  public String whoami() {
    return credentials.getPrincipal();
  }","@Override
  public String whoami() {
    return credentials.getPrincipal();
  }",0,[0]
7705,bugs-dot-jar_LOG4J2-310_3f1e0fdc,"public static SMTPManager getSMTPManager(final String to, final String cc, final String bcc,
                                             final String from, final String replyTo,
                                             final String subject, String protocol, final String host,
                                             final int port, final String username, final String password,
                                             final boolean isDebug, final String filterName, final int numElements) {
        if (Strings.isEmpty(protocol)) {
            protocol = ""smtp"";
        }

        final StringBuilder sb = new StringBuilder();
        if (to != null) {
            sb.append(to);
        }
        sb.append("":"");
        if (cc != null) {
            sb.append(cc);
        }
        sb.append("":"");
        if (bcc != null) {
            sb.append(bcc);
        }
        sb.append("":"");
        if (from != null) {
            sb.append(from);
        }
        sb.append("":"");
        if (replyTo != null) {
            sb.append(replyTo);
        }
        sb.append("":"");
        if (subject != null) {
            sb.append(subject);
        }
        sb.append("":"");
        sb.append(protocol).append("":"").append(host).append("":"").append(""port"").append("":"");
        if (username != null) {
            sb.append(username);
        }
        sb.append("":"");
        if (password != null) {
            sb.append(password);
        }
        sb.append(isDebug ? "":debug:"" : ""::"");
        sb.append(filterName);

        final String name = ""SMTP:"" + NameUtil.md5(sb.toString());

        return getManager(name, FACTORY, new FactoryData(to, cc, bcc, from, replyTo, subject,
            protocol, host, port, username, password, isDebug, numElements));
    }","public static SMTPManager getSMTPManager(final String to, final String cc, final String bcc,
                                             final String from, final String replyTo,
                                             final String subject, String protocol, final String host,
                                             final int port, final String username, final String password,
                                             final boolean isDebug, final String filterName, final int numElements) {
        if (Strings.isEmpty(protocol)) {
            protocol = ""smtp"";
        }

        final StringBuilder sb = new StringBuilder();
        if (to != null) {
            sb.append(to);
        }
        sb.append("":"");
        if (cc != null) {
            sb.append(cc);
        }
        sb.append("":"");
        if (bcc != null) {
            sb.append(bcc);
        }
        sb.append("":"");
        if (from != null) {
            sb.append(from);
        }
        sb.append("":"");
        if (replyTo != null) {
            sb.append(replyTo);
        }
        sb.append("":"");
        if (subject != null) {
            sb.append(subject);
        }
        sb.append("":"");
        sb.append(protocol).append("":"").append(host).append("":"").append(""port"").append("":"");
        if (username != null) {
            sb.append(username);
        }
        sb.append("":"");
        if (password != null) {
            sb.append(password);
        }
        sb.append(isDebug ? "":debug:"" : ""::"");
        sb.append(filterName);

        final String name = ""SMTP:"" + NameUtil.md5(sb.toString());

        return getManager(name, FACTORY, new FactoryData(to, cc, bcc, from, replyTo, subject,
            protocol, host, port, username, password, isDebug, numElements));
    }",0,[0]
2554,bugs-dot-jar_MNG-3131_56cd921f,"private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo, Parameter param,
                                                                StringBuilder messageBuffer )
    {
        String expression = param.getExpression();

        if ( param.isEditable() )
        {
            messageBuffer.append( ""Inside the definition for plugin \'"" + mojo.getPluginDescriptor().getArtifactId()
                + ""\', specify the following:\n\n<configuration>\n  ...\n  <"" + param.getName() + "">VALUE</""
                + param.getName() + "">\n</configuration>"" );

            String alias = param.getAlias();
            if ( StringUtils.isNotEmpty( alias ) && !alias.equals( param.getName() ) )
            {
                messageBuffer.append(
                    ""\n\n-OR-\n\n<configuration>\n  ...\n  <"" + alias + "">VALUE</"" + alias + "">\n</configuration>\n"" );
            }
        }

        if ( StringUtils.isEmpty( expression ) )
        {
            messageBuffer.append( ""."" );
        }
        else
        {
            if ( param.isEditable() )
            {
                messageBuffer.append( ""\n\n-OR-\n\n"" );
            }

            //addParameterUsageInfo( expression, messageBuffer );
        }
    }","private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo, Parameter param,
                                                                StringBuilder messageBuffer )
    {
        String expression = param.getExpression();
        
        if ( param.isEditable() )
        {
            boolean isArray = param.getType().endsWith( ""[]"" );
            boolean isCollection = false;
            boolean isMap = false;
            if ( !isArray )
            {
                try
                {
                    //assuming Type is available in current ClassLoader
                    isCollection = Collection.class.isAssignableFrom( Class.forName( param.getType() ) );
                    isMap = Map.class.isAssignableFrom( Class.forName( param.getType() ) );
                }
                catch ( ClassNotFoundException e )
                {
                    // assume it is not assignable from Collection or Map
                }
            }
            
            messageBuffer.append( ""Inside the definition for plugin \'"");
            messageBuffer.append( mojo.getPluginDescriptor().getArtifactId() );
            messageBuffer.append( ""\', specify the following:\n\n<configuration>\n  ...\n"" );
            messageBuffer.append( ""  <"" ).append( param.getName() ).append( '>' );
            if( isArray || isCollection )
            {
                messageBuffer.append(  '\n' );
                messageBuffer.append( ""    <item>"" );
            }
            else if ( isMap )
            {
                messageBuffer.append(  '\n' );
                messageBuffer.append( ""    <KEY>"" );
            }
            messageBuffer.append( ""VALUE"" );
            if( isArray || isCollection )
            {
                messageBuffer.append( ""</item>\n"" );
                messageBuffer.append( ""  "" );
            }    
            else if ( isMap )
            {
                messageBuffer.append( ""</KEY>\n"" );
                messageBuffer.append( ""  "" );
            }    
            messageBuffer.append( ""</"" ).append( param.getName() ).append( "">\n"" );
            messageBuffer.append( ""</configuration>"" );

            String alias = param.getAlias();
            if ( StringUtils.isNotEmpty( alias ) && !alias.equals( param.getName() ) )
            {
                messageBuffer.append(
                    ""\n\n-OR-\n\n<configuration>\n  ...\n  <"" + alias + "">VALUE</"" + alias + "">\n</configuration>\n"" );
            }
        }

        if ( StringUtils.isEmpty( expression ) )
        {
            messageBuffer.append( ""."" );
        }
        else
        {
            if ( param.isEditable() )
            {
                messageBuffer.append( ""\n\n-OR-\n\n"" );
            }

            //addParameterUsageInfo( expression, messageBuffer );
        }
    }",1,"[7, 8, 9]"
7567,bugs-dot-jar_MATH-640_98556fed,"public float nextFloat() {
        return (float) nextDouble();
    }","public float nextFloat() {
        return (float) nextDouble();
    }",0,[0]
39676,bugs-dot-jar_MATH-1136_cc4ab51e,"public double getNumericalMean() {
        return numberOfTrials * probabilityOfSuccess;
    }","public double getNumericalMean() {
        return numberOfTrials * probabilityOfSuccess;
    }",0,[0]
31409,bugs-dot-jar_CAMEL-9340_1cab39f6,"@Override
    protected void doStart() throws Exception {
        ObjectHelper.notNull(fileStore, ""fileStore"", this);

        // init store if not loaded before
        if (init.compareAndSet(false, true)) {
            loadStore();
        }
    }","@Override
    protected void doStart() throws Exception {
        ObjectHelper.notNull(fileStore, ""fileStore"", this);

        // init store if not loaded before
        if (init.compareAndSet(false, true)) {
            loadStore();
        }
    }",0,[0]
25811,bugs-dot-jar_CAMEL-6723_b92d6237,"private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean preserveExchangeId) {
        Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId);
        // we do not want attachments for the splitted sub-messages
        answer.getIn().setAttachments(null);
        return answer;
    }","private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean preserveExchangeId) {
        Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId);
        // we do not want attachments for the splitted sub-messages
        answer.getIn().setAttachments(null);
        // we do not want to copy the message history for splitted sub-messages
        answer.getProperties().remove(Exchange.MESSAGE_HISTORY);
        return answer;
    }",1,[]
2088,bugs-dot-jar_WICKET-2961_3d8c9d75,"private boolean needToRenderTag(final ComponentTag openTag)
	{
		// If a open-close tag has been modified to be open-body-close than a
		// synthetic close tag must be rendered.
		boolean renderTag = (openTag == null ? false : !(openTag instanceof WicketTag));
		if (renderTag == false)
		{
			renderTag = !((getRequest() instanceof WebRequest) && ((WebRequest)getRequest()).isAjax());
			renderTag &= !getApplication().getMarkupSettings().getStripWicketTags();
		}
		return renderTag;
	}","private boolean needToRenderTag(final ComponentTag openTag)
	{
		// If a open-close tag has been modified to be open-body-close than a
		// synthetic close tag must be rendered.
		boolean renderTag = (openTag == null ? false : !(openTag instanceof WicketTag));
		if (renderTag == false)
		{
			renderTag = !((getRequest() instanceof WebRequest) && ((WebRequest)getRequest()).isAjax());
			renderTag &= !getApplication().getMarkupSettings().getStripWicketTags();
		}
		return renderTag;
	}",0,[0]
31986,bugs-dot-jar_WICKET-2181_d79d0192,"public final void setRowsPerPage(int rowsPerPage)
	{
		if (rowsPerPage < 0)
		{
			rowsPerPage = 0;
		}

		addStateChange(new RowsPerPageChange(this.rowsPerPage));
		this.rowsPerPage = rowsPerPage;
	}","public final void setRowsPerPage(int rowsPerPage)
	{
		if (rowsPerPage < 0)
		{
			rowsPerPage = 0;
		}

		addStateChange(new RowsPerPageChange(this.rowsPerPage));
		this.rowsPerPage = rowsPerPage;
	}",0,[0]
1171,Bears-152,"public String getTransporter() {
        return transporter;
    }","public String getTransporter() {
        return transporter;
    }",0,[0]
6819,bugs-dot-jar_WICKET-5114_518c933b,"public boolean isAbsolute()
	{
		return !getSegments().isEmpty() && Strings.isEmpty(getSegments().get(0));
	}","public boolean isAbsolute()
	{
		return !getSegments().isEmpty() && Strings.isEmpty(getSegments().get(0));
	}",0,[0]
40767,bugs-dot-jar_MATH-716_faa77857,"private double guessX(final double targetY, final double[] x, final double[] y,
                          final int start, final int end) {

        // compute Q Newton coefficients by divided differences
        for (int i = start; i < end - 1; ++i) {
            final int delta = i + 1 - start;
            for (int j = end - 1; j > i; --j) {
                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);
            }
        }

        // evaluate Q(targetY)
        double x0 = 0;
        for (int j = end - 1; j >= start; --j) {
            x0 = x[j] + x0 * (targetY - y[j]);
        }

        return x0;

    }","private double guessX(final double targetY, final double[] x, final double[] y,
                          final int start, final int end) {

        // compute Q Newton coefficients by divided differences
        for (int i = start; i < end - 1; ++i) {
            final int delta = i + 1 - start;
            for (int j = end - 1; j > i; --j) {
                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);
            }
        }

        // evaluate Q(targetY)
        double x0 = 0;
        for (int j = end - 1; j >= start; --j) {
            x0 = x[j] + x0 * (targetY - y[j]);
        }

        return x0;

    }",0,[0]
23563,bugs-dot-jar_LOG4J2-447_0343e9c7,"@Override
    /**
     * @return The content type.
     */
    public String getContentType() {
        return ""text/xml; charset="" + this.getCharset();
    }","@Override
    /**
     * @return The content type.
     */
    public String getContentType() {
        return ""text/xml; charset="" + this.getCharset();
    }",0,[0]
25596,bugs-dot-jar_ACCUMULO-3945_36225565,"public boolean isTabCompletionDisabled() {
    return tabCompletionDisabled;
  }","public boolean isTabCompletionDisabled() {
    return tabCompletionDisabled;
  }",0,[0]
694,Bears-22,"@Override
    public JavaType withStaticTyping() {
        return this;
    }","@Override
    public JavaType withStaticTyping() {
        return this;
    }",0,[0]
12466,bugs-dot-jar_FLINK-2968_59685903,"@Override
	public void close() throws Exception {
		super.close();
		functionsClosed = true;
		FunctionUtils.closeFunction(userFunction);
	}","@Override
	public void close() throws Exception {
		super.close();
		functionsClosed = true;
		FunctionUtils.closeFunction(userFunction);
	}",0,[0]
15993,bugs-dot-jar_FLINK-3684_e3759a5e,"@Override
	@SuppressWarnings(""unchecked"")
	public void open() throws Exception {
		if (keys == null) {
			keys = new HashSet<>();
		}

		if (nfaOperatorState == null) {
			nfaOperatorState = getPartitionedState(
					new ValueStateDescriptor<NFA<IN>>(
						NFA_OPERATOR_STATE_NAME,
						new KryoSerializer<NFA<IN>>((Class<NFA<IN>>) (Class<?>) NFA.class, getExecutionConfig()),
						null));
		}

		if (priorityQueueOperatorState == null) {
			priorityQueueOperatorState = getPartitionedState(
					new ValueStateDescriptor<PriorityQueue<StreamRecord<IN>>>(
						PRIORIRY_QUEUE_STATE_NAME,
						new PriorityQueueSerializer<StreamRecord<IN>>(
							new StreamRecordSerializer<IN>(getInputSerializer()),
							new PriorityQueueStreamRecordFactory<IN>()),
						null));
		}
	}","@Override
	@SuppressWarnings(""unchecked"")
	public void open() throws Exception {
		if (keys == null) {
			keys = new HashSet<>();
		}

		if (nfaOperatorState == null) {
			nfaOperatorState = getPartitionedState(
					new ValueStateDescriptor<NFA<IN>>(
						NFA_OPERATOR_STATE_NAME,
						new KryoSerializer<NFA<IN>>((Class<NFA<IN>>) (Class<?>) NFA.class, getExecutionConfig()),
						null));
		}

		if (priorityQueueOperatorState == null) {
			priorityQueueOperatorState = getPartitionedState(
					new ValueStateDescriptor<PriorityQueue<StreamRecord<IN>>>(
						PRIORIRY_QUEUE_STATE_NAME,
						new PriorityQueueSerializer<StreamRecord<IN>>(
							new StreamRecordSerializer<IN>(getInputSerializer()),
							new PriorityQueueStreamRecordFactory<IN>()),
						null));
		}
	}",0,[0]
15293,bugs-dot-jar_FLINK-3314_8fc7e7af,"public final boolean isRunning() {
		return isRunning;
	}","public final boolean isRunning() {
		return isRunning;
	}",0,[0]
14442,bugs-dot-jar_WICKET-5138_e8dab4a0,"public WicketFilter()
	{
	}","public WicketFilter()
	{
	}",0,[0]
10891,bugs-dot-jar_CAMEL-7883_d57f402b,"private String getUri(String systemId) {
        if (resourcePath != null) {
            return FileUtil.onlyPath(resourceUri) + ""/"" + systemId;
        } else {
            return systemId;
        }
    }","private String getUri(String systemId) {
        if (resourcePath != null) {
            return FileUtil.onlyPath(resourceUri) + ""/"" + systemId;
        } else {
            return systemId;
        }
    }",0,[0]
9882,bugs-dot-jar_OAK-3634_90ad50da,"private static long getModifiedFromOperation(Operation op) {
        return op == null ? 0L : Long.parseLong(op.value.toString());
    }","private static long getModifiedFromOperation(Operation op) {
        return op == null ? 0L : Long.parseLong(op.value.toString());
    }",0,[0]
9,bugs-dot-jar_LOG4J2-104_3b12e13d,"protected static LoggerContext getContext(String fqcn, boolean currentContext) {
        return factory.getContext(fqcn, null, currentContext);
    }","protected static LoggerContext getContext(String fqcn, boolean currentContext) {
        return factory.getContext(fqcn, null, currentContext);
    }",0,[0]
5273,bugs-dot-jar_OAK-499_61381ea2,"private PropertyValueImpl parsePropertyValue(String name) throws ParseException {
        if (readIf(""."")) {
            return factory.propertyValue(name, readName());
        } else {
            return factory.propertyValue(getOnlySelectorName(), name);
        }
    }","private PropertyValueImpl parsePropertyValue(String name) throws ParseException {
        if (readIf(""."")) {
            return factory.propertyValue(name, readName());
        } else {
            return factory.propertyValue(getOnlySelectorName(), name);
        }
    }",0,[0]
851,bugs-dot-jar_OAK-3333_194999ed,"private void collectRevisionsAndCommitRoot() {
        NavigableMap<Revision, String> revisions =
                new TreeMap<Revision, String>(context.getRevisionComparator());
        for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {
            if (splitRevs.contains(entry.getKey())) {
                revisions.put(entry.getKey(), entry.getValue());
                numValues++;
            } else {
                // move _revisions entries that act as commit root without
                // local changes
                if (context.getClusterId() != entry.getKey().getClusterId()) {
                    // only consider local changes
                    continue;
                }
                if (doc.isCommitted(entry.getKey())
                        && !mostRecentRevs.contains(entry.getKey())) {
                    // this is a commit root for changes in other documents
                    revisions.put(entry.getKey(), entry.getValue());
                    numValues++;
                    trackHigh(entry.getKey());
                    trackLow(entry.getKey());
                }
            }
        }
        committedChanges.put(REVISIONS, revisions);
        NavigableMap<Revision, String> commitRoot =
                new TreeMap<Revision, String>(context.getRevisionComparator());
        for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {
            Revision r = entry.getKey();
            if (splitRevs.contains(r)) {
                commitRoot.put(r, entry.getValue());
                numValues++;
            } else if (r.getClusterId() == context.getClusterId() 
                    && !changes.contains(r)) {
                // OAK-2528: _commitRoot entry without associated
                // change -> consider as garbage
                addGarbage(r, COMMIT_ROOT);
            }
        }
        committedChanges.put(COMMIT_ROOT, commitRoot);
    }","private void collectRevisionsAndCommitRoot() {
        NavigableMap<Revision, String> revisions =
                new TreeMap<Revision, String>(context.getRevisionComparator());
        for (Map.Entry<Revision, String> entry : doc.getLocalRevisions().entrySet()) {
            if (splitRevs.contains(entry.getKey())) {
                revisions.put(entry.getKey(), entry.getValue());
                numValues++;
            } else {
                // move _revisions entries that act as commit root without
                // local changes
                if (context.getClusterId() != entry.getKey().getClusterId()) {
                    // only consider local changes
                    continue;
                }
                if (doc.isCommitted(entry.getKey())
                        && !mostRecentRevs.contains(entry.getKey())) {
                    // this is a commit root for changes in other documents
                    revisions.put(entry.getKey(), entry.getValue());
                    numValues++;
                    trackHigh(entry.getKey());
                    trackLow(entry.getKey());
                }
            }
        }
        committedChanges.put(REVISIONS, revisions);
        NavigableMap<Revision, String> commitRoot =
                new TreeMap<Revision, String>(context.getRevisionComparator());
        boolean mostRecent = true;
        for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {
            Revision r = entry.getKey();
            if (splitRevs.contains(r)) {
                commitRoot.put(r, entry.getValue());
                numValues++;
            } else if (r.getClusterId() == context.getClusterId() 
                    && !changes.contains(r)) {
                // OAK-2528: _commitRoot entry without associated change
                // consider all but most recent as garbage (OAK-3333)
                if (mostRecent) {
                    mostRecent = false;
                } else {
                    addGarbage(r, COMMIT_ROOT);
                }
            }
        }
        committedChanges.put(COMMIT_ROOT, commitRoot);
    }",1,"[34, 35, 36]"
178,Bears-6,"public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
        _fields = new Linked<AnnotatedField>(a, _fields, name, explName, visible, ignored);
    }","public void addField(AnnotatedField a, PropertyName name, boolean explName, boolean visible, boolean ignored) {
        _fields = new Linked<AnnotatedField>(a, _fields, name, explName, visible, ignored);
    }",0,[0]
26411,bugs-dot-jar_OAK-3310_4416a9f8,"@Override
    public long getLong() throws RepositoryException {
        return getValue().getLong();
    }","@Override
    public long getLong() throws RepositoryException {
        return getValue().getLong();
    }",0,[0]
23271,bugs-dot-jar_FLINK-1496_0a4c7694,"public String getTaskNameWithSubtasks() {
		return environment.getTaskNameWithSubtasks();
	}","public String getTaskNameWithSubtasks() {
		return environment.getTaskNameWithSubtasks();
	}",0,[0]
3319,bugs-dot-jar_LOG4J2-492_61ccbb95,"private static void registerContexts(final List<LoggerContext> contexts, final MBeanServer mbs,
            final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException,
            NotCompliantMBeanException {

        for (final LoggerContext ctx : contexts) {
            // first unregister the context and all nested loggers & appenders
            unregisterContext(ctx.getName());

            final LoggerContextAdmin mbean = new LoggerContextAdmin(ctx, executor);
            register(mbs, mbean, mbean.getObjectName());

            if (ctx instanceof AsyncLoggerContext) {
                RingBufferAdmin rbmbean = AsyncLogger.createRingBufferAdmin(ctx.getName());
                register(mbs, rbmbean, rbmbean.getObjectName());
            }
        }
    }","private static void registerContexts(final List<LoggerContext> contexts, final MBeanServer mbs,
            final Executor executor) throws InstanceAlreadyExistsException, MBeanRegistrationException,
            NotCompliantMBeanException {

        for (final LoggerContext ctx : contexts) {
            // first unregister the context and all nested loggers & appenders
            unregisterContext(ctx.getName());

            final LoggerContextAdmin mbean = new LoggerContextAdmin(ctx, executor);
            register(mbs, mbean, mbean.getObjectName());

            if (ctx instanceof AsyncLoggerContext) {
                RingBufferAdmin rbmbean = AsyncLogger.createRingBufferAdmin(ctx.getName());
                register(mbs, rbmbean, rbmbean.getObjectName());
            }
        }
    }",0,[0]
36179,bugs-dot-jar_CAMEL-9444_baece126,"@SuppressWarnings(""unchecked"")
    @Deprecated
    public Type beanRef(String ref) {
        BeanDefinition answer = new BeanDefinition(ref);
        addOutput(answer);
        return (Type) this;
    }","@SuppressWarnings(""unchecked"")
    @Deprecated
    public Type beanRef(String ref) {
        BeanDefinition answer = new BeanDefinition(ref);
        addOutput(answer);
        return (Type) this;
    }",0,[0]
29340,bugs-dot-jar_LOG4J2-268_8faf7f77,"@Override
    public Message getMessage() {
        return event.getMessage();
    }","@Override
    public Message getMessage() {
        return event.getMessage();
    }",0,[0]
611,bugs-dot-jar_OAK-2426_920f32d0,"private static List<NodeInclude> findRelativeNodeIncludes(List<? extends Include> includes) {
        List<NodeInclude> result = newArrayList();
        for (Include i : includes){
            if (i instanceof NodeInclude){
                NodeInclude ni = (NodeInclude) i;
                if (ni.relativeNode){
                    result.add(ni);
                }
            }
        }
        return ImmutableList.copyOf(result);
    }","private static List<NodeInclude> findRelativeNodeIncludes(List<? extends Include> includes) {
        List<NodeInclude> result = newArrayList();
        for (Include i : includes){
            if (i instanceof NodeInclude){
                NodeInclude ni = (NodeInclude) i;
                if (ni.relativeNode){
                    result.add(ni);
                }
            }
        }
        return ImmutableList.copyOf(result);
    }",0,[0]
20799,bugs-dot-jar_CAMEL-5215_033eb6fe,"@FallbackConverter
    public static Object convertTo(Class<?> type, Exchange exchange, Object value, TypeConverterRegistry registry) {
        // use a fallback type converter so we can convert the embedded body if the value is GenericFile
        if (GenericFile.class.isAssignableFrom(value.getClass())) {

            GenericFile<?> file = (GenericFile<?>) value;
            Class<?> from = file.getBody().getClass();

            // maybe from is already the type we want
            if (from.isAssignableFrom(type)) {
                return file.getBody();
            }

            // no then try to lookup a type converter
            TypeConverter tc = registry.lookup(type, from);
            if (tc != null) {
                Object body = file.getBody();
                return tc.convertTo(type, exchange, body);
            }
        }
        
        return null;
    }","@FallbackConverter
    public static Object convertTo(Class<?> type, Exchange exchange, Object value, TypeConverterRegistry registry) {
        // use a fallback type converter so we can convert the embedded body if the value is GenericFile
        if (GenericFile.class.isAssignableFrom(value.getClass())) {

            GenericFile<?> file = (GenericFile<?>) value;
            Class<?> from = file.getBody().getClass();

            // maybe from is already the type we want
            if (from.isAssignableFrom(type)) {
                return file.getBody();
            }

            // no then try to lookup a type converter
            TypeConverter tc = registry.lookup(type, from);
            if (tc != null) {
                Object body = file.getBody();
                return tc.convertTo(type, exchange, body);
            }
        }
        
        return null;
    }",0,[0]
37165,bugs-dot-jar_OAK-1648_fdc54465,"private void createIfNotExist() {
        if (store.find(Collection.SETTINGS, ID) == null) {
            UpdateOp updateOp = new UpdateOp(ID, true);
            updateOp.set(Document.ID, ID);
            store.createOrUpdate(Collection.SETTINGS, updateOp);
        }
    }","private void createIfNotExist() {
        if (store.find(Collection.SETTINGS, ID) == null) {
            UpdateOp updateOp = new UpdateOp(ID, true);
            updateOp.set(Document.ID, ID);
            store.createOrUpdate(Collection.SETTINGS, updateOp);
        }
    }",0,[0]
32539,bugs-dot-jar_OAK-4300_06c367af,"private boolean evaluateSpellcheckEnabled() {
        for (IndexingRule indexingRule : definedRules) {
            for (PropertyDefinition propertyDefinition : indexingRule.propConfigs.values()) {
                if (propertyDefinition.useInSpellcheck) {
                    return true;
                }
            }
            for (NamePattern np : indexingRule.namePatterns) {
                if (np.getConfig().useInSpellcheck) {
                    return true;
                }
            }
        }
        return false;
    }","private boolean evaluateSpellcheckEnabled() {
        for (IndexingRule indexingRule : definedRules) {
            for (PropertyDefinition propertyDefinition : indexingRule.propConfigs.values()) {
                if (propertyDefinition.useInSpellcheck) {
                    return true;
                }
            }
            for (NamePattern np : indexingRule.namePatterns) {
                if (np.getConfig().useInSpellcheck) {
                    return true;
                }
            }
        }
        return false;
    }",0,[0]
4236,bugs-dot-jar_CAMEL-4682_1e54865c,"public synchronized void removeRouteDefinition(RouteDefinition routeDefinition) throws Exception {
        String id = routeDefinition.idOrCreate(nodeIdFactory);
        stopRoute(id);
        removeRoute(id);
    }","public synchronized void removeRouteDefinition(RouteDefinition routeDefinition) throws Exception {
        String id = routeDefinition.idOrCreate(nodeIdFactory);
        stopRoute(id);
        removeRoute(id);
    }",0,[0]
755,Bears-83,"static void insertAllSuperInterfaces(CtType<?> targetType, Template<?> template, CtClass<? extends Template<?>> sourceClass) {

		// insert all the interfaces
		for (CtTypeReference<?> t : sourceClass.getSuperInterfaces()) {
			if (!t.equals(targetType.getFactory().Type().createReference(Template.class))) {
				CtTypeReference<?> t1 = t;
				// substitute ref if needed
				if (Parameters.getNames(sourceClass).contains(t.getSimpleName())) {
					Object o = Parameters.getValue(template, t.getSimpleName(), null);
					if (o instanceof CtTypeReference) {
						t1 = (CtTypeReference<?>) o;
					} else if (o instanceof Class) {
						t1 = targetType.getFactory().Type().createReference((Class<?>) o);
					} else if (o instanceof String) {
						t1 = targetType.getFactory().Type().createReference((String) o);
					}
				}
				if (!t1.equals(targetType.getReference())) {
					Class<?> c = null;
					try {
						c = t1.getActualClass();
					} catch (Exception e) {
						// swallow it
					}
					if (c != null && c.isInterface()) {
						targetType.addSuperInterface(t1);
					}
					if (c == null) {
						targetType.addSuperInterface(t1);
					}
				}
			}
		}
	}","static void insertAllSuperInterfaces(CtType<?> targetType, Template<?> template, CtClass<? extends Template<?>> sourceClass) {

		// insert all the interfaces
		for (CtTypeReference<?> t : sourceClass.getSuperInterfaces()) {
			if (!t.equals(targetType.getFactory().Type().createReference(Template.class))) {
				CtTypeReference<?> t1 = t;
				// substitute ref if needed
				if (Parameters.getNames(sourceClass).contains(t.getSimpleName())) {
					Object o = Parameters.getValue(template, t.getSimpleName(), null);
					if (o instanceof CtTypeReference) {
						t1 = (CtTypeReference<?>) o;
					} else if (o instanceof Class) {
						t1 = targetType.getFactory().Type().createReference((Class<?>) o);
					} else if (o instanceof String) {
						t1 = targetType.getFactory().Type().createReference((String) o);
					}
				}
				if (!t1.equals(targetType.getReference())) {
					Class<?> c = null;
					try {
						c = t1.getActualClass();
					} catch (Exception e) {
						// swallow it
					}
					if (c != null && c.isInterface()) {
						targetType.addSuperInterface(t1);
					}
					if (c == null) {
						targetType.addSuperInterface(t1);
					}
				}
			}
		}
	}",0,[0]
16964,bugs-dot-jar_WICKET-5728_3cc3fe95,"private MarkupContainer internalQueue()
	{
		MarkupContainer region = null;
		Page page = null;

		MarkupContainer cursor = this;

		while (cursor != null)
		{
			if (region == null && cursor instanceof IQueueRegion)
			{
				region = cursor;
			}
			if (cursor instanceof Page)
			{
				page = (Page)cursor;
			}
			cursor = cursor.getParent();
		}

		if (page != null)
		{
			if (!region.getRequestFlag(RFLAG_CONTAINER_DEQUEING))
			{
				region.dequeue();
			}
		}

		return this;
	}","private MarkupContainer internalQueue()
	{
		MarkupContainer region = null;
		Page page = null;

		MarkupContainer cursor = this;

		while (cursor != null)
		{
			if (region == null && cursor instanceof IQueueRegion)
			{
				region = cursor;
			}
			if (cursor instanceof Page)
			{
				page = (Page)cursor;
			}
			cursor = cursor.getParent();
		}

		if (page != null)
		{
			if (!region.getRequestFlag(RFLAG_CONTAINER_DEQUEING))
			{
				region.dequeue();
			}
		}

		return this;
	}",0,[0]
278,Bears-12,"@Override
    protected BeanDeserializerBase asArrayDeserializer() {
        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();
        return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod);
    }","@Override
    protected BeanDeserializerBase asArrayDeserializer() {
        SettableBeanProperty[] props = _beanProperties.getPropertiesInInsertionOrder();
        return new BeanAsArrayBuilderDeserializer(this, props, _buildMethod);
    }",0,[0]
16118,bugs-dot-jar_WICKET-4816_66bfc885,"public static String firstPathComponent(final String path, final char separator)
	{
		if (path == null)
		{
			return null;
		}
		final int index = path.indexOf(separator);

		if (index == -1)
		{
			return path;
		}

		return path.substring(0, index);
	}","public static String firstPathComponent(final String path, final char separator)
	{
		if (path == null)
		{
			return null;
		}
		final int index = path.indexOf(separator);

		if (index == -1)
		{
			return path;
		}

		return path.substring(0, index);
	}",0,[0]
3323,bugs-dot-jar_LOG4J2-492_61ccbb95,"private static void unregisterContexts(final MBeanServer mbs) {
        final String pattern = LoggerContextAdminMBean.PATTERN;
        final String search = String.format(pattern, ""*"");
        unregisterAllMatching(search, mbs);
    }","private static void unregisterContexts(final MBeanServer mbs) {
        final String pattern = LoggerContextAdminMBean.PATTERN;
        final String search = String.format(pattern, ""*"");
        unregisterAllMatching(search, mbs);
    }",0,[0]
33132,bugs-dot-jar_MATH-1123_a197ba85,"public BSPTree<S> getMinus() {
        return minus;
    }","public BSPTree<S> getMinus() {
        return minus;
    }",0,[0]
27410,bugs-dot-jar_WICKET-428_d906576c,"public Set keySet()
	{
		return new AbstractSet()
		{
			public Iterator iterator()
			{
				return new Iterator()
				{
					public boolean hasNext()
					{
						return index < MicroMap.this.size();
					}

					public Object next()
					{
						index++;

						return key;
					}

					public void remove()
					{
						MicroMap.this.clear();
					}

					int index;
				};
			}

			public int size()
			{
				return MicroMap.this.size();
			}
		};
	}","public Set keySet()
	{
		return new AbstractSet()
		{
			public Iterator iterator()
			{
				return new Iterator()
				{
					public boolean hasNext()
					{
						return index < MicroMap.this.size();
					}

					public Object next()
					{
						if (!hasNext())
						{
							throw new NoSuchElementException();
						}
						index++;

						return key;
					}

					public void remove()
					{
						MicroMap.this.clear();
					}

					int index;
				};
			}

			public int size()
			{
				return MicroMap.this.size();
			}
		};
	}",1,[]
15714,bugs-dot-jar_WICKET-4509_b672cb2d,"public static String basePath(final String path, final String extension)
	{
		if (extension != null)
		{
			return path.substring(0, path.length() - extension.length() - 1);
		}
		return path;
	}","public static String basePath(final String path, final String extension)
	{
		if (extension != null)
		{
			return path.substring(0, path.length() - extension.length() - 1);
		}
		return path;
	}",0,[0]
1072,Bears-140,"public static String formatWeek(Integer week, Integer year){

        // Special cases (ie. 11, 12, 13 are postfixed with 'th')
        if(week == 11 || week == 12 || week == 13)
            return String.valueOf(week) + ""th ("" + year + "")"";

        char digit;
        if(week.toString().length() == 2){
            digit = week.toString().charAt(1);
        } else {
            digit = week.toString().charAt(0);
        }
        if(digit == '1'){
            return String.valueOf(week) + ""st ("" + year + "")"";
        } else if (digit == '2') {
            return String.valueOf(week) + ""nd ("" + year + "")"";
        } else if (digit == '3') {
            return String.valueOf(week) + ""rd ("" + year + "")"";
        } else {
            return String.valueOf(week) + ""th ("" + year + "")"";
        }
    }","public static String formatWeek(Integer week, Integer year){

        // Null cases
        if(week == null || year == null)
                return null;

        // Invalid value cases
        if(week < 1 || week > 52 || year < 1)
            return null;

        // Format Week for special cases (ie. 11, 12, 13 are postfixed with 'th')
        if(week == 11 || week == 12 || week == 13)
            return String.valueOf(week) + ""th ("" + year + "")"";

        // Format Week
        char digit;
        if(week.toString().length() == 2){
            digit = week.toString().charAt(1);
        } else {
            digit = week.toString().charAt(0);
        }
        if(digit == '1'){
            return String.valueOf(week) + ""st ("" + year + "")"";
        } else if (digit == '2') {
            return String.valueOf(week) + ""nd ("" + year + "")"";
        } else if (digit == '3') {
            return String.valueOf(week) + ""rd ("" + year + "")"";
        } else {
            return String.valueOf(week) + ""th ("" + year + "")"";
        }
    }",1,[2]
1946,bugs-dot-jar_CAMEL-3535_b56d2962,"public int getCompletionSize() {
        return completionSize;
    }","public int getCompletionSize() {
        return completionSize;
    }",0,[0]
2497,bugs-dot-jar_CAMEL-3388_0919a0f6,"public static <T> Expression bodyExpression(final Class<T> type) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return exchange.getIn().getBody(type);
            }

            @Override
            public String toString() {
                return ""bodyAs["" + type.getName() + ""]"";
            }
        };
    }","public static <T> Expression bodyExpression(final Class<T> type) {
        return new ExpressionAdapter() {
            public Object evaluate(Exchange exchange) {
                return exchange.getIn().getBody(type);
            }

            @Override
            public String toString() {
                return ""bodyAs["" + type.getName() + ""]"";
            }
        };
    }",0,[0]
3869,bugs-dot-jar_WICKET-4578_c66cf607,"final void internalOnRemove()
	{
		setFlag(FLAG_REMOVING_FROM_HIERARCHY, true);
		onRemove();
		if (getFlag(FLAG_REMOVING_FROM_HIERARCHY))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly removed from hierachy. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onRemove() in the override of onRemove() method"");
		}
		removeChildren();
	}","final void internalOnRemove()
	{
		setFlag(FLAG_REMOVING_FROM_HIERARCHY, true);
		onRemove();
		if (getFlag(FLAG_REMOVING_FROM_HIERARCHY))
		{
			throw new IllegalStateException(Component.class.getName() +
				"" has not been properly removed from hierachy. Something in the hierarchy of "" +
				getClass().getName() +
				"" has not called super.onRemove() in the override of onRemove() method"");
		}
		removeChildren();
	}",0,[0]
14300,bugs-dot-jar_ACCUMULO-1199_813109d7,"@Override
  public void checkIteratorConflicts(ByteBuffer login, String tableName, org.apache.accumulo.proxy.thrift.IteratorSetting setting,
      Set<org.apache.accumulo.proxy.thrift.IteratorScope> scopes) throws TException {
    try {
      getConnector(login).tableOperations().checkIteratorConflicts(tableName, getIteratorSetting(setting), getIteratorScopes(scopes));
    } catch (Exception e) {
      throw translateException(e);
    }
  }","@Override
  public void checkIteratorConflicts(ByteBuffer login, String tableName, org.apache.accumulo.proxy.thrift.IteratorSetting setting,
      Set<org.apache.accumulo.proxy.thrift.IteratorScope> scopes) throws TException {
    try {
      getConnector(login).tableOperations().checkIteratorConflicts(tableName, getIteratorSetting(setting), getIteratorScopes(scopes));
    } catch (Exception e) {
      throw translateException(e);
    }
  }",0,[0]
37958,bugs-dot-jar_OAK-738_8ed779dc,"@Override
    @Nonnull
    public String getIdentifier() throws RepositoryException {
        return perform(new ItemReadOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                return dlg.getIdentifier();
            }
        });
    }","@Override
    @Nonnull
    public String getIdentifier() throws RepositoryException {
        return perform(new ItemReadOperation<String>() {
            @Override
            public String perform() throws RepositoryException {
                return dlg.getIdentifier();
            }
        });
    }",0,[0]
36641,bugs-dot-jar_MATH-904_6844aba9,"private static double log(final double x, final double[] hiPrec) {
        if (x==0) { // Handle special case of +0/-0
            return Double.NEGATIVE_INFINITY;
        }
        long bits = Double.doubleToLongBits(x);

        /* Handle special cases of negative input, and NaN */
        if ((bits & 0x8000000000000000L) != 0 || x != x) {
            if (x != 0.0) {
                if (hiPrec != null) {
                    hiPrec[0] = Double.NaN;
                }

                return Double.NaN;
            }
        }

        /* Handle special cases of Positive infinity. */
        if (x == Double.POSITIVE_INFINITY) {
            if (hiPrec != null) {
                hiPrec[0] = Double.POSITIVE_INFINITY;
            }

            return Double.POSITIVE_INFINITY;
        }

        /* Extract the exponent */
        int exp = (int)(bits >> 52)-1023;

        if ((bits & 0x7ff0000000000000L) == 0) {
            // Subnormal!
            if (x == 0) {
                // Zero
                if (hiPrec != null) {
                    hiPrec[0] = Double.NEGATIVE_INFINITY;
                }

                return Double.NEGATIVE_INFINITY;
            }

            /* Normalize the subnormal number. */
            bits <<= 1;
            while ( (bits & 0x0010000000000000L) == 0) {
                --exp;
                bits <<= 1;
            }
        }


        if (exp == -1 || exp == 0) {
            if (x < 1.01 && x > 0.99 && hiPrec == null) {
                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
           polynomial expansion in higer precision. */

               /* Compute x - 1.0 and split it */
                double xa = x - 1.0;
                double xb = xa - x + 1.0;
                double tmp = xa * HEX_40000000;
                double aa = xa + tmp - tmp;
                double ab = xa - aa;
                xa = aa;
                xb = ab;

                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
                double ya = lnCoef_last[0];
                double yb = lnCoef_last[1];

                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
                    /* Multiply a = y * x */
                    aa = ya * xa;
                    ab = ya * xb + yb * xa + yb * xb;
                    /* split, so now y = a */
                    tmp = aa * HEX_40000000;
                    ya = aa + tmp - tmp;
                    yb = aa - ya + ab;

                    /* Add  a = y + lnQuickCoef */
                    final double[] lnCoef_i = LN_QUICK_COEF[i];
                    aa = ya + lnCoef_i[0];
                    ab = yb + lnCoef_i[1];
                    /* Split y = a */
                    tmp = aa * HEX_40000000;
                    ya = aa + tmp - tmp;
                    yb = aa - ya + ab;
                }

                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                return ya + yb;
            }
        }

        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)
        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];

        /*
    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);

    epsilon -= 1.0;
         */

        // y is the most significant 10 bits of the mantissa
        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);
        //double epsilon = (x - y) / y;
        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));

        double lnza = 0.0;
        double lnzb = 0.0;

        if (hiPrec != null) {
            /* split epsilon -> x */
            double tmp = epsilon * HEX_40000000;
            double aa = epsilon + tmp - tmp;
            double ab = epsilon - aa;
            double xa = aa;
            double xb = ab;

            /* Need a more accurate epsilon, so adjust the division. */
            final double numer = bits & 0x3ffffffffffL;
            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
            aa = numer - xa*denom - xb * denom;
            xb += aa / denom;

            /* Remez polynomial evaluation */
            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];
            double ya = lnCoef_last[0];
            double yb = lnCoef_last[1];

            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                /* Add  a = y + lnHiPrecCoef */
                final double[] lnCoef_i = LN_HI_PREC_COEF[i];
                aa = ya + lnCoef_i[0];
                ab = yb + lnCoef_i[1];
                /* Split y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;
            }

            /* Multiply a = y * x */
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;

            /* split, so now lnz = a */
            /*
      tmp = aa * 1073741824.0;
      lnza = aa + tmp - tmp;
      lnzb = aa - lnza + ab;
             */
            lnza = aa + ab;
            lnzb = -(lnza - aa - ab);
        } else {
            /* High precision not required.  Eval Remez polynomial
         using standard double precision */
            lnza = -0.16624882440418567;
            lnza = lnza * epsilon + 0.19999954120254515;
            lnza = lnza * epsilon + -0.2499999997677497;
            lnza = lnza * epsilon + 0.3333333333332802;
            lnza = lnza * epsilon + -0.5;
            lnza = lnza * epsilon + 1.0;
            lnza = lnza * epsilon;
        }

        /* Relative sizes:
         * lnzb     [0, 2.33E-10]
         * lnm[1]   [0, 1.17E-7]
         * ln2B*exp [0, 1.12E-4]
         * lnza      [0, 9.7E-4]
         * lnm[0]   [0, 0.692]
         * ln2A*exp [0, 709]
         */

        /* Compute the following sum:
         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
         */

        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
        double a = LN_2_A*exp;
        double b = 0.0;
        double c = a+lnm[0];
        double d = -(c-a-lnm[0]);
        a = c;
        b = b + d;

        c = a + lnza;
        d = -(c - a - lnza);
        a = c;
        b = b + d;

        c = a + LN_2_B*exp;
        d = -(c - a - LN_2_B*exp);
        a = c;
        b = b + d;

        c = a + lnm[1];
        d = -(c - a - lnm[1]);
        a = c;
        b = b + d;

        c = a + lnzb;
        d = -(c - a - lnzb);
        a = c;
        b = b + d;

        if (hiPrec != null) {
            hiPrec[0] = a;
            hiPrec[1] = b;
        }

        return a + b;
    }","private static double log(final double x, final double[] hiPrec) {
        if (x==0) { // Handle special case of +0/-0
            return Double.NEGATIVE_INFINITY;
        }
        long bits = Double.doubleToLongBits(x);

        /* Handle special cases of negative input, and NaN */
        if ((bits & 0x8000000000000000L) != 0 || x != x) {
            if (x != 0.0) {
                if (hiPrec != null) {
                    hiPrec[0] = Double.NaN;
                }

                return Double.NaN;
            }
        }

        /* Handle special cases of Positive infinity. */
        if (x == Double.POSITIVE_INFINITY) {
            if (hiPrec != null) {
                hiPrec[0] = Double.POSITIVE_INFINITY;
            }

            return Double.POSITIVE_INFINITY;
        }

        /* Extract the exponent */
        int exp = (int)(bits >> 52)-1023;

        if ((bits & 0x7ff0000000000000L) == 0) {
            // Subnormal!
            if (x == 0) {
                // Zero
                if (hiPrec != null) {
                    hiPrec[0] = Double.NEGATIVE_INFINITY;
                }

                return Double.NEGATIVE_INFINITY;
            }

            /* Normalize the subnormal number. */
            bits <<= 1;
            while ( (bits & 0x0010000000000000L) == 0) {
                --exp;
                bits <<= 1;
            }
        }


        if (exp == -1 || exp == 0) {
            if (x < 1.01 && x > 0.99 && hiPrec == null) {
                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight
           polynomial expansion in higer precision. */

               /* Compute x - 1.0 and split it */
                double xa = x - 1.0;
                double xb = xa - x + 1.0;
                double tmp = xa * HEX_40000000;
                double aa = xa + tmp - tmp;
                double ab = xa - aa;
                xa = aa;
                xb = ab;

                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];
                double ya = lnCoef_last[0];
                double yb = lnCoef_last[1];

                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {
                    /* Multiply a = y * x */
                    aa = ya * xa;
                    ab = ya * xb + yb * xa + yb * xb;
                    /* split, so now y = a */
                    tmp = aa * HEX_40000000;
                    ya = aa + tmp - tmp;
                    yb = aa - ya + ab;

                    /* Add  a = y + lnQuickCoef */
                    final double[] lnCoef_i = LN_QUICK_COEF[i];
                    aa = ya + lnCoef_i[0];
                    ab = yb + lnCoef_i[1];
                    /* Split y = a */
                    tmp = aa * HEX_40000000;
                    ya = aa + tmp - tmp;
                    yb = aa - ya + ab;
                }

                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                return ya + yb;
            }
        }

        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)
        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];

        /*
    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);

    epsilon -= 1.0;
         */

        // y is the most significant 10 bits of the mantissa
        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);
        //double epsilon = (x - y) / y;
        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));

        double lnza = 0.0;
        double lnzb = 0.0;

        if (hiPrec != null) {
            /* split epsilon -> x */
            double tmp = epsilon * HEX_40000000;
            double aa = epsilon + tmp - tmp;
            double ab = epsilon - aa;
            double xa = aa;
            double xb = ab;

            /* Need a more accurate epsilon, so adjust the division. */
            final double numer = bits & 0x3ffffffffffL;
            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);
            aa = numer - xa*denom - xb * denom;
            xb += aa / denom;

            /* Remez polynomial evaluation */
            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];
            double ya = lnCoef_last[0];
            double yb = lnCoef_last[1];

            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
                /* Multiply a = y * x */
                aa = ya * xa;
                ab = ya * xb + yb * xa + yb * xb;
                /* split, so now y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;

                /* Add  a = y + lnHiPrecCoef */
                final double[] lnCoef_i = LN_HI_PREC_COEF[i];
                aa = ya + lnCoef_i[0];
                ab = yb + lnCoef_i[1];
                /* Split y = a */
                tmp = aa * HEX_40000000;
                ya = aa + tmp - tmp;
                yb = aa - ya + ab;
            }

            /* Multiply a = y * x */
            aa = ya * xa;
            ab = ya * xb + yb * xa + yb * xb;

            /* split, so now lnz = a */
            /*
      tmp = aa * 1073741824.0;
      lnza = aa + tmp - tmp;
      lnzb = aa - lnza + ab;
             */
            lnza = aa + ab;
            lnzb = -(lnza - aa - ab);
        } else {
            /* High precision not required.  Eval Remez polynomial
         using standard double precision */
            lnza = -0.16624882440418567;
            lnza = lnza * epsilon + 0.19999954120254515;
            lnza = lnza * epsilon + -0.2499999997677497;
            lnza = lnza * epsilon + 0.3333333333332802;
            lnza = lnza * epsilon + -0.5;
            lnza = lnza * epsilon + 1.0;
            lnza = lnza * epsilon;
        }

        /* Relative sizes:
         * lnzb     [0, 2.33E-10]
         * lnm[1]   [0, 1.17E-7]
         * ln2B*exp [0, 1.12E-4]
         * lnza      [0, 9.7E-4]
         * lnm[0]   [0, 0.692]
         * ln2A*exp [0, 709]
         */

        /* Compute the following sum:
         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
         */

        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
        double a = LN_2_A*exp;
        double b = 0.0;
        double c = a+lnm[0];
        double d = -(c-a-lnm[0]);
        a = c;
        b = b + d;

        c = a + lnza;
        d = -(c - a - lnza);
        a = c;
        b = b + d;

        c = a + LN_2_B*exp;
        d = -(c - a - LN_2_B*exp);
        a = c;
        b = b + d;

        c = a + lnm[1];
        d = -(c - a - lnm[1]);
        a = c;
        b = b + d;

        c = a + lnzb;
        d = -(c - a - lnzb);
        a = c;
        b = b + d;

        if (hiPrec != null) {
            hiPrec[0] = a;
            hiPrec[1] = b;
        }

        return a + b;
    }",0,[0]
22536,bugs-dot-jar_OAK-606_f0fbacab,"@CheckForNull
    public NodeDelegate getParent() throws InvalidItemStateException {
        return NodeDelegate.create(sessionDelegate, getLocation().getParent());
    }","@CheckForNull
    public NodeDelegate getParent() throws InvalidItemStateException {
        return NodeDelegate.create(sessionDelegate, getLocation().getParent());
    }",0,[0]
24821,bugs-dot-jar_ACCUMULO-2671_17344890,"public BlockedOutputStream(OutputStream out, int blockSize, int bufferSize) {
    if (bufferSize <= 0)
      throw new IllegalArgumentException(""bufferSize must be greater than 0."");
    if (out instanceof DataOutputStream)
      this.out = (DataOutputStream) out;
    else
      this.out = new DataOutputStream(out);
    this.blockSize = blockSize;
    int remainder = bufferSize % blockSize;
    if (remainder != 0)
      remainder = blockSize - remainder;
    // some buffer space + bytes to make the buffer evened up with the cipher block size - 4 bytes for the size int
    bb = ByteBuffer.allocate(bufferSize + remainder - 4);
  }","public BlockedOutputStream(OutputStream out, int blockSize, int bufferSize) {
    if (bufferSize <= 0)
      throw new IllegalArgumentException(""bufferSize must be greater than 0."");
    if (out instanceof DataOutputStream)
      this.out = (DataOutputStream) out;
    else
      this.out = new DataOutputStream(out);
    this.blockSize = blockSize;
    int remainder = bufferSize % blockSize;
    if (remainder != 0)
      remainder = blockSize - remainder;
    // some buffer space + bytes to make the buffer evened up with the cipher block size - 4 bytes for the size int
    bb = ByteBuffer.allocate(bufferSize + remainder - 4);
  }",0,[0]
40707,bugs-dot-jar_WICKET-442_246d53c5,"public final RequestParameters getRequestParameters()
	{
		return this.requestParameters;
	}","public final RequestParameters getRequestParameters()
	{
		return this.requestParameters;
	}",0,[0]
40538,bugs-dot-jar_WICKET-442_246d53c5,"protected void configureResponse()
	{
		// Get the response and application
		final RequestCycle cycle = getRequestCycle();
		final Application application = cycle.getApplication();
		final Response response = cycle.getResponse();

		// Determine encoding
		final String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();

		// Set content type based on markup type for page
		response.setContentType(""text/"" + getMarkupType() + ""; charset="" + encoding);

		// Write out an xml declaration if the markup stream and settings allow
		final MarkupStream markupStream = findMarkupStream();
		if ((markupStream != null) && (markupStream.getXmlDeclaration() != null)
				&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))
		{
			response.write(""<?xml version='1.0' encoding='"");
			response.write(encoding);
			response.write(""'?>"");
		}

		// Set response locale from session locale
		response.setLocale(getSession().getLocale());
	}","protected void configureResponse()
	{
		// Get the response and application
		final RequestCycle cycle = getRequestCycle();
		final Application application = cycle.getApplication();
		final Response response = cycle.getResponse();

		// Determine encoding
		final String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();

		// Set content type based on markup type for page
		response.setContentType(""text/"" + getMarkupType() + ""; charset="" + encoding);

		// Write out an xml declaration if the markup stream and settings allow
		final MarkupStream markupStream = findMarkupStream();
		if ((markupStream != null) && (markupStream.getXmlDeclaration() != null)
				&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))
		{
			response.write(""<?xml version='1.0' encoding='"");
			response.write(encoding);
			response.write(""'?>"");
		}

		// Set response locale from session locale
		response.setLocale(getSession().getLocale());
	}",0,[0]
149,Bears-6,"@Override
    public boolean isExplicitlyNamed() {
        return _anyExplicitNames(_fields)
                || _anyExplicitNames(_getters)
                || _anyExplicitNames(_setters)
                || _anyExplicitNames(_ctorParameters)
                ;
    }","@Override
    public boolean isExplicitlyNamed() {
        return _anyExplicitNames(_fields)
                || _anyExplicitNames(_getters)
                || _anyExplicitNames(_setters)
                || _anyExplicitNames(_ctorParameters)
                ;
    }",0,[0]
20832,bugs-dot-jar_CAMEL-5215_033eb6fe,"@Converter
    public static InputStream toInputStream(String text, Exchange exchange) throws IOException {
        return toInputStream(text.getBytes(IOHelper.getCharsetName(exchange)));
    }","@Converter
    public static InputStream toInputStream(String text, Exchange exchange) throws IOException {
        return toInputStream(text.getBytes(IOHelper.getCharsetName(exchange)));
    }",0,[0]
20817,bugs-dot-jar_CAMEL-5215_033eb6fe,"private IOConverter() {
    }","private IOConverter() {
    }",0,[0]
300,bugs-dot-jar_FLINK-3566_434e88fd,"@PublicEvolving
	public static <T> TypeInformation<T> getPartitionerTypes(Partitioner<T> partitioner) {
		return getPartitionerTypes(partitioner, null, false);
	}","@PublicEvolving
	public static <T> TypeInformation<T> getPartitionerTypes(Partitioner<T> partitioner) {
		return getPartitionerTypes(partitioner, null, false);
	}",0,[0]
6892,bugs-dot-jar_OAK-2062_5c4589bd,"public PropertyValue currentProperty(String propertyName, int propertyType) {
        String pn = normalizePropertyName(propertyName);
        return currentOakProperty(pn, propertyType);
    }","public PropertyValue currentProperty(String propertyName, int propertyType) {
        String pn = normalizePropertyName(propertyName);
        return currentOakProperty(pn, propertyType);
    }",0,[0]
